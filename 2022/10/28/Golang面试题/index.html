<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <meta name="renderer" content="webkit">
<!--  <meta name="baidu-site-verification" content="code-ofAqabWYEE" />-->
  <meta name="google-site-verification" content="7_aCpLDu0s7bOCrqbIhiPhkHrFGEKMhTyXB5-my2L4g" />

  
  <title>Go-面试题 | 可可西里-博客</title>

  <link rel="shortcut icon" href="/images/favicon.png">
  <link rel="alternate" href="/atom.xml" title="可可西里-博客" type="application/atom+xml">
  <meta name="description" content="Go常见面试题分享，涵盖了常见的Go面试八股文 1. 无缓冲Chan的发送和接收是否同步12ch :&#x3D; make(chan int)    无缓冲的channel由于没有缓冲发送和接收需要同步ch :&#x3D; make(chan int, 2) 有缓冲channel不要求发送和接收操作同步   channel无缓冲时，发送阻塞直到数据被接收，接收阻塞直到读到数据 channel有缓冲时，当缓冲满时发送阻">
<meta property="og:type" content="article">
<meta property="og:title" content="Go-面试题">
<meta property="og:url" content="https://huajun-chen.github.io/2022/10/28/Golang%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="可可西里-博客">
<meta property="og:description" content="Go常见面试题分享，涵盖了常见的Go面试八股文 1. 无缓冲Chan的发送和接收是否同步12ch :&#x3D; make(chan int)    无缓冲的channel由于没有缓冲发送和接收需要同步ch :&#x3D; make(chan int, 2) 有缓冲channel不要求发送和接收操作同步   channel无缓冲时，发送阻塞直到数据被接收，接收阻塞直到读到数据 channel有缓冲时，当缓冲满时发送阻">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://tva1.sinaimg.cn/large/0079DIvogy1h7no7xmdcgj313c0b0jtt.jpg">
<meta property="og:image" content="http://tva1.sinaimg.cn/large/0079DIvogy1h7nojprq3uj30ns0kgdi9.jpg">
<meta property="og:image" content="http://tva1.sinaimg.cn/large/0079DIvogy1h82o60shgaj312i0x2wn7.jpg">
<meta property="article:published_time" content="2022-10-28T00:24:34.000Z">
<meta property="article:modified_time" content="2022-11-24T08:55:09.068Z">
<meta property="article:author" content="可可西里">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tva1.sinaimg.cn/large/0079DIvogy1h7no7xmdcgj313c0b0jtt.jpg">

  <meta name="keywords" content=",Go">
  <meta name="format-detection" content="telephone=no,email=no">
  <meta name="theme-color" content="#9C27B0">

  <meta name="mobile-web-app-capable" content="yes">
  <meta name="application-name" content="可可西里-博客">
  <meta name="msapplication-starturl" content="https://huajun-chen.github.io/2022/10/28/Golang%E9%9D%A2%E8%AF%95%E9%A2%98/">
  <meta name="msapplication-navbutton-color" content="#9C27B0">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="可可西里-博客">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="/images/favicon.png">

  
    <link rel="canonical" href="https://huajun-chen.github.io/2022/10/28/Golang%E9%9D%A2%E8%AF%95%E9%A2%98/">
  

  
  

  
  
  

  
<link rel="stylesheet" href="/css/mdui.css">
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/custom.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body class="mdui-appbar-with-toolbar mdui-theme-primary-grey mdui-theme-accent-deep-purple">
  <script>var a=localStorage.getItem("mdui-theme-layout-dark");if(a){document.getElementsByTagName("body")[0].className+=" mdui-theme-layout-dark"};</script>
  <script>if(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches){document.getElementsByTagName("body")[0].className+=" mdui-theme-layout-dark"};</script>
  <script>var a=localStorage.getItem("mdui-drawer-close");if(!a){document.getElementsByTagName("body")[0].className+=" mdui-drawer-body-left"};</script>
  <header id="header" class="mdui-appbar mdui-appbar-fixed mdui-appbar-scroll-hide mdui-appbar-inset">
  <div class="mdui-toolbar mdui-color-theme">
    <a href="javascript:;" class="mdui-btn mdui-btn-icon" mdui-drawer="{target: '#sidebar', swipe: true}"><i class="mdui-icon material-icons">menu</i></a>
    <a href="/" class="mdui-typo-headline">可可西里-博客</a>
    <div class="mdui-toolbar-spacer"></div>
    <a href="javascript:;" class="mdui-btn mdui-btn-icon" mdui-dialog="{target: '#search'}" mdui-tooltip="{content: '搜索'}"><i class="mdui-icon material-icons">search</i></a>
    <a href="/atom.xml" class="mdui-btn mdui-btn-icon" mdui-tooltip="{content: 'RSS'}"><i class="mdui-icon material-icons">rss_feed</i></a>
<!--      <a href="javascript:;" class="mdui-btn mdui-btn-icon" mdui-drawer="{target: '#sidebar', swipe: true}" style="margin-right: 0px"><i class="mdui-icon material-icons" style="cursor:pointer">brightness_4</i></a>-->
      <a href="javascript:;" class="mdui-btn mdui-btn-icon" style="margin-right: 0px"><i class="mdui-icon material-icons" style="cursor:pointer">brightness_4</i></a>
      <div style="margin-left: 0px;cursor:pointer">长按切换</div>
  </div>
</header>
<div class="mdui-dialog" id="search">
  
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="请输入关键字"><input type="hidden" name="sitesearch" value="https://huajun-chen.github.io"></form>
    <div class="search-result"></div>
  
</div>

  <aside id="sidebar" class="mdui-drawer mdui-drawer-full-height">
  <script>var a=localStorage.getItem("mdui-drawer-close");if(a){document.getElementById("sidebar").className+=" mdui-drawer-close"};</script>
  <div class="mdui-grid-tile">
    <img src="/images/banner.png" style="height: 160px;">
    <img src="/images/avatar.png" class="avatar-animation" style="position: absolute; top: 10%; left: 24px; width: 64px; height: 64px; border: 2px solid #fff; border-radius: 50%;">
    <div class="mdui-grid-tile-actions">
      <div class="mdui-grid-tile-text">
        <div class="mdui-grid-tile-title">可可西里</div>
<!--        <div class="mdui-grid-tile-subtitle"><i class="mdui-icon material-icons">art_track</i>好好吃饭 好好睡觉 好好上班</div>-->
        <div class="mdui-grid-tile-subtitle">好好吃饭 好好睡觉 好好上班</div>
      </div>
      
        <div class="mdui-grid-tile-buttons">
          <a href="mailto:hellowuhan@protonmail.com" class="mdui-btn mdui-btn-icon" mdui-tooltip="{content: 'hellowuhan@protonmail.com'}"><i class="mdui-icon material-icons">email</i></a>
        </div>
      
    </div>
  </div>

  <div class="mdui-list" mdui-collapse="{accordion: true}">
    <a href="/" class="mdui-list-item mdui-ripple">
      <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-blue">home</i>
      <div class="mdui-list-item-content">主页</div>
    </a>
    <div class="mdui-collapse-item">
      <script>var a=localStorage.getItem("mdui-collapse-item-0");if(a){document.getElementsByClassName("mdui-collapse-item")[0].className+=" mdui-collapse-item-open"};</script>
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-deep-orange">archive</i>
        <div class="mdui-list-item-content">归档</div>
        <i class="mdui-collapse-item-arrow mdui-icon material-icons">keyboard_arrow_down</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
        
        <a class="mdui-ripple sidebar_archives-link" href="/archives/2022/12/">十二月 2022<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2022/11/">十一月 2022<span class="mdui-ripple sidebar_archives-count">22</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2022/10/">十月 2022<span class="mdui-ripple sidebar_archives-count">10</span></a>
        
      </div>
    </div>
    <div class="mdui-collapse-item">
      <script>var a=localStorage.getItem("mdui-collapse-item-1");if(a){document.getElementsByClassName("mdui-collapse-item")[1].className+=" mdui-collapse-item-open"};</script>
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-green">class</i>
        <div class="mdui-list-item-content">分类</div>
        <i class="mdui-collapse-item-arrow mdui-icon material-icons">keyboard_arrow_down</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
        
        <a class="mdui-ripple sidebar_archives-link" href="/categories/%E5%8A%A0%E5%AF%86/">加密<span class="mdui-ripple sidebar_archives-count">3</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端<span class="mdui-ripple sidebar_archives-count">19</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试<span class="mdui-ripple sidebar_archives-count">12</span></a>
        
      </div>
    </div>
    <div class="mdui-collapse-item">
      <script>var a=localStorage.getItem("mdui-collapse-item-2");if(a){document.getElementsByClassName("mdui-collapse-item")[2].className+=" mdui-collapse-item-open"};</script>
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-brown">bookmark</i>
        <div class="mdui-list-item-content">标签</div>
        <i class="mdui-collapse-item-arrow mdui-icon material-icons">keyboard_arrow_down</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
        
        <a class="mdui-ripple sidebar_archives-link" href="/tags/ES/" rel="tag">ES<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/Go/" rel="tag">Go<span class="mdui-ripple sidebar_archives-count">6</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/Kafka/" rel="tag">Kafka<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/Linux/" rel="tag">Linux<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/MySQL/" rel="tag">MySQL<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/Redis/" rel="tag">Redis<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" rel="tag">云原生<span class="mdui-ripple sidebar_archives-count">18</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%9E%B6%E6%9E%84/" rel="tag">系统设计与架构<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式<span class="mdui-ripple sidebar_archives-count">1</span></a>
        
      </div>
    </div>
    <a href="/about" class="mdui-list-item mdui-ripple">
      <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-purple">person</i>
      <div class="mdui-list-item-content">关于</div>
    </a>
  </div>

  <div class="mdui-divider"></div>

  <div class="mdui-list" mdui-collapse="{accordion: true}">
    
      <a href="/timeline" class="mdui-list-item mdui-ripple">时间轴</a>
    
      <a href="/tagcloud" class="mdui-list-item mdui-ripple">标签云</a>
    
      <a href="/gallery" class="mdui-list-item mdui-ripple">相册</a>
    
    <div class="mdui-collapse-item">
      <script>var a=localStorage.getItem("mdui-collapse-item-3");if(a){document.getElementsByClassName("mdui-collapse-item")[3].className+=" mdui-collapse-item-open"};</script>
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <div class="mdui-list-item-content">友情链接</div>
        <i class="mdui-list-item-icon mdui-icon material-icons">link</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
        
        
          <a href="javascript:;" class="mdui-list-item mdui-p-l-2 mdui-text-color-theme mdui-ripple" style="justify-content: center;">链接为空</a>
        
      </div>
    </div>
  </div>
</aside>

  <main id="main" class="mdui-m-t-5 fadeIn animated">
  
<link rel="stylesheet" href="//cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  <style>#main article .mdui-card-content .center-block{display:block!important;margin-right:auto!important;margin-left:auto!important}</style>
  <style>#main article .mdui-card-content .text-center{text-align:center!important}</style>
  <article class="mdui-card mdui-m-b-5">
    <header class="mdui-card-media">
      <img src="/images/random/material-6.png" style="max-height: 240px;">
      <div class="mdui-card-media-covered">
        <div class="mdui-card-primary">
          <div class="mdui-card-primary-title">Go-面试题</div>
          <div class="mdui-card-primary-subtitle"><i class="iconfont">&#xe697;</i> 2022-10-28 / <i class="iconfont">&#xe601;</i> 可可西里</div>
        </div>
      </div>
      <div class="mdui-card-menu">
<!--        -->
<!--          <button class="mdui-btn mdui-btn-icon mdui-text-color-white" mdui-menu="{target: '#qrcode', align: 'right'}"><i class="mdui-icon material-icons">devices</i></button>-->
<!--          <ul class="mdui-menu" id="qrcode">-->
<!--            -->
<!--              <li class="mdui-menu-item"><a class="mdui-text-center mdui-ripple">发送到手机</a></li>-->
<!--            -->
<!--            <li class="mdui-menu-item" disabled>-->
<!--              -->
<!--                <img src="//qr.liantu.com/api.php?w=246&m=10&text=https://huajun-chen.github.io/2022/10/28/Golang%E9%9D%A2%E8%AF%95%E9%A2%98/">-->
<!--              -->
<!--            </li>-->
<!--          </ul>-->
<!--        -->
        
          <button class="mdui-btn mdui-btn-icon mdui-text-color-white" mdui-menu="{target: '#share_menu', align: 'right'}"><i class="mdui-icon material-icons">share</i></button>
          <ul class="mdui-menu" id="share_menu">
            <li class="mdui-menu-item">
              <a href="https://service.weibo.com/share/share.php?appkey=&title=Go-面试题&url=https://huajun-chen.github.io/2022/10/28/Golang%E9%9D%A2%E8%AF%95%E9%A2%98/&pic=https://huajun-chen.github.io/images/favicon.png&searchPic=false&style=simple" target="_blank" class="mdui-ripple">分享到 Weibo</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://twitter.com/intent/tweet?text=Go-面试题&url=https://huajun-chen.github.io/2022/10/28/Golang%E9%9D%A2%E8%AF%95%E9%A2%98/&via=可可西里" target="_blank" class="mdui-ripple">分享到 Twitter</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://www.facebook.com/sharer/sharer.php?u=https://huajun-chen.github.io/2022/10/28/Golang%E9%9D%A2%E8%AF%95%E9%A2%98/" target="_blank" class="mdui-ripple">分享到 Facebook</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://plus.google.com/share?url=https://huajun-chen.github.io/2022/10/28/Golang%E9%9D%A2%E8%AF%95%E9%A2%98/" target="_blank" class="mdui-ripple">分享到 Google+</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://huajun-chen.github.io/2022/10/28/Golang%E9%9D%A2%E8%AF%95%E9%A2%98/&title=Go-面试题" target="_blank" class="mdui-ripple">分享到 LinkedIn</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://connect.qq.com/widget/shareqq/index.html?site=可可西里-博客&title=Go-面试题&pics=https://huajun-chen.github.io/images/favicon.png&url=https://huajun-chen.github.io/2022/10/28/Golang%E9%9D%A2%E8%AF%95%E9%A2%98/" target="_blank" class="mdui-ripple">分享到 QQ</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://telegram.me/share/url?url=https://huajun-chen.github.io/2022/10/28/Golang%E9%9D%A2%E8%AF%95%E9%A2%98/&text=Go-面试题" target="_blank" class="mdui-ripple">分享到 Telegram</a>
            </li>
          </ul>
        
      </div>
    </header>
    <div class="mdui-card-content mdui-typo">
      <p>Go常见面试题分享，涵盖了常见的Go面试八股文</p>
<h4 id="1-无缓冲Chan的发送和接收是否同步"><a href="#1-无缓冲Chan的发送和接收是否同步" class="headerlink" title="1. 无缓冲Chan的发送和接收是否同步"></a><font color=DarkOrange>1. 无缓冲Chan的发送和接收是否同步</font></h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch := make(chan int)    无缓冲的channel由于没有缓冲发送和接收需要同步</span><br><span class="line">ch := make(chan int, 2) 有缓冲channel不要求发送和接收操作同步</span><br></pre></td></tr></table></figure>

<ul>
<li>channel无缓冲时，发送阻塞直到数据被接收，接收阻塞直到读到数据</li>
<li>channel有缓冲时，当缓冲满时发送阻塞，当缓冲空时接收阻塞</li>
</ul>
<h4 id="2-什么是channel，为什么它可以做到线程安全"><a href="#2-什么是channel，为什么它可以做到线程安全" class="headerlink" title="2. 什么是channel，为什么它可以做到线程安全"></a><font color=DarkOrange>2. 什么是channel，为什么它可以做到线程安全</font></h4><ul>
<li>Channel是Go中的一个核心类型，可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication)，Channel也可以理解是一个先进先出的队列，通过管道进行通信</li>
<li>Golang的Channel，发送一个数据到Channel和从Channel接收一个数据都是原子性的</li>
<li>Go的设计思想就是，不要通过共享内存来通信，而是通过通信来共享内存，前者就是传统的加锁，后者就是Channel</li>
<li>设计Channel的主要目的就是在多任务间传递数据的，本身就是安全的</li>
</ul>
<h4 id="3-Goroutine和Channel的作用分别是什么"><a href="#3-Goroutine和Channel的作用分别是什么" class="headerlink" title="3. Goroutine和Channel的作用分别是什么"></a><font color=DarkOrange>3. Goroutine和Channel的作用分别是什么</font></h4><p>进程是内存资源管理和cpu调度的执行单元。为了有效利用多核处理器的优势，将进程进一步细分，允许一个进程里存在多个线程，这多个线程还是共享同一片内存空间，但cpu调度的最小单元变成了线程</p>
<p>协程，可以看作是轻量级的线程。但与线程不同的是，线程的切换是由操作系统控制的，而协程的切换则是由用户控制的</p>
<p>Go中的goroutinue就是协程，可以实现并行，多个协程可以在多个处理器同时跑。而协程同一时刻只能在一个处理器上跑（可以把宿主语言想象成单线程的就好了）</p>
<p>多个goroutine之间的通信是通过channel，在Golang中channel则是goroutinues之间进行通信的渠道。可以把channel形象比喻为工厂里的传送带，一头的生产者goroutine往传输带放东西，另一头的消费者goroutinue则从输送带取东西。channel实际上是一个有类型的消息队列，遵循先进先出的特点</p>
<h4 id="4-Channel是同步的还是异步的"><a href="#4-Channel是同步的还是异步的" class="headerlink" title="4. Channel是同步的还是异步的"></a><font color=DarkOrange>4. Channel是同步的还是异步的</font></h4><p>Channel是异步进行的，channel存在3种状态：</p>
<ul>
<li>nil，未初始化的状态，只进行了声明，或者手动赋值为nil</li>
<li>active，正常的channel，可读或者可写</li>
<li>closed，已关闭，千万不要误认为关闭channel后，channel的值是nil</li>
</ul>
<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">一个零值nil通道</th>
<th align="left">一个非零值但已关闭的通道</th>
<th align="left">一个非零值且尚未关闭的通道</th>
</tr>
</thead>
<tbody><tr>
<td align="left">关闭</td>
<td align="left">产生恐慌</td>
<td align="left">产生恐慌</td>
<td align="left">成功关闭</td>
</tr>
<tr>
<td align="left">发送数据</td>
<td align="left">永久阻塞</td>
<td align="left">产生恐慌</td>
<td align="left">阻塞或者成功发送</td>
</tr>
<tr>
<td align="left">接收数据</td>
<td align="left">永久阻塞</td>
<td align="left">永不阻塞</td>
<td align="left">阻塞或者成功接收</td>
</tr>
</tbody></table>
<h4 id="5-Go中的channel的实现"><a href="#5-Go中的channel的实现" class="headerlink" title="5. Go中的channel的实现"></a><font color=DarkOrange>5. Go中的channel的实现</font></h4><p>在Go中最常见的就是通信顺序进程（Communicating sequential processes，CSP）的并发模型，通过共享通信，来实现共享内存，这里就提到了channel。Goroutine 和 Channel 分别对应 CSP 中的实体和传递信息的媒介，Go 语言中的 Goroutine 会通过 Channel 传递数据</p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7no7xmdcgj313c0b0jtt.jpg" alt="image.png" style="zoom:25%;" /></div>

<p>Goroutine通过使用channel传递数据，一个会向 Channel 中发送数据，另一个会从 Channel 中接收数据，它们两者能够独立运行并不存在直接关联，但是能通过 Channel 间接完成通信</p>
<p>Channel 收发操作均遵循了先入先出（FIFO）的设计，具体规则如下：</p>
<ul>
<li>先从 Channel 读取数据的 Goroutine 会先接收到数据</li>
<li>先向 Channel 发送数据的 Goroutine 会得到先发送数据的权利</li>
</ul>
<p>Channel 通常会有以下三种类型：</p>
<ul>
<li>同步 Channel — 不需要缓冲区，发送方会直接将数据交给（Handoff）接收方</li>
<li>异步 Channel：基于环形缓存的传统生产者消费者模型</li>
<li><code>chan struct&#123;&#125;</code> 类型的异步 <code>Channel</code> 的 <code>struct&#123;&#125;</code> 类型不占用内存空间，不需要实现缓冲区和直接发送（Handoff）的语义</li>
</ul>
<p>Channel 在运行时使用 <code>runtime.hchan</code> 结构体表示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="type">uint</span>           <span class="comment">// 当前队列里还剩余元素个数</span></span><br><span class="line">    dataqsiz <span class="type">uint</span>           <span class="comment">// 环形队列长度，即缓冲区的大小，即make(chan T,N) 中的N</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// 环形队列指针</span></span><br><span class="line">    elemsize <span class="type">uint16</span>         <span class="comment">// 每个元素的大小</span></span><br><span class="line">    closed   <span class="type">uint32</span>         <span class="comment">// 标识当前通道是否处于关闭状态，创建通道后，该字段设置0，即打开通道；通道调用close将其设置为1，通道关闭</span></span><br><span class="line">    elemtype *_type         <span class="comment">// 元素类型，用于数据传递过程中的赋值</span></span><br><span class="line">    sendx    <span class="type">uint</span>           <span class="comment">// 环形缓冲区的状态字段，它只是缓冲区的当前索引-支持数组，它可以从中发送数据</span></span><br><span class="line">    recvx    <span class="type">uint</span>          <span class="comment">// 环形缓冲区的状态字段，它只是缓冲区当前索引-支持数组，它可以从中接受数据</span></span><br><span class="line">    recvq    waitq         <span class="comment">// 等待读消息的goroutine队列</span></span><br><span class="line">    sendq    waitq         <span class="comment">// 等待写消息的goroutine队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">    <span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line">    <span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">    <span class="comment">// with stack shrinking.</span></span><br><span class="line">    lock mutex           <span class="comment">// 互斥锁，为每个读写操作锁定通道，因为发送和接受必须是互斥操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">    first *sudog</span><br><span class="line">    last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中hchan结构体中有五个字段是构建底层的循环队列：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">qcount：Channel中的元素个数</span><br><span class="line">dataqsiz：Channel中的循环队列的长度</span><br><span class="line">buf：Channel的缓冲区数据指针</span><br><span class="line">sendx：Channel的发送操作处理到的位置</span><br><span class="line">recvx：Channel的接收操作处理到的位置</span><br></pre></td></tr></table></figure>

<h4 id="6-Golang并发机制以及它所使用的CSP并发模型"><a href="#6-Golang并发机制以及它所使用的CSP并发模型" class="headerlink" title="6. Golang并发机制以及它所使用的CSP并发模型"></a><font color=DarkOrange>6. Golang并发机制以及它所使用的CSP并发模型</font></h4><p>在计算机科学中，通信顺序过程（communicating sequential processes，CSP）是一种描述并发系统中交互模式的正式语言，它是并发数学理论家族中的一个成员，被称为过程算法（process algebras），或者说过程计算（process calculate），是基于消息的通道传递的数学理论</p>
<p>Golang中的Goroutine的特性：</p>
<p>Golang内部有三个对象： P对象(processor) 代表上下文（或者可以认为是cpu），M(work thread)代表工作线程，G对象（goroutine）</p>
<p>正常情况下一个cpu对象启一个工作线程对象，线程去检查并执行goroutine对象。碰到goroutine对象阻塞的时候，会启动一个新的工作线程，以充分利用cpu资源。所以有时候线程对象会比处理器对象多很多</p>
<ul>
<li>G（Goroutine） ：我们所说的协程，为用户级的轻量级线程，每个Goroutine对象中的sched保存着其上下文信息</li>
<li>M（Machine） ：对Os内核级线程的封装，数量对应真实的CPU数（真正干活的对象）</li>
<li>P（Processor） ：逻辑处理器，即为G和M的调度对象，用来调度G和M之间的关联关系，其数量可通过GOMAXPROCS()来设置，默认为核心数</li>
</ul>
<p>在单核情况下，所有Goroutine运行在同一个线程（M0）中，每一个线程维护一个上下文（P），任何时刻，一个上下文中只有一个Goroutine，其他Goroutine在runqueue中等待。一个Goroutine运行完自己的时间片后，让出上下文，自己回到runqueue中（如下图所示）</p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7nojprq3uj30ns0kgdi9.jpg" alt="image.png" style="zoom:38%;" /></div>

<p>当正在运行的G0阻塞的时候（可以需要IO），会再创建一个线程（M1），P转到新的线程中去运行</p>
<p>当M0返回时，它会尝试从其他线程中“偷”一个上下文过来，如果没有偷到，会把Goroutine放到Global runqueue中去，然后把自己放入线程缓存中。上下文会定时检查Global runqueue</p>
<p>Golang的CSP并发模型，是通过Goroutine和Channel来实现的</p>
<p>因此，GPM的简要概括即为：事件循环，线程池，工作队列</p>
<h4 id="7-Go的GPM如何调度"><a href="#7-Go的GPM如何调度" class="headerlink" title="7. Go的GPM如何调度"></a><font color=DarkOrange>7. Go的GPM如何调度</font></h4><p>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此，协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置</p>
<p>线程和进程的操作是由程序触发系统接口，最后的执行者是系统；协程的操作执行者则是用户自身程序，goroutine也是协程</p>
<p>groutine能拥有强大的并发实现是通过GPM调度模型实现</p>
<p>Go的调度器内部有四个重要的结构：M，G，P，Sched：</p>
<ul>
<li>M：M代表内核级线程，一个M就是一个线程，goroutine就是跑在M之上的；M是一个很大的结构，里面维护小对象内存cache（mcache）、当前执行的goroutine、随机数发生器等等非常多的信息</li>
<li>G：代表一个goroutine，它有自己的栈，instruction pointer和其他信息（正在等待的channel等等），用于调度</li>
<li>P：P全称是Processor，逻辑处理器，它的主要用途就是用来执行goroutine的，所以它也维护了一个goroutine队列，里面存储了所有需要它来执行的goroutine</li>
<li>Sched：代表调度器，它维护有存储M和G的队列以及调度器的一些状态信息等</li>
</ul>
<hr>
<ol>
<li>新创建的Goroutine会先存放在Global全局队列中，等待Go调度器进行调度，随后Goroutine被分配给其中的一个逻辑处理器P，并放到这个逻辑处理器对应的Local本地运行队列中，最终等待被逻辑处理器P执行即可</li>
<li>在M与P绑定后，M会不断从P的Local队列中无锁地取出G，并切换到G的堆栈执行，当P的Local队列中没有G时，再从Global队列中获取一个G，当Global队列中也没有待运行的G时，则尝试从其它的P窃取部分G来执行相当于P之间的负载均衡</li>
<li>每一个M都拥有一个处理器P，每一个也都有一个正在运行的goroutine。P的数量可以通过GOMAXPROCS()来设置，它其实也就代表了真正的并发度，即有多少个goroutine可以同时运行</li>
<li>对于没有运行的goroutine，而是出于ready的就绪态，正在等待被调度。P维护着这个队列（称之为runqueue），Go语言里，启动一个goroutine很容易：go function 就行，所以每有一个go语句被执行，runqueue队列就在其末尾加入一个goroutine，在下一个调度点，就从runqueue中取出（如何决定取哪个goroutine？）一个goroutine执行</li>
<li>当一个OS线程M0陷入阻塞时，P转而在运行M1，图中的M1可能是正被创建，或者从线程缓存中取出</li>
<li>当MO返回时，它必须尝试取得一个P来运行goroutine，一般情况下，它会从其他的OS线程那里拿一个P过来，如果没有拿到的话，它就把goroutine放在一个<code>global runqueue</code>里，然后自己睡眠（放入线程缓存里）。所有的P也会周期性的检查<code>global runqueue</code>并运行其中的goroutine，否则<code>global runqueue</code>上的goroutine永远无法执行</li>
<li>另一种情况是P所分配的任务G很快就执行完了（分配不均），这就导致了这个处理器P处于空闲的状态，但是此时其他的P还有任务，此时如果global runqueue没有任务G了，那么这个P就会从其他的P里偷取一些G来执行。通常来说，如果P从其他的P那里要拿任务的话，一般就拿<code>run queue</code>的一半，这就确保了每个OS线程都能充分的使用</li>
</ol>
<h4 id="8-Golang中常用的并发模型"><a href="#8-Golang中常用的并发模型" class="headerlink" title="8. Golang中常用的并发模型"></a><font color=DarkOrange>8. Golang中常用的并发模型</font></h4><p>Golang中常用的并发模型有三种:</p>
<ul>
<li>通过channel通知实现并发控制</li>
<li>通过sync包中的WaitGroup实现并发控制</li>
<li>在Go1.7以后引进的强大的Context上下文，实现并发控制</li>
</ul>
<ol>
<li><p>通过channel通知实现并发控制</p>
<p>无缓冲的通道指的是通道的大小为0，也就是说，这种类型的通道在接收前没有能力保存任何值，它要求发送 goroutine 和接收 goroutine 同时准备好，才可以完成发送和接收操作</p>
<p>发送 goroutine 和接收 gouroutine 必须是同步的，同时准备后，如果没有同时准备好的话，先执行的操作就会阻塞等待，直到另一个相对应的操作准备好为止</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;start working&quot;</span>)</span><br><span class="line">        time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">        ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;-ch</span><br><span class="line">    fmt.Println(<span class="string">&quot;finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当主 goroutine 运行到 <code>&lt;-ch</code> 接受 channel 的值的时候，如果该 channel 中没有数据，就会一直阻塞等待，直到有值。 这样就可以简单实现并发控制</p>
<hr>
</li>
<li><p>通过sync包中的WaitGroup实现并发控制</p>
<p>Goroutine是异步执行的，有的时候为了防止在结束main函数的时候结束掉Goroutine，所以需要同步等待，这个时候就需要用 WaitGroup了，在sync包中，提供了WaitGroup，它会等待它收集的所有Goroutine任务全部完成。在WaitGroup里主要有三个方法:</p>
<ul>
<li>Add，可以添加或减少Goroutine的数量</li>
<li>Done，相当于Add(-1)</li>
<li>Wait，执行后会堵塞主线程，直到WaitGroup里的值减至0</li>
</ul>
<p>在主 goroutine 中 Add(delta int) 索要等待goroutine 的数量。在每一个 goroutine 完成后 Done() 表示这一个goroutine 已经完成，当所有的 goroutine 都完成后，在主 goroutine 中 WaitGroup 返回</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">var</span> urls = []<span class="type">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;http://www.golang.org/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://www.google.com/&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            http.Get(url)</span><br><span class="line">        &#125;(url)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Golang官网中对于WaitGroup介绍是<code>A WaitGroup must not be copied after first use</code>,在 WaitGroup第一次使用后，不能被拷贝</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(wg sync.WaitGroup, i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;i:%d&quot;</span>, i)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(wg, i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;exit&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之后会报错：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i:1i:3i:2i:0i:4fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine 1 [semacquire]:</span><br><span class="line">sync.runtime_Semacquire(0xc000094018)</span><br><span class="line">        /home/keke/soft/go/src/runtime/sema.go:56 +0x39</span><br><span class="line"><span class="built_in">sync</span>.(*WaitGroup).Wait(0xc000094010)</span><br><span class="line">        /home/keke/soft/go/src/sync/waitgroup.go:130 +0x64</span><br><span class="line">main.main()</span><br><span class="line">        /home/keke/go/Test/wait.go:17 +0xab</span><br><span class="line"><span class="built_in">exit</span> status 2</span><br></pre></td></tr></table></figure>

<p>它提示所有的 <code>goroutine</code> 都已经睡眠了，出现了死锁。这是因为wg给拷贝传递到了goroutine中，导致只有Add操作，其实Done操作是在wg的副本执行的，因此 Wait 就会死锁</p>
<ul>
<li><p>这个第一个修改方式：将匿名函数中wg的传入类型改为 <code>*sync.WaitGroup，</code>这样就能引用到正确的<code>WaitGroup</code>了</p>
</li>
<li><p>这个第二个修改方式：将匿名函数中的wg的传入参数去掉，因为Go支持闭包类型，在匿名函数中可以直接使用外面的wg变量</p>
</li>
</ul>
<hr>
</li>
<li><p>Context上下文实现并发控制</p>
<p>通常，在一些简单场景下使用channel和WaitGroup已经足够了，但是当面临一些复杂多变的网络并发场景下channel和WaitGroup显得有些力不从心了，比如一个网络请求Request，每个Request都需要开启一个goroutine做一些事情，这些goroutine又可能会开启其他的goroutine，比如数据库和RPC服务</p>
<p>所以我们需要一种可以跟踪goroutine的方案，才可以达到控制他们的目的，这就是Go语言为我们提供的Context，称之为上下文非常贴切，它就是goroutine的上下文，它是包括一个程序的运行环境、现场和快照等。每个程序要运行时，都需要知道当前程序的运行状态，通常Go将这些封装在一个 Context里，再将它传给要执行的goroutine ，context包主要是用来处理多个goroutine之间共享数据，及多个goroutine的管理</p>
<p>context包的核心是struct Context，接口声明如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Context carries a deadline, cancelation signal, and request-scoped values</span></span><br><span class="line"><span class="comment">// across API boundaries. Its methods are safe for simultaneous use by multiple</span></span><br><span class="line"><span class="comment">// goroutines.</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Done returns a channel that is closed when this `Context` is canceled</span></span><br><span class="line">    <span class="comment">// or times out.</span></span><br><span class="line">    <span class="comment">// Done() 返回一个只能接受数据的channel类型，当该context关闭或者超时时间到了的时候，该channel就会有一个取消信号</span></span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Err indicates why this Context was canceled, after the Done channel</span></span><br><span class="line">    <span class="comment">// is closed.</span></span><br><span class="line">    <span class="comment">// Err() 在Done() 之后，返回context 取消的原因。</span></span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deadline returns the time when this Context will be canceled, if any.</span></span><br><span class="line">    <span class="comment">// Deadline() 设置该context cancel的时间点</span></span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Value returns the value associated with key or nil if none.</span></span><br><span class="line">    <span class="comment">// Value() 方法允许 Context 对象携带request作用域的数据，该数据必须是线程安全的。</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Context对象是线程安全的，你可以把一个Context对象传递给任意个数的gorotuine，对它执行 取消 操作时，所有goroutine都会接收到取消信号。一个Context不能拥有Cancel方法，同时我们也只能Done channel接收数据。其中的原因是一致的：接收取消信号的函数和发送信号的函数通常不是一个。典型的场景是：父操作为子操作操作启动goroutine，子操作也就不能取消父操作</p>
</li>
</ol>
<h4 id="9-并发编程概念是什么"><a href="#9-并发编程概念是什么" class="headerlink" title="9. 并发编程概念是什么"></a><font color=DarkOrange>9. 并发编程概念是什么</font></h4><ul>
<li>并行是指两个或者多个事件在同一时刻发生；并发是指两个或多个事件在同一时间间隔发生</li>
<li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群</li>
<li>并发偏重于多个任务交替执行，而多个任务之间有可能还是串行的。而并行是真正意义上的“同时执行”</li>
<li>并发编程是指在一台处理器上“同时”处理多个任务。并发是在同一实体上的多个事件。多个事件在同一时间间隔发生。并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能</li>
</ul>
<h4 id="10-怎么查看Goroutine的数量"><a href="#10-怎么查看Goroutine的数量" class="headerlink" title="10. 怎么查看Goroutine的数量"></a><font color=DarkOrange>10. 怎么查看Goroutine的数量</font></h4><p>在Golang中，<code>GOMAXPROCS</code>中控制的是未被阻塞的所有Goroutine，可以被 <code>Multiplex</code> 到多少个线程上运行，通过<code>GOMAXPROCS</code>可以查看Goroutine的数量</p>
<h4 id="11-怎么限制Goroutine的数量"><a href="#11-怎么限制Goroutine的数量" class="headerlink" title="11. 怎么限制Goroutine的数量"></a><font color=DarkOrange>11. 怎么限制Goroutine的数量</font></h4><p>在Golang中，Goroutine虽然很好，但是数量太多了，往往会带来很多麻烦，比如耗尽系统资源导致程序崩溃，或者CPU使用率过高导致系统忙不过来。所以我们可以限制下Goroutine的数量，这样就需要在每一次执行go之前判断goroutine的数量，如果数量超了，就要阻塞go的执行</p>
<ul>
<li>使用通道，每次执行的go之前向通道写入值，直到通道满的时候就阻塞了</li>
<li>但是新的问题于是就出现了，因为并不是所有的goroutine都执行完了，在main函数退出之后，还有一些goroutine没有执行完就被强制结束了。这个时候我们就需要用到sync.WaitGroup。使用WaitGroup等待所有的goroutine退出</li>
<li>Go的GOMAXPROCS默认值已经设置为CPU的核数， 这里允许我们的Go程序充分使用机器的每一个CPU，最大程度的提高我们程序的并发性能。<code>runtime.NumGoroutine</code>函数在被调用后，会返回系统中的处于特定状态的Goroutine的数量。这里的特指是指<code>Grunnable\Gruning\Gsyscall\Gwaition</code>。处于这些状态的Groutine即被看做是活跃的或者说正在被调度</li>
<li><strong>注意：</strong> 垃圾回收所在Groutine的状态也处于这个范围内的话，也会被纳入该计数器</li>
</ul>
<h4 id="12-Goroutine和线程的区别"><a href="#12-Goroutine和线程的区别" class="headerlink" title="12. Goroutine和线程的区别"></a><font color=DarkOrange>12. Goroutine和线程的区别</font></h4><p>从调度上看，goroutine的调度开销远远小于线程调度开销</p>
<ul>
<li>线程：OS的线程由OS内核调度，每隔几毫秒，一个硬件时钟中断发到CPU，CPU调用一个调度器内核函数。这个函数暂停当前正在运行的线程，把他的寄存器信息保存到内存中，查看线程列表并决定接下来运行哪一个线程，再从内存中恢复线程的注册表信息，最后继续执行选中的线程。这种线程切换需要一个完整的上下文切换：即保存一个线程的状态到内存，再恢复另外一个线程的状态，最后更新调度器的数据结构。某种意义上，这种操作还是很慢的</li>
<li>goroutine：Go运行的时候包涵一个自己的调度器，这个调度器使用一个称为一个M:N调度技术，m个goroutine到n个os线程（可以用GOMAXPROCS来控制n的数量），Go的调度器不是由硬件时钟来定期触发的，而是由特定的go语言结构来触发的，他不需要切换到内核语境，所以调度一个goroutine比调度一个线程的成本低很多</li>
</ul>
<p>从栈空间上，goroutine的栈空间更加动态灵活</p>
<p>每个OS的线程都有一个固定大小的栈内存，通常是2MB，栈内存用于保存在其他函数调用期间哪些正在执行或者临时暂停的函数的局部变量。这个固定的栈大小，如果对于goroutine来说，可能是一种巨大的浪费。作为对比goroutine在生命周期开始只有一个很小的栈，典型情况是2KB, 在go程序中，一次创建十万左右的goroutine也不罕见（2KB*100,000&#x3D;200MB）。而且goroutine的栈不是固定大小，它可以按需增大和缩小，最大限制可以到1GB</p>
<p>goroutine没有一个特定的标识</p>
<p>在大部分支持多线程的操作系统和编程语言中，线程有一个独特的标识，通常是一个整数或者指针，这个特性可以让我们构建一个线程的局部存储，本质是一个全局的map，以线程的标识作为键，这样每个线程可以独立使用这个map存储和获取值，不受其他线程干扰</p>
<p>goroutine中没有可供程序员访问的标识，原因是一种纯函数的理念，不希望滥用线程局部存储导致一个不健康的超距作用，即函数的行为不仅取决于它的参数，还取决于运行它的线程标识</p>
<h4 id="13-在Go函数中为什么会发生内存泄露，Goroutine发生了泄漏如何检测"><a href="#13-在Go函数中为什么会发生内存泄露，Goroutine发生了泄漏如何检测" class="headerlink" title="13. 在Go函数中为什么会发生内存泄露，Goroutine发生了泄漏如何检测"></a><font color=DarkOrange>13. 在Go函数中为什么会发生内存泄露，Goroutine发生了泄漏如何检测</font></h4><p>内存泄漏，指的是能够预期的能很快被释放的内存由于附着在了长期存活的内存上、或生命期意外地被延长，导致预计能够立即回收的内存而长时间得不到回收</p>
<ul>
<li>预期能被快速释放的内存因被根对象引用而没有得到迅速释放；当有一个全局对象时，可能不经意间将某个变量附着在其上，且忽略的将其进行释放，则该内存永远不会得到释放</li>
<li>Goroutine泄漏；Goroutine作为一种逻辑上理解的轻量级线程，需要维护执行用户代码的上下文信息。在运行过程中也需要消耗一定的内存来保存这类信息，而这些内存在目前版本的 Go 中是不会被释放的。因此，如果一个程序持续不断地产生新的 goroutine、且不结束已经创建的goroutine并复用这部分内存，就会造成内存泄漏的现象</li>
<li>检测方法：通过Go自带的工具pprof或者使用Gops去检测诊断当前在系统上运行的Go进程的占用的资源</li>
</ul>
<hr>
<h5 id="13-1-PProf是什么"><a href="#13-1-PProf是什么" class="headerlink" title="13.1 PProf是什么"></a><font color=DarkOrange>13.1 PProf是什么</font></h5><ol>
<li><code>PProf</code>是一个<code>Go</code>程序性能分析工具，可以分析<code>CPU</code>，内存等性能</li>
<li><code>Go</code>在语言层面上集成了<code>profile</code>采样工具，只需要在代码中简单的引入<code>runtime/ppro</code>或者<code>net/http/pprof</code>包即可获取程序的<code>profile</code>文件，并通过该文件来进行性能分析</li>
<li><code>runtime/pprof</code>还可以为控制台程序或者测试程序产生<code>pprof</code>数据</li>
<li>其实<code>net/http/pprof</code>中只是使用<code>runtime/pprof</code>包来进行封装了一下，并在<code>HTTP</code>端口上暴露出来</li>
</ol>
<h5 id="13-2-PProf使用"><a href="#13-2-PProf使用" class="headerlink" title="13.2 PProf使用"></a><font color=DarkOrange>13.2 PProf使用</font></h5><p>在<code>gin</code>的路由中注册<code>pprof</code>的路由</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pprof router</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-contrib/pprof&quot;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">	Router = gin.New()</span><br><span class="line">	pprof.Register(Router)</span><br></pre></td></tr></table></figure>

<p>通过<code>go tool pprof http://127.0.0.1/debug/pprof/profile</code>可以获取<code>profile</code>采集信息并分析</p>
<p>也可以直接在浏览器访问<code>http://localhost:8080/debug/pprof</code>来查看当前<code>API</code>服务的状态，包括<code>CPU</code>占用情况和内存使用情况等</p>
<p>通过<code>topN</code>的输出可以分析出哪些函数占用<code>CPU</code>时间片最多，这些函数可能存在性能问题。此命名用于显示<code>profile</code>文件中的最靠前的N个样本（默认前10个<code>sample</code>），它的输出格式字段的含义依次是：</p>
<ul>
<li>采样点落在该函数中的总时间</li>
<li>采样点落在该函数中的百分比</li>
<li>上一项的累积百分比</li>
<li>采样点落在该函数，以及被它调用的函数中的总时间</li>
<li>采样点落在该函数，以及被它调用的函数中的总次数百分比</li>
<li>函数名</li>
</ul>
<p>如果觉得不直观，可以直接再生成函数调用图，通过调用图来判断哪些函数耗时最久，在<code>pprof</code>交互界面，执行<code>svg</code>生成<code>svg</code>文件</p>
<p>但是需要确保系统已经安装<code>graphviz</code>命令（<code>Mac OS:brew install graphviz; CentOS: yum -y install graphviz.x86_64</code>）</p>
<h4 id="14-Goroutine和内核线程（KernelThread）之间是什么关系"><a href="#14-Goroutine和内核线程（KernelThread）之间是什么关系" class="headerlink" title="14. Goroutine和内核线程（KernelThread）之间是什么关系"></a><font color=DarkOrange>14. Goroutine和内核线程（KernelThread）之间是什么关系</font></h4><p>进程、线程、协程的关系和区别：</p>
<ul>
<li>进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度</li>
<li>线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)</li>
<li>协程和线程一样共享堆，不共享栈，协程由程序开发者在协程的代码里显示调度</li>
</ul>
<p>为什么协程比线程轻量？</p>
<ul>
<li>go协程调用跟切换比线程效率高<ul>
<li>线程并发执行流程: 线程是内核对外提供的服务，应用程序可以通过系统调用让内核启动线程，由内核来负责线程调度和切换。线程在等待IO操作时线程变为unrunnable状态会触发上下文切换。现代操作系统一般都采用抢占式调度，上下文切换一般发生在时钟中断和系统调用返回前，调度器计算当前线程的时间片，如果需要切换就从运行队列中选出一个目标线程，保存当前线程的环境，并且恢复目标线程的运行环境，最典型的就是切换ESP指向目标线程内核堆栈，将EIP指向目标线程上次被调度出时的指令地址</li>
<li>go协程并发执行流程：不依赖操作系统和其提供的线程，golang自己实现的CSP并发模型实现：M, P, G .go协程也叫用户态线程，协程之间的切换发生在用户态。在用户态没有时钟中断，系统调用等机制,因此效率高</li>
</ul>
</li>
<li>go协程占用内存少<ul>
<li>执行go协程只需要极少的栈内存（大概是4～5KB），默认情况下，线程栈的大小为1MB。goroutine就是一段代码，一个函数入口，以及在堆上为其分配的一个堆栈。所以它非常廉价，我们可以很轻松的创建上万个goroutine，但它们并不是被操作系统所调度执行</li>
<li>因此协程和线程一样共享堆，不共享栈，协程由用户态下面的轻量级线程</li>
</ul>
</li>
</ul>
<h4 id="15-协程和线程和进程的区别"><a href="#15-协程和线程和进程的区别" class="headerlink" title="15. 协程和线程和进程的区别"></a><font color=DarkOrange>15. 协程和线程和进程的区别</font></h4><ul>
<li>进程：是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。<br>每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全</li>
<li>线程：是进程的一个实体，线程是内核态，而且是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据</li>
<li>协程：是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快</li>
</ul>
<h4 id="16-G0的作用"><a href="#16-G0的作用" class="headerlink" title="16. G0的作用"></a><font color=DarkOrange>16. G0的作用</font></h4><ul>
<li>在Go中g0作为一个特殊的goroutine，为scheduler执行调度循环提供了场地（栈）。对于一个线程来说，g0总是它第一个创建的 goroutine。之后，它会不断地寻找其他普通的goroutine来执行，直到进程退出</li>
<li>当需要执行一些任务，且不想扩栈时，就可以用到 g0了，因为g0的栈比较大</li>
<li>g0 其他的一些“职责”有：创建 <code>goroutine</code>、<code>deferproc</code> 函数里新建 <code>_defer</code>、垃圾回收相关的工作（例如stw、扫描goroutine的执行栈、一些标识清扫的工作、栈增长）等等</li>
</ul>
<h4 id="17-Golang的内存模型中为什么小对象多了会造成GC压力"><a href="#17-Golang的内存模型中为什么小对象多了会造成GC压力" class="headerlink" title="17. Golang的内存模型中为什么小对象多了会造成GC压力"></a><font color=DarkOrange>17. Golang的内存模型中为什么小对象多了会造成GC压力</font></h4><p>通常小对象过多会导致GC三色法消耗过多的CPU。优化思路：减少对象分配</p>
<h4 id="18-Go的对象在内存中是怎样分配的"><a href="#18-Go的对象在内存中是怎样分配的" class="headerlink" title="18. Go的对象在内存中是怎样分配的"></a><font color=DarkOrange>18. Go的对象在内存中是怎样分配的</font></h4><p>Go中的内存分类并不像TCMalloc那样分成小、中、大对象，但是它的小对象里又细分了一个Tiny对象，Tiny对象指大小在1Byte到16Byte之间并且不包含指针的对象。小对象和大对象只用大小划定，无其他区分</p>
<p>大对象指大小大于32kb，小对象是在mcache中分配的，而大对象是直接从mheap分配的，从小对象的内存分配看起</p>
<p>Go的内存分配原则：</p>
<ul>
<li>Go在程序启动的时候，会先向操作系统申请一块内存（注意这时还只是一段虚拟的地址空间，并不会真正地分配内存），切成小块后自己进行管理</li>
<li>申请到的内存块被分配了三个区域，在X64上分别是512MB，16GB，512GB大小</li>
<li>arena区域就是我们所谓的堆区，Go动态分配的内存都是在这个区域，它把内存分割成8KB大小的页，一些页组合起来称为mspan</li>
<li>bitmap区域标识arena区域哪些地址保存了对象，并且用4bit标志位表示对象是否包含指针、GC标记信息。bitmap中一个byte大小的内存对应arena区域中4个指针大小（指针大小为 8B ）的内存，所以bitmap区域的大小是<code>512GB/(4*8B)=16GB</code></li>
<li>bitmap的高地址部分指向arena区域的低地址部分，这里bitmap的地址是由高地址向低地址增长的</li>
<li>spans区域存放mspan（是一些arena分割的页组合起来的内存管理基本单元，后文会再讲）的指针，每个指针对应一页，所以spans区域的大小就是<code>512GB/8KB*8B=512MB</code></li>
<li>除以8KB是计算arena区域的页数，而最后乘以8是计算spans区域所有指针的大小。创建mspan的时候，按页填充对应的spans区域，在回收object时，根据地址很容易就能找到它所属的mspan</li>
</ul>
<h4 id="19-栈的内存是怎么分配的"><a href="#19-栈的内存是怎么分配的" class="headerlink" title="19. 栈的内存是怎么分配的"></a><font color=DarkOrange>19. 栈的内存是怎么分配的</font></h4><p>栈和堆只是虚拟内存上2块不同功能的内存区域：</p>
<ul>
<li>栈在高地址，从高地址向低地址增长</li>
<li>堆在低地址，从低地址向高地址增长</li>
</ul>
<p>栈和堆相比优势：</p>
<ul>
<li>栈的内存管理简单，分配比堆上快。</li>
<li>栈的内存不需要回收，而堆需要，无论是主动free，还是被动的垃圾回收，这都需要花费额外的CPU。</li>
<li>栈上的内存有更好的局部性，堆上内存访问就不那么友好了，CPU访问的2块数据可能在不同的页上，CPU访问数据的时间可能就上去了</li>
</ul>
<h4 id="20-堆内存管理怎么分配的"><a href="#20-堆内存管理怎么分配的" class="headerlink" title="20. 堆内存管理怎么分配的"></a><font color=DarkOrange>20. 堆内存管理怎么分配的</font></h4><ul>
<li>通常在Golang中，当我们谈论内存管理的时候，主要是指堆内存的管理，因为栈的内存管理不需要程序去操心</li>
<li>堆内存管理中主要是三部分, 1.分配内存块，2.回收内存块, 3.组织内存块</li>
<li>一个内存块包含了3类信息：元数据、用户数据和对齐字段，内存对齐是为了提高访问效率。申请内存的时候，就需要进行内存对齐</li>
<li>释放内存实质是把使用的内存块从链表中取出来，然后标记为未使用，当分配内存块的时候，可以从未使用内存块中有先查找大小相近的内存块，如果找不到，再从未分配的内存中分配内存</li>
<li>因为随着内存不断的申请和释放，内存上会存在大量的碎片，降低内存的使用率。为了解决内存碎片，可以将2个连续的未使用的内存块合并，减少碎片</li>
</ul>
<h4 id="21-在Go函数中为什么会发生内存泄露"><a href="#21-在Go函数中为什么会发生内存泄露" class="headerlink" title="21. 在Go函数中为什么会发生内存泄露"></a><font color=DarkOrange>21. 在Go函数中为什么会发生内存泄露</font></h4><p>同上13</p>
<h4 id="22-Go语言的栈空间管理是怎么样的"><a href="#22-Go语言的栈空间管理是怎么样的" class="headerlink" title="22. Go语言的栈空间管理是怎么样的"></a><font color=DarkOrange>22. Go语言的栈空间管理是怎么样的</font></h4><p>Go语言的运行环境（runtime）会在goroutine需要的时候动态地分配栈空间，而不是给每个goroutine分配固定大小的内存空间。这样就避免了需要程序员来决定栈的大小</p>
<p>分块式的栈是最初Go语言组织栈的方式。当创建一个goroutine的时候，它会分配一个8KB的内存空间来给goroutine的栈使用。我们可能会考虑当这8KB的栈空间被用完的时候该怎么办？</p>
<p>为了处理这种情况，每个Go函数的开头都有一小段检测代码。这段代码会检查我们是否已经用完了分配的栈空间。如果是的话，它会调用<code>morestack</code>函数。<code>morestack</code>函数分配一块新的内存作为栈空间，并且在这块栈空间的底部填入各种信息（包括之前的那块栈地址）。在分配了这块新的栈空间之后，它会重试刚才造成栈空间不足的函数。这个过程叫做栈分裂（stack split）</p>
<p>在新分配的栈底部，还插入了一个叫做<code>lessstack</code>的函数指针。这个函数还没有被调用。这样设置是为了从刚才造成栈空间不足的那个函数返回时做准备的。当我们从那个函数返回时，它会跳转到<code>lessstack</code>。<code>lessstack</code>函数会查看在栈底部存放的数据结构里的信息，然后调整栈指针（stack pointer）。这样就完成了从新的栈块到老的栈块的跳转。接下来，新分配的这个块栈空间就可以被释放掉了</p>
<h4 id="23-Go中的逃逸分析是什么"><a href="#23-Go中的逃逸分析是什么" class="headerlink" title="23. Go中的逃逸分析是什么"></a><font color=DarkOrange>23. Go中的逃逸分析是什么</font></h4><p>在Go中逃逸分析是一种确定指针动态范围的方法，可以分析在程序的哪些地方可以访问到指针。它涉及到指针分析和形状分析</p>
<p>当一个变量(或对象)在子程序中被分配时，一个指向变量的指针可能逃逸到其它执行线程中，或者去调用子程序。如果使用尾递归优化（通常在函数编程语言中是需要的），对象也可能逃逸到被调用的子程序中。 如果一个子程序分配一个对象并返回一个该对象的指针，该对象可能在程序中的任何一个地方被访问到——这样指针就成功“逃逸”了</p>
<p>如果指针存储在全局变量或者其它数据结构中，它们也可能发生逃逸，这种情况是当前程序中的指针逃逸。 逃逸分析需要确定指针所有可以存储的地方，保证指针的生命周期只在当前进程或线程中</p>
<p>导致内存逃逸的情况比较多，有些可能还是官方未能够实现精确的分析逃逸情况的 bug，通常来讲就是如果变量的作用域不会扩大并且其行为或者大小能够在编译的时候确定，一般情况下都是分配到栈上，否则就可能发生内存逃逸分配到堆上</p>
<p>内存逃逸的五种情况：</p>
<ol>
<li>发送指针的指针或值包含了指针到<code>channel</code> 中，由于在编译阶段无法确定其作用域与传递的路径，所以一般都会逃逸到堆上分配</li>
<li>slices 中的值是指针的指针或包含指针字段。一个例子是类似<code>[]*string</code> 的类型。这总是导致 slice 的逃逸。即使切片的底层存储数组仍可能位于堆栈上，数据的引用也会转移到堆中。</li>
<li>slice 由于 append 操作超出其容量，因此会导致 slice 重新分配。这种情况下，由于在编译时 slice 的初始大小的已知情况下，将会在栈上分配。如果 slice 的底层存储必须基于仅在运行时数据进行扩展，则它将分配在堆上</li>
<li>调用接口类型的方法。接口类型的方法调用是动态调度，实际使用的具体实现只能在运行时确定。考虑一个接口类型为 io.Reader 的变量 r。对 r.Read(b) 的调用将导致 r 的值和字节片b的后续转义并因此分配到堆上</li>
<li>尽管能够符合分配到栈的场景，但是其大小不能够在在编译时候确定的情况，也会分配到堆上</li>
</ol>
<p>有效的避免上述的五种逃逸的情况，就可以避免内存逃逸</p>
<h4 id="24-Go函数返回局部变量的指针是否安全"><a href="#24-Go函数返回局部变量的指针是否安全" class="headerlink" title="24. Go函数返回局部变量的指针是否安全"></a><font color=DarkOrange>24. Go函数返回局部变量的指针是否安全</font></h4><p>在Go中是安全的，Go编译器将会对每个局部变量进行逃逸分析。如果发现局部变量的作用域超出该函数，则不会将内存分配在栈上，而是分配在堆上</p>
<h4 id="25-Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量"><a href="#25-Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量" class="headerlink" title="25. Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量"></a><font color=DarkOrange>25. Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量</font></h4><p>Golang中Goroutine可以通过Channel进行安全读写共享变量，还可以通过原子性操作进行</p>
<h4 id="26-Go中的锁有哪些"><a href="#26-Go中的锁有哪些" class="headerlink" title="26. Go中的锁有哪些"></a><font color=DarkOrange>26. Go中的锁有哪些</font></h4><p>Go中的三种锁包括：</p>
<ul>
<li>互斥锁</li>
<li>读写锁</li>
<li>sync.Map安全锁</li>
</ul>
<ol>
<li><p>互斥锁</p>
<p>Go并发程序对共享资源进行访问控制的主要手段，由标准库代码包中sync中的Mutex结构体表示，sync.Mutex包中的类型只有两个公开的指针方法Lock和Unlock</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Locker表示可以锁定和解锁的对象。</span></span><br><span class="line"> <span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 锁定当前的互斥量</span></span><br><span class="line"> <span class="comment">// 如果锁已被使用，则调用goroutine</span></span><br><span class="line"> <span class="comment">// 阻塞直到互斥锁可用。</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() </span><br><span class="line"></span><br><span class="line"> <span class="comment">// 对当前互斥量进行解锁</span></span><br><span class="line"> <span class="comment">// 如果在进入解锁时未锁定m，则为运行时错误。</span></span><br><span class="line"> <span class="comment">// 锁定的互斥锁与特定的goroutine无关。</span></span><br><span class="line"> <span class="comment">// 允许一个goroutine锁定Mutex然后安排另一个goroutine来解锁它。</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock()</span><br></pre></td></tr></table></figure>

<p>如果对一个已经上锁的对象再次上锁，那么就会导致该锁定操作被阻塞，直到该互斥锁回到被解锁状态。互斥锁锁定操作的逆操作并不会导致协程阻塞，但是有可能导致引发一个无法恢复的运行时的panic，比如对一个未锁定的互斥锁进行解锁时就会发生panic。避免这种情况的最有效方式就是使用defer</p>
<hr>
</li>
<li><p>读写锁</p>
<p>读写锁是针对读写操作的互斥锁，可以分别针对读操作与写操作进行锁定和解锁操作 。读写锁的访问控制规则如下：</p>
<ul>
<li>多个写操作之间是互斥的</li>
<li>写操作与读操作之间也是互斥的</li>
<li>多个读操作之间不是互斥的</li>
</ul>
<p>在这样的控制规则下，读写锁可以大大降低性能损耗。sync中的RWMutex有以下几种方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对读操作的锁定</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//对读操作的解锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//对写操作的锁定</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//对写操作的解锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个实现了sync.Locker接口类型的值，实际上是回调rw.RLock and rw.RUnlock.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLocker() Locker</span><br></pre></td></tr></table></figure>

<ul>
<li>若对一个未被写锁定的读写锁进行写解锁，就会引发一个不可恢复的panic，同理对一个未被读锁定的读写锁进行读写锁也会如此。</li>
<li>由于读写锁控制下的多个读操作之间不是互斥的，因此对于读解锁更容易被忽视。对于同一个读写锁，添加多少个读锁定，就必要有等量的读解锁，这样才能其他协程有机会进行操作</li>
<li>因此Go中读写锁，在多个读线程可以同时访问共享数据,写线程必须等待所有读线程都释放锁以后，才能取得锁</li>
<li>同样的，读线程必须等待写线程释放锁后，才能取得锁，也就是说读写锁要确保的是如下互斥关系，可以同时读，但是读-写，写-写都是互斥的</li>
</ul>
<hr>
</li>
<li><p>sync.Map安全锁</p>
<p>golang中的sync.Map是并发安全的，其实也就是sync包中golang自定义的一个名叫Map的结构体</p>
<ul>
<li>Delete 方法</li>
<li>Store 方法</li>
<li>Load方法</li>
</ul>
<p>sync.Map是通过冗余的两个数据结构(read、dirty)，实现性能的提升。为了提升性能，load、delete、store等操作尽量使用只读的read；为了提高read的key击中概率，采用动态调整，将dirty数据提升为read；对于数据的删除，采用延迟标记删除法，只有在提升dirty的时候才删除</p>
</li>
</ol>
<h4 id="27-Go中的锁如何实现"><a href="#27-Go中的锁如何实现" class="headerlink" title="27. Go中的锁如何实现"></a><font color=DarkOrange>27. Go中的锁如何实现</font></h4><p>锁是一种同步机制，用于在多任务环境中限制资源的访问，以满足互斥需求</p>
<p>go源码sync包中经常用于同步操作的方式：</p>
<ul>
<li>原子操作</li>
<li>互斥锁</li>
<li>读写锁</li>
<li>waitgroup</li>
</ul>
<p>互斥锁的数据结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Mutex is a mutual exclusion lock.</span></span><br><span class="line"><span class="comment">// The zero value for a Mutex is an unlocked mutex.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A Mutex must not be copied after first use.</span></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    state <span class="type">int32</span>   <span class="comment">// 互斥锁上锁状态枚举值如下所示</span></span><br><span class="line">    sema  <span class="type">uint32</span>  <span class="comment">// 信号量，向处于Gwaitting的G发送信号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// 值为1，表示在state中由低向高第1位，意义：锁是否可用,0可用，1不可用,锁定中</span></span><br><span class="line">    mutexWoken   <span class="comment">// 值为2，表示在state中由低向高第2位，意义：mutex是否被唤醒</span></span><br><span class="line">    mutexStarving <span class="comment">// 当前的互斥锁进入饥饿状态；</span></span><br><span class="line">    mutexWaiterShift = <span class="literal">iota</span>  <span class="comment">//值为2，表示state中统计阻塞在此mutex上goroutine的数目需要位移的偏移量</span></span><br><span class="line">    starvationThresholdNs = <span class="number">1e6</span> </span><br></pre></td></tr></table></figure>

<p>state和sema两个加起来只占 8 字节空间的结构体表示了 Go 语言中的互斥锁</p>
<p>在默认情况下，互斥锁的所有状态位都是 0，int32 中的不同位分别表示了不同的状态：</p>
<ul>
<li>mutexLocked 表示互斥锁的锁定状态；</li>
<li>mutexWoken 表示从正常模式被从唤醒；</li>
<li>mutexStarving 当前的互斥锁进入饥饿状态</li>
<li>waitersCount 当前互斥锁上等待的 Goroutine 个数</li>
</ul>
<p>sync.Mutex 有两种模式，正常模式和饥饿模式：</p>
<ul>
<li>正常模式：锁的等待者会按照先进先出的顺序获取锁。但是刚被唤起的 <code>Goroutine</code> 与新创建的 <code>Goroutine</code> 竞争时，大概率会获取不到锁，为了减少这种情况的出现，一旦 Goroutine 超过 1ms 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止部分 Goroutine 被饿死</li>
<li>饥饿模式：饥饿模式是在 Go 语言 1.9 版本引入的优化的，引入的目的是保证互斥锁的公平性（Fairness）。在饥饿模式中，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会被切换回正常模式</li>
</ul>
<p>相比于饥饿模式，正常模式下的互斥锁能够提供更好地性能，饥饿模式的能避免 Goroutine 由于陷入等待无法获取锁而造成的高尾延时</p>
<h4 id="28-Go中数据竞争问题怎么解决"><a href="#28-Go中数据竞争问题怎么解决" class="headerlink" title="28. Go中数据竞争问题怎么解决"></a><font color=DarkOrange>28. Go中数据竞争问题怎么解决</font></h4><ul>
<li>数据竞争问题可以使用互斥锁sync.Mutex，或者也可以通过CAS无锁并发解决</li>
<li>其中使用同步访问共享数据或者CAS无锁并发是处理数据竞争的一种有效的方法</li>
<li>golang在1.1之后引入了竞争检测机制，可以使用 <code>go run -race</code> 或者 <code>go build -race</code>来进行静态检测。其在内部的实现是，开启多个协程执行同一个命令， 并且记录下每个变量的状态</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> test -race mypkg    <span class="comment">// 测试包</span></span><br><span class="line"><span class="keyword">go</span> run -race mysrc.<span class="keyword">go</span>  <span class="comment">// 编译和运行程序</span></span><br><span class="line"><span class="keyword">go</span> build -race mycmd   <span class="comment">// 构建程序</span></span><br><span class="line"><span class="keyword">go</span> install -race mypkg <span class="comment">// 安装程序</span></span><br></pre></td></tr></table></figure>

<h4 id="29-Go中CAS是怎么回事"><a href="#29-Go中CAS是怎么回事" class="headerlink" title="29. Go中CAS是怎么回事"></a><font color=DarkOrange>29. Go中CAS是怎么回事</font></h4><p>CAS算法（Compare And Swap），是原子操作的一种，CAS算法是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题</p>
<p>该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值</p>
<p>Go中的CAS操作是借用了CPU提供的原子性指令来实现。CAS操作修改共享变量时候不需要对共享变量加锁，而是通过类似乐观锁的方式进行检查，本质还是不断的占用CPU 资源换取加锁带来的开销（比如上下文切换开销）</p>
<p>Go中CAS操作可以有效的减少使用锁所带来的开销，但是需要注意在高并发下这是使用cpu资源做交换的</p>
<h4 id="30-Go主协程如何等其余协程完再操作"><a href="#30-Go主协程如何等其余协程完再操作" class="headerlink" title="30. Go主协程如何等其余协程完再操作"></a><font color=DarkOrange>30. Go主协程如何等其余协程完再操作</font></h4><ul>
<li>Go提供了更简单的方法——使用<code>sync.WaitGroup</code>。<code>WaitGroup</code>，就是用来等待一组操作完成的。<code>WaitGroup</code>内部实现了一个计数器，用来记录未完成的操作个数</li>
<li>它提供了三个方法，<code>Add()</code>用来添加计数。<code>Done()</code>用来在操作结束时调用，使计数减一。<code>Wait()</code>用来等待所有的操作结束，即计数变为0，该函数会在计数不为0时等待，在计数为0时立即返回</li>
</ul>
<h4 id="31-Context包的用途是什么"><a href="#31-Context包的用途是什么" class="headerlink" title="31. Context包的用途是什么"></a><font color=DarkOrange>31. Context包的用途是什么</font></h4><p>在 Go http包的Server中，每一个请求在都有一个对应的 goroutine 去处理。请求处理函数通常会启动额外的 goroutine 用来访问后端服务，比如数据库和RPC服务。用来处理一个请求的 goroutine 通常需要访问一些与请求特定的数据，比如终端用户的身份认证信息、验证相关的token、请求的截止时间。 当一个请求被取消或超时时，所有用来处理该请求的 goroutine 都应该迅速退出，然后系统才能释放这些 goroutine 占用的资源</p>
<p>在Google 内部，我们开发了 Context 包，专门用来简化 对于处理单个请求的多个 goroutine 之间与请求域的数据、取消信号、截止时间等相关操作，这些操作可能涉及多个 API 调用</p>
<p>Context中的方法：</p>
<ul>
<li>Done会返回一个channel，当该context被取消的时候，该channel会被关闭，同时对应的使用该context的routine也应该结束并返回</li>
<li>Context中的方法是协程安全的，这也就代表了在父routine中创建的context，可以传递给任意数量的routine并让他们同时访问</li>
<li>Deadline会返回一个超时时间，routine获得了超时时间后，可以对某些io操作设定超时时间</li>
<li>Value可以让routine共享一些数据，当然获得数据是协程安全的</li>
</ul>
<p>这里需要注意一点的是在goroutine中使用context包的时候，通常我们需要在goroutine中新创建一个上下文的context，原因是：如果直接传递外部context到协层中，一个请求可能在主函数中已经结束，在goroutine中如果还没有结束的话，会直接导致goroutine中的运行的被取消</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">   _, ctx, _ := log.FromContextOrNew(context.Background(), <span class="literal">nil</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>context.Background函数的返回值是一个空的context，经常作为树的根结点，它一般由接收请求的第一个routine创建，不能被取消、没有值、也没有过期时间</p>
<p>Context上下文数据的存储就像一个树，每个结点只存储一个<code>key/value</code>对。WithValue()保存一个<code>key/value</code>对，它将父context嵌入到新的子context，并在节点中保存了<code>key/value</code>数据。Value()查询key对应的value数据，会从当前context中查询，如果查不到，会递归查询父context中的数据</p>
<p>值得注意的是，context中的上下文数据并不是全局的，它只查询本节点及父节点们的数据，不能查询兄弟节点的数据</p>
<p>Context 使用原则：</p>
<ul>
<li>不要把Context放在结构体中，要以参数的方式传递</li>
<li>以Context作为参数的函数方法，应该把Context作为第一个参数，放在第一位</li>
<li>给一个函数方法传递Context的时候，不要传递nil，如果不知道传递什么，就使用context.TODO</li>
<li>Context的Value相关方法应该传递必须的数据，不要什么数据都使用这个传递</li>
<li>Context是线程安全的，可以放心的在多个goroutine中传递</li>
</ul>
<h4 id="32-Go中对nil的Slice和空Slice的处理是一致的吗"><a href="#32-Go中对nil的Slice和空Slice的处理是一致的吗" class="headerlink" title="32. Go中对nil的Slice和空Slice的处理是一致的吗"></a><font color=DarkOrange>32. Go中对nil的Slice和空Slice的处理是一致的吗</font></h4><p>首先Go的JSON 标准库对 <code>nil slice</code> 和 空 <code>slice</code> 的处理是不一致</p>
<p>通常错误的用法，会报数组越界的错误，因为只是声明了slice，却没有给实例化的对象。nil的slice定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>此时slice的值是nil，这种情况可以用于需要返回slice的函数，当函数出现异常的时候，保证函数依然会有nil的返回值</p>
<hr>
<p>空的slice是指slice不为nil，但是slice没有值，slice的底层的空间是空的，空的slice定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>）</span><br><span class="line">slice := []<span class="type">int</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>当我们查询或者处理一个空的列表的时候，这非常有用，它会告诉我们返回的是一个列表，但是列表内没有任何值</p>
<p><strong>总结：</strong> nil的slice和空的slice是不同的东西，需要我们加以区分</p>
<h4 id="33-Go的Slice如何扩容"><a href="#33-Go的Slice如何扩容" class="headerlink" title="33. Go的Slice如何扩容"></a><font color=DarkOrange>33. Go的Slice如何扩容</font></h4><h5 id="33-1-数组Array和切片Slice"><a href="#33-1-数组Array和切片Slice" class="headerlink" title="33.1 数组Array和切片Slice"></a><font color=DarkOrange>33.1 数组Array和切片Slice</font></h5><ol>
<li>数组和切片都是用来存储相同数据类型的数据结构</li>
<li>数组在初始化或者是定义的时候就必须指明长度，或者初始化的时候使用…自动推导其数组的长度，数组初始化后其长度就是固定不变的；切片在初始化或定义的时候无需声明其长度，可以往切片里追加元素，追加元素可能导致切片扩容</li>
<li>数组和切片都可以通过内置函数<code>len</code>求元素个数，都可以通过下标索引获取相对应的元素值，都可以通过<code>for range</code>进行遍历</li>
<li>函数参数：<strong>数组</strong>作为函数参数时，必须指定参数数组的大小，且传入的数组大小必须与指定的大小一致，数组为按值传递的，函数内对数组的值的改变不影响初始数组；<strong>切片</strong>作为函数参数传递时为按引用传递的，函数内对切片内元素的修改将导致函数外的值也发生改变，不过由于传入函数的是一个指针的副本，所以对该指针的修改不会导致原来的指针的变化（例如append函数不会改变原来的切片的值）</li>
</ol>
<hr>
<ul>
<li>slice是Go中的一种基本的数据结构，使用这种结构可以用来管理数据集合。但是slice本身并不是动态数据或者数组指针。slice常见的操作有 reslice、append、copy</li>
<li>slice自身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。slice本身是一个只读对象，其工作机制类似数组指针的一种封装</li>
<li>slice是对数组一个连续片段的引用，所以切片是一个引用类型。这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集</li>
<li>slice的结构体由3部分构成，Pointer 是指向一个数组的指针，len 代表当前切片的长度，cap 是当前切片的容量。cap 总是大于等于 len 的</li>
</ul>
<p>通常我们在对slice进行append等操作时，可能会造成slice的自动扩容</p>
<ul>
<li><strong>1.18版本之前：</strong> 当原slice容量小于1024的时候，新slice容量变成原来的2倍；原slice容量超过1024，新slice容量变成原来的1.25倍</li>
<li><strong>1.18版本之后：</strong> 当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的2倍；原slice容量超过256，新slice容量newcap &#x3D; oldcap+(oldcap+3*256)&#x2F;4</li>
<li><strong>最后：</strong> 扩容后的容量并不一定就是按照以上公式计算的结果，容量可能会存在小的差异，主要原因是扩容后会有内存对齐，导致容量不是百分百按照公式计算的结果。如果扩容之后，还没有触及原数组的容量，那么，切片中的指针指向的位置，就还是原数组，如果扩容之后，超过了原数组的容量，那么，Go就会开辟一块新的内存，把原来的值拷贝过来，这种情况丝毫不会影响到原数组</li>
</ul>
<h4 id="34-Go的Struct能不能比较"><a href="#34-Go的Struct能不能比较" class="headerlink" title="34. Go的Struct能不能比较"></a><font color=DarkOrange>34. Go的Struct能不能比较</font></h4><ul>
<li>相同struct类型的可以比较</li>
<li>不同struct类型的不可以比较，编译都不过，类型不匹配</li>
</ul>
<h4 id="35-Go中的map的实现"><a href="#35-Go中的map的实现" class="headerlink" title="35. Go中的map的实现"></a><font color=DarkOrange>35. Go中的map的实现</font></h4><p>Go中Map是一个KV对集合。底层使用<code>hash table</code>，用链表来解决冲突 ，出现冲突时，不是每一个Key都申请一个结构通过链表串起来，而是以bmap为最小粒度挂载，一个bmap可以放8个kv</p>
<p>在哈希函数的选择上，会在程序启动时，检测 cpu 是否支持 <code>aes</code>，如果支持，则使用<code>aes hash</code>，否则使用<code>memhash</code></p>
<p>每个map的底层结构是hmap，是有若干个结构为bmap的bucket组成的数组。每个bucket底层都采用链表结构</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count     <span class="type">int</span>    <span class="comment">// 元素个数</span></span><br><span class="line">    flags     <span class="type">uint8</span>  <span class="comment">// 用来标记状态</span></span><br><span class="line">    B         <span class="type">uint8</span>  <span class="comment">// 扩容常量相关字段B是buckets数组的长度的对数 2^B</span></span><br><span class="line">    noverflow <span class="type">uint16</span> <span class="comment">// noverflow是溢出桶的数量，当B&lt;16时，为精确值,当B&gt;=16时，为估计值                       </span></span><br><span class="line">    hash0     <span class="type">uint32</span> <span class="comment">// 是哈希的种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定，并在调用哈希函数时作为参数传入</span></span><br><span class="line"></span><br><span class="line">    buckets    unsafe.Pointer <span class="comment">// 桶的地址 </span></span><br><span class="line">    oldbuckets unsafe.Pointer <span class="comment">// 旧桶的地址，用于扩容 </span></span><br><span class="line">    nevacuate  <span class="type">uintptr</span>        <span class="comment">// 搬迁进度，扩容需要将旧数据搬迁至新数据，这里是利用指针来比较判断有没有迁移 </span></span><br><span class="line"></span><br><span class="line">    extra *mapextra <span class="comment">// 用于扩容的指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">    overflow    *[]*bmap</span><br><span class="line">    oldoverflow *[]*bmap</span><br><span class="line">    <span class="comment">// nextOverflow holds a pointer to a free overflow bucket.</span></span><br><span class="line">    nextOverflow *bmap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A bucket for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    tophash [bucketCnt]<span class="type">uint8</span>  <span class="comment">// tophash用于记录8个key哈希值的高8位，这样在寻找对应key的时候可以更快，不必每次都对key做全等判断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际上编辑期间会动态生成一个新的结构体</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    topbits  [<span class="number">8</span>]<span class="type">uint8</span></span><br><span class="line">    keys     [<span class="number">8</span>]keytype</span><br><span class="line">    values   [<span class="number">8</span>]valuetype</span><br><span class="line">    pad      <span class="type">uintptr</span></span><br><span class="line">    overflow <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bmap 就是我们常说的“桶”，桶里面会最多装 8 个 key，这些 key之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果是“一类”的，关于key的定位我们在map的查询和赋值中详细说明</p>
<p>在桶内，又会根据key计算出来的hash值的高8位来决定 key到底落入桶内的哪个位置（一个桶内最多有8个位置)</p>
<p>当map的key和value都不是指针，并且 size都小于128字节的情况下，会把bmap标记为不含指针，这样可以避免gc时扫描整个hmap</p>
<p>bmap其实有一个overflow的字段，是指针类型的，破坏了 bmap 不含指针的设想，这时会把overflow移动到 hmap的extra 字段来</p>
<p>这样随着哈希表存储的数据逐渐增多，我们会扩容哈希表或者使用额外的桶存储溢出的数据，不会让单个桶中的数据超过 8 个，不过溢出桶只是临时的解决方案，创建过多的溢出桶最终也会导致哈希的扩容</p>
<h4 id="36-Go中的map如何实现顺序读取"><a href="#36-Go中的map如何实现顺序读取" class="headerlink" title="36. Go中的map如何实现顺序读取"></a><font color=DarkOrange>36. Go中的map如何实现顺序读取</font></h4><p>Go中map如果要实现顺序读取的话，先把map中的key添加到数组（array）或切片（slice）中，然后通过sort包对数组或切片进行排序，最后在遍历数组或切片的时候将map中key以及对应的value取出来</p>
<h4 id="37-Go中new和make的区别"><a href="#37-Go中new和make的区别" class="headerlink" title="37. Go中new和make的区别"></a><font color=DarkOrange>37. Go中new和make的区别</font></h4><ul>
<li>值类型：int，float，bool，string，struct和array。变量直接存储值，分配栈区的内存空间，这些变量所占据的空间在函数被调用完后会自动释放</li>
<li>引用类型：slice，map，chan和值类型对应的指针。变量存储的是一个地址（或者理解为指针），指针指向内存中真正存储数据的首地址。内存通常在堆上分配，通过GC回收</li>
<li><strong>注意：</strong> 对于引用类型的变量，我们不仅要声明变量，更重要的是，我们得手动为它分配空间</li>
</ul>
<ol>
<li>new该方法的参数要求传入一个类型，而不是一个值，它会申请一个该类型大小的内存空间，并会初始化为对应的零值，返回指向该内存空间的一个指针。new只用于分配内存，返回一个指向地址的<strong>指针</strong>。它为每个新类型分配一片内存，初始化为0且返回类型*T的内存地址，它相当于&amp;T{}</li>
<li>make也是用于内存分配，但是和new不同，只用来引用对象slice、map和channel的内存创建，它返回的类型就是类型本身，而不是它们的指针类型。make只可用于<strong>slice</strong>，<strong>map</strong>，<strong>channel</strong>的初始化，返回的是<strong>引用</strong></li>
</ol>
<h4 id="38-Go的defer原理是什么"><a href="#38-Go的defer原理是什么" class="headerlink" title="38. Go的defer原理是什么"></a><font color=DarkOrange>38. Go的defer原理是什么</font></h4><p>defer意为延迟，在 golang 中用于延迟执行一个函数。它可以帮助我们处理容易忽略的问题，如资源释放、连接关闭等。但在实际使用过程中，有一些需要注意的地方：</p>
<ul>
<li>若函数中有多个 defer，其执行顺序为 先进后出，可以理解为栈</li>
<li>return 会做什么？Go 的函数返回值是通过堆栈返回的，return 语句不是原子操作，而是被拆成了两步<ul>
<li>给返回值赋值 (rval)</li>
<li>调用 defer 表达式</li>
<li>返回给调用函数(ret)</li>
</ul>
</li>
<li>若 defer 表达式有返回值，将会被丢弃。在实际开发中，defer 的使用经常伴随着闭包与匿名函数的使用</li>
</ul>
<h4 id="39-Go的select可以用于什么"><a href="#39-Go的select可以用于什么" class="headerlink" title="39. Go的select可以用于什么"></a><font color=DarkOrange>39. Go的select可以用于什么</font></h4><p>Golang 的 select 机制可以理解为是在语言层面实现了和 select, poll, epoll 相似的功能：监听多个描述符的读&#x2F;写等事件，一旦某个描述符就绪（一般是读或者写事件发生了），就能够将发生的事件通知给关心的应用程序去处理该事件。 golang 的 select 机制是，监听多个channel，每一个 case 是一个事件，可以是读事件也可以是写事件，随机选择一个执行，可以设置default，它的作用是：当监听的多个事件都阻塞住会执行default的逻辑</p>
<p>使用select case ,ok实现goroutine的优雅退出</p>
<ul>
<li>使用for-range退出</li>
<li>使用select case ,ok退出</li>
<li>使用退出通道退出</li>
</ul>
<h4 id="40-Go值接收者和指针接收者的区别"><a href="#40-Go值接收者和指针接收者的区别" class="headerlink" title="40. Go值接收者和指针接收者的区别"></a><font color=DarkOrange>40. Go值接收者和指针接收者的区别</font></h4><p>Go中的方法能给用户自定义的类型添加新的行为。它和函数的区别在于方法有一个接收者，给一个函数添加一个接收者，那么它就变成了方法。接收者可以是值接收者，也可以是指针接收者</p>
<p>在调用方法的时候，值类型既可以调用值接收者的方法，也可以调用指针接收者的方法；指针类型既可以调用指针接收者的方法，也可以调用值接收者的方法。也就是说，不管方法的接收者是什么类型，该类型的值和指针都可以调用，不必严格符合接收者的类型</p>
<table>
<thead>
<tr>
<th align="left">函数和方法</th>
<th align="left">值接收者</th>
<th align="left">指针接收者</th>
</tr>
</thead>
<tbody><tr>
<td align="left">值类型调用者</td>
<td align="left">方法会使用调用者的一个副本，类似于“传值”</td>
<td align="left">使用值的引用来调用方法，上例中，p1.GetAge() 实际上是 (&amp;p1).GetAge()</td>
</tr>
<tr>
<td align="left">指针类型调用者</td>
<td align="left">指针被解引用为值，上例中，p2.GetAge()实际上是 (*p1).GetAge()</td>
<td align="left">实际上也是“传值”，方法里的操作会影响到调用者，类似于指针传参，拷贝了一份指针</td>
</tr>
</tbody></table>
<p>如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法</p>
<p>如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身</p>
<p>通常我们使用指针作为方法的接收者的理由：</p>
<ul>
<li>使用指针方法能够修改接收者指向的值。</li>
<li>可以避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效</li>
</ul>
<p>因而，我们是使用值接收者还是指针接收者，不是由该方法是否修改了调用者（也就是接收者）来决定，而是应该基于该类型的本质</p>
<h4 id="41-Go中两个Nil可能不相等吗"><a href="#41-Go中两个Nil可能不相等吗" class="headerlink" title="41. Go中两个Nil可能不相等吗"></a><font color=DarkOrange>41. Go中两个Nil可能不相等吗</font></h4><p>Go中两个Nil可能不相等</p>
<p>接口(interface) 是对非接口值(例如指针，struct等)的封装，内部实现包含 2 个字段，类型 T 和 值 V。一个接口等于 nil，当且仅当 T 和 V 处于 unset 状态（T&#x3D;nil，V is unset）。两个接口值比较时，会先比较 T，再比较 V。接口值与非接口值比较时，会先将非接口值尝试转换为接口值，再比较</p>
<h4 id="42-Golang垃圾回收算法"><a href="#42-Golang垃圾回收算法" class="headerlink" title="42. Golang垃圾回收算法"></a><font color=DarkOrange>42. Golang垃圾回收算法</font></h4><p>Golang1.5版本后，采取的是“非分代的、非移动的、并发的、三色的”标记清除垃圾回收算法</p>
<p>垃圾回收算法分类：</p>
<ul>
<li>引用计数</li>
<li>标记-清除</li>
<li>分代回收</li>
</ul>
<p>golang的垃圾回收是基于标记清扫算法，这种算法需要进行 STW（stop the world)，这个过程就会导致程序是卡顿的，频繁的 GC 会严重影响程序性能，golang在此基础上进行了改进，通过三色标记清扫法与写屏障来减少STW的时间</p>
<p>gc的过程一共分为四个阶段：</p>
<ol>
<li>栈扫描（开始时STW） 所有对象最开始都是白色</li>
<li>从 root 开始找到所有可达对象，标记为灰色，放入待处理队列</li>
<li>遍历灰色对象队列，将其引用对象标记为灰色放入待处理队列，自身标记为黑色</li>
<li>清除（并发） 循环步骤3直到灰色队列为空为止，此时所有引用对象都被标记为黑色，所有不可达的对象依然为白色，白色的就是需要进行回收的对象</li>
</ol>
<p>三色标记法相对于普通标记清扫，减少了STW时间. 这主要得益于标记过程是 “on-the-fly” 的，在标记过程中是不需要STW的，它与程序是并发执行的，这就大大缩短了STW的时间</p>
<p>写屏障：</p>
<ul>
<li>当标记和程序是并发执行的，这就会造成一个问题. 在标记过程中，有新的引用产生，可能会导致误清扫</li>
<li>清扫开始前，标记为黑色的对象引用了一个新申请的对象，它肯定是白色的，而黑色对象不会被再次扫描，那么这个白色对象无法被扫描变成灰色、黑色，它就会最终被清扫，而实际它不应该被清扫</li>
<li>golang采用了写屏障，其作用就是为了避免这类误清扫问题. 写屏障即在内存写操作前，维护一个约束，从而确保清扫开始前，黑色的对象不能引用白色对象</li>
</ul>
<h4 id="43-GC的触发条件"><a href="#43-GC的触发条件" class="headerlink" title="43. GC的触发条件"></a><font color=DarkOrange>43. GC的触发条件</font></h4><ul>
<li>主动触发(手动触发)，通过调用<code>runtime.GC</code> 来触发<code>GC</code>，此调用阻塞式地等待当前<code>GC</code>运行完毕</li>
<li>被动触发，分为两种方式：<ul>
<li>使用系统监控，当超过两分钟没有产生任何<code>GC</code>时，强制触发 <code>GC</code></li>
<li>使用步调（Pacing）算法，其核心思想是控制内存增长的比例，当前内存分配达到一定比例则触发</li>
</ul>
</li>
</ul>
<h4 id="44-Go中的http包的实现原理"><a href="#44-Go中的http包的实现原理" class="headerlink" title="44. Go中的http包的实现原理"></a><font color=DarkOrange>44. Go中的http包的实现原理</font></h4><p>Golang中http包中处理 HTTP 请求主要跟两个东西相关：ServeMux 和 Handler</p>
<p>ServeMux 本质上是一个 HTTP 请求路由器（或者叫多路复用器，Multiplexor）。它把收到的请求与一组预先定义的 URL 路径列表做对比，然后在匹配到路径的时候调用关联的处理器（Handler）</p>
<p>处理器（Handler）负责输出HTTP响应的头和正文。任何满足了http.Handler接口的对象都可作为一个处理器。通俗的说，对象只要有个如下签名的ServeHTTP方法即可</p>
<p>Go 语言的 HTTP 包自带了几个函数用作常用处理器，比如<code>FileServer</code>，<code>NotFoundHandler</code> 和 <code>RedirectHandler</code></p>
<h4 id="45-Go中的defer函数使用下面的两种情况下结果是什么"><a href="#45-Go中的defer函数使用下面的两种情况下结果是什么" class="headerlink" title="45. Go中的defer函数使用下面的两种情况下结果是什么"></a><font color=DarkOrange>45. Go中的defer函数使用下面的两种情况下结果是什么</font></h4><p>无</p>
<hr>
<h4 id="1-Go项目性能测试、压测"><a href="#1-Go项目性能测试、压测" class="headerlink" title="1. Go项目性能测试、压测"></a><font color=DarkOrange>1. Go项目性能测试、压测</font></h4><ol>
<li>单元测试，以<code>Test</code>开头，在需要测试的包路径内执行<code>go test</code>对该包进行测试</li>
<li>性能测试，以<code>Benchmark</code>开头，<code>go test</code>默认不会执行压力测试函数，需要通过指定参数<code>-test.bench</code>来运行压力测试函数，<code>-test.bench</code>后跟正则表达式，如：<code>go -test.bench=&quot;.*&quot;</code>表示执行所有的压力测试函数</li>
<li>测试覆盖率，<code>cover</code>工具，<code>go test -coverprofile=cover.out</code>，在测试文件目录下运行并统计测试覆盖率</li>
<li>性能分析，<code>pprof</code>进行性能分析</li>
<li>使用<code>Jmeter</code>做<code>Web</code>性能测试</li>
</ol>
<p>API性能测试指标，主要有3个：</p>
<ol>
<li>并发数（<code>Concurrent</code>），是指某个时间范围内，同时正在使用系统的用户数</li>
<li>每秒查询数（<code>QPS</code>），是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，<code>QPS</code>&#x3D;并发数&#x2F;平均请求响应时间，在说<code>QPS</code>时需要指明多少并发数下的<code>QPS</code>，因为不同并发数下<code>QPS</code>是不同的</li>
<li>请求响应时间（<code>TTLB</code>），是从客户端发出请求到得到响应的整个时间</li>
</ol>
<hr>
<h4 id="2-下面2个函数分别输出什么结果"><a href="#2-下面2个函数分别输出什么结果" class="headerlink" title="2. 下面2个函数分别输出什么结果"></a><font color=DarkOrange>2. 下面2个函数分别输出什么结果</font></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> (a <span class="type">int</span>) &#123;</span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		a += <span class="number">1</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 函数的返回值是(a int)</span></span><br><span class="line">	<span class="comment">// return语句不是原子操作，1.给返回值赋值，2.调用defer表达式，3.返回给调用函数</span></span><br><span class="line">	<span class="comment">// defer遵循先进后出，return时，先把100赋值给a，然后a执行了defer func()+1操作</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	a := <span class="number">1</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		a += <span class="number">1</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 函数返回的是int类型的数，没指定返回的一定是a，所以直接返回return后面的数字</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(A()) <span class="comment">// 101</span></span><br><span class="line">	<span class="built_in">println</span>(B()) <span class="comment">// 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h82o60shgaj312i0x2wn7.jpg" alt="image.png" style="zoom:55%;" /></div>

<h4 id="3-Go面向对象"><a href="#3-Go面向对象" class="headerlink" title="3. Go面向对象"></a><font color=DarkOrange>3. Go面向对象</font></h4><p>面向对象的三大基本特性：<strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong></p>
<ul>
<li>封装<ul>
<li>面向对象中的 “封装” 指的是可以隐藏对象的内部属性和实现细节，仅对外提供公开接口调用，这样子用户就不需要关注你内部是怎么实现的</li>
<li>在 Go 语言中的属性访问权限，通过首字母大小写来控制：<ul>
<li>首字母大写，代表是公共的，可被外部访问的</li>
<li>首字母小写，代表是私有的，不可以被外部访问</li>
</ul>
</li>
</ul>
</li>
<li>继承<ul>
<li>面向对象中的 “继承” 指的是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为</li>
<li>继承是编译时特征，在<code>struct</code>内加入所需要继承的类即可</li>
</ul>
</li>
<li>多态<ul>
<li>面向对象中的 “多态” 指的同一个行为具有多种不同表现形式或形态的能力，具体是指一个类实例（对象）的相同方法在不同情形有不同表现形式</li>
<li>多态也使得不同内部结构的对象可以共享相同的外部接口，也就是都是一套外部模板，内部实际是什么，只要符合规格就可以</li>
<li>多态是运行时特征，在 Go 语言中，多态是通过接口<code>interface</code>来实现的，类型和接口是松耦合的，某个类型的实例可以赋给它所实现的任意接口类型的变量</li>
</ul>
</li>
</ul>
<h4 id="4-Go编写HTTP服务器"><a href="#4-Go编写HTTP服务器" class="headerlink" title="4. Go编写HTTP服务器"></a><font color=DarkOrange>4. Go编写HTTP服务器</font></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, HelloHandler)</span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;:8000&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行代码之后，在浏览器中打开<code>localhost:8000</code>就可以看到<code>Hello World</code>。这段代码先利用<code>http.HandleFunc</code>在根路由<code>/</code>上注册了一个<code>HelloHandler</code>，然后利用<code>http.ListenAndServe</code>启动服务器并监听本地的 8000 端口。当有请求过来时，则根据路由执行对应的<code>handler</code>函数</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1584872">点击跳转</a></p>
<h4 id="5-Gin示例"><a href="#5-Gin示例" class="headerlink" title="5. Gin示例"></a><font color=DarkOrange>5. Gin示例</font></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个默认的路由引擎</span></span><br><span class="line">	r := gin.Default()</span><br><span class="line">	<span class="comment">// GET：请求方式；/hello：请求的路径</span></span><br><span class="line">	<span class="comment">// 当客户端以GET方法请求/hello路径时，会执行后面的匿名函数</span></span><br><span class="line">	r.GET(<span class="string">&quot;api/v1/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// c.JSON：返回JSON格式的数据</span></span><br><span class="line">		c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// 启动HTTP服务，默认在0.0.0.0:8080启动服务</span></span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>知乎Golang面试题总结链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/471490292">点击跳转</a></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><font color=DarkOrange>总结</font></h4><p>Go面试复习应该有所侧重，关注切片，通道，异常处理，Goroutine，GMP模型，字符串高效拼接，指针，反射，接口，sync。对于比较难懂的部分，GMP模型和GC和内存管理，应该主动去看<strong>源码</strong>，然后慢慢理解。业务代码写多了，自然就有理解了</p>

      
      <blockquote>
        
        <strong>本文链接：</strong><br><a href="https://huajun-chen.github.io/2022/10/28/Golang%E9%9D%A2%E8%AF%95%E9%A2%98/">https://huajun-chen.github.io/2022/10/28/Golang面试题/</a>
      </blockquote>
    </div>
    <footer class="mdui-card-actions">
      
        <a class="mdui-ripple article_categories-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
      
      
        <a class="mdui-ripple article_tags-link" href="/tags/Go/" rel="tag">Go</a>
      
    </footer>
    
  </article>
  
<script src="//cdn.bootcdn.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>

  <script>$("#main article .mdui-card-content img.fancybox").on("click",function(e){$.fancybox.open({src:$(this).attr("src")});});</script>


  <nav id="paginator">
    
      <a rel="prev" class="extend prev" href="/2022/10/28/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/">
        <button aria-label="prev" class="mdui-btn mdui-btn-raised mdui-btn-icon mdui-color-theme-accent mdui-ripple"><i class="mdui-icon material-icons">arrow_back</i></button>
        <span class="mdui-p-x-3" mdui-tooltip="{content: 'MySQL面试题'}">上一篇</span>
      </a>
    
    <div class="spacer"></div>
    
      <a rel="next" class="extend next" href="/2022/10/27/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/">
        <span class="mdui-p-x-3" mdui-tooltip="{content: '关于博客'}">下一篇</span>
        <button aria-label="next" class="mdui-btn mdui-btn-raised mdui-btn-icon mdui-color-theme-accent mdui-ripple"><i class="mdui-icon material-icons">arrow_forward</i></button>
      </a>
    
  </nav>




  <div style="position: fixed !important; left: 240px; top: 30%;">
    <button class="mdui-fab mdui-fab-mini mdui-ripple" mdui-menu="{target: '#toc'}"><i class="mdui-icon material-icons">toc</i></button>
    <ul class="mdui-menu" id="toc">
      <li class="mdui-menu-item" disabled><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%97%A0%E7%BC%93%E5%86%B2Chan%E7%9A%84%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E6%98%AF%E5%90%A6%E5%90%8C%E6%AD%A5"><span class="toc-text">1. 无缓冲Chan的发送和接收是否同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AFchannel%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%83%E5%8F%AF%E4%BB%A5%E5%81%9A%E5%88%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-text">2. 什么是channel，为什么它可以做到线程安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Goroutine%E5%92%8CChannel%E7%9A%84%E4%BD%9C%E7%94%A8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">3. Goroutine和Channel的作用分别是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Channel%E6%98%AF%E5%90%8C%E6%AD%A5%E7%9A%84%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84"><span class="toc-text">4. Channel是同步的还是异步的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Go%E4%B8%AD%E7%9A%84channel%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">5. Go中的channel的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Golang%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E5%AE%83%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84CSP%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B"><span class="toc-text">6. Golang并发机制以及它所使用的CSP并发模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-Go%E7%9A%84GPM%E5%A6%82%E4%BD%95%E8%B0%83%E5%BA%A6"><span class="toc-text">7. Go的GPM如何调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-Golang%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B"><span class="toc-text">8. Golang中常用的并发模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">9. 并发编程概念是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8BGoroutine%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-text">10. 怎么查看Goroutine的数量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E6%80%8E%E4%B9%88%E9%99%90%E5%88%B6Goroutine%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-text">11. 怎么限制Goroutine的数量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-Goroutine%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">12. Goroutine和线程的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E5%9C%A8Go%E5%87%BD%E6%95%B0%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%91%E7%94%9F%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%8CGoroutine%E5%8F%91%E7%94%9F%E4%BA%86%E6%B3%84%E6%BC%8F%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B"><span class="toc-text">13. 在Go函数中为什么会发生内存泄露，Goroutine发生了泄漏如何检测</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#13-1-PProf%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">13.1 PProf是什么</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-2-PProf%E4%BD%BF%E7%94%A8"><span class="toc-text">13.2 PProf使用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-Goroutine%E5%92%8C%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%EF%BC%88KernelThread%EF%BC%89%E4%B9%8B%E9%97%B4%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB"><span class="toc-text">14. Goroutine和内核线程（KernelThread）之间是什么关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-%E5%8D%8F%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">15. 协程和线程和进程的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-G0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">16. G0的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-Golang%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%8F%E5%AF%B9%E8%B1%A1%E5%A4%9A%E4%BA%86%E4%BC%9A%E9%80%A0%E6%88%90GC%E5%8E%8B%E5%8A%9B"><span class="toc-text">17. Golang的内存模型中为什么小对象多了会造成GC压力</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-Go%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E6%80%8E%E6%A0%B7%E5%88%86%E9%85%8D%E7%9A%84"><span class="toc-text">18. Go的对象在内存中是怎样分配的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-%E6%A0%88%E7%9A%84%E5%86%85%E5%AD%98%E6%98%AF%E6%80%8E%E4%B9%88%E5%88%86%E9%85%8D%E7%9A%84"><span class="toc-text">19. 栈的内存是怎么分配的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%8E%E4%B9%88%E5%88%86%E9%85%8D%E7%9A%84"><span class="toc-text">20. 堆内存管理怎么分配的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-%E5%9C%A8Go%E5%87%BD%E6%95%B0%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%91%E7%94%9F%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-text">21. 在Go函数中为什么会发生内存泄露</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-Go%E8%AF%AD%E8%A8%80%E7%9A%84%E6%A0%88%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="toc-text">22. Go语言的栈空间管理是怎么样的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-Go%E4%B8%AD%E7%9A%84%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">23. Go中的逃逸分析是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-Go%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E6%8C%87%E9%92%88%E6%98%AF%E5%90%A6%E5%AE%89%E5%85%A8"><span class="toc-text">24. Go函数返回局部变量的指针是否安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25-Golang%E4%B8%AD%E9%99%A4%E4%BA%86%E5%8A%A0Mutex%E9%94%81%E4%BB%A5%E5%A4%96%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%E5%AE%89%E5%85%A8%E8%AF%BB%E5%86%99%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F"><span class="toc-text">25. Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26-Go%E4%B8%AD%E7%9A%84%E9%94%81%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">26. Go中的锁有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27-Go%E4%B8%AD%E7%9A%84%E9%94%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">27. Go中的锁如何实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28-Go%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-text">28. Go中数据竞争问题怎么解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29-Go%E4%B8%ADCAS%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B"><span class="toc-text">29. Go中CAS是怎么回事</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30-Go%E4%B8%BB%E5%8D%8F%E7%A8%8B%E5%A6%82%E4%BD%95%E7%AD%89%E5%85%B6%E4%BD%99%E5%8D%8F%E7%A8%8B%E5%AE%8C%E5%86%8D%E6%93%8D%E4%BD%9C"><span class="toc-text">30. Go主协程如何等其余协程完再操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31-Context%E5%8C%85%E7%9A%84%E7%94%A8%E9%80%94%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">31. Context包的用途是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32-Go%E4%B8%AD%E5%AF%B9nil%E7%9A%84Slice%E5%92%8C%E7%A9%BASlice%E7%9A%84%E5%A4%84%E7%90%86%E6%98%AF%E4%B8%80%E8%87%B4%E7%9A%84%E5%90%97"><span class="toc-text">32. Go中对nil的Slice和空Slice的处理是一致的吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33-Go%E7%9A%84Slice%E5%A6%82%E4%BD%95%E6%89%A9%E5%AE%B9"><span class="toc-text">33. Go的Slice如何扩容</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#33-1-%E6%95%B0%E7%BB%84Array%E5%92%8C%E5%88%87%E7%89%87Slice"><span class="toc-text">33.1 数组Array和切片Slice</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34-Go%E7%9A%84Struct%E8%83%BD%E4%B8%8D%E8%83%BD%E6%AF%94%E8%BE%83"><span class="toc-text">34. Go的Struct能不能比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#35-Go%E4%B8%AD%E7%9A%84map%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">35. Go中的map的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#36-Go%E4%B8%AD%E7%9A%84map%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%8F%96"><span class="toc-text">36. Go中的map如何实现顺序读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#37-Go%E4%B8%ADnew%E5%92%8Cmake%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">37. Go中new和make的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#38-Go%E7%9A%84defer%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">38. Go的defer原理是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#39-Go%E7%9A%84select%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88"><span class="toc-text">39. Go的select可以用于什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#40-Go%E5%80%BC%E6%8E%A5%E6%94%B6%E8%80%85%E5%92%8C%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">40. Go值接收者和指针接收者的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#41-Go%E4%B8%AD%E4%B8%A4%E4%B8%AANil%E5%8F%AF%E8%83%BD%E4%B8%8D%E7%9B%B8%E7%AD%89%E5%90%97"><span class="toc-text">41. Go中两个Nil可能不相等吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#42-Golang%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-text">42. Golang垃圾回收算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#43-GC%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-text">43. GC的触发条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#44-Go%E4%B8%AD%E7%9A%84http%E5%8C%85%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">44. Go中的http包的实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#45-Go%E4%B8%AD%E7%9A%84defer%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%83%85%E5%86%B5%E4%B8%8B%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">45. Go中的defer函数使用下面的两种情况下结果是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Go%E9%A1%B9%E7%9B%AE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E3%80%81%E5%8E%8B%E6%B5%8B"><span class="toc-text">1. Go项目性能测试、压测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%8B%E9%9D%A22%E4%B8%AA%E5%87%BD%E6%95%B0%E5%88%86%E5%88%AB%E8%BE%93%E5%87%BA%E4%BB%80%E4%B9%88%E7%BB%93%E6%9E%9C"><span class="toc-text">2. 下面2个函数分别输出什么结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">3. Go面向对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Go%E7%BC%96%E5%86%99HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">4. Go编写HTTP服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Gin%E7%A4%BA%E4%BE%8B"><span class="toc-text">5. Gin示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li>
    </ul>
  </div>


</main>
  <footer id="footer" class="mdui-m-t-5 mdui-p-y-3 mdui-color-theme">
  <div class="mdui-p-y-0 mdui-text-center">
    
    
    
    
    
    
    
    
    
    
    
    
  </div>
  <div class="mdui-p-y-1 mdui-text-center">
    Copyright &copy; 2022 可可西里<br>
    Powered by <a href="https://hexo.io/" target="_blank" class="mdui-text-color-theme-accent">Hexo</a>
    
  </div>
</footer>

  <button id="gotop" class="mdui-fab mdui-fab-fixed mdui-fab-hide mdui-color-theme-accent mdui-ripple"><i class="mdui-icon material-icons">arrow_upward</i></button>
  
  
<script src="/js/mdui.js"></script>
<script src="/js/script.js"></script>

  
<script src="/custom.js"></script>

</body>
</html>
