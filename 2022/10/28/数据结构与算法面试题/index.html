<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <meta name="renderer" content="webkit">
<!--  <meta name="baidu-site-verification" content="code-ofAqabWYEE" />-->
  <meta name="google-site-verification" content="7_aCpLDu0s7bOCrqbIhiPhkHrFGEKMhTyXB5-my2L4g" />

  
  <title>数据结构与算法面试题 | 可可西里-博客</title>

  <link rel="shortcut icon" href="/images/favicon.png">
  <link rel="alternate" href="/atom.xml" title="可可西里-博客" type="application/atom+xml">
  <meta name="description" content="常见高频面试数据结构与算法题  出现的频率从上到下依次递减 1. 反转链表（Go）206-容易题目： 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表 示例： 123456输入：head &#x3D; [1,2,3,4,5]输出：[5,4,3,2,1]输入：head &#x3D; [1,2]输出：[2,1]输入：head &#x3D; []输出：[]  提示：  链表中节点的数目范围是 [0, 5000] -5">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法面试题">
<meta property="og:url" content="https://huajun-chen.github.io/2022/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="可可西里-博客">
<meta property="og:description" content="常见高频面试数据结构与算法题  出现的频率从上到下依次递减 1. 反转链表（Go）206-容易题目： 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表 示例： 123456输入：head &#x3D; [1,2,3,4,5]输出：[5,4,3,2,1]输入：head &#x3D; [1,2]输出：[2,1]输入：head &#x3D; []输出：[]  提示：  链表中节点的数目范围是 [0, 5000] -5">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.bmp.ovh/imgs/2022/06/21/935d47f8204310d8.png">
<meta property="og:image" content="https://i.bmp.ovh/imgs/2022/06/21/2f768ff06b617809.png">
<meta property="og:image" content="https://i.bmp.ovh/imgs/2022/06/21/83dd1b48338dee5d.png">
<meta property="og:image" content="https://i.bmp.ovh/imgs/2022/06/21/736001c2f7e7a333.png">
<meta property="og:image" content="https://i.bmp.ovh/imgs/2022/06/22/f79a7d99292db85e.png">
<meta property="article:published_time" content="2022-10-28T12:29:11.000Z">
<meta property="article:modified_time" content="2023-03-27T03:48:53.732Z">
<meta property="article:author" content="可可西里">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.bmp.ovh/imgs/2022/06/21/935d47f8204310d8.png">

  <meta name="keywords" content=",算法">
  <meta name="format-detection" content="telephone=no,email=no">
  <meta name="theme-color" content="#9C27B0">

  <meta name="mobile-web-app-capable" content="yes">
  <meta name="application-name" content="可可西里-博客">
  <meta name="msapplication-starturl" content="https://huajun-chen.github.io/2022/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/">
  <meta name="msapplication-navbutton-color" content="#9C27B0">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="可可西里-博客">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="/images/favicon.png">

  
    <link rel="canonical" href="https://huajun-chen.github.io/2022/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/">
  

  
  

  
  
  

  
<link rel="stylesheet" href="/css/mdui.css">
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/custom.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body class="mdui-appbar-with-toolbar mdui-theme-primary-grey mdui-theme-accent-deep-purple">
  <script>var a=localStorage.getItem("mdui-theme-layout-dark");if(a){document.getElementsByTagName("body")[0].className+=" mdui-theme-layout-dark"};</script>
  <script>if(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches){document.getElementsByTagName("body")[0].className+=" mdui-theme-layout-dark"};</script>
  <script>var a=localStorage.getItem("mdui-drawer-close");if(!a){document.getElementsByTagName("body")[0].className+=" mdui-drawer-body-left"};</script>
  <header id="header" class="mdui-appbar mdui-appbar-fixed mdui-appbar-scroll-hide mdui-appbar-inset">
  <div class="mdui-toolbar mdui-color-theme">
    <a href="javascript:;" class="mdui-btn mdui-btn-icon" mdui-drawer="{target: '#sidebar', swipe: true}"><i class="mdui-icon material-icons">menu</i></a>
    <a href="/" class="mdui-typo-headline">可可西里-博客</a>
    <div class="mdui-toolbar-spacer"></div>
    <a href="javascript:;" class="mdui-btn mdui-btn-icon" mdui-dialog="{target: '#search'}" mdui-tooltip="{content: '搜索'}"><i class="mdui-icon material-icons">search</i></a>
    <a href="/atom.xml" class="mdui-btn mdui-btn-icon" mdui-tooltip="{content: 'RSS'}"><i class="mdui-icon material-icons">rss_feed</i></a>
<!--      <a href="javascript:;" class="mdui-btn mdui-btn-icon" mdui-drawer="{target: '#sidebar', swipe: true}" style="margin-right: 0px"><i class="mdui-icon material-icons" style="cursor:pointer">brightness_4</i></a>-->
      <a href="javascript:;" class="mdui-btn mdui-btn-icon" style="margin-right: 0px"><i class="mdui-icon material-icons" style="cursor:pointer">brightness_4</i></a>
      <div style="margin-left: 0px;cursor:pointer">长按切换</div>
  </div>
</header>
<div class="mdui-dialog" id="search">
  
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="请输入关键字"><input type="hidden" name="sitesearch" value="https://huajun-chen.github.io"></form>
    <div class="search-result"></div>
  
</div>

  <aside id="sidebar" class="mdui-drawer mdui-drawer-full-height">
  <script>var a=localStorage.getItem("mdui-drawer-close");if(a){document.getElementById("sidebar").className+=" mdui-drawer-close"};</script>
  <div class="mdui-grid-tile">
    <img src="/images/banner.png" style="height: 160px;">
    <img src="/images/avatar.png" class="avatar-animation" style="position: absolute; top: 10%; left: 24px; width: 64px; height: 64px; border: 2px solid #fff; border-radius: 50%;">
    <div class="mdui-grid-tile-actions">
      <div class="mdui-grid-tile-text">
        <div class="mdui-grid-tile-title">可可西里</div>
<!--        <div class="mdui-grid-tile-subtitle"><i class="mdui-icon material-icons">art_track</i>好好吃饭 好好睡觉 好好上班</div>-->
        <div class="mdui-grid-tile-subtitle">好好吃饭 好好睡觉 好好上班</div>
      </div>
      
        <div class="mdui-grid-tile-buttons">
          <a href="mailto:hellowuhan@protonmail.com" class="mdui-btn mdui-btn-icon" mdui-tooltip="{content: 'hellowuhan@protonmail.com'}"><i class="mdui-icon material-icons">email</i></a>
        </div>
      
    </div>
  </div>

  <div class="mdui-list" mdui-collapse="{accordion: true}">
    <a href="/" class="mdui-list-item mdui-ripple">
      <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-blue">home</i>
      <div class="mdui-list-item-content">主页</div>
    </a>
    <div class="mdui-collapse-item">
      <script>var a=localStorage.getItem("mdui-collapse-item-0");if(a){document.getElementsByClassName("mdui-collapse-item")[0].className+=" mdui-collapse-item-open"};</script>
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-deep-orange">archive</i>
        <div class="mdui-list-item-content">归档</div>
        <i class="mdui-collapse-item-arrow mdui-icon material-icons">keyboard_arrow_down</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
        
        <a class="mdui-ripple sidebar_archives-link" href="/archives/2023/03/">三月 2023<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2022/12/">十二月 2022<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2022/11/">十一月 2022<span class="mdui-ripple sidebar_archives-count">22</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2022/10/">十月 2022<span class="mdui-ripple sidebar_archives-count">10</span></a>
        
      </div>
    </div>
    <div class="mdui-collapse-item">
      <script>var a=localStorage.getItem("mdui-collapse-item-1");if(a){document.getElementsByClassName("mdui-collapse-item")[1].className+=" mdui-collapse-item-open"};</script>
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-green">class</i>
        <div class="mdui-list-item-content">分类</div>
        <i class="mdui-collapse-item-arrow mdui-icon material-icons">keyboard_arrow_down</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
        
        <a class="mdui-ripple sidebar_archives-link" href="/categories/%E5%8A%A0%E5%AF%86/">加密<span class="mdui-ripple sidebar_archives-count">3</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端<span class="mdui-ripple sidebar_archives-count">19</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试<span class="mdui-ripple sidebar_archives-count">14</span></a>
        
      </div>
    </div>
    <div class="mdui-collapse-item">
      <script>var a=localStorage.getItem("mdui-collapse-item-2");if(a){document.getElementsByClassName("mdui-collapse-item")[2].className+=" mdui-collapse-item-open"};</script>
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-brown">bookmark</i>
        <div class="mdui-list-item-content">标签</div>
        <i class="mdui-collapse-item-arrow mdui-icon material-icons">keyboard_arrow_down</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
        
        <a class="mdui-ripple sidebar_archives-link" href="/tags/ES/" rel="tag">ES<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/Go/" rel="tag">Go<span class="mdui-ripple sidebar_archives-count">6</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/Kafka/" rel="tag">Kafka<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/Linux/" rel="tag">Linux<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/Python/" rel="tag">Python<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" rel="tag">云原生<span class="mdui-ripple sidebar_archives-count">18</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%9E%B6%E6%9E%84/" rel="tag">系统设计与架构<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式<span class="mdui-ripple sidebar_archives-count">1</span></a>
        
      </div>
    </div>
    <a href="/about" class="mdui-list-item mdui-ripple">
      <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-purple">person</i>
      <div class="mdui-list-item-content">关于</div>
    </a>
  </div>

  <div class="mdui-divider"></div>

  <div class="mdui-list" mdui-collapse="{accordion: true}">
    
      <a href="/timeline" class="mdui-list-item mdui-ripple">时间轴</a>
    
      <a href="/tagcloud" class="mdui-list-item mdui-ripple">标签云</a>
    
      <a href="/gallery" class="mdui-list-item mdui-ripple">相册</a>
    
    <div class="mdui-collapse-item">
      <script>var a=localStorage.getItem("mdui-collapse-item-3");if(a){document.getElementsByClassName("mdui-collapse-item")[3].className+=" mdui-collapse-item-open"};</script>
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <div class="mdui-list-item-content">友情链接</div>
        <i class="mdui-list-item-icon mdui-icon material-icons">link</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
        
        
          <a href="javascript:;" class="mdui-list-item mdui-p-l-2 mdui-text-color-theme mdui-ripple" style="justify-content: center;">链接为空</a>
        
      </div>
    </div>
  </div>
</aside>

  <main id="main" class="mdui-m-t-5 fadeIn animated">
  
<link rel="stylesheet" href="//cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  <style>#main article .mdui-card-content .center-block{display:block!important;margin-right:auto!important;margin-left:auto!important}</style>
  <style>#main article .mdui-card-content .text-center{text-align:center!important}</style>
  <article class="mdui-card mdui-m-b-5">
    <header class="mdui-card-media">
      <img src="/images/random/material-12.png" style="max-height: 240px;">
      <div class="mdui-card-media-covered">
        <div class="mdui-card-primary">
          <div class="mdui-card-primary-title">数据结构与算法面试题</div>
          <div class="mdui-card-primary-subtitle"><i class="iconfont">&#xe697;</i> 2022-10-28 / <i class="iconfont">&#xe601;</i> 可可西里</div>
        </div>
      </div>
      <div class="mdui-card-menu">
<!--        -->
<!--          <button class="mdui-btn mdui-btn-icon mdui-text-color-white" mdui-menu="{target: '#qrcode', align: 'right'}"><i class="mdui-icon material-icons">devices</i></button>-->
<!--          <ul class="mdui-menu" id="qrcode">-->
<!--            -->
<!--              <li class="mdui-menu-item"><a class="mdui-text-center mdui-ripple">发送到手机</a></li>-->
<!--            -->
<!--            <li class="mdui-menu-item" disabled>-->
<!--              -->
<!--                <img src="//qr.liantu.com/api.php?w=246&m=10&text=https://huajun-chen.github.io/2022/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/">-->
<!--              -->
<!--            </li>-->
<!--          </ul>-->
<!--        -->
        
          <button class="mdui-btn mdui-btn-icon mdui-text-color-white" mdui-menu="{target: '#share_menu', align: 'right'}"><i class="mdui-icon material-icons">share</i></button>
          <ul class="mdui-menu" id="share_menu">
            <li class="mdui-menu-item">
              <a href="https://service.weibo.com/share/share.php?appkey=&title=数据结构与算法面试题&url=https://huajun-chen.github.io/2022/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/&pic=https://huajun-chen.github.io/images/favicon.png&searchPic=false&style=simple" target="_blank" class="mdui-ripple">分享到 Weibo</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://twitter.com/intent/tweet?text=数据结构与算法面试题&url=https://huajun-chen.github.io/2022/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/&via=可可西里" target="_blank" class="mdui-ripple">分享到 Twitter</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://www.facebook.com/sharer/sharer.php?u=https://huajun-chen.github.io/2022/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/" target="_blank" class="mdui-ripple">分享到 Facebook</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://plus.google.com/share?url=https://huajun-chen.github.io/2022/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/" target="_blank" class="mdui-ripple">分享到 Google+</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://huajun-chen.github.io/2022/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/&title=数据结构与算法面试题" target="_blank" class="mdui-ripple">分享到 LinkedIn</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://connect.qq.com/widget/shareqq/index.html?site=可可西里-博客&title=数据结构与算法面试题&pics=https://huajun-chen.github.io/images/favicon.png&url=https://huajun-chen.github.io/2022/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/" target="_blank" class="mdui-ripple">分享到 QQ</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://telegram.me/share/url?url=https://huajun-chen.github.io/2022/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/&text=数据结构与算法面试题" target="_blank" class="mdui-ripple">分享到 Telegram</a>
            </li>
          </ul>
        
      </div>
    </header>
    <div class="mdui-card-content mdui-typo">
      <p>常见高频面试数据结构与算法题</p>
<hr>
<p><strong>出现的频率从上到下依次递减</strong></p>
<h4 id="1-反转链表（Go）206-容易"><a href="#1-反转链表（Go）206-容易" class="headerlink" title="1. 反转链表（Go）206-容易"></a><font color=DarkOrange>1. 反转链表（Go）206-容易</font></h4><p><strong>题目：</strong></p>
<p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输入：head = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输入：head = <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：迭代<br>假设链表为 1→2→3→∅，我们想要把它改成∅←1←2←3</p>
<p>在遍历链表时，将当前节点的 <code>next</code> 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用</p>
<div align="center"><img src="https://i.bmp.ovh/imgs/2022/06/21/935d47f8204310d8.png" style="zoom:50%;" /></div>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 是链表的长度。需要遍历链表一次</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ListNode 定义单链表</span></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Value <span class="type">int</span></span><br><span class="line">	Next  *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Solution 反转单链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Solution</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">	<span class="keyword">var</span> prev *ListNode</span><br><span class="line">	curr := head</span><br><span class="line">	<span class="keyword">for</span> curr != <span class="literal">nil</span> &#123;</span><br><span class="line">		next := curr.Next</span><br><span class="line">		curr.Next = prev</span><br><span class="line">		prev = curr</span><br><span class="line">		curr = next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateListNode 使用slice生成单链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateListNode</span><span class="params">(nums []<span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">	<span class="keyword">var</span> head ListNode</span><br><span class="line">	<span class="keyword">var</span> pre ListNode</span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		node := ListNode&#123;Value: num, Next: <span class="literal">nil</span>&#125;</span><br><span class="line">		<span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">			head.Next = &amp;node</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> pre.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">			pre.Next = &amp;node</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			pre.Next.Next = &amp;node</span><br><span class="line">			pre = *pre.Next</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Traverse 遍历链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Traverse</span><span class="params">(t *ListNode)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;空链表&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> t != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d &quot;</span>, t.Value)</span><br><span class="line">		t = t.Next</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">10</span>&#125;</span><br><span class="line">	head := CreateListNode(nums)</span><br><span class="line">	<span class="comment">// 遍历链表</span></span><br><span class="line">	Traverse(head)</span><br><span class="line">	<span class="comment">// 反转链表</span></span><br><span class="line">	solution := Solution(head)</span><br><span class="line">	<span class="comment">// 遍历反转后的链表</span></span><br><span class="line">	Traverse(solution)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-LRU缓存（Go）146-中等"><a href="#2-LRU缓存（Go）146-中等" class="headerlink" title="2. LRU缓存（Go）146-中等"></a><font color=DarkOrange>2. LRU缓存（Go）146-中等</font></h4><p><strong>题目：</strong></p>
<p>请你设计并实现一个满足 <code>LRU (最近最少使用)</code> 缓存 约束的数据结构<br>实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以 正整数 作为容量 <code>capacity</code> 初始化 <code>LRU</code> 缓存</li>
<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 -1 </li>
<li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 逐出 最久未使用的关键字</li>
</ul>
<p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line"><span class="punctuation">[</span><span class="string">&quot;LRUCache&quot;</span><span class="punctuation">,</span> <span class="string">&quot;put&quot;</span><span class="punctuation">,</span> <span class="string">&quot;put&quot;</span><span class="punctuation">,</span> <span class="string">&quot;get&quot;</span><span class="punctuation">,</span> <span class="string">&quot;put&quot;</span><span class="punctuation">,</span> <span class="string">&quot;get&quot;</span><span class="punctuation">,</span> <span class="string">&quot;put&quot;</span><span class="punctuation">,</span> <span class="string">&quot;get&quot;</span><span class="punctuation">,</span> <span class="string">&quot;get&quot;</span><span class="punctuation">,</span> <span class="string">&quot;get&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">4</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">输出</span><br><span class="line"><span class="punctuation">[</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="number">-1</span><span class="punctuation">,</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="number">-1</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">LRUCache lRUCache = new LRUCache(<span class="number">2</span>);</span><br><span class="line">lRUCache.put(<span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span>); <span class="comment">// 缓存是 &#123;1=1&#125;</span></span><br><span class="line">lRUCache.put(<span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span>); <span class="comment">// 缓存是 &#123;1=1, 2=2&#125;</span></span><br><span class="line">lRUCache.get(<span class="number">1</span>);    <span class="comment">// 返回 1</span></span><br><span class="line">lRUCache.put(<span class="number">3</span><span class="punctuation">,</span> <span class="number">3</span>); <span class="comment">// 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span></span><br><span class="line">lRUCache.get(<span class="number">2</span>);    <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">lRUCache.put(<span class="number">4</span><span class="punctuation">,</span> <span class="number">4</span>); <span class="comment">// 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span></span><br><span class="line">lRUCache.get(<span class="number">1</span>);    <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">lRUCache.get(<span class="number">3</span>);    <span class="comment">// 返回 3</span></span><br><span class="line">lRUCache.get(<span class="number">4</span>);    <span class="comment">// 返回 4</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= capacity &lt;= 3000</code></li>
<li><code>0 &lt;= key &lt;= 10000</code></li>
<li><code>0 &lt;= value &lt;= 105</code></li>
<li>最多调用 <code>2 * 105</code> 次 <code>get</code> 和 <code>put</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：哈希表 + 双向链表</p>
<p>LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对</p>
<ul>
<li>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的</li>
<li>哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置</li>
</ul>
<p>这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 O(1) 的时间内完成 <code>get</code> 或者 <code>put</code> 操作。具体的方法如下：</p>
<ul>
<li><p>对于 <code>get</code> 操作，首先判断 <code>key</code> 是否存在：</p>
<ul>
<li>如果 <code>key</code> 不存在，则返回 −1</li>
<li>如果 <code>key</code> 存在，则 <code>key</code> 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值</li>
</ul>
</li>
<li><p>对于 <code>put</code> 操作，首先判断 <code>key</code> 是否存在：</p>
<ul>
<li>如果 <code>key</code> 不存在，使用 <code>key</code> 和 <code>value</code> 创建一个新的节点，在双向链表的头部添加该节点，并将 <code>key</code> 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项</li>
<li>如果 <code>key</code> 存在，则与 <code>get</code> 操作类似，先通过哈希表定位，再将对应的节点的值更新为 <code>value</code>，并将该节点移到双向链表的头部</li>
</ul>
</li>
</ul>
<p>上述各项操作中，访问哈希表的时间复杂度为 O(1)，在双向链表的头部添加节点、在双向链表的尾部删除节点的复杂度也为 O(1)。而将一个节点移到双向链表的头部，可以分成「删除该节点」和「在双向链表的头部添加节点」两步操作，都可以在 O(1) 时间内完成</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：对于 <code>put</code> 和 <code>get</code> 都是 O(1)</li>
<li>空间复杂度：O(capacity)，因为哈希表和双向链表最多存储 capacity+1 个元素</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    size <span class="type">int</span></span><br><span class="line">    capacity <span class="type">int</span></span><br><span class="line">    cache <span class="keyword">map</span>[<span class="type">int</span>]*DLinkedNode</span><br><span class="line">    head, tail *DLinkedNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DLinkedNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    key, value <span class="type">int</span></span><br><span class="line">    prev, next *DLinkedNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDLinkedNode</span><span class="params">(key, value <span class="type">int</span>)</span></span> *DLinkedNode &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;DLinkedNode&#123;</span><br><span class="line">        key: key,</span><br><span class="line">        value: value,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line">    lruCache := LRUCache&#123;</span><br><span class="line">        cache: <span class="keyword">map</span>[<span class="type">int</span>]*DLinkedNode&#123;&#125;,</span><br><span class="line">        head: initDLinkedNode(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        tail: initDLinkedNode(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        capacity: capacity,</span><br><span class="line">    &#125;</span><br><span class="line">    lruCache.head.next = lruCache.tail</span><br><span class="line">    lruCache.tail.prev = lruCache.head</span><br><span class="line">    <span class="keyword">return</span> lruCache</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    _, ok := this.cache[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    node := this.cache[key]</span><br><span class="line">    this.moveToHead(node)</span><br><span class="line">    <span class="keyword">return</span> node.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>)  &#123;</span><br><span class="line">    _, ok := this.cache[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        node := initDLinkedNode(key, value)</span><br><span class="line">        this.cache[key] = node</span><br><span class="line">        this.addToHead(node)</span><br><span class="line">        this.size++</span><br><span class="line">        <span class="keyword">if</span> this.size &gt; this.capacity &#123;</span><br><span class="line">            removeed :=this.removeTail()</span><br><span class="line">            <span class="built_in">delete</span>(this.cache, removeed.key)</span><br><span class="line">            this.size--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node := this.cache[key]</span><br><span class="line">        node.value = value</span><br><span class="line">        this.moveToHead(node)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> addToHead(node *DLinkedNode) &#123;</span><br><span class="line">    node.prev = this.head</span><br><span class="line">    node.next = this.head.next</span><br><span class="line">    this.head.next.prev = node</span><br><span class="line">    this.head.next = node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> removeNode(node *DLinkedNode) &#123;</span><br><span class="line">    node.prev.next = node.next</span><br><span class="line">    node.next.prev = node.prev</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> moveToHead(node *DLinkedNode) &#123;</span><br><span class="line">    this.removeNode(node)</span><br><span class="line">    this.addToHead(node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> removeTail() *DLinkedNode &#123;</span><br><span class="line">    node := this.tail.prev</span><br><span class="line">    this.removeNode(node)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-CodeTop补充题：手撕快速排序（Go）-排序数组-912-中等"><a href="#3-CodeTop补充题：手撕快速排序（Go）-排序数组-912-中等" class="headerlink" title="3. CodeTop补充题：手撕快速排序（Go） | 排序数组 912-中等"></a><font color=DarkOrange>3. CodeTop补充题：手撕快速排序（Go） | 排序数组 912-中等</font></h4><blockquote>
<p><font color=red><strong>10大排序算法： 1. 冒泡排序，2. 选择排序，3. 插入排序，4. 归并排序，5. 快速排序，6. 堆排序，8. 计数排序，9. 桶排序，10. 基数排序</strong></font></p>
</blockquote>
<p><strong>题目：</strong></p>
<p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 5 * 10^4</code></li>
<li><code>-5 * 10^4 &lt;= nums[i] &lt;= 5 * 10^4</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：快速排序<br>思路和算法</p>
<p>快速排序的主要思想是通过划分将待排序的序列分成前后两部分，其中前一部分的数据都比后一部分的数据要小，然后再递归调用函数对两部分的序列分别进行快速排序，以此使整个序列达到有序</p>
<p>我们定义函数 <code>randomized_quicksort(nums, l, r)</code> 为对 <code>nums</code> 数组里 [l,r]的部分进行排序，每次先调用 <code>randomized_partition</code> 函数对 <code>nums</code> 数组里 [l,r]的部分进行划分，并返回分界值的下标 <code>pos</code>，然后按上述将的递归调用 <code>randomized_quicksort(nums, l, pos - 1)</code> 和 <code>randomized_quicksort(nums, pos + 1, r)</code> 即可</p>
<p>那么核心就是划分函数的实现了，划分函数一开始需要确定一个分界值（我们称之为主元 <code>pivot</code>)，然后再进行划分。而主元的选取有很多种方式，这里我们采用随机的方式，对当前划分区间 [l,r] 里的数等概率随机一个作为我们的主元，再将主元放到区间末尾，进行划分</p>
<p>整个划分函数 <code>partition</code> 主要涉及两个指针 i 和 j，一开始 <code>i = l - 1</code>，<code>j = l</code>。我们需要实时维护两个指针使得任意时候，对于任意数组下标 k，我们有如下条件成立：</p>
<ol>
<li>l≤k≤i 时，nums[k]≤pivot</li>
<li>i+1≤k≤j−1 时，nums[k]&gt;pivot</li>
<li>k&#x3D;&#x3D;r 时，nums[k]&#x3D;pivot</li>
</ol>
<p>我们每次移动指针 j ，如果 nums[j]&gt;pivot，我们只需要继续移动指针 j ，即能使上述三个条件成立，否则我们需要将指针 i 加一，然后交换 nums[i] 和 nums[j]，再移动指针 j 才能使得三个条件成立</p>
<p>当 j 移动到 r−1 时结束循环，此时我们可以由上述三个条件知道 [l,i] 的数都小于等于主元 <code>pivot</code>，[i+1,r−1] 的数都大于主元 <code>pivot</code>，那么我们只要交换 nums[i+1] 和 nums[r] ，即能使得 [l,i+1] 区间的数都小于 [i+2,r] 区间的数，完成一次划分，且分界值下标为 i+1，返回即可</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：基于随机选取主元的快速排序时间复杂度为期望 O(nlogn)，其中 n 为数组的长度</li>
<li>空间复杂度：O(h)，其中 h 为快速排序递归调用的层数。我们需要额外的 O(h) 的递归调用的栈空间，由于划分的结果不同导致了快速排序递归调用的层数也会不同，最坏情况下需 O(n) 的空间，最优情况下每次都平衡，此时整个递归树高度为 logn，空间复杂度为 O(logn)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数将对数组进行原地排序，不返回任何东西。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(nums []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 如果左索引小于右索引，说明还有元素需要排序</span></span><br><span class="line">	<span class="keyword">if</span> left &lt; right &#123;</span><br><span class="line">		<span class="comment">// 执行分区操作，获取基准元素的索引</span></span><br><span class="line">		pivot := partition(nums, left, right)</span><br><span class="line">		<span class="comment">// 递归地对基准元素的左边和右边进行快速排序</span></span><br><span class="line">		quickSort(nums, left, pivot<span class="number">-1</span>)</span><br><span class="line">		quickSort(nums, pivot+<span class="number">1</span>, right)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个分区函数，接受一个整数数组和左右索引，返回基准元素的索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(nums []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 选择最右边的元素作为基准元素</span></span><br><span class="line">	pivot := nums[right]</span><br><span class="line">	<span class="comment">// 定义 i 为小于基准元素的区域的右边界，初始值为 left-1</span></span><br><span class="line">	i := left - <span class="number">1</span></span><br><span class="line">	<span class="comment">// 遍历左边到右边之间的元素</span></span><br><span class="line">	<span class="keyword">for</span> j := left; j &lt; right; j++ &#123;</span><br><span class="line">		<span class="comment">// 如果当前元素小于基准元素，就将其移到小于区域的右边界之后</span></span><br><span class="line">		<span class="keyword">if</span> nums[j] &lt; pivot &#123;</span><br><span class="line">			i++</span><br><span class="line">			nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 最后，将基准元素移到小于区域的右边界之后，并返回其索引</span></span><br><span class="line">	nums[i+<span class="number">1</span>], nums[right] = nums[right], nums[i+<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">25</span>, <span class="number">11</span>&#125;</span><br><span class="line">	quickSort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Sorted nums:&quot;</span>, nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-合并两个有序链表（Go）-21-简单"><a href="#4-合并两个有序链表（Go）-21-简单" class="headerlink" title="4. 合并两个有序链表（Go） 21-简单"></a><font color=DarkOrange>4. 合并两个有序链表（Go） 21-简单</font></h4><p><strong>题目：</strong></p>
<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">,</span> l2 = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span></span><br><span class="line">输入：l1 = <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> l2 = <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">输入：l1 = <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> l2 = <span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>两个链表的节点数目范围是 <code>[0, 50]</code></li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：递归<br>思路</p>
<p>我们可以如下递归地定义两个链表里的 merge 操作（忽略边界情况，比如空链表等）：</p>
<p>list1[0] + merge(list1[1:], list2) list1[0] &lt; list2[0]</p>
<p>list2[0] + merge(list1, list2[1:]) otherwise </p>
<p>也就是说，两个链表头部值较小的一个节点与剩下元素的 <code>merge</code> 操作结果合并</p>
<p>算法：</p>
<p>我们直接将以上递归过程建模，同时需要考虑边界情况</p>
<p>如果 <code>l1</code> 或者 <code>l2</code> 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 <code>l1</code> 和 <code>l2</code> 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。因为每次调用递归都会去掉 <code>l1</code> 或者 <code>l2</code> 的头节点（直到至少有一个链表为空），函数 <code>mergeTwoList</code> 至多只会递归调用每个节点一次。因此，时间复杂度取决于合并后的链表长度，即 O(n+m)</li>
<li>空间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。递归调用 <code>mergeTwoLists</code> 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。结束递归调用时 mergeTwoLists 函数最多调用 n+m 次，因此空间复杂度为 O(n+m)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> ListNode struct &#123;</span><br><span class="line">	Value <span class="built_in">int</span></span><br><span class="line">	Next  *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// CreateListNode 使用<span class="built_in">slice</span>创建单链表</span><br><span class="line">func CreateListNode(nums []<span class="built_in">int</span>) *ListNode &#123;</span><br><span class="line">	var head ListNode</span><br><span class="line">	var pre ListNode</span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="built_in">range</span> nums &#123;</span><br><span class="line">		node := ListNode&#123;Value: num, Next: nil&#125;</span><br><span class="line">		<span class="keyword">if</span> head.Next == nil &#123;</span><br><span class="line">			head.Next = &amp;node</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> pre.Next == nil &#123;</span><br><span class="line">			pre.Next = &amp;node</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			pre.Next.Next = &amp;node</span><br><span class="line">			pre = *pre.Next</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Traverse 遍历链表</span><br><span class="line">func Traverse(t *ListNode) &#123;</span><br><span class="line">	<span class="keyword">if</span> t == nil &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;空链表&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> t != nil &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot; %d&quot;</span>, t.Value)</span><br><span class="line">		t = t.Next</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// MergeTwoListNode 合并<span class="number">2</span>个链表</span><br><span class="line">func MergeTwoListNode(List1, List2 *ListNode) *ListNode &#123;</span><br><span class="line">	// 如果有一条链表为nil，直接返回另一条链表</span><br><span class="line">	<span class="keyword">if</span> List1 == nil &#123;</span><br><span class="line">		<span class="keyword">return</span> List2</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> List2 == nil &#123;</span><br><span class="line">		<span class="keyword">return</span> List1</span><br><span class="line">	&#125;</span><br><span class="line">	// 定义一个节点</span><br><span class="line">	var result *ListNode</span><br><span class="line">	<span class="keyword">if</span> List1.Value &gt;= List2.Value &#123;</span><br><span class="line">		result = List2</span><br><span class="line">		result.Next = MergeTwoListNode(List1, List2.Next)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		result = List1</span><br><span class="line">		result.Next = MergeTwoListNode(List1.Next, List2)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	nums1 := []<span class="built_in">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;</span><br><span class="line">	nums2 := []<span class="built_in">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>&#125;</span><br><span class="line">	lis1 := CreateListNode(nums1)</span><br><span class="line">	lis2 := CreateListNode(nums2)</span><br><span class="line">	mergeTwoListNode := MergeTwoListNode(lis1, lis2)</span><br><span class="line">	Traverse(mergeTwoListNode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-最大子数组和（Go）53-简单"><a href="#5-最大子数组和（Go）53-简单" class="headerlink" title="5. 最大子数组和（Go）53-简单"></a><font color=DarkOrange>5. 最大子数组和（Go）53-简单</font></h4><p><strong>题目：</strong></p>
<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和</p>
<p><strong>子数组</strong> 是数组中的一个连续部分</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">-2</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">-3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">-1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">-5</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：连续子数组 <span class="punctuation">[</span><span class="number">4</span><span class="punctuation">,</span><span class="number">-1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span> 的和最大，为 <span class="number">6</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">-1</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">23</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：动态规划（核心：若前一个元素大于0，则将其加到当前元素上）<br>思路和算法</p>
<p>假设 nums 数组的长度是 n，下标从 0 到 n−1</p>
<p>我们用 f(i) 代表以第 i 个数结尾的「连续子数组的最大和」，那么很显然我们要求的答案就是：<br>0≤i的max≤n−1的{f(i)}</p>
<p>因此我们只需要求出每个位置的 f(i)，然后返回 f 数组中的最大值即可。那么我们如何求 f(i) 呢？我们可以考虑 nums[i] 单独成为一段还是加入 f(i−1) 对应的那一段，这取决于 nums[i] 和 f(i-1) +nums[i] 的大小，我们希望获得一个比较大的，于是可以写出这样的动态规划转移方程：<br>f(i)&#x3D;max{f(i−1)+nums[i],nums[i]}</p>
<p>不难给出一个时间复杂度 O(n)、空间复杂度 O(n) 的实现，即用一个 ff 数组来保存 f(i) 的值，用一个循环求出所有 f(i)。考虑到 f(i) 只和 f(i−1) 相关，于是我们可以只用一个变量 pre 来维护对于当前 f(i) 的 f(i−1) 的值是多少，从而让空间复杂度降低到 O(1)，这有点类似「滚动数组」的思想</p>
<div align="center"><img src="https://i.bmp.ovh/imgs/2022/06/21/2f768ff06b617809.png" style="zoom:50%;" /></div>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 为 nums 数组的长度。我们只需要遍历一遍数组即可求得答案</li>
<li>空间复杂度：O(1)。我们只需要常数空间存放若干变量</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    max := nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] + nums[i - <span class="number">1</span>] &gt; nums[i] &#123;</span><br><span class="line">            nums[i] += nums[i - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; max &#123;</span><br><span class="line">            max = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-字符串相加（Go）415-简单"><a href="#6-字符串相加（Go）415-简单" class="headerlink" title="6. 字符串相加（Go）415-简单"></a><font color=DarkOrange>6. 字符串相加（Go）415-简单</font></h4><p><strong>题目：</strong></p>
<p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回</p>
<p>你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：num1 = <span class="string">&quot;11&quot;</span><span class="punctuation">,</span> num2 = <span class="string">&quot;123&quot;</span></span><br><span class="line">输出：<span class="string">&quot;134&quot;</span></span><br><span class="line">输入：num1 = <span class="string">&quot;456&quot;</span><span class="punctuation">,</span> num2 = <span class="string">&quot;77&quot;</span></span><br><span class="line">输出：<span class="string">&quot;533&quot;</span></span><br><span class="line">输入：num1 = <span class="string">&quot;0&quot;</span><span class="punctuation">,</span> num2 = <span class="string">&quot;0&quot;</span></span><br><span class="line">输出：<span class="string">&quot;0&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= num1.length, num2.length &lt;= 10的4次方</code></li>
<li><code>num1</code> 和<code>num2</code> 都只包含数字 <code>0-9</code></li>
<li><code>num1</code> 和<code>num2</code> 都不包含任何前导零</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：模拟<br>思路与算法</p>
<p>本题我们只需要对两个大整数模拟「竖式加法」的过程。竖式加法就是我们平常学习生活中常用的对两个整数相加的方法，回想一下我们在纸上对两个整数相加的操作，是不是如下图将相同数位对齐，从低到高逐位相加，如果当前位和超过 10，则向高位进一位？因此我们只要将这个过程用代码写出来即可</p>
<p>具体实现也不复杂，我们定义两个指针 i 和 j 分别指向 num1  和 num 2 的末尾，即最低位，同时定义一个变量 add 维护当前是否有进位，然后从末尾到开头逐位相加即可。你可能会想两个数字位数不同怎么处理，这里我们统一在指针当前下标处于负数的时候返回 0，等价于对位数较短的数字进行了补零操作，这样就可以除去两个数字位数不同情况的处理，具体可以看下面的代码</p>
<div align="center"><img src="https://i.bmp.ovh/imgs/2022/06/21/83dd1b48338dee5d.png" style="zoom:50%;" /></div>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(max(len1,len2))，其中 len1&#x3D;num1.length，len2&#x3D;num2.length。竖式加法的次数取决于较大数的位数</li>
<li>空间复杂度：O(1)。除答案外我们只需要常数空间存放若干变量。在 Java 解法中使用到了 <code>StringBuffer</code>，故 Java 解法的空间复杂度为O(n)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addStrings</span><span class="params">(num1 <span class="type">string</span>, num2 <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    add := <span class="number">0</span></span><br><span class="line">    ans := <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="built_in">len</span>(num1) - <span class="number">1</span>, <span class="built_in">len</span>(num2) - <span class="number">1</span>; i &gt;= <span class="number">0</span> ||</span><br><span class="line">    j &gt;= <span class="number">0</span> || add != <span class="number">0</span>; i, j = i - <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> x, y <span class="type">int</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            x = <span class="type">int</span>(num1[i] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> j &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            y = <span class="type">int</span>(num2[j] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        result := x + y + add</span><br><span class="line">        ans = strconv.Itoa(result % <span class="number">10</span>) + ans</span><br><span class="line">        add = result / <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-二分查找（Go）704-简单"><a href="#7-二分查找（Go）704-简单" class="headerlink" title="7. 二分查找（Go）704-简单"></a><font color=DarkOrange>7. 二分查找（Go）704-简单</font></h4><p><strong>题目：</strong></p>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 <code>target</code>  ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 -1</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入<span class="punctuation">:</span> nums = <span class="punctuation">[</span><span class="number">-1</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">12</span><span class="punctuation">]</span><span class="punctuation">,</span> target = <span class="number">9</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line">解释<span class="punctuation">:</span> <span class="number">9</span> 出现在 nums 中并且下标为 <span class="number">4</span></span><br><span class="line">输入<span class="punctuation">:</span> nums = <span class="punctuation">[</span><span class="number">-1</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">12</span><span class="punctuation">]</span><span class="punctuation">,</span> target = <span class="number">2</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="number">-1</span></span><br><span class="line">解释<span class="punctuation">:</span> <span class="number">2</span> 不存在 nums 中因此返回 <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li>你可以假设 <code>nums</code> 中的所有元素是不重复的</li>
<li><code>n</code> 将在 <code>[1, 10000]</code>之间</li>
<li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间</li>
</ol>
<p><strong>思路：</strong></p>
<p>方法一：二分查找<br>在升序数组 nums 中寻找目标值 target，对于特定下标 i，比较 nums[i] 和 target 的大小：</p>
<ul>
<li><p>如果 nums[i] &#x3D; target，则下标 i 即为要寻找的下标</p>
</li>
<li><p>如果 nums[i] &gt; target，则 target 只可能在下标 i 的左侧</p>
</li>
<li><p>如果 nums[i] &lt; target，则 target 只可能在下标 i 的右侧</p>
</li>
</ul>
<p>基于上述事实，可以在有序数组中使用二分查找寻找目标值<br>二分查找的做法是，定义查找的范围 [left,right]，初始查找范围是整个数组。每次取查找范围的中点 mid，比较 nums[mid] 和 target 的大小，如果相等则 mid 即为要寻找的下标，如果不相等则根据 nums[mid] 和 target 的大小关系将查找范围缩小一半</p>
<p>由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是 O(logn)，其中 n 是数组的长度</p>
<p>二分查找的条件是查找范围不为空，即 left &lt;&#x3D; right。如果 target 在数组中，二分查找可以保证找到 target，返回 target 在数组中的下标。如果 target 不在数组中，则当 left &gt; right 时结束查找，返回 -1</p>
<div align="center"><img src="https://i.bmp.ovh/imgs/2022/06/21/736001c2f7e7a333.png" style="zoom:50%;" /></div>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(logn)，其中 n 是数组的长度</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        mid := (right - left) / <span class="number">2</span> + left</span><br><span class="line">        num := nums[mid]</span><br><span class="line">        <span class="keyword">if</span> num == target &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> num &gt; target &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-无重复字符串的最长子串（Go）3-中等"><a href="#8-无重复字符串的最长子串（Go）3-中等" class="headerlink" title="8. 无重复字符串的最长子串（Go）3-中等"></a><font color=DarkOrange>8. 无重复字符串的最长子串（Go）3-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入<span class="punctuation">:</span> s = <span class="string">&quot;abcabcbb&quot;</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="number">3</span> </span><br><span class="line">解释<span class="punctuation">:</span> 因为无重复字符的最长子串是 <span class="string">&quot;abc&quot;</span>，所以其长度为 <span class="number">3</span></span><br><span class="line">输入<span class="punctuation">:</span> s = <span class="string">&quot;bbbbb&quot;</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">解释<span class="punctuation">:</span> 因为无重复字符的最长子串是 <span class="string">&quot;b&quot;</span>，所以其长度为 <span class="number">1</span></span><br><span class="line">输入<span class="punctuation">:</span> s = <span class="string">&quot;pwwkew&quot;</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="number">3</span></span><br><span class="line">解释<span class="punctuation">:</span> 因为无重复字符的最长子串是 <span class="string">&quot;wke&quot;</span>，所以其长度为 <span class="number">3</span></span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">&quot;pwke&quot;</span> 是一个子序列，不是子串</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 5 * 10^4</code></li>
<li><code>s</code> 由英文字母、数字、符号和空格组成</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：滑动窗口</p>
<p>思路和算法</p>
<p>我们先用一个例子考虑如何在较优的时间复杂度内通过本题</p>
<p>我们不妨以示例一中的字符串 abcabcbb 为例，找出从每一个字符开始的，不包含重复字符的最长子串，那么其中最长的那个字符串即为答案。对于示例一中的字符串，我们列举出这些结果，其中括号中表示选中的字符以及最长的字符串：</p>
<ul>
<li><p>以 (a)bcabcbb 开始的最长字符串为 (abc)abcbb</p>
</li>
<li><p>以 a(b)cabcbb 开始的最长字符串为 a(bca)bcbb</p>
</li>
<li><p>以 ab(c)abcbb 开始的最长字符串为 ab(cab)cbb</p>
</li>
<li><p>以 abc(a)bcbb 开始的最长字符串为 abc(abc)bb</p>
</li>
<li><p>以 abca(b)cbb 开始的最长字符串为 abca(bc)bb</p>
</li>
<li><p>以 abcab(c)bb 开始的最长字符串为 abcab(cb)b</p>
</li>
<li><p>以 abcabc(b)b 开始的最长字符串为 abcabc(b)b</p>
</li>
<li><p>以 abcabcb(b) 开始的最长字符串为 abcabcb(b)</p>
</li>
</ul>
<p>发现了什么？如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的！这里的原因在于，假设我们选择字符串中的第 k 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 tk 。那么当我们选择第 k+1 个字符作为起始位置时，首先从 k+1 到 tk  的字符显然是不重复的，并且由于少了原本的第 k 个字符，我们可以尝试继续增大 tk，直到右侧出现了重复字符为止</p>
<p>这样一来，我们就可以使用「滑动窗口」来解决这个问题了：</p>
<ul>
<li>我们使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的 rk</li>
<li>在每一步的操作中，我们会将左指针向右移动一格，表示 我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 以左指针开始的，不包含重复字符的最长子串。我们记录下这个子串的长度</li>
<li>在枚举结束后，我们找到的最长的子串的长度即为答案</li>
</ul>
<p>判断重复字符：</p>
<p>在上面的流程中，我们还需要使用一种数据结构来判断 是否有重复的字符，常用的数据结构为哈希集合（即 <code>C++</code>中的 <code>std::unordered_set</code>，<code>Java</code> 中的 <code>HashSet</code>，<code>Python</code> 中的 <code>set</code> , <code>JavaScript</code> 中的 <code>Set</code>）。在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，我们往哈希集合中添加一个字符</p>
<p>至此，我们就完美解决了本题</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N 是字符串的长度。左指针和右指针分别会遍历整个字符串一次</li>
<li>空间复杂度：O(∣Σ∣)，其中Σ 表示字符集（即字符串中可以出现的字符），∣Σ∣ 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 [0,128) 内的字符，即 ∣Σ∣&#x3D;128。我们需要用到哈希集合来存储出现过的字符，而字符最多有 ∣Σ∣ 个，因此空间复杂度为 O(∣Σ∣)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 哈希集合，记录每个字符串是否出现过</span></span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="comment">// 右指针，初始值为-1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">    rk, ans := <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 左指针向右移动一格，移除一个字符串</span></span><br><span class="line">            <span class="built_in">delete</span>(m, s[i - <span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> rk + <span class="number">1</span> &lt; n &amp;&amp; m[s[rk + <span class="number">1</span>]] == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 不断的移动右指针</span></span><br><span class="line">            m[s[rk + <span class="number">1</span>]]++</span><br><span class="line">            rk++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第i到rk个字符是一个极长的无重复字符子串</span></span><br><span class="line">        ans = max(ans, rk - i + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-数组中的第K个最大元素（Go）215-中等"><a href="#9-数组中的第K个最大元素（Go）215-中等" class="headerlink" title="9. 数组中的第K个最大元素（Go）215-中等"></a><font color=DarkOrange>9. 数组中的第K个最大元素（Go）215-中等</font></h4><p><strong>题目：</strong></p>
<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素</p>
<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入<span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span> 和 k = <span class="number">2</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="number">5</span></span><br><span class="line">输入<span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">]</span> 和 k = <span class="number">4</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= nums.length &lt;= 10的4次方</code></li>
<li><code>-10的4次方 &lt;= nums[i] &lt;= 10的4次方</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：基于快速排序的选择方法</p>
<p>思路和算法</p>
<p>我们可以用快速排序来解决这个问题，先对原数组排序，再返回倒数第 k 个位置，这样平均时间复杂度是 O(nlogn)，但其实我们可以做的更快</p>
<p>首先我们来回顾一下快速排序，这是一个典型的分治算法。我们对数组 a[l⋯r] 做快速排序的过程是（参考《算法导论》）：</p>
<ul>
<li>分解： 将数组 a[l⋯r] 「划分」成两个子数组 a[l⋯q−1]、a[q+1⋯r]，使得 a[l⋯q−1] 中的每个元素小于等于 a[q]，且 a[q] 小于等于 a[q+1⋯r] 中的每个元素。其中，计算下标 q 也是「划分」过程的一部分</li>
<li>解决： 通过递归调用快速排序，对子数组 a[l⋯q−1] 和 a[q+1⋯r] 进行排序</li>
<li>合并： 因为子数组都是原址排序的，所以不需要进行合并操作，a[l⋯r] 已经有序</li>
<li>上文中提到的 「划分」 过程是：从子数组 a[l⋯r] 中选择任意一个元素 x 作为主元，调整子数组的元素使得左边的元素都小于等于它，右边的元素都大于等于它， x 的最终位置就是 q</li>
</ul>
<p>由此可以发现每次经过「划分」操作后，我们一定可以确定一个元素的最终位置，即 x 的最终位置为 q，并且保证 a[l⋯q−1] 中的每个元素小于等于 a[q]，且 a[q] 小于等于 a[q+1⋯r] 中的每个元素。所以只要某次划分的 q 为倒数第 k 个下标的时候，我们就已经找到了答案。 我们只关心这一点，至于 a[l⋯q−1] 和 a[q+1⋯r] 是否是有序的，我们不关心</p>
<p>因此我们可以改进快速排序算法来解决这个问题：在分解的过程当中，我们会对子数组进行划分，如果划分得到的 q 正好就是我们需要的下标，就直接返回 a[q]；否则，如果 q 比目标下标小，就递归右子区间，否则递归左子区间。这样就可以把原来递归两个区间变成只递归一个区间，提高了时间效率。这就是「快速选择」算法</p>
<p>我们知道快速排序的性能和「划分」出的子数组的长度密切相关。直观地理解如果每次规模为 n 的问题我们都划分成 1 和 n−1，每次递归的时候又向 n−1 的集合中递归，这种情况是最坏的，时间代价是 O n的2次方。我们可以引入随机化来加速这个过程，它的时间代价的期望是 O(n)，证明过程可以参考「《算法导论》9.2：期望为线性的选择算法」</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)，如上文所述，证明过程可以参考「《算法导论》9.2：期望为线性的选择算法」</li>
<li>空间复杂度：O(logn)，递归使用栈空间的空间代价的期望为 O(logn)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthLargest</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>, <span class="built_in">len</span>(nums) - k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSelect</span><span class="params">(a []<span class="type">int</span>, l, r, index <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    q := randomPartition(a, l, r)</span><br><span class="line">    <span class="keyword">if</span> q == index &#123;</span><br><span class="line">        <span class="keyword">return</span> a[q]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> q &lt; index &#123;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(a, q + <span class="number">1</span>, r, index)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSelect(a, l, q - <span class="number">1</span>, index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomPartition</span><span class="params">(a []<span class="type">int</span>, l, r <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    i := rand.Int() % (r - l + <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">    a[i], a[r] = a[r], a[i]</span><br><span class="line">    <span class="keyword">return</span> partition(a, l, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(a []<span class="type">int</span>, l, r <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    x := a[r]</span><br><span class="line">    i := l - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; r; j ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> a[j] &lt;= x &#123;</span><br><span class="line">            i++</span><br><span class="line">            a[i], a[j] = a[j], a[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[i + <span class="number">1</span>], a[r] = a[r], a[i + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-字符串转换整数-8-中等"><a href="#10-字符串转换整数-8-中等" class="headerlink" title="10. 字符串转换整数 8-中等"></a><font color=DarkOrange>10. 字符串转换整数 8-中等</font></h4><p>题目：</p>
<p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C&#x2F;C++ 中的 <code>atoi</code> 函数</p>
<p>函数 <code>myAtoi(string s)</code> 的算法如下：</p>
<ol>
<li>读入字符串并丢弃无用的前导空格</li>
<li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正</li>
<li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略<br>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）</li>
<li>如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整</li>
<li>应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 </li>
<li>返回整数作为最终结果</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>本题中的空白字符只包括空格字符 <code>&#39; &#39;</code> </li>
<li>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong> 任何其他字符</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;42&quot;</span></span><br><span class="line">输出：<span class="number">42</span></span><br><span class="line">解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符</span><br><span class="line">第 <span class="number">1</span> 步：<span class="string">&quot;42&quot;</span>（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 <span class="number">2</span> 步：<span class="string">&quot;42&quot;</span>（当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;）</span><br><span class="line">         ^</span><br><span class="line">第 <span class="number">3</span> 步：<span class="string">&quot;42&quot;</span>（读入 <span class="string">&quot;42&quot;</span>）</span><br><span class="line">           ^</span><br><span class="line">解析得到整数 <span class="number">42</span></span><br><span class="line">由于 <span class="string">&quot;42&quot;</span> 在范围 <span class="punctuation">[</span><span class="number">-231</span><span class="punctuation">,</span> <span class="number">231</span> - <span class="number">1</span><span class="punctuation">]</span> 内，最终结果为 <span class="number">42</span></span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;   -42&quot;</span></span><br><span class="line">输出：<span class="number">-42</span></span><br><span class="line">解释：</span><br><span class="line">第 <span class="number">1</span> 步：<span class="string">&quot;   -42&quot;</span>（读入前导空格，但忽视掉）</span><br><span class="line">            ^</span><br><span class="line">第 <span class="number">2</span> 步：<span class="string">&quot;   -42&quot;</span>（读入 &#x27;-&#x27; 字符，所以结果应该是负数）</span><br><span class="line">             ^</span><br><span class="line">第 <span class="number">3</span> 步：<span class="string">&quot;   -42&quot;</span>（读入 <span class="string">&quot;42&quot;</span>）</span><br><span class="line">               ^</span><br><span class="line">解析得到整数 <span class="number">-42</span></span><br><span class="line">由于 <span class="string">&quot;-42&quot;</span> 在范围 <span class="punctuation">[</span><span class="number">-231</span><span class="punctuation">,</span> <span class="number">231</span> - <span class="number">1</span><span class="punctuation">]</span> 内，最终结果为 <span class="number">-42</span></span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;4193 with words&quot;</span></span><br><span class="line">输出：<span class="number">4193</span></span><br><span class="line">解释：</span><br><span class="line">第 <span class="number">1</span> 步：<span class="string">&quot;4193 with words&quot;</span>（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 <span class="number">2</span> 步：<span class="string">&quot;4193 with words&quot;</span>（当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;）</span><br><span class="line">         ^</span><br><span class="line">第 <span class="number">3</span> 步：<span class="string">&quot;4193 with words&quot;</span>（读入 <span class="string">&quot;4193&quot;</span>；由于下一个字符不是一个数字，所以读入停止）</span><br><span class="line">             ^</span><br><span class="line">解析得到整数 <span class="number">4193</span></span><br><span class="line">由于 <span class="string">&quot;4193&quot;</span> 在范围 <span class="punctuation">[</span><span class="number">-231</span><span class="punctuation">,</span> <span class="number">231</span> - <span class="number">1</span><span class="punctuation">]</span> 内，最终结果为 <span class="number">4193</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 200</code></li>
<li><code>s</code> 由英文字母（大写和小写）、数字（<code>0-9</code>）、<code>&#39; &#39;</code>、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code> 和 <code>&#39;.&#39;</code> 组成</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：自动机</p>
<p>思路</p>
<p>字符串处理的题目往往涉及复杂的流程以及条件情况，如果直接上手写程序，一不小心就会写出极其臃肿的代码</p>
<p>因此，为了有条理地分析每个输入字符的处理方法，我们可以使用自动机这个概念：</p>
<p>我们的程序在每个时刻有一个状态 <code>s</code>，每次从序列中输入一个字符 <code>c</code>，并根据字符 <code>c</code> 转移到下一个状态 <code>s</code>。这样，我们只需要建立一个覆盖所有情况的从 <code>s</code> 与 <code>c</code> 映射到 <code>s</code> 的表格即可解决题目中的问题</p>
<p>算法</p>
<p>本题可以建立如下图所示的自动机：</p>
<p>我们也可以用下面的表格来表示这个自动机：</p>
<p>接下来编程部分就非常简单了：我们只需要把上面这个状态转换表抄进代码即可</p>
<p>另外自动机也需要记录当前已经输入的数字，只要在 <code>s</code> 为 <code>in_number</code> 时，更新我们输入的数字，即可最终得到输入的数字</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 nn 为字符串的长度。我们只需要依次处理所有的字符，处理每个字符需要的时间为 O(1)</li>
<li>空间复杂度：O(1)。自动机的状态只需要常数空间存储</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">myAtoi</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">min</span>(<span class="built_in">int</span>(*re.findall(<span class="string">&#x27;^[\+\-]?\d+&#x27;</span>, s.lstrip())), <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>), -<span class="number">2</span>**<span class="number">31</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">INT_MAX = <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span></span><br><span class="line">INT_MIN = -<span class="number">2</span> ** <span class="number">31</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Automaton</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.state = <span class="string">&#x27;start&#x27;</span></span><br><span class="line">        self.sign = <span class="number">1</span></span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line">        self.table = &#123;</span><br><span class="line">            <span class="string">&#x27;start&#x27;</span>: [<span class="string">&#x27;start&#x27;</span>, <span class="string">&#x27;signed&#x27;</span>, <span class="string">&#x27;in_number&#x27;</span>, <span class="string">&#x27;end&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;signed&#x27;</span>: [<span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;in_number&#x27;</span>, <span class="string">&#x27;end&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;in_number&#x27;</span>: [<span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;in_number&#x27;</span>, <span class="string">&#x27;end&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;end&#x27;</span>: [<span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>],</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_col</span>(<span class="params">self, c</span>):</span><br><span class="line">        <span class="keyword">if</span> c.isspace():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&#x27;+&#x27;</span> <span class="keyword">or</span> c == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> c.isdigit():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, c</span>):</span><br><span class="line">        self.state = self.table[self.state][self.get_col(c)]</span><br><span class="line">        <span class="keyword">if</span> self.state == <span class="string">&#x27;in_number&#x27;</span>:</span><br><span class="line">            self.ans = self.ans * <span class="number">10</span> + <span class="built_in">int</span>(c)</span><br><span class="line">            self.ans = <span class="built_in">min</span>(self.ans, INT_MAX) <span class="keyword">if</span> self.sign == <span class="number">1</span> <span class="keyword">else</span> <span class="built_in">min</span>(self.ans, -INT_MIN)</span><br><span class="line">        <span class="keyword">elif</span> self.state == <span class="string">&#x27;signed&#x27;</span>:</span><br><span class="line">            self.sign = <span class="number">1</span> <span class="keyword">if</span> c == <span class="string">&#x27;+&#x27;</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">myAtoi</span>(<span class="params">self, <span class="built_in">str</span>: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        automaton = Automaton()</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">            automaton.get(c)</span><br><span class="line">        <span class="keyword">return</span> automaton.sign * automaton.ans</span><br></pre></td></tr></table></figure>

<h4 id="11-回文链表（Go）234-简单"><a href="#11-回文链表（Go）234-简单" class="headerlink" title="11. 回文链表（Go）234-简单"></a><font color=DarkOrange>11. 回文链表（Go）234-简单</font></h4><p><strong>题目：</strong></p>
<p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> </p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">true</span></span></span><br><span class="line">输入：head = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">false</span></span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点数目在范围<code>[1, 10^5]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：将值复制到数组中后用双指针法<br>思路</p>
<p>如果你还不太熟悉链表，下面有关于列表的概要讲述</p>
<p>有两种常用的列表实现，分别为数组列表和链表。如果我们想在列表中存储值，它们是如何实现的呢</p>
<ul>
<li>数组列表底层是使用数组存储值，我们可以通过索引在 O(1) 的时间访问列表任何位置的值，这是由基于内存寻址的方式</li>
<li>链表存储的是称为节点的对象，每个节点保存一个值和指向下一个节点的指针。访问某个特定索引的节点需要 O(n) 的时间，因为要通过指针获取到下一个位置的节点</li>
</ul>
<p>确定数组列表是否回文很简单，我们可以使用双指针法来比较两端的元素，并向中间移动。一个指针从起点向中间移动，另一个指针从终点向中间移动。这需要 O(n) 的时间，因为访问每个元素的时间是 O(1)，而有 n 个元素要访问</p>
<p>然而同样的方法在链表上操作并不简单，因为不论是正向访问还是反向访问都不是 O(1)。而将链表的值复制到数组列表中是 O(n)，因此最简单的方法就是将链表的值复制到数组列表中，再使用双指针法判断</p>
<p>算法</p>
<p>一共为两个步骤：</p>
<ol>
<li>复制链表值到数组列表中</li>
<li>使用双指针法判断是否为回文</li>
</ol>
<p>第一步，我们需要遍历链表将值复制到数组列表中。我们用 <code>currentNode</code> 指向当前节点。每次迭代向数组添加 <code>currentNode.val</code>，并更新 <code>currentNode = currentNode.next</code>，当 currentNode &#x3D; null&#96; 时停止循环</p>
<p>执行第二步的最佳方法取决于你使用的语言。在 Python 中，很容易构造一个列表的反向副本，也很容易比较两个列表。而在其他语言中，就没有那么简单。因此最好使用双指针法来检查是否为回文。我们在起点放置一个指针，在结尾放置一个指针，每一次迭代判断两个指针指向的元素是否相同，若不同，返回 <code>false</code>；相同则将两个指针向内移动，并继续判断，直到两个指针相遇</p>
<p>在编码的过程中，注意我们比较的是节点值的大小，而不是节点本身。正确的比较方式是：<code>node_1.val == node_2.val</code>，而 <code>node_1 == node_2</code> 是错误的</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li><p>时间复杂度：O(n)，其中 n 指的是链表的元素个数</p>
<ul>
<li>第一步： 遍历链表并将值复制到数组中，O(n)</li>
<li>第二步：双指针判断是否为回文，执行了 O(n&#x2F;2) 次的判断，即 O(n)</li>
<li>总的时间复杂度：O(2n)&#x3D;O(n)</li>
</ul>
</li>
<li><p>空间复杂度：O(n)，其中 nn 指的是链表的元素个数，我们使用了一个数组列表存放链表的元素值</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(head *ListNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    vals := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> ; head != <span class="literal">nil</span>; head = head.Next &#123;</span><br><span class="line">        vals = <span class="built_in">append</span>(vals, head.Val)</span><br><span class="line">    &#125;</span><br><span class="line">    n := <span class="built_in">len</span>(vals)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> vals[:n / <span class="number">2</span>] &#123;</span><br><span class="line">        <span class="keyword">if</span> v != vals[n - <span class="number">1</span> - i] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-用Rand7-实现Rand10-（Go）470-中等"><a href="#12-用Rand7-实现Rand10-（Go）470-中等" class="headerlink" title="12. 用Rand7()实现Rand10()（Go）470-中等"></a><font color=DarkOrange>12. 用Rand7()实现Rand10()（Go）470-中等</font></h4><p><strong>题目：</strong></p>
<p>给定方法 <code>rand7</code> 可生成 <code>[1,7]</code> 范围内的均匀随机整数，试写一个方法 <code>rand10</code> 生成 <code>[1,10]</code> 范围内的均匀随机整数</p>
<p>你只能调用 <code>rand7()</code> 且不能调用其他方法。请不要使用系统的 <code>Math.random()</code> 方法</p>
<p>每个测试用例将有一个内部参数 <code>n</code>，即你实现的函数 <code>rand10()</code> 在测试时将被调用的次数。请注意，这不是传递给 <code>rand10()</code> 的参数</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入<span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">输入<span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">]</span></span><br><span class="line">输入<span class="punctuation">:</span> <span class="number">3</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">,</span><span class="number">10</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
</ul>
<p><strong>思想：</strong></p>
<p>方法一：拒绝采样</p>
<p>思路与算法</p>
<p>我们可以用拒绝采样的方法实现 Rand10()。在拒绝采样中，如果生成的随机数满足要求，那么就返回该随机数，否则会不断生成，直到生成一个满足要求的随机数为止</p>
<ul>
<li>我们只需要能够满足等概率的生成 10 个不同的数即可，具体的生成方法可以有很多种，比如我们可以利用两个 Rand7() 相乘，我们只取其中等概率的 10 个不同的数的组合即可，当然还有许多其他不同的解法，可以利用各种运算和函数的组合等方式来实现<ul>
<li>比如我们可以利用两个Rand7()相乘，分别可以得到结果如下：一大个表格</li>
<li>我们可以得到每个数生成的概率为：一大个表格</li>
<li>我们可以从中挑选 10个等概率的数即可</li>
</ul>
</li>
<li>题目中要求尽可能的减少 Rand7() 的调用次数，则我们应该尽量保证生成的每个不同的数的生成概率尽可能的大，即调用 Rand7() 期望次数尽可能的小</li>
<li>我们可以调用两次 Rand7()，那么可以生成 [1,49] 之间的随机整数，我们只用到其中的前 40 个用来实现 Rand10()，而拒绝剩下的 9 个数，如下图所示</li>
<li>我们可以看到表中的 [1,49] 每个数生成的概率为49分之1。我们实际上只取 [1,40] 这前 40 个数，转化为 [1,10] 时，这 10 个数中每个数的生成概率则为 49分之1</li>
</ul>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：期望时间复杂度为 O(1)，但最坏情况下会达到 O*(∞)（一直被拒绝）</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rand10</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        row := rand7()</span><br><span class="line">        col := rand7()</span><br><span class="line">        idx := (row - <span class="number">1</span>) * <span class="number">7</span> + col</span><br><span class="line">        <span class="keyword">if</span> idx &lt;= <span class="number">40</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + (idx - <span class="number">1</span>) % <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="13-两数之和（Go）1-简单"><a href="#13-两数之和（Go）1-简单" class="headerlink" title="13. 两数之和（Go）1-简单"></a><font color=DarkOrange>13. 两数之和（Go）1-简单</font></h4><p>题目：</p>
<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 和为目标值 <code>target</code>  的那 两个 整数，并返回它们的数组下标</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现</p>
<p>你可以按任意顺序返回答案</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">11</span><span class="punctuation">,</span><span class="number">15</span><span class="punctuation">]</span><span class="punctuation">,</span> target = <span class="number">9</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">解释：因为 nums<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span> + nums<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> == <span class="number">9</span> ，返回 <span class="punctuation">[</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">,</span> target = <span class="number">6</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">,</span> target = <span class="number">6</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 10^4</code></li>
<li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li>
<li><code>-10^9 &lt;= target &lt;= 10^9</code></li>
<li><strong>只会存在一个有效答案</strong></li>
</ul>
<p><strong>思想：</strong></p>
<p>方法二：哈希表</p>
<p>思路及算法</p>
<p>注意到方法一的时间复杂度较高的原因是寻找 <code>target - x</code> 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引</p>
<p>使用哈希表，可以将寻找 <code>target - x</code> 的时间复杂度降低到从 O(N) 降低到 O(1)</p>
<p>这样我们创建一个哈希表，对于每一个 <code>x</code>，我们首先查询哈希表中是否存在 <code>target - x</code>，然后将 <code>x</code> 插入到哈希表中，即可保证不会让 <code>x</code> 和自己匹配</p>
<p><strong>复杂度分析：</strong></p>
<p>时间复杂度：O(N)，其中 NN 是数组中的元素数量。对于每一个元素 <code>x</code>，我们可以 O(1) 地寻找 <code>target - x</code></p>
<p>空间复杂度：O(N)，其中 N 是数组中的元素数量。主要为哈希表的开销</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    hashTable := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> p, ok := hashTable[target - x]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;p, i&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        hashTable[x] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="14-爬楼梯（Go）70-简单"><a href="#14-爬楼梯（Go）70-简单" class="headerlink" title="14. 爬楼梯（Go）70-简单"></a><font color=DarkOrange>14. 爬楼梯（Go）70-简单</font></h4><p><strong>题目：</strong></p>
<p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：有两种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1.</span> <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span> <span class="number">2</span> 阶</span><br><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：有三种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1.</span> <span class="number">1</span> 阶 + <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span> <span class="number">1</span> 阶 + <span class="number">2</span> 阶</span><br><span class="line"><span class="number">3.</span> <span class="number">2</span> 阶 + <span class="number">1</span> 阶</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 45</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：动态规划</p>
<p>思路和算法</p>
<p>我们用 f(x) 表示爬到第 x 级台阶的方案数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，所以我们可以列出如下式子：<br>f(x)&#x3D;f(x−1)+f(x−2)</p>
<p>它意味着爬到第 x 级台阶的方案数是爬到第 x−1 级台阶的方案数和爬到第 x−2 级台阶的方案数的和。很好理解，因为每次只能爬 1 级或 2 级，所以 f(x) 只能从 f(x−1) 和 f(x−2) 转移过来，而这里要统计方案总数，我们就需要对这两项的贡献求和</p>
<p>以上是动态规划的转移方程，下面我们来讨论边界条件。我们是从第 0 级开始爬的，所以从第 0 级爬到第 0 级我们可以看作只有一种方案，即 f(0)&#x3D;1；从第 0 级到第 1 级也只有一种方案，即爬一级，f(1)&#x3D;1。这两个作为边界条件就可以继续向后推导出第 n 级的正确结果</p>
<p>我们不妨写几项来验证一下，根据转移方程得到 f(2)&#x3D;2，f(3)&#x3D;3，f(4)&#x3D;5，……，我们把这些情况都枚举出来，发现计算的结果是正确的</p>
<p>我们不难通过转移方程和边界条件给出一个时间复杂度和空间复杂度都是 O(n) 的实现，但是由于这里的 f(x) 只和 f(x−1) 与 f(x−2) 有关，所以我们可以用「滚动数组思想」把空间复杂度优化成 O(1)。下面的代码中给出的就是这种实现</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：循环执行 n 次，每次花费常数的时间代价，故渐进时间复杂度为 O(n)</li>
<li>空间复杂度：这里只用了常数个变量作为辅助空间，故渐进空间复杂度为 O(1)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    p, q, r := <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        p = q</span><br><span class="line">        q = r</span><br><span class="line">        r = p + q</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-最长递增子系列（Go）-300-中等"><a href="#15-最长递增子系列（Go）-300-中等" class="headerlink" title="15. 最长递增子系列（Go） 300-中等"></a><font color=DarkOrange>15. 最长递增子系列（Go） 300-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度</p>
<p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">10</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">101</span><span class="punctuation">,</span><span class="number">18</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：最长递增子序列是 <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">101</span><span class="punctuation">]</span>，因此长度为 <span class="number">4</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">7</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2500</code></li>
<li><code>-10的4次方 &lt;= nums[i] &lt;= 10的4次方</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：动态规划</p>
<p>思路与算法</p>
<p>定义 dp[i] 为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取</p>
<p>我们从小到大计算 dp 数组的值，在计算 dp[i] 之前，我们已经计算出 dp[0…i−1] 的值，则状态转移方程为：<br>dp[i] &#x3D; max(dp[j]) + 1，其中0&lt;&#x3D;j&lt;i并且num[j]&lt;num[i]</p>
<p>即考虑往 dp[0…i−1] 中最长的上升子序列后面再加一个 nums[i]。由于 dp[j] 代表 nums[0…j] 中以 nums[j] 结尾的最长上升子序列，所以如果能从 dp[j] 这个状态转移过来，那么 nums[i] 必然要大于 nums[j]，才能将 nums[i] 放在 nums[j] 后面以形成更长的上升子序列</p>
<p>最后，整个数组的最长上升子序列即所有 dp[i] 中的最大值</p>
<p>LISlength &#x3D; max(dp[i])，其中0&lt;&#x3D;i&lt;n</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n的2次方)，其中 n 为数组 nums 的长度。动态规划的状态数为 n，计算状态 dp[i] 时，需要 O(n) 的时间遍历 dp[0…i−1] 的所有状态，所以总时间复杂度为 O(n的2次方)</li>
<li>空间复杂度：O(n)，需要额外使用长度为 n 的 dp 数组</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">func LengthOfList(nums []<span class="built_in">int</span>) <span class="built_in">int</span> &#123;</span><br><span class="line">	// 定义dp[i]标识以nums[i]这个数据结尾的最长递增子系列的长度</span><br><span class="line">	dp := make([]<span class="built_in">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">	ans := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(dp); i++ &#123;</span><br><span class="line">		dp[i] = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">		<span class="keyword">for</span> k := <span class="number">0</span>; k &lt; j; k++ &#123;</span><br><span class="line">			<span class="keyword">if</span> nums[j] &gt; nums[k] &#123;</span><br><span class="line">				<span class="keyword">if</span> dp[j] &lt; dp[k]+<span class="number">1</span> &#123;</span><br><span class="line">					dp[j] = dp[k] + <span class="number">1</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="built_in">range</span> dp &#123;</span><br><span class="line">		<span class="keyword">if</span> v &gt; ans &#123;</span><br><span class="line">			ans = v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	nums := []<span class="built_in">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">11</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;结果为：&quot;</span>, LengthOfList(nums))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="16-有效的括号（Go）20-简单"><a href="#16-有效的括号（Go）20-简单" class="headerlink" title="16. 有效的括号（Go）20-简单"></a><font color=DarkOrange>16. 有效的括号（Go）20-简单</font></h4><p><strong>题目：</strong></p>
<p>给定一个只包括 <code>&#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合</li>
<li>左括号必须以正确的顺序闭合</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;()&quot;</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">true</span></span></span><br><span class="line">输入：s = <span class="string">&quot;()[]&#123;&#125;&quot;</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">true</span></span></span><br><span class="line">输入：s = <span class="string">&quot;(]&quot;</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">false</span></span></span><br><span class="line">输入：s = <span class="string">&quot;([)]&quot;</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">false</span></span></span><br><span class="line">输入：s = <span class="string">&quot;&#123;[]&#125;&quot;</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">true</span></span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10^4</code></li>
<li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：栈</p>
<p>判断括号的有效性可以使用「栈」这一数据结构来解决</p>
<p>我们遍历给定的字符串 s。当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶</p>
<p>当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串 s 无效，返回 False。为了快速判断括号的类型，我们可以使用哈希表存储每一种括号。哈希表的键为右括号，值为相同类型的左括号</p>
<p>在遍历结束后，如果栈中没有左括号，说明我们将字符串 s 中的所有左括号闭合，返回 True，否则返回 False</p>
<p>注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 False，省去后续的遍历判断过程</p>
<div align="center"><img src="https://i.bmp.ovh/imgs/2022/06/22/f79a7d99292db85e.png" style="zoom:50%;" /></div>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 是字符串 s 的长度</li>
<li>空间复杂度：O(n+∣Σ∣)，其中 Σ 表示字符集，本题中字符串只包含 6 种括号，∣Σ∣&#x3D;6。栈中的字符数量为 O(n)，而哈希表使用的空间为 O(∣Σ∣)，相加即可得到总空间复杂度</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    pairs := <span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">byte</span>&#123;</span><br><span class="line">        <span class="string">&#x27;)&#x27;</span>:<span class="string">&#x27;(&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;]&#x27;</span>:<span class="string">&#x27;[&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>:<span class="string">&#x27;&#123;&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    stack := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> pairs[s[i]] &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> || stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>] != pairs[s[i]] &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, s[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="17-环形链表（Go）141-简单"><a href="#17-环形链表（Go）141-简单" class="headerlink" title="17. 环形链表（Go）141-简单"></a><font color=DarkOrange>17. 环形链表（Go）141-简单</font></h4><p><strong>题目：</strong></p>
<p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环</p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：<code>pos</code> 不作为参数进行传递 。仅仅是为了标识链表的实际情况</p>
<p>如果链表中存在环 ，则返回 <code>true</code> 。 否则，返回 <code>false</code> </p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">-4</span><span class="punctuation">]</span><span class="punctuation">,</span> pos = <span class="number">1</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">true</span></span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点</span><br><span class="line">输入：head = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> pos = <span class="number">0</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">true</span></span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点</span><br><span class="line">输入：head = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> pos = <span class="number">-1</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">false</span></span></span><br><span class="line">解释：链表中没有环</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 10^4]</code></li>
<li><code>-10^5&lt;= Node.val &lt;= 10^5</code></li>
<li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：哈希表<br>思路及算法</p>
<p>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过</p>
<p>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N 是链表中的节点数。最坏情况下我们需要遍历每个节点一次</li>
<li>空间复杂度：O(N)，其中 N 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    seen := <span class="keyword">map</span>[*ListNode]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> _, ok := seen[head]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        seen[head] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        head = head.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="18-寻找旋转排序数组中的最小值（Go）153-中等"><a href="#18-寻找旋转排序数组中的最小值（Go）153-中等" class="headerlink" title="18. 寻找旋转排序数组中的最小值（Go）153-中等"></a><font color=DarkOrange>18. 寻找旋转排序数组中的最小值（Go）153-中等</font></h4><p><strong>题目：</strong></p>
<p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 旋转 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p>
<ul>
<li>若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]</li>
<li>若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]</li>
</ul>
<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 旋转一次 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> </p>
<p>给你一个元素值 互不相同 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 </p>
<p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：原数组为 <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span> ，旋转 <span class="number">3</span> 次得到输入数组</span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：原数组为 <span class="punctuation">[</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">]</span> ，旋转 <span class="number">4</span> 次得到输入数组</span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">11</span><span class="punctuation">,</span><span class="number">13</span><span class="punctuation">,</span><span class="number">15</span><span class="punctuation">,</span><span class="number">17</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">11</span></span><br><span class="line">解释：原数组为 <span class="punctuation">[</span><span class="number">11</span><span class="punctuation">,</span><span class="number">13</span><span class="punctuation">,</span><span class="number">15</span><span class="punctuation">,</span><span class="number">17</span><span class="punctuation">]</span> ，旋转 <span class="number">4</span> 次得到输入数组</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 5000</code></li>
<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>
<li><code>nums</code> 中的所有整数 互不相同</li>
<li><code>nums</code> 原来是一个升序排序的数组，并进行了 1 至 n 次旋转</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：二分查找</p>
<p>思路与算法</p>
<p>一个不包含重复元素的升序数组在经过旋转之后，可以得到下面可视化的折线图：</p>
<p>其中横轴表示数组元素的下标，纵轴表示数组元素的值。图中标出了最小值的位置，是我们需要查找的目标</p>
<p>我们考虑数组中的最后一个元素 x：在最小值右侧的元素（不包括最后一个元素本身），它们的值一定都严格小于 x；而在最小值左侧的元素，它们的值一定都严格大于 x。因此，我们可以根据这一条性质，通过二分查找的方法找出最小值</p>
<p>在二分查找的每一步中，左边界为 low，右边界为 high，区间的中点为 pivot，最小值就在该区间内。我们将中轴元素 nums[pivot] 与右边界元素 nums[high] 进行比较，可能会有以下的三种情况：</p>
<p>第一种情况是 nums[pivot]&lt;nums[high]。如下图所示，这说明 nums[pivot] 是最小值右侧的元素，因此我们可以忽略二分查找区间的右半部分</p>
<p>第二种情况是 nums[pivot]&gt;nums[high]。如下图所示，这说明 nums[pivot] 是最小值左侧的元素，因此我们可以忽略二分查找区间的左半部分</p>
<p>由于数组不包含重复元素，并且只要当前的区间长度不为 1，pivot 就不会与 high 重合；而如果当前的区间长度为 1，这说明我们已经可以结束二分查找了。因此不会存在 nums[pivot]&#x3D;nums[high] 的情况</p>
<p>当二分查找结束时，我们就得到了最小值所在的位置</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：时间复杂度为 O(logn)，其中 nn 是数组 nums 的长度。在二分查找的过程中，每一步会忽略一半的区间，因此时间复杂度为 O(logn)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMin</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    low, high := <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> low &lt; high &#123;</span><br><span class="line">        pivot := low + (high - low) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[pivot] &lt; nums[high] &#123;</span><br><span class="line">            high = pivot</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = pivot + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[low]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="19-最长回文子串（Go）5-中等"><a href="#19-最长回文子串（Go）5-中等" class="headerlink" title="19. 最长回文子串（Go）5-中等"></a><font color=DarkOrange>19. 最长回文子串（Go）5-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;babad&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bab&quot;</span></span><br><span class="line">解释：<span class="string">&quot;aba&quot;</span> 同样是符合题意的答案</span><br><span class="line">输入：s = <span class="string">&quot;cbbd&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bb&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 仅由数字和英文字母组成</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法二：中心扩展算法</p>
<p>思路与算法</p>
<p>我们仔细观察一下方法一中的状态转移方程：</p>
<p>P(i,i) &#x3D; true<br>P(i,i+1) &#x3D; (Si&#x3D;&#x3D;Si+1)</p>
<p>P(i,j) &#x3D; P(i+1, j+1)^(Si&#x3D;&#x3D;Sj)</p>
<p>找出其中的状态转移链：</p>
<p><em>P</em>(<em>i</em>,<em>j</em>)←<em>P</em>(<em>i</em>+1,<em>j</em>−1)←<em>P</em>(<em>i</em>+2,<em>j</em>−2)←⋯←某一边界情况</p>
<p>可以发现，所有的状态在转移的时候的可能性都是唯一的。也就是说，我们可以从每一种边界情况开始「扩展」，也可以得出所有的状态对应的答案</p>
<p>边界情况即为子串长度为 1 或 2 的情况。我们枚举每一种边界情况，并从对应的子串开始不断地向两边扩展。如果两边的字母相同，我们就可以继续扩展，例如从 P(i+1,j−1) 扩展到 P(i,j)；如果两边的字母不同，我们就可以停止扩展，因为在这之后的子串都不能是回文串了</p>
<p>聪明的读者此时应该可以发现，「边界情况」对应的子串实际上就是我们「扩展」出的回文串的「回文中心」。方法二的本质即为：我们枚举所有的「回文中心」并尝试「扩展」，直到无法扩展为止，此时的回文串长度即为此「回文中心」下的最长回文串长度。我们对所有的长度求出最大值，即可得到最终的答案</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n的2次方)，其中 n 是字符串的长度。长度为 1 和 2 的回文中心分别有 n 和 n−1 个，每个回文中心最多会向外扩展 O(n) 次</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    start, end := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        left1, right1 := expandAroundCenter(s, i ,i)</span><br><span class="line">        left2, right2 := expandAroundCenter(s, i, i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> right1 - left1 &gt; end - start &#123;</span><br><span class="line">            start, end = left1, right1</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> right2 - left2 &gt; end - start &#123;</span><br><span class="line">            start ,end = left2, right2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s[start:end + <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">expandAroundCenter</span><span class="params">(s <span class="type">string</span>, left, right <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> ; left &gt;= <span class="number">0</span> &amp;&amp; right &lt; <span class="built_in">len</span>(s) &amp;&amp; s[left] == s[right]; </span><br><span class="line">    left, right = left - <span class="number">1</span>, right + <span class="number">1</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">return</span> left + <span class="number">1</span>, right - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="20-最长公共子序列（Go）1143-中等"><a href="#20-最长公共子序列（Go）1143-中等" class="headerlink" title="20. 最长公共子序列（Go）1143-中等"></a><font color=DarkOrange>20. 最长公共子序列（Go）1143-中等</font></h4><p><strong>题目：</strong></p>
<p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 </p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串</p>
<ul>
<li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列</li>
</ul>
<p>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = <span class="string">&quot;abcde&quot;</span><span class="punctuation">,</span> text2 = <span class="string">&quot;ace&quot;</span> </span><br><span class="line">输出：<span class="number">3</span>  </span><br><span class="line">解释：最长公共子序列是 <span class="string">&quot;ace&quot;</span> ，它的长度为 <span class="number">3</span></span><br><span class="line">输入：text1 = <span class="string">&quot;abc&quot;</span><span class="punctuation">,</span> text2 = <span class="string">&quot;abc&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：最长公共子序列是 <span class="string">&quot;abc&quot;</span> ，它的长度为 <span class="number">3</span></span><br><span class="line">输入：text1 = <span class="string">&quot;abc&quot;</span><span class="punctuation">,</span> text2 = <span class="string">&quot;def&quot;</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：两个字符串没有公共子序列，返回 <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li>
<li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：动态规划<br>最长公共子序列问题是典型的二维动态规划问题</p>
<p>假设字符串 text 1和 text2的长度分别为 m 和 n，创建 m+1 行 n+1 列的二维数组 dp，其中 dp[i] [j]表示 text1[0:i] 和 text2[0:j] 的最长公共子序列的长度</p>
<p>上述表示中，text1[0:i] 表示 text1的长度为 i 的前缀，text2[0:j] 表示 text2的长度为 j 的前缀</p>
<p>考虑动态规划的边界情况：</p>
<ul>
<li>当 i&#x3D;0 时，text1[0:i] 为空，空字符串和任何字符串的最长公共子序列的长度都是 0，因此对任意 0≤j≤n，有 dp[0] [j]&#x3D;0</li>
<li>当 j&#x3D;0 时，text2 [0:j] 为空，同理可得，对任意 0≤i≤m，有 dp[i] [0]&#x3D;0</li>
</ul>
<p>因此动态规划的边界情况是：当 i&#x3D;0 或 j&#x3D;0 时，dp[i] [j]&#x3D;0</p>
<p>当 i&gt;0 且 j&gt;0 时，考虑 dp[i] [j] 的计算：</p>
<ul>
<li>当text1[i-1]!&#x3D;text2[j-1]时，将这两个相同的字符称为公共字符，考虑text1[0:i-1]和text2[0:j-1]的最长公共子序列，再增加一个字符（即公共字符）即可得到text1[0:i]和text2[0:j]的最长公共子序列，因此dp[i] [j]&#x3D;dp[i-1] [j-1]+1</li>
<li>当text1[i-1]!&#x3D;text2[j-1]时，考虑以下两项：<ul>
<li>text1[0:i-1]和text2[0:j]的最长公共子序列</li>
<li>text1[0:i]和text2[0:j-1]的最长公共子系列</li>
</ul>
</li>
</ul>
<p>要得到text1[0:i]和text[o:j]的最长公共子系列，应取两项中的长度较大的一项，因此dp[i] [j]&#x3D;max(dp[i-1],dp[i][j-1])</p>
<p>由此可得到如下状态转移方程：</p>
<p>dp[i] [j]&#x3D;1:dp[i-1] [j-1]+1,text1[i-1]&#x3D;text2[j-1] 2:max(dp[i-1] [j],dp[i] [j-1]),text[i-1]!&#x3D;text[j-1]</p>
<p>最终计算得到db[m] [n] 即为text1和text2的最长公共子系列的长度</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(mn)，其中 m 和 n 分别是字符串 text1和 text 2的长度。二维数组 dp 有m+1 行和 n+1 列，需要对 dp 中的每个元素进行计算</li>
<li>空间复杂度：O(mn)，其中 m 和 n 分别是字符串 text1和 text 2的长度。创建了 m+1 行 n+1 列的二维数组 dp</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonSubsequence</span><span class="params">(text1 <span class="type">string</span>, text2 <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    m, n := <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, c1 := <span class="keyword">range</span> text1 &#123;</span><br><span class="line">        <span class="keyword">for</span> j, c2 := <span class="keyword">range</span> text2 &#123;</span><br><span class="line">            <span class="keyword">if</span> c1 == c2 &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j] + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = max(dp[i][j + <span class="number">1</span>], dp[i + <span class="number">1</span>][j]) </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="21-三数之和（Go）15-中等"><a href="#21-三数之和（Go）15-中等" class="headerlink" title="21. 三数之和（Go）15-中等"></a><font color=DarkOrange>21. 三数之和（Go）15-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <code>a，b，c</code> ，使得 <code>a + b + c = 0</code> ？请你找出所有和为 <code>0</code> 且不重复的三元组。<strong>注意：</strong>答案中不可以包含重复的三元组</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">-1</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">-1</span><span class="punctuation">,</span><span class="number">-4</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="punctuation">[</span><span class="number">-1</span><span class="punctuation">,</span><span class="number">-1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="punctuation">[</span><span class="number">-1</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 3000</code></li>
<li><code>-10的5次方 &lt;= nums[i] &lt;= 10的5次方</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：排序 + 双指针</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(N的2次方)，其中 N 是数组 nums 的长度</li>
<li>空间复杂度：O(logN)。我们忽略存储答案的空间，额外的排序的空间复杂度为 O(logN)。然而我们修改了输入的数组 nums，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了 nums 的副本并进行排序，空间复杂度为 O(N)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    ans := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 枚举a</span></span><br><span class="line">    <span class="keyword">for</span> first := <span class="number">0</span>; first &lt; n; first++ &#123;</span><br><span class="line">        <span class="comment">// 需要和上一次枚举的数不同</span></span><br><span class="line">        <span class="keyword">if</span> first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first <span class="number">-1</span>] &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// c对应的指针初始指向数组的最右端</span></span><br><span class="line">        third := n - <span class="number">1</span></span><br><span class="line">        target := <span class="number">-1</span> * nums[first]</span><br><span class="line">        <span class="comment">// 枚举b</span></span><br><span class="line">        <span class="keyword">for</span> second := first + <span class="number">1</span>; second &lt; n; second++ &#123;</span><br><span class="line">            <span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">            <span class="keyword">if</span> second &gt; first + <span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 需要保证b的指针在c的指针左侧</span></span><br><span class="line">            <span class="keyword">for</span> second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target &#123;</span><br><span class="line">                third --</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果指针重合，随着b后续的增加，就不会有满足a+b+c=0并且b&lt;c的c了，可以退出循环</span></span><br><span class="line">            <span class="keyword">if</span> second == third &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> nums[second] + nums[third] == target &#123;</span><br><span class="line">                ans = <span class="built_in">append</span>(ans, []<span class="type">int</span>&#123;nums[first], nums[second], nums[third]&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="22-寻找两个正序数组的中位数（Go）4-困难"><a href="#22-寻找两个正序数组的中位数（Go）4-困难" class="headerlink" title="22. 寻找两个正序数组的中位数（Go）4-困难"></a><font color=DarkOrange>22. 寻找两个正序数组的中位数（Go）4-困难</font></h4><p><strong>题目：</strong></p>
<p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> </p>
<p>算法的时间复杂度应该为 <code>O(log (m+n))</code> </p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">,</span> nums2 = <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">2.00000</span></span><br><span class="line">解释：合并数组 = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span> ，中位数 <span class="number">2</span></span><br><span class="line">===</span><br><span class="line">输入：nums1 = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> nums2 = <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">2.50000</span></span><br><span class="line">解释：合并数组 = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span> ，中位数 (<span class="number">2</span> + <span class="number">3</span>) / <span class="number">2</span> = <span class="number">2.5</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<p><strong>思路：</strong></p>
<p>方法一：二分查找</p>
<p>给定两个有序数组，要求找到两个有序数组的中位数，最直观的思路有以下两种：</p>
<ul>
<li>使用归并的方式，合并两个有序数组，得到一个大的有序数组。大的有序数组的中间位置的元素，即为中位数</li>
<li>不需要合并两个有序数组，只要找到中位数的位置即可。由于两个数组的长度已知，因此中位数对应的两个数组的下标之和也是已知的。维护两个指针，初始时分别指向两个数组的下标 00 的位置，每次将指向较小值的指针后移一位（如果一个指针已经到达数组末尾，则只需要移动另一个数组的指针），直到到达中位数的位置</li>
</ul>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(log(m+n))，其中 mm 和 nn 分别是数组nums1和 nums2的长度。初始时有 k&#x3D;(m+n)&#x2F;2 或 k&#x3D;(m+n)&#x2F;2+1，每一轮循环可以将查找范围减少一半，因此时间复杂度是 O(log(m+n))</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="type">int</span>, nums2 []<span class="type">int</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">	totalLength := <span class="built_in">len</span>(nums1) + <span class="built_in">len</span>(nums2)</span><br><span class="line">	<span class="keyword">if</span> totalLength%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">		midIndex := totalLength / <span class="number">2</span></span><br><span class="line">		<span class="keyword">return</span> <span class="type">float64</span>(getKthElement(nums1, nums2, midIndex+<span class="number">1</span>))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		midIndex1, midIndex2 := totalLength/<span class="number">2</span><span class="number">-1</span>, totalLength/<span class="number">2</span></span><br><span class="line">		<span class="keyword">return</span> <span class="type">float64</span>(getKthElement(nums1, nums2, midIndex1+<span class="number">1</span>)+getKthElement(nums1, nums2, midIndex2+<span class="number">1</span>)) / <span class="number">2.0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getKthElement</span><span class="params">(nums1, nums2 []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	index1, index2 := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> index1 == <span class="built_in">len</span>(nums1) &#123;</span><br><span class="line">			<span class="keyword">return</span> nums2[index2+k<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> index2 == <span class="built_in">len</span>(nums2) &#123;</span><br><span class="line">			<span class="keyword">return</span> nums1[index1+k<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> k == <span class="number">1</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> min(nums1[index1], nums2[index2])</span><br><span class="line">		&#125;</span><br><span class="line">		half := k / <span class="number">2</span></span><br><span class="line">		newIndex1 := min(index1+half, <span class="built_in">len</span>(nums1)) - <span class="number">1</span></span><br><span class="line">		newIndex2 := min(index2+half, <span class="built_in">len</span>(nums2)) - <span class="number">1</span></span><br><span class="line">		pivot1, pivot2 := nums1[newIndex1], nums2[newIndex2]</span><br><span class="line">		<span class="keyword">if</span> pivot1 &lt;= pivot2 &#123;</span><br><span class="line">			k -= (newIndex1 - index1 + <span class="number">1</span>)</span><br><span class="line">			index1 = newIndex1 + <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			k -= (newIndex2 - index2 + <span class="number">1</span>)</span><br><span class="line">			index2 = newIndex2 + <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>&#125;</span><br><span class="line">	nums2 := []<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;结果为：&quot;</span>, findMedianSortedArrays(nums1, nums2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="23-二叉树的层序遍历（Go）102-中等"><a href="#23-二叉树的层序遍历（Go）102-中等" class="headerlink" title="23. 二叉树的层序遍历（Go）102-中等"></a><font color=DarkOrange>23. 二叉树的层序遍历（Go）102-中等</font></h4><p><strong>题目：</strong></p>
<p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：root = <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">20</span><span class="punctuation">,</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="number">15</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="punctuation">[</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="punctuation">[</span><span class="number">9</span><span class="punctuation">,</span><span class="number">20</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="punctuation">[</span><span class="number">15</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">输入：root = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">输入：root = <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[0, 2000]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：广度优先搜索</p>
<p>思路和算法</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：每个点进队出队各一次，故渐进时间复杂度为 O(n)</li>
<li>空间复杂度：队列中元素的个数不超过 n 个，故渐进空间复杂度为 O(n)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeNode 定义二叉树</span></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Val   <span class="type">int</span></span><br><span class="line">	Left  *TreeNode</span><br><span class="line">	Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateNode 创建二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateNode</span><span class="params">(i <span class="type">int</span>, nums []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">	tree := &amp;TreeNode&#123;nums[i], <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">	<span class="comment">// 左节点的数组下标为1，,3，,5...2*i+1</span></span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(nums) &amp;&amp; <span class="number">2</span>*i+<span class="number">1</span> &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">		tree.Left = CreateNode(<span class="number">2</span>*i+<span class="number">1</span>, nums)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 右节点的数组下标为2,4,6...2*i+2</span></span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(nums) &amp;&amp; <span class="number">2</span>*i+<span class="number">2</span> &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">		tree.Right = CreateNode(<span class="number">2</span>*i+<span class="number">2</span>, nums)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LevelOrder 二叉树层序遍历（广度优先搜索）-中等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LevelOrder</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ret [][]<span class="type">int</span></span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ret</span><br><span class="line">	&#125;</span><br><span class="line">	q := []*TreeNode&#123;root&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; <span class="built_in">len</span>(q) &gt; <span class="number">0</span>; i++ &#123;</span><br><span class="line">		ret = <span class="built_in">append</span>(ret, []<span class="type">int</span>&#123;&#125;)</span><br><span class="line">		<span class="keyword">var</span> p []*TreeNode</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(q); j++ &#123;</span><br><span class="line">			node := q[j]</span><br><span class="line">			ret[i] = <span class="built_in">append</span>(ret[i], node.Val)</span><br><span class="line">			<span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">				p = <span class="built_in">append</span>(p, node.Left)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">				p = <span class="built_in">append</span>(p, node.Right)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		q = p</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PreorderTraversal 二叉树前序遍历（递归）-简单-根节点——左子树——右子树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PreorderTraversal</span><span class="params">(root *TreeNode)</span></span> (vals []<span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> preorder <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span></span><br><span class="line">	preorder = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		vals = <span class="built_in">append</span>(vals, node.Val)</span><br><span class="line">		preorder(node.Left)</span><br><span class="line">		preorder(node.Right)</span><br><span class="line">	&#125;</span><br><span class="line">	preorder(root)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InorderTraversal 二叉树中序遍历（递归）-简单-左子树——根节点——右子树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InorderTraversal</span><span class="params">(root *TreeNode)</span></span> (res []<span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> inorder <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span></span><br><span class="line">	inorder = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		inorder(node.Left)</span><br><span class="line">		res = <span class="built_in">append</span>(res, node.Val)</span><br><span class="line">		inorder(node.Right)</span><br><span class="line">	&#125;</span><br><span class="line">	inorder(root)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PostorderTraversal 二叉树后续遍历（递归）-简单-左子树——右子树——根节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PostorderTraversal</span><span class="params">(root *TreeNode)</span></span> (res []<span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> postorder <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span></span><br><span class="line">	postorder = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		postorder(node.Left)</span><br><span class="line">		postorder(node.Right)</span><br><span class="line">		res = <span class="built_in">append</span>(res, node.Val)</span><br><span class="line">	&#125;</span><br><span class="line">	postorder(root)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 0代表节点为空</span></span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line">	<span class="comment">// 将数组切片转化为二叉树结构体</span></span><br><span class="line">	tree := CreateNode(<span class="number">0</span>, nums)</span><br><span class="line">	levelOrder := LevelOrder(tree)</span><br><span class="line">	fmt.Println(<span class="string">&quot;二叉树层序遍历：&quot;</span>, levelOrder)</span><br><span class="line">	preorderTraversal := PreorderTraversal(tree)</span><br><span class="line">	fmt.Println(<span class="string">&quot;二叉树前序遍历：&quot;</span>, preorderTraversal)</span><br><span class="line">	inorderTraversal := InorderTraversal(tree)</span><br><span class="line">	fmt.Println(<span class="string">&quot;二叉树中序遍历：&quot;</span>, inorderTraversal)</span><br><span class="line">	postorderTraversal := PostorderTraversal(tree)</span><br><span class="line">	fmt.Println(<span class="string">&quot;二叉树后序遍历：&quot;</span>, postorderTraversal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="24-补充题6：手撕堆排序（Go）-912-中等"><a href="#24-补充题6：手撕堆排序（Go）-912-中等" class="headerlink" title="24. 补充题6：手撕堆排序（Go） 912-中等"></a><font color=DarkOrange>24. 补充题6：手撕堆排序（Go） 912-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<p><strong>思路：</strong></p>
<p>算法描述：首先建一个堆，然后调整堆，调整过程是将节点和子节点进行比较，将 其中最大的值变为父节点，递归调整调整次数lgn,最后将根节点和尾节点交换再n次 调整<strong>O(nlgn)</strong></p>
<p>步骤：</p>
<ul>
<li>创建最大堆或者最小堆（我是最小堆）</li>
<li>调整堆</li>
<li>交换首尾节点(为了维持一个完全二叉树才要进行收尾交换)</li>
</ul>
<p><strong>复杂度分析：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapSortMax</span><span class="params">(nums []<span class="type">int</span>, length <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> length &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> nums</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 二叉树深度</span></span><br><span class="line">	depth := length/<span class="number">2</span> - <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := depth; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		<span class="comment">// 假定最大的位置就在i的位置</span></span><br><span class="line">		topmax := i</span><br><span class="line">		leftchild := <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">		rightchild := <span class="number">2</span>*i + <span class="number">2</span></span><br><span class="line">		<span class="comment">// nums[leftchild] &gt; nums[topmax] 防止越界</span></span><br><span class="line">		<span class="keyword">if</span> leftchild &lt;= length<span class="number">-1</span> &amp;&amp; nums[leftchild] &gt; nums[topmax] &#123;</span><br><span class="line">			topmax = leftchild</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// nums[rightchild] &gt; nums[topmax] 防止越界</span></span><br><span class="line">		<span class="keyword">if</span> rightchild &lt;= length<span class="number">-1</span> &amp;&amp; nums[rightchild] &gt; nums[topmax] &#123;</span><br><span class="line">			topmax = rightchild</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> topmax != i &#123;</span><br><span class="line">			nums[i], nums[topmax] = nums[topmax], nums[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	lenght := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; lenght; i++ &#123;</span><br><span class="line">		lastLen := lenght - i</span><br><span class="line">		HeapSortMax(nums, lastLen)</span><br><span class="line">		<span class="keyword">if</span> i &lt; lenght &#123;</span><br><span class="line">			nums[<span class="number">0</span>], nums[lastLen<span class="number">-1</span>] = nums[lastLen<span class="number">-1</span>], nums[<span class="number">0</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">6</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;结果为：&quot;</span>, HeapSort(nums))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="25-相交链表（Go）160-简单"><a href="#25-相交链表（Go）160-简单" class="headerlink" title="25. 相交链表（Go）160-简单"></a><font color=DarkOrange>25. 相交链表（Go）160-简单</font></h4><p><strong>题目：</strong></p>
<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> </p>
<p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p>
<p>题目数据 保证 整个链式结构中不存在环</p>
<p>注意，函数返回结果后，链表必须 保持其原始结构 </p>
<p>自定义评测：</p>
<p>评测系统 的输入如下（你设计的程序 不适用 此输入）：</p>
<ul>
<li>intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0</li>
<li>listA - 第一个链表</li>
<li>listB - 第二个链表</li>
<li>skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数</li>
<li>skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数</li>
</ul>
<p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 </p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = <span class="number">8</span><span class="punctuation">,</span> listA = <span class="punctuation">[</span><span class="number">4</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span><span class="punctuation">,</span> listB = <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span><span class="punctuation">,</span> skipA = <span class="number">2</span><span class="punctuation">,</span> skipB = <span class="number">3</span></span><br><span class="line">输出：Intersected at &#x27;<span class="number">8</span>&#x27;</span><br><span class="line">解释：相交节点的值为 <span class="number">8</span> （注意，如果两个链表相交则不能为 <span class="number">0</span>）</span><br><span class="line">从各自的表头开始算起，链表 A 为 <span class="punctuation">[</span><span class="number">4</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span>，链表 B 为 <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span></span><br><span class="line">在 A 中，相交节点前有 <span class="number">2</span> 个节点；在 B 中，相交节点前有 <span class="number">3</span> 个节点</span><br><span class="line">输入：intersectVal = <span class="number">2</span><span class="punctuation">,</span> listA = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">,</span> listB = <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">,</span> skipA = <span class="number">3</span><span class="punctuation">,</span> skipB = <span class="number">1</span></span><br><span class="line">输出：Intersected at &#x27;<span class="number">2</span>&#x27;</span><br><span class="line">解释：相交节点的值为 <span class="number">2</span> （注意，如果两个链表相交则不能为 <span class="number">0</span>）</span><br><span class="line">从各自的表头开始算起，链表 A 为 <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span>，链表 B 为 <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span></span><br><span class="line">在 A 中，相交节点前有 <span class="number">3</span> 个节点；在 B 中，相交节点前有 <span class="number">1</span> 个节点。</span><br><span class="line">输入：intersectVal = <span class="number">0</span><span class="punctuation">,</span> listA = <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">,</span> listB = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span><span class="punctuation">,</span> skipA = <span class="number">3</span><span class="punctuation">,</span> skipB = <span class="number">2</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">null</span></span></span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span>，链表 B 为 <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span></span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 <span class="number">0</span>，而 skipA 和 skipB 可以是任意值</span><br><span class="line">这两个链表不相交，因此返回 <span class="literal"><span class="keyword">null</span></span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<p><strong>思路：</strong></p>
<p>方法一：哈希集合<br>思路和算法</p>
<p>判断两个链表是否相交，可以使用哈希集合存储链表节点</p>
<p>首先遍历链表 headA，并将链表 headA 中的每个节点加入哈希集合中。然后遍历链表 headB，对于遍历到的每个节点，判断该节点是否在哈希集合中：</p>
<ul>
<li>如果当前节点不在哈希集合中，则继续遍历下一个节点</li>
<li>如果当前节点在哈希集合中，则后面的节点都在哈希集合中，即从当前节点开始的所有节点都在两个链表的相交部分，因此在链表 headB 中遍历到的第一个在哈希集合中的节点就是两个链表相交的节点，返回该节点</li>
</ul>
<p>如果链表 headB 中的所有节点都不在哈希集合中，则两个链表不相交，返回 null</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(m+n)，其中 m 和 n 是分别是链表 headA 和 headB 的长度。需要遍历两个链表各一次</li>
<li>空间复杂度：O(m)，其中 m 是链表 headA 的长度。需要使用哈希集合存储链表 headA 中的全部节点</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    vis := <span class="keyword">map</span>[*ListNode]<span class="type">bool</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> tmp := headA; tmp != <span class="literal">nil</span>; tmp = tmp.Next &#123;</span><br><span class="line">        vis[tmp] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> tmp := headB; tmp != <span class="literal">nil</span>; tmp = tmp.Next &#123;</span><br><span class="line">        <span class="keyword">if</span> vis[tmp] &#123;</span><br><span class="line">            <span class="keyword">return</span> tmp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="26-二叉搜索树的第K大节点（Go）-剑指offer54-简单"><a href="#26-二叉搜索树的第K大节点（Go）-剑指offer54-简单" class="headerlink" title="26. 二叉搜索树的第K大节点（Go） 剑指offer54-简单"></a><font color=DarkOrange>26. 二叉搜索树的第K大节点（Go） 剑指offer54-简单</font></h4><p><strong>题目：</strong></p>
<p>给定一棵二叉搜索树，请找出其中第 <code>k</code> 大的节点的值</p>
<p><strong>示例：</strong></p>
<p><strong>提示：</strong></p>
<p><strong>思路：</strong></p>
<ol>
<li>通过二叉树的中序遍历便是一个从小到大的排序</li>
<li>设置一个count，每遍历一个数据便自增1，当count&#x3D;k时，就找到了正确答案</li>
</ol>
<p><strong>复杂度分析：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 思路：返回中序遍历生成的序列中的第k个节点</span></span><br><span class="line"><span class="comment">// 此题最好只实现：InorderTraverse和KthLargest</span></span><br><span class="line"><span class="comment">// 在Goland IDE里实现全部貌似结果不正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Val   <span class="type">int</span></span><br><span class="line">	Left  *TreeNode</span><br><span class="line">	Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateNode 创建二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateNode</span><span class="params">(i <span class="type">int</span>, nums []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">	tree := &amp;TreeNode&#123;nums[i], <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">	<span class="comment">// 左节点的数组下标为1,3,5...2*i+1</span></span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(nums) &amp;&amp; <span class="number">2</span>*i+<span class="number">1</span> &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">		tree.Left = CreateNode(<span class="number">2</span>*i+<span class="number">1</span>, nums)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 右节点的数组下标为2,4,6...2*i+2</span></span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(nums) &amp;&amp; <span class="number">2</span>*i+<span class="number">2</span> &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">		tree.Right = CreateNode(<span class="number">2</span>*i+<span class="number">2</span>, nums)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InorderTraverse</span><span class="params">(root *TreeNode, ret *[]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	InorderTraverse(root.Left, ret)</span><br><span class="line">	*ret = <span class="built_in">append</span>(*ret, root.Val)</span><br><span class="line">	InorderTraverse(root.Right, ret)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">KthLargest</span><span class="params">(root *TreeNode, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	ret := &amp;[]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	InorderTraverse(root, ret)</span><br><span class="line">	<span class="comment">// 说明没找到第k大节点</span></span><br><span class="line">	<span class="keyword">if</span> k &lt; <span class="number">1</span> &amp;&amp; k &gt; <span class="built_in">len</span>(*ret) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (*ret)[<span class="built_in">len</span>(*ret)-k]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	<span class="comment">// 0代表节点为空</span></span><br><span class="line">	treeNode := CreateNode(<span class="number">0</span>, nums)</span><br><span class="line">	fmt.Println(<span class="string">&quot;结果为：&quot;</span>, KthLargest(treeNode, <span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="27-LFU缓存（Go）-460-困难"><a href="#27-LFU缓存（Go）-460-困难" class="headerlink" title="27. LFU缓存（Go） 460-困难"></a><font color=DarkOrange>27. LFU缓存（Go） 460-困难</font></h4><p><strong>题目：</strong></p>
<p>请你为 最不经常使用（LFU）缓存算法设计并实现数据结构</p>
<p><strong>示例：</strong></p>
<p><strong>提示：</strong></p>
<p><strong>思路：</strong></p>
<p>方法二：双哈希表</p>
<p><strong>复杂度分析：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">	Key   <span class="type">int</span></span><br><span class="line">	Value <span class="type">int</span></span><br><span class="line">	freq  <span class="type">int</span></span><br><span class="line">	pre   *Node</span><br><span class="line">	next  *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LFUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">	limit   <span class="type">int</span></span><br><span class="line">	HashMap <span class="keyword">map</span>[<span class="type">int</span>]*Node</span><br><span class="line">	head    *Node</span><br><span class="line">	end     *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LFUConstructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LFUCache &#123;</span><br><span class="line">	lfuCache := LFUCache&#123;&#125;</span><br><span class="line">	lfuCache.limit = capacity</span><br><span class="line">	lfuCache.HashMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*Node, capacity)</span><br><span class="line">	<span class="keyword">return</span> lfuCache</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lfuCache *LFUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> value, ok := lfuCache.HashMap[key]; ok &#123;</span><br><span class="line">		value.freq++</span><br><span class="line">		lfuCache.refreshNode(value)</span><br><span class="line">		<span class="keyword">return</span> value.Value</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lfuCache *LFUCache)</span></span> Put(key, value <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> v, ok := lfuCache.HashMap[key]; !ok &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(lfuCache.HashMap) &gt;= lfuCache.limit &#123;</span><br><span class="line">			oldKey := lfuCache.removeNode(lfuCache.head)</span><br><span class="line">			<span class="built_in">delete</span>(lfuCache.HashMap, oldKey)</span><br><span class="line">		&#125;</span><br><span class="line">		node := Node&#123;Key: key, Value: value, freq: <span class="number">1</span>&#125;</span><br><span class="line">		lfuCache.addNode(&amp;node)</span><br><span class="line">		lfuCache.HashMap[key] = &amp;node</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		v.Value = value</span><br><span class="line">		v.freq++</span><br><span class="line">		lfuCache.refreshNode(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lfuCache *LFUCache)</span></span> refreshNode(node *Node) &#123;</span><br><span class="line">	<span class="keyword">if</span> node == lfuCache.end &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	lfuCache.removeNode(node)</span><br><span class="line">	lfuCache.addNode(node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lfuCache *LFUCache)</span></span> removeNode(node *Node) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> node == lfuCache.end &#123;</span><br><span class="line">		lfuCache.end = lfuCache.end.pre</span><br><span class="line">		lfuCache.end.next = <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> node == lfuCache.head &#123;</span><br><span class="line">		lfuCache.head = lfuCache.head.next</span><br><span class="line">		lfuCache.head.pre = <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		node.pre.next = node.next</span><br><span class="line">		node.next.pre = node.pre</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> node.Key</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lfuCache *LFUCache)</span></span> addNode(node *Node) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> lfuCache.head == <span class="literal">nil</span> &amp;&amp; lfuCache.end == <span class="literal">nil</span> &#123;</span><br><span class="line">		lfuCache.head = node</span><br><span class="line">		lfuCache.end = node</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	head := lfuCache.head</span><br><span class="line">	<span class="keyword">for</span> head != <span class="literal">nil</span> &amp;&amp; node.freq &gt;= head.freq &#123;</span><br><span class="line">		head = head.next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">		lfuCache.end.next = node</span><br><span class="line">		node.pre = lfuCache.end</span><br><span class="line">		lfuCache.end = node</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">		head.pre.next = node</span><br><span class="line">		node.pre = head.pre</span><br><span class="line">		head.pre = node</span><br><span class="line">		node.next = head</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lfuCache.head.pre = <span class="literal">nil</span></span><br><span class="line">	lfuCache.end.next = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	lfuCache := LFUConstructor(<span class="number">3</span>)</span><br><span class="line">	lfuCache.Put(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">	lfuCache.Put(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">	lfuCache.Put(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">	fmt.Println(lfuCache) <span class="comment">// 此时的链表顺序应该是 1 : 3   2 : 4   3 : 5   lfuCache.head 为1 : 3   lfuCache.end 为3 : 5</span></span><br><span class="line">	lfuCache.Get(<span class="number">1</span>)</span><br><span class="line">	fmt.Println(lfuCache) <span class="comment">// 此时的链表顺序应该是  2 : 4   3 : 5  1 : 3   lfuCache.head 为2 : 4    lfuCache.end 为1 : 3</span></span><br><span class="line">	lfuCache.Put(<span class="number">4</span>, <span class="number">6</span>)</span><br><span class="line">	fmt.Println(lfuCache) <span class="comment">// 此时的链表顺序应该是  3 : 5  4 : 6   1 : 3    lfuCache.head 为3 : 5   lfuCache.end 为1 : 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="28-K个一组翻转链表（Go）25-困难"><a href="#28-K个一组翻转链表（Go）25-困难" class="headerlink" title="28. K个一组翻转链表（Go）25-困难"></a><font color=DarkOrange>28. K个一组翻转链表（Go）25-困难</font></h4><p><strong>题目：</strong></p>
<p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。<code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换</p>
<p><strong>示例：</strong></p>
<p><strong>提示：</strong></p>
<p><strong>思路：</strong></p>
<p><strong>复杂度分析：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Value <span class="type">int</span></span><br><span class="line">	Next  *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseKGroup</span><span class="params">(head *ListNode, k <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">	dummyNode := &amp;ListNode&#123;Next: head&#125;</span><br><span class="line">	pre := dummyNode</span><br><span class="line">	<span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">		tail := pre</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">			tail = tail.Next</span><br><span class="line">			<span class="keyword">if</span> tail == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> dummyNode.Next</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//记录tail后一个节点，以及pre后一个节点</span></span><br><span class="line">		nextGroupHead := tail.Next</span><br><span class="line">		head = pre.Next</span><br><span class="line">		<span class="comment">//反转</span></span><br><span class="line">		ReverseList(head, tail)</span><br><span class="line">		<span class="comment">//拼接</span></span><br><span class="line">		pre.Next = tail</span><br><span class="line">		head.Next = nextGroupHead</span><br><span class="line">		<span class="comment">//更新pre和head</span></span><br><span class="line">		pre = head</span><br><span class="line">		head = nextGroupHead</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dummyNode.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReverseList 翻转链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReverseList</span><span class="params">(head *ListNode, tail *ListNode)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> pre *ListNode</span><br><span class="line">	cur := head</span><br><span class="line">	<span class="keyword">for</span> pre != tail &#123;</span><br><span class="line">		next := cur.Next</span><br><span class="line">		cur.Next = pre</span><br><span class="line">		pre = cur</span><br><span class="line">		cur = next</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="29-买卖股票的最佳时机（Go）121-简单"><a href="#29-买卖股票的最佳时机（Go）121-简单" class="headerlink" title="29. 买卖股票的最佳时机（Go）121-简单"></a><font color=DarkOrange>29. 买卖股票的最佳时机（Go）121-简单</font></h4><p><strong>题目：</strong></p>
<p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 </p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="punctuation">[</span><span class="number">7</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出，最大利润 = <span class="number">6</span><span class="number">-1</span> = <span class="number">5</span></span><br><span class="line">     注意利润不能是 <span class="number">7</span><span class="number">-1</span> = <span class="number">6</span><span class="punctuation">,</span> 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票</span><br><span class="line">输入：prices = <span class="punctuation">[</span><span class="number">7</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：在这种情况下<span class="punctuation">,</span> 没有交易完成<span class="punctuation">,</span> 所以最大利润为 <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 10的5次方</code></li>
<li><code>0 &lt;= prices[i] &lt;= 10的4次方</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法二：一次遍历（贪心算法）</p>
<p>算法</p>
<p>假设给定的数组为：<code>[7, 1, 5, 3, 6, 4]</code></p>
<p>如果我们在图表上绘制给定数组中的数字，我们将会得到：</p>
<p>我们来假设自己来购买股票。随着时间的推移，每天我们都可以选择出售股票与否。那么，假设在第 i 天，如果我们要在今天卖股票，那么我们能赚多少钱呢</p>
<p>显然，如果我们真的在买卖股票，我们肯定会想：如果我是在历史最低点买的股票就好了！太好了，在题目中，我们只要用一个变量记录一个历史最低价格 minprice，我们就可以假设自己的股票是在那天买的。那么我们在第 i 天卖出股票能得到的利润就是 prices[i] - minprice</p>
<p>因此，我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)，只需要遍历一次</li>
<li>空间复杂度：O(1)，只使用了常数个变量</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MaxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 贪心</span></span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	m := prices[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> prices[i] &gt; m &#123;</span><br><span class="line">			<span class="keyword">if</span> (prices[i] - m) &gt; res &#123;</span><br><span class="line">				res = prices[i] - m</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			m = prices[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;结果为：&quot;</span>, MaxProfit(nums))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="30-基本计算器2（Go）227-中等"><a href="#30-基本计算器2（Go）227-中等" class="headerlink" title="30. 基本计算器2（Go）227-中等"></a><font color=DarkOrange>30. 基本计算器2（Go）227-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值</p>
<p>整数除法仅保留整数部分</p>
<p>你可以假设给定的表达式总是有效的。所有中间结果将在 <code>[-2^31, 2^31 - 1]</code> 的范围内</p>
<p>注意：不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval()</code> </p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;3+2*2&quot;</span></span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">输入：s = <span class="string">&quot; 3/2 &quot;</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">输入：s = <span class="string">&quot; 3+5 / 2 &quot;</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; s.length &lt;&#x3D; 3 * 10^5</li>
<li>s 由整数和算符 (‘+’, ‘-‘, ‘*’, ‘&#x2F;‘) 组成，中间由一些空格隔开</li>
<li>s 表示一个 有效表达式</li>
<li>表达式中的所有整数都是非负整数，且在范围 [0, 2^31 - 1] 内</li>
<li>题目数据保证答案是一个 32-bit 整数</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：栈<br>思路</p>
<p>由于乘除优先于加减计算，因此不妨考虑先进行所有乘除运算，并将这些乘除运算后的整数值放回原表达式的相应位置，则随后整个表达式的值，就等于一系列整数加减后的值</p>
<p>基于此，我们可以用一个栈，保存这些（进行乘除运算后的）整数的值。对于加减号后的数字，将其直接压入栈中；对于乘除号后的数字，可以直接与栈顶元素计算，并替换栈顶元素为计算后的结果</p>
<p>具体来说，遍历字符串 s，并用变量 preSign 记录每个数字之前的运算符，对于第一个数字，其之前的运算符视为加号。每次遍历到数字末尾时，根据 preSign 来决定计算方式：</p>
<ul>
<li>加号：将数字压入栈</li>
<li>减号：将数字的相反数压入栈</li>
<li>乘除号：计算数字与栈顶元素，并将栈顶元素替换为计算结果</li>
</ul>
<p>代码实现中，若读到一个运算符，或者遍历到字符串末尾，即认为是遍历到了数字末尾。处理完该数字后，更新 preSign 为当前遍历的字符</p>
<p>遍历完字符串 s 后，将栈中元素累加，即为该字符串表达式的值</p>
<p><strong>复杂度分析：</strong></p>
<p>时间复杂度：O(n)，其中 n 为字符串 s 的长度。需要遍历字符串 s 一次，计算表达式的值</p>
<p>空间复杂度：O(n)，其中 n 为字符串 s 的长度。空间复杂度主要取决于栈的空间，栈的元素个数不超过 n</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculate</span><span class="params">(s <span class="type">string</span>)</span></span> (ans <span class="type">int</span>) &#123;</span><br><span class="line">    stack := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    preSign := <span class="string">&#x27;+&#x27;</span></span><br><span class="line">    num := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, ch := <span class="keyword">range</span> s &#123;</span><br><span class="line">        isDigit := <span class="string">&#x27;0&#x27;</span> &lt; ch &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> isDigit &#123;</span><br><span class="line">            num = num * <span class="number">10</span> + <span class="type">int</span>(ch - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !isDigit &amp;&amp; ch != <span class="string">&#x27; &#x27;</span> || i == <span class="built_in">len</span>(s) - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> preSign &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, num)</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, -num)</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>] *= num</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>] /= num</span><br><span class="line">            &#125;</span><br><span class="line">            preSign = ch</span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> stack &#123;</span><br><span class="line">        ans += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="31-数组中重复的数据（Go）442-中等"><a href="#31-数组中重复的数据（Go）442-中等" class="headerlink" title="31. 数组中重复的数据（Go）442-中等"></a><font color=DarkOrange>31. 数组中重复的数据（Go）442-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，其中 <code>nums</code> 的所有整数都在范围 <code>[1, n]</code> 内，且每个整数出现 一次 或 两次 。请你找出所有出现 两次 的整数，并以数组形式返回</p>
<p>你必须设计并实现一个时间复杂度为 <code>O(n)</code> 且仅使用常量额外空间的算法解决此问题</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">4</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= n</code></li>
<li><code>nums</code> 中的每个元素出现 <strong>一次</strong> 或 <strong>两次</strong></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：将元素交换到对应的位置<br>思路与算法</p>
<p>由于给定的 n 个数都在 [1,n] 的范围内，如果有数字出现了两次，就意味着 [1,n] 中有数字没有出现过</p>
<p>因此，我们可以尝试将每一个数放在对应的位置。由于数组的下标范围是 [0,n−1]，我们需要将数 i 放在数组中下标为 i−1 的位置：</p>
<ul>
<li>如果 i 恰好出现了一次，那么将 i 放在数组中下标为 i−1 的位置即可</li>
<li>如果 i 出现了两次，那么我们希望其中的一个 i 放在数组下标中为 i−1 的位置，另一个 i 放置在任意「不冲突」的位置 j。也就是说，数 j+1 没有在数组中出现过</li>
</ul>
<p>这样一来，如果我们按照上述的规则放置每一个数，那么我们只需要对数组进行一次遍历。当遍历到位置 i 时，如果 nums[i]−1!&#x3D;i，说明 nums[i] 出现了两次（另一次出现在位置 num[i]−1），我们就可以将 num[i] 放入答案</p>
<p>放置的方法也很直观：我们对数组进行一次遍历。当遍历到位置 i 时，我们知道 nums[i] 应该被放在位置 nums[i]−1。因此我们交换 num[i] 和 nums[nums[i]−1] 即可，直到待交换的两个元素相等为止</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li><p>时间复杂度：O(n)。每一次交换操作会使得至少一个元素被交换到对应的正确位置，因此交换的次数为 O(n)，总时间复杂度为 O(n)</p>
</li>
<li><p>空间复杂度：O(1)。返回值不计入空间复杂度</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDuplicates</span><span class="params">(nums []<span class="type">int</span>)</span></span> (ans []<span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">for</span> nums[i] != nums[nums[i] - <span class="number">1</span>] &#123;</span><br><span class="line">            nums[i], nums[nums[i] - <span class="number">1</span>] = nums[nums[i] - <span class="number">1</span>], nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num - <span class="number">1</span> != i &#123;</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, num)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="32-零钱兑换（Go）-332-中等"><a href="#32-零钱兑换（Go）-332-中等" class="headerlink" title="32. 零钱兑换（Go） 332-中等"></a><font color=DarkOrange>32. 零钱兑换（Go） 332-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。你可以认为每种硬币的数量是无限的</p>
<p><strong>示例：</strong></p>
<p><strong>提示：</strong></p>
<p><strong>思路：</strong></p>
<p>动态规划</p>
<p><strong>复杂度分析：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CoinChange</span><span class="params">(coins []<span class="type">int</span>, amount <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">	<span class="comment">// 初始化线性备忘录</span></span><br><span class="line">	<span class="keyword">for</span> k := <span class="keyword">range</span> dp &#123;</span><br><span class="line">		<span class="comment">// 相当于无限大，方便比较</span></span><br><span class="line">		dp[k] = amount + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 这个就是占位的</span></span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(dp); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> _, coin := <span class="keyword">range</span> coins &#123;</span><br><span class="line">			<span class="comment">// 至少包含 1 枚某种硬币</span></span><br><span class="line">			<span class="keyword">if</span> i-coin &lt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span> <span class="comment">// 这种情况别闹</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 选择一个较小的</span></span><br><span class="line">			dp[i] = min(dp[i], <span class="number">1</span>+dp[i-coin])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> dp[amount] == amount+<span class="number">1</span> &#123;</span><br><span class="line">		<span class="comment">// 没有合适的</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;结果为：&quot;</span>, CoinChange(nums, <span class="number">11</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="33-两数相加（Go）2-中等"><a href="#33-两数相加（Go）2-中等" class="headerlink" title="33. 两数相加（Go）2-中等"></a><font color=DarkOrange>33. 两数相加（Go）2-中等</font></h4><p><strong>题目：</strong></p>
<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">,</span> l2 = <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">7</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">]</span></span><br><span class="line">解释：<span class="number">342</span> + <span class="number">465</span> = <span class="number">807.</span></span><br><span class="line">输入：l1 = <span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span><span class="punctuation">,</span> l2 = <span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span></span><br><span class="line">输入：l1 = <span class="punctuation">[</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">]</span><span class="punctuation">,</span> l2 = <span class="punctuation">[</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">8</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
<li>题目数据保证列表表示的数字不含前导零</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：模拟<br>思路与算法</p>
<p>由于输入的两个链表都是逆序存储数字的位数的，因此两个链表中同一位置的数字可以直接相加</p>
<p>我们同时遍历两个链表，逐位计算它们的和，并与当前位置的进位值相加。具体而言，如果当前两个链表处相应位置的数字为 n1,n2，进位值为 carry，则它们的和为 n1+n2+carry；其中，答案链表处相应位置的数字为 (n1+n2+carry)mod10，而新的进位值为 ⌊<br>n1+n2+carry除以10⌋</p>
<p>如果两个链表的长度不同，则可以认为长度短的链表的后面有若干个 0 </p>
<p>此外，如果链表遍历结束后，有 carry&gt;0，还需要在答案链表的后面附加一个节点，节点的值为 carry</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(max(m,n))，其中 m 和 n 分别为两个链表的长度。我们要遍历两个链表的全部位置，而处理每个位置只需要 O(1) 的时间</li>
<li>空间复杂度：O(1)。注意返回值不计入空间复杂度</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span></span> (head *ListNode) &#123;</span><br><span class="line">    <span class="keyword">var</span> tail *ListNode</span><br><span class="line">    carry := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> l1 != <span class="literal">nil</span> || l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        n1, n2 := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            n1 = l1.Val</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            n2 = l2.Val</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        sum := n1 + n2 +carry</span><br><span class="line">        sum, carry = sum % <span class="number">10</span>, sum / <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">            head = &amp;ListNode&#123;Val: sum&#125;</span><br><span class="line">            tail = head</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail.Next = &amp;ListNode&#123;Val: sum&#125;</span><br><span class="line">            tail = tail.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> carry &gt; <span class="number">0</span> &#123;</span><br><span class="line">        tail.Next = &amp;ListNode&#123;Val: carry&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="34-链表中倒数第K个节点（Go）剑指offer22-简单"><a href="#34-链表中倒数第K个节点（Go）剑指offer22-简单" class="headerlink" title="34. 链表中倒数第K个节点（Go）剑指offer22-简单"></a><font color=DarkOrange>34. 链表中倒数第K个节点（Go）剑指offer22-简单</font></h4><p><strong>题目：</strong></p>
<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点</p>
<p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 <code>1、2、3、4、5、6</code>。这个链表的倒数第 3 个节点是值为 4 的节点</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表<span class="punctuation">:</span> <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span><span class="punctuation">,</span> 和 k = <span class="number">2.</span></span><br><span class="line">返回链表 <span class="number">4</span>-&gt;<span class="number">5.</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<p><strong>思路：</strong></p>
<p>方法一：顺序查找<br>思路与算法</p>
<p>最简单直接的方法即为顺序查找，假设当前链表的长度为 n，则我们知道链表的倒数第 k 个节点即为正数第 n−k 个节点，此时我们只需要顺序遍历到链表的第 n−k 个节点即为倒数第 k 个节点</p>
<p>我们首先求出链表的长度 n，然后顺序遍历到链表的第 n−k 个节点返回即可</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 为链表的长度。需要两次遍历</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getKthFromEnd</span><span class="params">(head *ListNode, k <span class="type">int</span>)</span></span> (kth *ListNode) &#123;</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> node := head; node != <span class="literal">nil</span>; node = node.Next &#123;</span><br><span class="line">        n++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> kth = head; n &gt; k; n-- &#123;</span><br><span class="line">        kth = kth.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="35-路径总和（Go）112-简单"><a href="#35-路径总和（Go）112-简单" class="headerlink" title="35. 路径总和（Go）112-简单"></a><font color=DarkOrange>35. 路径总和（Go）112-简单</font></h4><p><strong>题目：</strong></p>
<p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> </p>
<p>叶子节点 是指没有子节点的节点</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：root = <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">,</span><span class="number">11</span><span class="punctuation">,</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="number">13</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> targetSum = <span class="number">22</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">true</span></span></span><br><span class="line">解释：等于目标和的根节点到叶节点路径如上图所示</span><br><span class="line">输入：root = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">,</span> targetSum = <span class="number">5</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">false</span></span></span><br><span class="line">解释：树中存在两条根节点到叶子节点的路径：</span><br><span class="line">(<span class="number">1</span> --&gt; <span class="number">2</span>)<span class="punctuation">:</span> 和为 <span class="number">3</span></span><br><span class="line">(<span class="number">1</span> --&gt; <span class="number">3</span>)<span class="punctuation">:</span> 和为 <span class="number">4</span></span><br><span class="line">不存在 sum = <span class="number">5</span> 的根节点到叶子节点的路径</span><br><span class="line">输入：root = <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> targetSum = <span class="number">0</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">false</span></span></span><br><span class="line">解释：由于树是空的，所以不存在根节点到叶子节点的路径</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目在范围 <code>[0, 5000]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：广度优先搜索<br>思路及算法</p>
<p>首先我们可以想到使用广度优先搜索的方式，记录从根节点到当前节点的路径和，以防止重复计算</p>
<p>这样我们使用两个队列，分别存储将要遍历的节点，以及根节点到这些节点的路径和即可</p>
<p><strong>复杂度分析：</strong></p>
<p>时间复杂度：O(N)，其中 N 是树的节点数。对每个节点访问一次</p>
<p>空间复杂度：O(N)，其中 N 是树的节点数。空间复杂度主要取决于队列的开销，队列中的元素个数不会超过树的节点数</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasPathSum</span><span class="params">(root *TreeNode, targetSum <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    queNode := []*TreeNode&#123;&#125;</span><br><span class="line">    queVal := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    queNode = <span class="built_in">append</span>(queNode, root)</span><br><span class="line">    queVal = <span class="built_in">append</span>(queVal, root.Val)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queNode) != <span class="number">0</span> &#123;</span><br><span class="line">        now := queNode[<span class="number">0</span>]</span><br><span class="line">        queNode = queNode[<span class="number">1</span>:]</span><br><span class="line">        temp := queVal[<span class="number">0</span>]</span><br><span class="line">        queVal = queVal[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">if</span> now.Left == <span class="literal">nil</span> &amp;&amp; now.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> temp == targetSum &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> now.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">            queNode = <span class="built_in">append</span>(queNode, now.Left)</span><br><span class="line">            queVal = <span class="built_in">append</span>(queVal, now.Left.Val + temp)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> now.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">            queNode = <span class="built_in">append</span>(queNode, now.Right)</span><br><span class="line">            queVal = <span class="built_in">append</span>(queVal, now.Right.Val + temp)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="36-字符串相乘（Go）43-中等"><a href="#36-字符串相乘（Go）43-中等" class="headerlink" title="36. 字符串相乘（Go）43-中等"></a><font color=DarkOrange>36. 字符串相乘（Go）43-中等</font></h4><p><strong>题目：</strong></p>
<p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式</p>
<p>注意：不能使用任何内置的 <code>BigInteger</code> 库或直接将输入转换为整数</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入<span class="punctuation">:</span> num1 = <span class="string">&quot;2&quot;</span><span class="punctuation">,</span> num2 = <span class="string">&quot;3&quot;</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="string">&quot;6&quot;</span></span><br><span class="line">输入<span class="punctuation">:</span> num1 = <span class="string">&quot;123&quot;</span><span class="punctuation">,</span> num2 = <span class="string">&quot;456&quot;</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="string">&quot;56088&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; num1.length, num2.length &lt;&#x3D; 200</li>
<li>num1 和 num2 只能由数字组成</li>
<li>num1 和 num2 都不包含任何前导零，除了数字0本身</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：做加法<br>如果 num1和 num2之一是 0，则直接将 0 作为结果返回即可</p>
<p>如果 num1和 num2都不是 0，则可以通过模拟「竖式乘法」的方法计算乘积。从右往左遍历乘数，将乘数的每一位与被乘数相乘得到对应的结果，再将每次得到的结果累加。这道题中，被乘数是 num1，乘数是 num2</p>
<p>需要注意的是，num2除了最低位以外，其余的每一位的运算结果都需要补 0</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(mn+n^2)，其中 m 和 n 分别是 num1和 num2的长度。需要从右往左遍历 num2，对于 num2 的每一位，都需要和 num1的每一位计算乘积，因此计算乘积的总次数是 mn。字符串相加操作共有 n 次，相加的字符串长度最长为 m+n，因此字符串相加的时间复杂度是 O(mn+n^2)。总时间复杂度是 O(mn+n^2)</li>
<li>空间复杂度：O(m+n)，其中 m 和 n 分别是 num1和 num2的长度。空间复杂度取决于存储中间状态的字符串，由于乘积的最大长度为 m+n，因此存储中间状态的字符串的长度不会超过 m+n</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiply</span><span class="params">(num1 <span class="type">string</span>, num2 <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> num1 == <span class="string">&quot;0&quot;</span> || num2 == <span class="string">&quot;0&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="string">&quot;0&quot;</span></span><br><span class="line">    m, n := <span class="built_in">len</span>(num1), <span class="built_in">len</span>(num2)</span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        curr := <span class="string">&quot;&quot;</span></span><br><span class="line">        add := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j := n - <span class="number">1</span>; j &gt; i; j-- &#123;</span><br><span class="line">            curr += <span class="string">&quot;0&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        y := <span class="type">int</span>(num2[i] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> j := m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j-- &#123;</span><br><span class="line">            x := <span class="type">int</span>(num1[j] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            product := x * y + add</span><br><span class="line">            curr = strconv.Itoa(product % <span class="number">10</span>) + curr</span><br><span class="line">            add = product / <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ; add != <span class="number">0</span>; add /= <span class="number">10</span> &#123;</span><br><span class="line">            curr = strconv.Itoa(add % <span class="number">10</span>) + curr</span><br><span class="line">        &#125;</span><br><span class="line">        ans = addStrings(ans, curr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addStrings</span><span class="params">(num1, num2 <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    i, j := <span class="built_in">len</span>(num1) - <span class="number">1</span>, <span class="built_in">len</span>(num2) - <span class="number">1</span></span><br><span class="line">    add := <span class="number">0</span></span><br><span class="line">    ans := <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> ; i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>; i, j = i - <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">        x, y := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> x &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            x = <span class="type">int</span>(num1[i] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> j &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            y = <span class="type">int</span>(num2[j] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        result := x + y + add</span><br><span class="line">        ans = strconv.Itoa(result % <span class="number">10</span>) + ans</span><br><span class="line">        add = result / <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="37-用栈实现队列（Go）-232-简单"><a href="#37-用栈实现队列（Go）-232-简单" class="headerlink" title="37. 用栈实现队列（Go） 232-简单"></a><font color=DarkOrange>37. 用栈实现队列（Go） 232-简单</font></h4><p><strong>题目：</strong></p>
<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p>
<p>实现 <code>MyQueue</code> 类：</p>
<ul>
<li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li>
<li><code>int pop()</code> 从队列的开头移除并返回元素</li>
<li><code>int peek()</code> 返回队列开头的元素</li>
<li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li>
</ul>
<p>说明：</p>
<ul>
<li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="punctuation">[</span><span class="string">&quot;MyQueue&quot;</span><span class="punctuation">,</span> <span class="string">&quot;push&quot;</span><span class="punctuation">,</span> <span class="string">&quot;push&quot;</span><span class="punctuation">,</span> <span class="string">&quot;peek&quot;</span><span class="punctuation">,</span> <span class="string">&quot;pop&quot;</span><span class="punctuation">,</span> <span class="string">&quot;empty&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">输出：</span><br><span class="line"><span class="punctuation">[</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyQueue myQueue = new MyQueue();</span><br><span class="line">myQueue.push(<span class="number">1</span>); <span class="comment">// queue is: [1]</span></span><br><span class="line">myQueue.push(<span class="number">2</span>); <span class="comment">// queue is: [1, 2] (leftmost is front of the queue)</span></span><br><span class="line">myQueue.peek(); <span class="comment">// return 1</span></span><br><span class="line">myQueue.pop(); <span class="comment">// return 1, queue is [2]</span></span><br><span class="line">myQueue.empty(); <span class="comment">// return false</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= x &lt;= 9</code></li>
<li>最多调用 <code>100</code> 次 <code>push</code>、<code>pop</code>、pe<code>ek</code> 和 <code>empty</code></li>
<li>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li>
</ul>
<p><strong>思路：</strong></p>
<p>队列是一种 先进先出（first in - first out， FIFO）的数据结构，队列中的元素都从后端（rear）入队（push），从前端（front）出队（pop）<br>实现队列最直观的方法是用链表，但在这篇文章里我会介绍另一个方法 - 使用栈</p>
<p>栈是一种 后进先出（last in - first out， LIFO）的数据结构，栈中元素从栈顶（top）压入（push)，也从栈顶弹出（pop）</p>
<p>为了满足队列的 FIFO 的特性，我们需要用到两个栈，用它们其中一个来反转元素的入队顺序，用另一个来存储元素的最终顺序</p>
<p>方法一（使用两个栈 入队 - O(n)， 出队 - O(1)）</p>
<p>算法</p>
<p><strong>一. 入队（push）</strong></p>
<p>一个队列是 FIFO 的，但一个栈是 LIFO 的。这就意味着最新压入的元素必须得放在栈底。为了实现这个目的，我们首先需要把 s1 中所有的元素移到 s2 中，接着把新元素压入 s2。最后把 s2 中所有的元素弹出，再把弹出的元素压入 s1</p>
<p><strong>二. 出队（pop）</strong></p>
<p>直接从 <code>s1</code> 弹出就可以了，因为 <code>s1</code> 的栈顶元素就是队列的队首元素。同时我们把弹出之后 <code>s1</code> 的栈顶元素赋值给代表队首元素的 <code>front</code> 变量</p>
<p><strong>三. 判断空（empty）</strong></p>
<p><code>s1</code> 存储了队列所有的元素，所以只需要检查 <code>s1</code> 的是否为空就可以了</p>
<p><strong>四. 取队首元素（peek）</strong></p>
<p>在我们的算法中，用了 <code>front</code> 变量来存储队首元素，在每次 <code>入队</code> 操作或者 <code>出队</code> 操作之后这个变量都会随之更新</p>
<p><strong>复杂度分析：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> MyQueue struct &#123;</span><br><span class="line">    stack []<span class="built_in">int</span></span><br><span class="line">    back []<span class="built_in">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Constructor() MyQueue &#123;</span><br><span class="line">    <span class="keyword">return</span> MyQueue&#123;</span><br><span class="line">        stack: make([]<span class="built_in">int</span>, <span class="number">0</span>),</span><br><span class="line">        back: make([]<span class="built_in">int</span>, <span class="number">0</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (this *MyQueue) Push(x <span class="built_in">int</span>)  &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(this.back) != <span class="number">0</span> &#123;</span><br><span class="line">        val := this.back[<span class="built_in">len</span>(this.back) - <span class="number">1</span>]</span><br><span class="line">        this.back = this.back[:<span class="built_in">len</span>(this.back) - <span class="number">1</span>]</span><br><span class="line">        this.stack = append(this.stack, val)</span><br><span class="line">    &#125;</span><br><span class="line">    this.stack = append(this.stack, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (this *MyQueue) Pop() <span class="built_in">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(this.stack) != <span class="number">0</span> &#123;</span><br><span class="line">        val := this.stack[<span class="built_in">len</span>(this.stack) - <span class="number">1</span>]</span><br><span class="line">        this.stack = this.stack[:<span class="built_in">len</span>(this.stack) - <span class="number">1</span>]</span><br><span class="line">        this.back = append(this.back, val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.back) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    val := this.back[<span class="built_in">len</span>(this.back) - <span class="number">1</span>]</span><br><span class="line">    this.back = this.back[:<span class="built_in">len</span>(this.back) - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (this *MyQueue) Peek() <span class="built_in">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(this.stack) != <span class="number">0</span> &#123;</span><br><span class="line">        val := this.stack[<span class="built_in">len</span>(this.stack) - <span class="number">1</span>]</span><br><span class="line">        this.stack = this.stack[:<span class="built_in">len</span>(this.stack) - <span class="number">1</span>]</span><br><span class="line">        this.back = append(this.back, val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.back) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    val := this.back[<span class="built_in">len</span>(this.back) - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (this *MyQueue) Empty() <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(this.stack) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(this.back) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="38-用队列实现栈（Go）225-简单"><a href="#38-用队列实现栈（Go）225-简单" class="headerlink" title="38. 用队列实现栈（Go）225-简单"></a><font color=DarkOrange>38. 用队列实现栈（Go）225-简单</font></h4><p><strong>题目：</strong></p>
<p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）</p>
<p><strong>示例：</strong></p>
<p><strong>提示：</strong></p>
<p><strong>思路：</strong></p>
<p><strong>复杂度分析：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyStack <span class="keyword">struct</span> &#123;</span><br><span class="line">	queue1, queue2 []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructor 在这里初始化你的数据结构</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> (s MyStack) &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyStack)</span></span> Push(x <span class="type">int</span>) &#123;</span><br><span class="line">	s.queue2 = <span class="built_in">append</span>(s.queue2, x)</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(s.queue1) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		s.queue2 = <span class="built_in">append</span>(s.queue2, s.queue1[<span class="number">0</span>])</span><br><span class="line">		s.queue1 = s.queue1[<span class="number">1</span>:]</span><br><span class="line">	&#125;</span><br><span class="line">	s.queue1, s.queue2 = s.queue2, s.queue1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyStack)</span></span> Pop() <span class="type">int</span> &#123;</span><br><span class="line">	v := s.queue1[<span class="number">0</span>]</span><br><span class="line">	s.queue1 = s.queue1[<span class="number">1</span>:]</span><br><span class="line">	<span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyStack)</span></span> Top() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.queue1[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyStack)</span></span> Empty() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s.queue1) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="39-翻转字符串里的单词-151-中等"><a href="#39-翻转字符串里的单词-151-中等" class="headerlink" title="39. 翻转字符串里的单词 151-中等"></a><font color=DarkOrange>39. 翻转字符串里的单词 151-中等</font></h4><p><strong>题目：</strong></p>
<p><strong>示例：</strong></p>
<p><strong>提示：</strong></p>
<p><strong>思路：</strong></p>
<p><strong>复杂度分析：</strong></p>
<p><strong>代码：</strong></p>
<h4 id="40-平衡二叉树（Go）110-简单"><a href="#40-平衡二叉树（Go）110-简单" class="headerlink" title="40. 平衡二叉树（Go）110-简单"></a><font color=DarkOrange>40. 平衡二叉树（Go）110-简单</font></h4><p><strong>题目：</strong></p>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树</p>
<p>本题中，一棵高度平衡二叉树定义为：一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 </p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：root = <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">20</span><span class="punctuation">,</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="number">15</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">true</span></span></span><br><span class="line">输入：root = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">false</span></span></span><br><span class="line">输入：root = <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">true</span></span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中的节点数在范围 <code>[0, 5000]</code> 内</li>
<li><code>-10^4 &lt;= Node.val &lt;= 10^4</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>前言<br>这道题中的平衡二叉树的定义是：二叉树的每个节点的左右子树的高度差的绝对值不超过 1，则二叉树是平衡二叉树。根据定义，一棵二叉树是平衡二叉树，当且仅当其所有子树也都是平衡二叉树，因此可以使用递归的方式判断二叉树是不是平衡二叉树，递归的顺序可以是自顶向下或者自底向上</p>
<p>方法一：自顶向下的递归<br>定义函数 height，用于计算二叉树中的任意一个节点 p 的高度：</p>
<p>有了计算节点高度的函数，即可判断二叉树是否平衡。具体做法类似于二叉树的前序遍历，即对于当前遍历到的节点，首先计算左右子树的高度，如果左右子树的高度差是否不超过 1，再分别递归地遍历左右子节点，并判断左子树和右子树是否平衡。这是一个自顶向下的递归的过程</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li><p>时间复杂度：O(n^2)，其中 n 是二叉树中的节点个数</p>
<p>最坏情况下，二叉树是满二叉树，需要遍历二叉树中的所有节点，时间复杂度是 O(n)</p>
<p>对于节点 p，如果它的高度是 d，则 height(p) 最多会被调用 d 次（即遍历到它的每一个祖先节点时）。对于平均的情况，一棵树的高度 h 满足 O(h)&#x3D;O(logn)，因为 d≤h，所以总时间复杂度为 O(nlogn)。对于最坏的情况，二叉树形成链式结构，高度为 O(n)，此时总时间复杂度为 O(n^2)</p>
</li>
<li><p>空间复杂度：O(n)，其中 n 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 n</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isBalanced</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> abs(height(root.Left) - height(root.Right)) &lt;= <span class="number">1</span> &amp;&amp;</span><br><span class="line">    isBalanced(root.Left) &amp;&amp; isBalanced(root.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">height</span><span class="params">(root * TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(height(root.Left), height(root.Right)) + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> * x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="41-螺旋矩阵（Go）54-中等"><a href="#41-螺旋矩阵（Go）54-中等" class="headerlink" title="41. 螺旋矩阵（Go）54-中等"></a><font color=DarkOrange>41. 螺旋矩阵（Go）54-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = <span class="punctuation">[</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="punctuation">[</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="punctuation">[</span><span class="number">7</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span></span><br><span class="line">输入：matrix = <span class="punctuation">[</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="punctuation">[</span><span class="number">9</span><span class="punctuation">,</span><span class="number">10</span><span class="punctuation">,</span><span class="number">11</span><span class="punctuation">,</span><span class="number">12</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">,</span><span class="number">12</span><span class="punctuation">,</span><span class="number">11</span><span class="punctuation">,</span><span class="number">10</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 10</code></li>
<li><code>-100 &lt;= matrix[i] [j] &lt;= 100</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：模拟<br>可以模拟螺旋矩阵的路径。初始位置是矩阵的左上角，初始方向是向右，当路径超出界限或者进入之前访问过的位置时，顺时针旋转，进入下一个方向</p>
<p>判断路径是否进入之前访问过的位置需要使用一个与输入矩阵大小相同的辅助矩阵 visited，其中的每个元素表示该位置是否被访问过。当一个元素被访问时，将 visited 中的对应位置的元素设为已访问</p>
<p>如何判断路径是否结束？由于矩阵中的每个元素都被访问一次，因此路径的长度即为矩阵中的元素数量，当路径的长度达到矩阵中的元素数量时即为完整路径，将该路径返回</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(mn)，其中 m 和 n 分别是输入矩阵的行数和列数。矩阵中的每个元素都要被访问一次</li>
<li>空间复杂度：O(mn)。需要创建一个大小为 m×n 的矩阵 visited 记录每个位置是否被访问过</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SpiralOrder</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> || <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	rows, columns := <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">	visited := <span class="built_in">make</span>([][]<span class="type">bool</span>, rows)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ &#123;</span><br><span class="line">		visited[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, columns)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		total          = rows * columns</span><br><span class="line">		order          = <span class="built_in">make</span>([]<span class="type">int</span>, total)</span><br><span class="line">		row, column    = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">		directions     = [][]<span class="type">int</span>&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;</span><br><span class="line">		directionIndex = <span class="number">0</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; total; i++ &#123;</span><br><span class="line">		order[i] = matrix[row][column]</span><br><span class="line">		visited[row][column] = <span class="literal">true</span></span><br><span class="line">		nextRow, nextColumn := row+directions[directionIndex][<span class="number">0</span>],</span><br><span class="line">			column+directions[directionIndex][<span class="number">1</span>]</span><br><span class="line">		<span class="keyword">if</span> nextRow &lt; <span class="number">0</span> || nextRow &gt;= rows || nextColumn &lt; <span class="number">0</span> ||</span><br><span class="line">			nextColumn &gt;= columns || visited[nextRow][nextColumn] &#123;</span><br><span class="line">			directionIndex = (directionIndex + <span class="number">1</span>) % <span class="number">4</span></span><br><span class="line">		&#125;</span><br><span class="line">		row += directions[directionIndex][<span class="number">0</span>]</span><br><span class="line">		column += directions[directionIndex][<span class="number">1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> order</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := [][]<span class="type">int</span>&#123;</span><br><span class="line">		&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">		&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">		&#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(SpiralOrder(nums))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>下面的题为面试经历过的题目</strong></p>
<h4 id="1-Golang合并2个切片并去重排序"><a href="#1-Golang合并2个切片并去重排序" class="headerlink" title="1. Golang合并2个切片并去重排序"></a><font color=DarkOrange>1. Golang合并2个切片并去重排序</font></h4><p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Solution</span><span class="params">(nums1, nums2 []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	nums1 = <span class="built_in">append</span>(nums1, nums2...)</span><br><span class="line">	hashMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">var</span> result []<span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums1 &#123;</span><br><span class="line">		<span class="comment">// 先计算Map长度，然后再往Map里添加数据</span></span><br><span class="line">		hashMapLen := <span class="built_in">len</span>(hashMap)</span><br><span class="line">		hashMap[num] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		<span class="comment">// 如何Map的长度有变化，说明num没有重复，可以将其添加到切片里</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(hashMap) != hashMapLen &#123;</span><br><span class="line">			result = <span class="built_in">append</span>(result, num)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 内置方法排序</span></span><br><span class="line">	sort.Ints(result)</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">2</span>&#125;</span><br><span class="line">	nums2 := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">1</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;结果为：&quot;</span>, Solution(nums1, nums2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-约瑟夫环问题"><a href="#2-约瑟夫环问题" class="headerlink" title="2. 约瑟夫环问题"></a><font color=DarkOrange>2. 约瑟夫环问题</font></h4><p><strong>题目：</strong>有n个人围成一圈，顺序排号。从第1个人开始报数（从1到3报数），凡报到3的人退出圈子，循环报数，问最后剩下的人是开始围圈时的第几号</p>
<p><strong>思路：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">JosephRing</span><span class="params">(nums [13]<span class="type">int</span>, n, m <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> front, rear, round = <span class="number">0</span>, n, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 队不为空</span></span><br><span class="line">		<span class="keyword">if</span> rear-front == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m<span class="number">-1</span>; i++ &#123;</span><br><span class="line">			front = (front + <span class="number">1</span>) % n</span><br><span class="line">			rear = (rear + <span class="number">1</span>) % n</span><br><span class="line">			nums[rear] = nums[front]</span><br><span class="line">		&#125;</span><br><span class="line">		front = (front + <span class="number">1</span>) % n</span><br><span class="line">		round++</span><br><span class="line">		fmt.Printf(<span class="string">&quot;第%d轮：%d\n&quot;</span>, round, nums[front])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> nums [<span class="number">13</span>]<span class="type">int</span></span><br><span class="line">	<span class="keyword">var</span> n, m = <span class="number">12</span>, <span class="number">3</span></span><br><span class="line">	nums[<span class="number">0</span>] = n</span><br><span class="line">	<span class="comment">// 初始化队列，入队</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n+<span class="number">1</span>; i++ &#123;</span><br><span class="line">		nums[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">	JosephRing(nums, n, m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Josephus</span><span class="params">(n <span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (Josephus(n<span class="number">-1</span>, k)+k<span class="number">-1</span>)%n + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	n := <span class="number">12</span></span><br><span class="line">	k := <span class="number">3</span></span><br><span class="line">	res := Josephus(n, k)</span><br><span class="line">	fmt.Println(<span class="string">&quot;结果为：&quot;</span>, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-一个单链表，如何求倒数第n-1个节点的值"><a href="#3-一个单链表，如何求倒数第n-1个节点的值" class="headerlink" title="3. 一个单链表，如何求倒数第n-1个节点的值"></a><font color=DarkOrange>3. 一个单链表，如何求倒数第n-1个节点的值</font></h4><p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Value <span class="type">int</span></span><br><span class="line">	Next  *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListNodeLen 求单链表长度</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">// 	head：单链表</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">// 	lenght：单链表长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListNodeLen</span><span class="params">(head *ListNode)</span></span> (lenght <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> ; head != <span class="literal">nil</span>; head = head.Next &#123;</span><br><span class="line">		lenght++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lenght</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ToSlice 将链表转化切片，然后直接下标取值</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">// 	head：单链表；n：第n个元素</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">// 	result：单链表第倒数n-1个元素的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToSlice</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> values []<span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> ; head != <span class="literal">nil</span>; head = head.Next &#123;</span><br><span class="line">		values = <span class="built_in">append</span>(values, head.Value)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 切片长度=链表长度</span></span><br><span class="line">	valuesLen := <span class="built_in">len</span>(values)</span><br><span class="line">	<span class="comment">// 判断是否会越界，左右都需要判断</span></span><br><span class="line">	<span class="keyword">if</span> n<span class="number">-1</span> &gt;= <span class="number">1</span> &amp;&amp; n &lt;= valuesLen+<span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> values[valuesLen-n+<span class="number">1</span>]</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FastSlow 快慢指针</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">// 	head：单链表；n：第n个元素</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">// 	result：单链表第倒数n-1个元素的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FastSlow</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">	dummy := &amp;ListNode&#123;<span class="number">0</span>, head&#125;</span><br><span class="line">	first, second := head, dummy</span><br><span class="line">	<span class="comment">// 需要判断是否会越界</span></span><br><span class="line">	listNodeLen := ListNodeLen(head)</span><br><span class="line">	<span class="keyword">if</span> n<span class="number">-1</span> &gt;= <span class="number">1</span> &amp;&amp; n &lt;= listNodeLen+<span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++ &#123;</span><br><span class="line">			first = first.Next</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> ; first != <span class="literal">nil</span>; first = first.Next &#123;</span><br><span class="line">			second = second.Next</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> second.Next.Value</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DoublePointer 双指针，优化后，不需要判断临界值</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">// 	head：单链表；n：第n个元素</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">// 	result：单链表第倒数n-1个元素的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoublePointer</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> second, first *ListNode</span><br><span class="line">	first = head</span><br><span class="line">	second = head</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; first.Next != <span class="literal">nil</span>; i++ &#123;</span><br><span class="line">		<span class="comment">//间隔n-1才赋值</span></span><br><span class="line">		<span class="keyword">if</span> i &gt;= n<span class="number">-1</span> &#123;</span><br><span class="line">			second = second.Next</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//头部往后移动</span></span><br><span class="line">		first = first.Next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> second.Value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReverseList 反转链表，链表反转后，未反转的链表的倒数第n-1个节点的值就是反转后链表的第n-1个的值</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">// 	head：单链表；n：第n个元素</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">// 	result：单链表第倒数n-1个元素的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReverseList</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> prev *ListNode</span><br><span class="line">	curr := head</span><br><span class="line">	<span class="keyword">for</span> curr != <span class="literal">nil</span> &#123;</span><br><span class="line">		next := curr.Next</span><br><span class="line">		curr.Next = prev</span><br><span class="line">		prev = curr</span><br><span class="line">		curr = next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历反转后的链表，然后取出第n-1个的值</span></span><br><span class="line">	i := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> prev != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> i == n<span class="number">-1</span> &#123;</span><br><span class="line">			result = prev.Value</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		i++</span><br><span class="line">		prev = prev.Next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateListNode 使用slice生成单链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateListNode</span><span class="params">(nums []<span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">	<span class="keyword">var</span> head ListNode</span><br><span class="line">	<span class="keyword">var</span> pre ListNode</span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		node := ListNode&#123;Value: num, Next: <span class="literal">nil</span>&#125;</span><br><span class="line">		<span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">			head.Next = &amp;node</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> pre.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">			pre.Next = &amp;node</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			pre.Next.Next = &amp;node</span><br><span class="line">			pre = *pre.Next</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>&#125;</span><br><span class="line">	n := <span class="number">5</span></span><br><span class="line">	head := CreateListNode(nums)</span><br><span class="line">	<span class="comment">// n值如果不在临界值内，返回0</span></span><br><span class="line">	toSlice := ToSlice(head, n)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;链表转切片，链表倒数第%d-1个：%d\n&quot;</span>, n, toSlice)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// n值如果不在临界值内，返回0</span></span><br><span class="line">	fastSlow := FastSlow(head, n)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;快慢指针，链表倒数第%d-1个：%d\n&quot;</span>, n, fastSlow)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// n值如果小于临界值指向链表最后一个元素，大于临界值指向链表第一个元素（倒数第n-1个元素）</span></span><br><span class="line">	doublePointer := DoublePointer(head, n)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;双指针优化后，链表倒数第%d-1个：%d\n&quot;</span>, n, doublePointer)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// n值如果不在临界值内，返回0</span></span><br><span class="line">	reverseList := ReverseList(head, n)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;反转链表，链表倒数第%d-1个：%d\n&quot;</span>, n, reverseList)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ToDo</span></span><br><span class="line">	<span class="comment">// 将单链表转为双链表，只需要找到第n个节点，然后取出双链表的第n个节点的上一个节点的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-abc组成的字符串删除"><a href="#4-abc组成的字符串删除" class="headerlink" title="4. abc组成的字符串删除"></a><font color=DarkOrange>4. abc组成的字符串删除</font></h4><p><strong>题目：</strong> 一个字符串，只有abc三个字符组成，现在需要删除字符串，删除规则为：每次只能删除2个字符，删除a和b或者删除a和c，字符串能否被全部删除，如果能，需要多少次</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Solution</span><span class="params">(str <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 判断字符串长度是否为奇数，奇数则无法完全删除</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(str) == <span class="number">0</span> || <span class="built_in">len</span>(str)%<span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	a, b, c := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> str &#123;</span><br><span class="line">		<span class="keyword">switch</span> <span class="type">string</span>(s) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">			a += <span class="number">1</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;b&quot;</span>:</span><br><span class="line">			b += <span class="number">1</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;c&quot;</span>:</span><br><span class="line">			c += <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// a的数量等于b+c的数量</span></span><br><span class="line">	<span class="keyword">if</span> a == b+c &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;aabbccaaaaabbcbb&quot;</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;结果为：&quot;</span>, Solution(str))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-计算非负数的平方根"><a href="#5-计算非负数的平方根" class="headerlink" title="5. 计算非负数的平方根"></a><font color=DarkOrange>5. 计算非负数的平方根</font></h4><p>给你一个非负小数x，计算并返回x的算术平方根。保留2位小数</p>
<p><strong>注意：</strong>不允许使用任何内置指数函数和算符，例如Pow(x,0.5)或者 ×**0.5</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrt</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 初始的猜测值为x的一半</span></span><br><span class="line">	z := x / <span class="number">2</span></span><br><span class="line">	<span class="comment">// 迭代求解</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		z = z - (z*z-x)/(<span class="number">2</span>*z)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="number">8.0</span></span><br><span class="line">	result := sqrt(x)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%.2f\n&quot;</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Go编程题30题"><a href="#Go编程题30题" class="headerlink" title="Go编程题30题"></a><font color=DarkOrange>Go编程题30题</font></h4><p>链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45604257/article/details/101649973">点击跳转</a></p>
<hr>

      
      <blockquote>
        
        <strong>本文链接：</strong><br><a href="https://huajun-chen.github.io/2022/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/">https://huajun-chen.github.io/2022/10/28/数据结构与算法面试题/</a>
      </blockquote>
    </div>
    <footer class="mdui-card-actions">
      
        <a class="mdui-ripple article_categories-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
      
      
        <a class="mdui-ripple article_tags-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a>
      
    </footer>
    
  </article>
  
<script src="//cdn.bootcdn.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>

  <script>$("#main article .mdui-card-content img.fancybox").on("click",function(e){$.fancybox.open({src:$(this).attr("src")});});</script>


  <nav id="paginator">
    
      <a rel="prev" class="extend prev" href="/2022/10/28/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E9%9D%A2%E8%AF%95%E9%A2%98/">
        <button aria-label="prev" class="mdui-btn mdui-btn-raised mdui-btn-icon mdui-color-theme-accent mdui-ripple"><i class="mdui-icon material-icons">arrow_back</i></button>
        <span class="mdui-p-x-3" mdui-tooltip="{content: '项目经验面试题'}">上一篇</span>
      </a>
    
    <div class="spacer"></div>
    
      <a rel="next" class="extend next" href="/2022/10/28/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98/">
        <span class="mdui-p-x-3" mdui-tooltip="{content: 'Linux操作系统面试题'}">下一篇</span>
        <button aria-label="next" class="mdui-btn mdui-btn-raised mdui-btn-icon mdui-color-theme-accent mdui-ripple"><i class="mdui-icon material-icons">arrow_forward</i></button>
      </a>
    
  </nav>




  <div style="position: fixed !important; left: 240px; top: 30%;">
    <button class="mdui-fab mdui-fab-mini mdui-ripple" mdui-menu="{target: '#toc'}"><i class="mdui-icon material-icons">toc</i></button>
    <ul class="mdui-menu" id="toc">
      <li class="mdui-menu-item" disabled><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88Go%EF%BC%89206-%E5%AE%B9%E6%98%93"><span class="toc-text">1. 反转链表（Go）206-容易</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-LRU%E7%BC%93%E5%AD%98%EF%BC%88Go%EF%BC%89146-%E4%B8%AD%E7%AD%89"><span class="toc-text">2. LRU缓存（Go）146-中等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-CodeTop%E8%A1%A5%E5%85%85%E9%A2%98%EF%BC%9A%E6%89%8B%E6%92%95%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88Go%EF%BC%89-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-912-%E4%B8%AD%E7%AD%89"><span class="toc-text">3. CodeTop补充题：手撕快速排序（Go） | 排序数组 912-中等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88Go%EF%BC%89-21-%E7%AE%80%E5%8D%95"><span class="toc-text">4. 合并两个有序链表（Go） 21-简单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%EF%BC%88Go%EF%BC%8953-%E7%AE%80%E5%8D%95"><span class="toc-text">5. 最大子数组和（Go）53-简单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0%EF%BC%88Go%EF%BC%89415-%E7%AE%80%E5%8D%95"><span class="toc-text">6. 字符串相加（Go）415-简单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88Go%EF%BC%89704-%E7%AE%80%E5%8D%95"><span class="toc-text">7. 二分查找（Go）704-简单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%EF%BC%88Go%EF%BC%893-%E4%B8%AD%E7%AD%89"><span class="toc-text">8. 无重复字符串的最长子串（Go）3-中等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%EF%BC%88Go%EF%BC%89215-%E4%B8%AD%E7%AD%89"><span class="toc-text">9. 数组中的第K个最大元素（Go）215-中等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-8-%E4%B8%AD%E7%AD%89"><span class="toc-text">10. 字符串转换整数 8-中等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%EF%BC%88Go%EF%BC%89234-%E7%AE%80%E5%8D%95"><span class="toc-text">11. 回文链表（Go）234-简单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E7%94%A8Rand7-%E5%AE%9E%E7%8E%B0Rand10-%EF%BC%88Go%EF%BC%89470-%E4%B8%AD%E7%AD%89"><span class="toc-text">12. 用Rand7()实现Rand10()（Go）470-中等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88Go%EF%BC%891-%E7%AE%80%E5%8D%95"><span class="toc-text">13. 两数之和（Go）1-简单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-%E7%88%AC%E6%A5%BC%E6%A2%AF%EF%BC%88Go%EF%BC%8970-%E7%AE%80%E5%8D%95"><span class="toc-text">14. 爬楼梯（Go）70-简单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E7%B3%BB%E5%88%97%EF%BC%88Go%EF%BC%89-300-%E4%B8%AD%E7%AD%89"><span class="toc-text">15. 最长递增子系列（Go） 300-中等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%EF%BC%88Go%EF%BC%8920-%E7%AE%80%E5%8D%95"><span class="toc-text">16. 有效的括号（Go）20-简单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%EF%BC%88Go%EF%BC%89141-%E7%AE%80%E5%8D%95"><span class="toc-text">17. 环形链表（Go）141-简单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%EF%BC%88Go%EF%BC%89153-%E4%B8%AD%E7%AD%89"><span class="toc-text">18. 寻找旋转排序数组中的最小值（Go）153-中等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%EF%BC%88Go%EF%BC%895-%E4%B8%AD%E7%AD%89"><span class="toc-text">19. 最长回文子串（Go）5-中等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88Go%EF%BC%891143-%E4%B8%AD%E7%AD%89"><span class="toc-text">20. 最长公共子序列（Go）1143-中等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88Go%EF%BC%8915-%E4%B8%AD%E7%AD%89"><span class="toc-text">21. 三数之和（Go）15-中等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%EF%BC%88Go%EF%BC%894-%E5%9B%B0%E9%9A%BE"><span class="toc-text">22. 寻找两个正序数组的中位数（Go）4-困难</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88Go%EF%BC%89102-%E4%B8%AD%E7%AD%89"><span class="toc-text">23. 二叉树的层序遍历（Go）102-中等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-%E8%A1%A5%E5%85%85%E9%A2%986%EF%BC%9A%E6%89%8B%E6%92%95%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88Go%EF%BC%89-912-%E4%B8%AD%E7%AD%89"><span class="toc-text">24. 补充题6：手撕堆排序（Go） 912-中等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%EF%BC%88Go%EF%BC%89160-%E7%AE%80%E5%8D%95"><span class="toc-text">25. 相交链表（Go）160-简单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACK%E5%A4%A7%E8%8A%82%E7%82%B9%EF%BC%88Go%EF%BC%89-%E5%89%91%E6%8C%87offer54-%E7%AE%80%E5%8D%95"><span class="toc-text">26. 二叉搜索树的第K大节点（Go） 剑指offer54-简单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27-LFU%E7%BC%93%E5%AD%98%EF%BC%88Go%EF%BC%89-460-%E5%9B%B0%E9%9A%BE"><span class="toc-text">27. LFU缓存（Go） 460-困难</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88Go%EF%BC%8925-%E5%9B%B0%E9%9A%BE"><span class="toc-text">28. K个一组翻转链表（Go）25-困难</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%EF%BC%88Go%EF%BC%89121-%E7%AE%80%E5%8D%95"><span class="toc-text">29. 买卖股票的最佳时机（Go）121-简单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A82%EF%BC%88Go%EF%BC%89227-%E4%B8%AD%E7%AD%89"><span class="toc-text">30. 基本计算器2（Go）227-中等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%88Go%EF%BC%89442-%E4%B8%AD%E7%AD%89"><span class="toc-text">31. 数组中重复的数据（Go）442-中等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%EF%BC%88Go%EF%BC%89-332-%E4%B8%AD%E7%AD%89"><span class="toc-text">32. 零钱兑换（Go） 332-中等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%EF%BC%88Go%EF%BC%892-%E4%B8%AD%E7%AD%89"><span class="toc-text">33. 两数相加（Go）2-中等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%88Go%EF%BC%89%E5%89%91%E6%8C%87offer22-%E7%AE%80%E5%8D%95"><span class="toc-text">34. 链表中倒数第K个节点（Go）剑指offer22-简单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#35-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%EF%BC%88Go%EF%BC%89112-%E7%AE%80%E5%8D%95"><span class="toc-text">35. 路径总和（Go）112-简单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#36-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98%EF%BC%88Go%EF%BC%8943-%E4%B8%AD%E7%AD%89"><span class="toc-text">36. 字符串相乘（Go）43-中等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#37-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%EF%BC%88Go%EF%BC%89-232-%E7%AE%80%E5%8D%95"><span class="toc-text">37. 用栈实现队列（Go） 232-简单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#38-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88%EF%BC%88Go%EF%BC%89225-%E7%AE%80%E5%8D%95"><span class="toc-text">38. 用队列实现栈（Go）225-简单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#39-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D-151-%E4%B8%AD%E7%AD%89"><span class="toc-text">39. 翻转字符串里的单词 151-中等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#40-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88Go%EF%BC%89110-%E7%AE%80%E5%8D%95"><span class="toc-text">40. 平衡二叉树（Go）110-简单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#41-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%EF%BC%88Go%EF%BC%8954-%E4%B8%AD%E7%AD%89"><span class="toc-text">41. 螺旋矩阵（Go）54-中等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Golang%E5%90%88%E5%B9%B62%E4%B8%AA%E5%88%87%E7%89%87%E5%B9%B6%E5%8E%BB%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-text">1. Golang合并2个切片并去重排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98"><span class="toc-text">2. 约瑟夫环问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%80%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%8C%E5%A6%82%E4%BD%95%E6%B1%82%E5%80%92%E6%95%B0%E7%AC%ACn-1%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%80%BC"><span class="toc-text">3. 一个单链表，如何求倒数第n-1个节点的值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-abc%E7%BB%84%E6%88%90%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%A0%E9%99%A4"><span class="toc-text">4. abc组成的字符串删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%AE%A1%E7%AE%97%E9%9D%9E%E8%B4%9F%E6%95%B0%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9"><span class="toc-text">5. 计算非负数的平方根</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Go%E7%BC%96%E7%A8%8B%E9%A2%9830%E9%A2%98"><span class="toc-text">Go编程题30题</span></a></li></ol></li>
    </ul>
  </div>


</main>
  <footer id="footer" class="mdui-m-t-5 mdui-p-y-3 mdui-color-theme">
  <div class="mdui-p-y-0 mdui-text-center">
    
    
    
    
    
    
    
    
    
    
    
    
  </div>
  <div class="mdui-p-y-1 mdui-text-center">
    Copyright &copy; 2023 可可西里<br>
    Powered by <a href="https://hexo.io/" target="_blank" class="mdui-text-color-theme-accent">Hexo</a>
    
  </div>
</footer>

  <button id="gotop" class="mdui-fab mdui-fab-fixed mdui-fab-hide mdui-color-theme-accent mdui-ripple"><i class="mdui-icon material-icons">arrow_upward</i></button>
  
  
<script src="/js/mdui.js"></script>
<script src="/js/script.js"></script>

  
<script src="/custom.js"></script>

</body>
</html>
