<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <meta name="renderer" content="webkit">
<!--  <meta name="baidu-site-verification" content="code-ofAqabWYEE" />-->
  <meta name="google-site-verification" content="7_aCpLDu0s7bOCrqbIhiPhkHrFGEKMhTyXB5-my2L4g" />

  
  <title>云原生02-编写Go程序 | 可可西里-博客</title>

  <link rel="shortcut icon" href="/images/favicon.png">
  <link rel="alternate" href="/atom.xml" title="可可西里-博客" type="application/atom+xml">
  <meta name="description" content="Go语言进阶知识整理 1. 线程加锁1.1 锁 Go 语言不仅仅提供基于 CSP 的通讯模型，也支持基于共享内存的多线程数据访问 Sync 包提供了锁的基本原语 sync.Mutex 互斥锁 Lock()加锁，Unlock 解锁   sync.RWMutex 读写分离锁 不限制并发读，只限制并发写和并发读写   sync.WaitGroup 等待一组 goroutine 返回   sync.Onc">
<meta property="og:type" content="article">
<meta property="og:title" content="云原生02-编写Go程序">
<meta property="og:url" content="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F02-%E7%BC%96%E5%86%99Go%E7%A8%8B%E5%BA%8F/index.html">
<meta property="og:site_name" content="可可西里-博客">
<meta property="og:description" content="Go语言进阶知识整理 1. 线程加锁1.1 锁 Go 语言不仅仅提供基于 CSP 的通讯模型，也支持基于共享内存的多线程数据访问 Sync 包提供了锁的基本原语 sync.Mutex 互斥锁 Lock()加锁，Unlock 解锁   sync.RWMutex 读写分离锁 不限制并发读，只限制并发写和并发读写   sync.WaitGroup 等待一组 goroutine 返回   sync.Onc">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://tva1.sinaimg.cn/large/0079DIvogy1h8d2s6imj8j31b60gutem.jpg">
<meta property="og:image" content="http://tva1.sinaimg.cn/large/0079DIvogy1h8d2tl546nj31n40o27fy.jpg">
<meta property="og:image" content="http://tva1.sinaimg.cn/large/0079DIvogy1h8d2uw9hhqj31cy0jm40u.jpg">
<meta property="og:image" content="http://tva1.sinaimg.cn/large/0079DIvogy1h8d2zvpsctj31e80lon5k.jpg">
<meta property="og:image" content="http://tva1.sinaimg.cn/large/0079DIvogy1h8d31hrzzjj30g608mwfr.jpg">
<meta property="og:image" content="http://tva1.sinaimg.cn/large/0079DIvogy1h8d32u86bpj31ke0r8naq.jpg">
<meta property="og:image" content="http://tva1.sinaimg.cn/large/0079DIvogy1h8d372j1f5j31jw0isdn7.jpg">
<meta property="og:image" content="http://tva1.sinaimg.cn/large/0079DIvogy1h8d38gftrpj316007uabs.jpg">
<meta property="og:image" content="http://tva1.sinaimg.cn/large/0079DIvogy1h8d39qtrfpj31k00nu7fm.jpg">
<meta property="og:image" content="http://tva1.sinaimg.cn/large/0079DIvogy1h8d3d17knjj31kq0ni499.jpg">
<meta property="og:image" content="http://tva1.sinaimg.cn/large/0079DIvogy1h8d3k484cmj31ci0ikwn9.jpg">
<meta property="og:image" content="http://tva1.sinaimg.cn/large/0079DIvogy1h8d3lpvwr3j31bw0940tw.jpg">
<meta property="og:image" content="http://tva1.sinaimg.cn/large/0079DIvogy1h8d3y19ws9j31by0lin5s.jpg">
<meta property="og:image" content="http://tva1.sinaimg.cn/large/0079DIvogy1h8d4695nkmj31dg0lmtjd.jpg">
<meta property="og:image" content="http://tva1.sinaimg.cn/large/0079DIvogy1h8d477ndpqj31f20lo142.jpg">
<meta property="og:image" content="http://tva1.sinaimg.cn/large/0079DIvogy1h8d4805ht4j318m0lmaif.jpg">
<meta property="og:image" content="http://tva1.sinaimg.cn/large/0079DIvogy1h8d48xagndj31nm0tsqd5.jpg">
<meta property="og:image" content="http://tva1.sinaimg.cn/large/0079DIvogy1h8d4aae3tyj30vk0d60x7.jpg">
<meta property="article:published_time" content="2022-11-08T03:00:00.000Z">
<meta property="article:modified_time" content="2022-11-24T08:53:30.297Z">
<meta property="article:author" content="可可西里">
<meta property="article:tag" content="云原生">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tva1.sinaimg.cn/large/0079DIvogy1h8d2s6imj8j31b60gutem.jpg">

  <meta name="keywords" content=",云原生,Go">
  <meta name="format-detection" content="telephone=no,email=no">
  <meta name="theme-color" content="#9C27B0">

  <meta name="mobile-web-app-capable" content="yes">
  <meta name="application-name" content="可可西里-博客">
  <meta name="msapplication-starturl" content="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F02-%E7%BC%96%E5%86%99Go%E7%A8%8B%E5%BA%8F/">
  <meta name="msapplication-navbutton-color" content="#9C27B0">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="可可西里-博客">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="/images/favicon.png">

  
    <link rel="canonical" href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F02-%E7%BC%96%E5%86%99Go%E7%A8%8B%E5%BA%8F/">
  

  
  

  
  
  

  
<link rel="stylesheet" href="/css/mdui.css">
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/custom.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body class="mdui-appbar-with-toolbar mdui-theme-primary-grey mdui-theme-accent-deep-purple">
  <script>var a=localStorage.getItem("mdui-theme-layout-dark");if(a){document.getElementsByTagName("body")[0].className+=" mdui-theme-layout-dark"};</script>
  <script>if(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches){document.getElementsByTagName("body")[0].className+=" mdui-theme-layout-dark"};</script>
  <script>var a=localStorage.getItem("mdui-drawer-close");if(!a){document.getElementsByTagName("body")[0].className+=" mdui-drawer-body-left"};</script>
  <header id="header" class="mdui-appbar mdui-appbar-fixed mdui-appbar-scroll-hide mdui-appbar-inset">
  <div class="mdui-toolbar mdui-color-theme">
    <a href="javascript:;" class="mdui-btn mdui-btn-icon" mdui-drawer="{target: '#sidebar', swipe: true}"><i class="mdui-icon material-icons">menu</i></a>
    <a href="/" class="mdui-typo-headline">可可西里-博客</a>
    <div class="mdui-toolbar-spacer"></div>
    <a href="javascript:;" class="mdui-btn mdui-btn-icon" mdui-dialog="{target: '#search'}" mdui-tooltip="{content: '搜索'}"><i class="mdui-icon material-icons">search</i></a>
    <a href="/atom.xml" class="mdui-btn mdui-btn-icon" mdui-tooltip="{content: 'RSS'}"><i class="mdui-icon material-icons">rss_feed</i></a>
<!--      <a href="javascript:;" class="mdui-btn mdui-btn-icon" mdui-drawer="{target: '#sidebar', swipe: true}" style="margin-right: 0px"><i class="mdui-icon material-icons" style="cursor:pointer">brightness_4</i></a>-->
      <a href="javascript:;" class="mdui-btn mdui-btn-icon" style="margin-right: 0px"><i class="mdui-icon material-icons" style="cursor:pointer">brightness_4</i></a>
      <div style="margin-left: 0px;cursor:pointer">长按切换</div>
  </div>
</header>
<div class="mdui-dialog" id="search">
  
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="请输入关键字"><input type="hidden" name="sitesearch" value="https://huajun-chen.github.io"></form>
    <div class="search-result"></div>
  
</div>

  <aside id="sidebar" class="mdui-drawer mdui-drawer-full-height">
  <script>var a=localStorage.getItem("mdui-drawer-close");if(a){document.getElementById("sidebar").className+=" mdui-drawer-close"};</script>
  <div class="mdui-grid-tile">
    <img src="/images/banner.png" style="height: 160px;">
    <img src="/images/avatar.png" class="avatar-animation" style="position: absolute; top: 10%; left: 24px; width: 64px; height: 64px; border: 2px solid #fff; border-radius: 50%;">
    <div class="mdui-grid-tile-actions">
      <div class="mdui-grid-tile-text">
        <div class="mdui-grid-tile-title">可可西里</div>
<!--        <div class="mdui-grid-tile-subtitle"><i class="mdui-icon material-icons">art_track</i>好好吃饭 好好睡觉 好好上班</div>-->
        <div class="mdui-grid-tile-subtitle">好好吃饭 好好睡觉 好好上班</div>
      </div>
      
        <div class="mdui-grid-tile-buttons">
          <a href="mailto:hellowuhan@protonmail.com" class="mdui-btn mdui-btn-icon" mdui-tooltip="{content: 'hellowuhan@protonmail.com'}"><i class="mdui-icon material-icons">email</i></a>
        </div>
      
    </div>
  </div>

  <div class="mdui-list" mdui-collapse="{accordion: true}">
    <a href="/" class="mdui-list-item mdui-ripple">
      <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-blue">home</i>
      <div class="mdui-list-item-content">主页</div>
    </a>
    <div class="mdui-collapse-item">
      <script>var a=localStorage.getItem("mdui-collapse-item-0");if(a){document.getElementsByClassName("mdui-collapse-item")[0].className+=" mdui-collapse-item-open"};</script>
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-deep-orange">archive</i>
        <div class="mdui-list-item-content">归档</div>
        <i class="mdui-collapse-item-arrow mdui-icon material-icons">keyboard_arrow_down</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
        
        <a class="mdui-ripple sidebar_archives-link" href="/archives/2022/12/">十二月 2022<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2022/11/">十一月 2022<span class="mdui-ripple sidebar_archives-count">22</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2022/10/">十月 2022<span class="mdui-ripple sidebar_archives-count">10</span></a>
        
      </div>
    </div>
    <div class="mdui-collapse-item">
      <script>var a=localStorage.getItem("mdui-collapse-item-1");if(a){document.getElementsByClassName("mdui-collapse-item")[1].className+=" mdui-collapse-item-open"};</script>
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-green">class</i>
        <div class="mdui-list-item-content">分类</div>
        <i class="mdui-collapse-item-arrow mdui-icon material-icons">keyboard_arrow_down</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
        
        <a class="mdui-ripple sidebar_archives-link" href="/categories/%E5%8A%A0%E5%AF%86/">加密<span class="mdui-ripple sidebar_archives-count">3</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端<span class="mdui-ripple sidebar_archives-count">19</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试<span class="mdui-ripple sidebar_archives-count">12</span></a>
        
      </div>
    </div>
    <div class="mdui-collapse-item">
      <script>var a=localStorage.getItem("mdui-collapse-item-2");if(a){document.getElementsByClassName("mdui-collapse-item")[2].className+=" mdui-collapse-item-open"};</script>
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-brown">bookmark</i>
        <div class="mdui-list-item-content">标签</div>
        <i class="mdui-collapse-item-arrow mdui-icon material-icons">keyboard_arrow_down</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
        
        <a class="mdui-ripple sidebar_archives-link" href="/tags/ES/" rel="tag">ES<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/Go/" rel="tag">Go<span class="mdui-ripple sidebar_archives-count">6</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/Kafka/" rel="tag">Kafka<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/Linux/" rel="tag">Linux<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/MySQL/" rel="tag">MySQL<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/Redis/" rel="tag">Redis<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" rel="tag">云原生<span class="mdui-ripple sidebar_archives-count">18</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%9E%B6%E6%9E%84/" rel="tag">系统设计与架构<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式<span class="mdui-ripple sidebar_archives-count">1</span></a>
        
      </div>
    </div>
    <a href="/about" class="mdui-list-item mdui-ripple">
      <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-purple">person</i>
      <div class="mdui-list-item-content">关于</div>
    </a>
  </div>

  <div class="mdui-divider"></div>

  <div class="mdui-list" mdui-collapse="{accordion: true}">
    
      <a href="/timeline" class="mdui-list-item mdui-ripple">时间轴</a>
    
      <a href="/tagcloud" class="mdui-list-item mdui-ripple">标签云</a>
    
      <a href="/gallery" class="mdui-list-item mdui-ripple">相册</a>
    
    <div class="mdui-collapse-item">
      <script>var a=localStorage.getItem("mdui-collapse-item-3");if(a){document.getElementsByClassName("mdui-collapse-item")[3].className+=" mdui-collapse-item-open"};</script>
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <div class="mdui-list-item-content">友情链接</div>
        <i class="mdui-list-item-icon mdui-icon material-icons">link</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
        
        
          <a href="javascript:;" class="mdui-list-item mdui-p-l-2 mdui-text-color-theme mdui-ripple" style="justify-content: center;">链接为空</a>
        
      </div>
    </div>
  </div>
</aside>

  <main id="main" class="mdui-m-t-5 fadeIn animated">
  
<link rel="stylesheet" href="//cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  <style>#main article .mdui-card-content .center-block{display:block!important;margin-right:auto!important;margin-left:auto!important}</style>
  <style>#main article .mdui-card-content .text-center{text-align:center!important}</style>
  <article class="mdui-card mdui-m-b-5">
    <header class="mdui-card-media">
      <img src="/images/random/material-19.png" style="max-height: 240px;">
      <div class="mdui-card-media-covered">
        <div class="mdui-card-primary">
          <div class="mdui-card-primary-title">云原生02-编写Go程序</div>
          <div class="mdui-card-primary-subtitle"><i class="iconfont">&#xe697;</i> 2022-11-08 / <i class="iconfont">&#xe601;</i> 可可西里</div>
        </div>
      </div>
      <div class="mdui-card-menu">
<!--        -->
<!--          <button class="mdui-btn mdui-btn-icon mdui-text-color-white" mdui-menu="{target: '#qrcode', align: 'right'}"><i class="mdui-icon material-icons">devices</i></button>-->
<!--          <ul class="mdui-menu" id="qrcode">-->
<!--            -->
<!--              <li class="mdui-menu-item"><a class="mdui-text-center mdui-ripple">发送到手机</a></li>-->
<!--            -->
<!--            <li class="mdui-menu-item" disabled>-->
<!--              -->
<!--                <img src="//qr.liantu.com/api.php?w=246&m=10&text=https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F02-%E7%BC%96%E5%86%99Go%E7%A8%8B%E5%BA%8F/">-->
<!--              -->
<!--            </li>-->
<!--          </ul>-->
<!--        -->
        
          <button class="mdui-btn mdui-btn-icon mdui-text-color-white" mdui-menu="{target: '#share_menu', align: 'right'}"><i class="mdui-icon material-icons">share</i></button>
          <ul class="mdui-menu" id="share_menu">
            <li class="mdui-menu-item">
              <a href="https://service.weibo.com/share/share.php?appkey=&title=云原生02-编写Go程序&url=https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F02-%E7%BC%96%E5%86%99Go%E7%A8%8B%E5%BA%8F/&pic=https://huajun-chen.github.io/images/favicon.png&searchPic=false&style=simple" target="_blank" class="mdui-ripple">分享到 Weibo</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://twitter.com/intent/tweet?text=云原生02-编写Go程序&url=https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F02-%E7%BC%96%E5%86%99Go%E7%A8%8B%E5%BA%8F/&via=可可西里" target="_blank" class="mdui-ripple">分享到 Twitter</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://www.facebook.com/sharer/sharer.php?u=https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F02-%E7%BC%96%E5%86%99Go%E7%A8%8B%E5%BA%8F/" target="_blank" class="mdui-ripple">分享到 Facebook</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://plus.google.com/share?url=https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F02-%E7%BC%96%E5%86%99Go%E7%A8%8B%E5%BA%8F/" target="_blank" class="mdui-ripple">分享到 Google+</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F02-%E7%BC%96%E5%86%99Go%E7%A8%8B%E5%BA%8F/&title=云原生02-编写Go程序" target="_blank" class="mdui-ripple">分享到 LinkedIn</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://connect.qq.com/widget/shareqq/index.html?site=可可西里-博客&title=云原生02-编写Go程序&pics=https://huajun-chen.github.io/images/favicon.png&url=https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F02-%E7%BC%96%E5%86%99Go%E7%A8%8B%E5%BA%8F/" target="_blank" class="mdui-ripple">分享到 QQ</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://telegram.me/share/url?url=https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F02-%E7%BC%96%E5%86%99Go%E7%A8%8B%E5%BA%8F/&text=云原生02-编写Go程序" target="_blank" class="mdui-ripple">分享到 Telegram</a>
            </li>
          </ul>
        
      </div>
    </header>
    <div class="mdui-card-content mdui-typo">
      <p>Go语言进阶知识整理</p>
<h4 id="1-线程加锁"><a href="#1-线程加锁" class="headerlink" title="1. 线程加锁"></a><font color=DarkOrange>1. 线程加锁</font></h4><h5 id="1-1-锁"><a href="#1-1-锁" class="headerlink" title="1.1 锁"></a><font color=DarkOrange>1.1 锁</font></h5><ul>
<li>Go 语言不仅仅提供基于 CSP 的通讯模型，也支持基于共享内存的多线程数据访问</li>
<li>Sync 包提供了锁的基本原语</li>
<li>sync.Mutex 互斥锁<ul>
<li>Lock()加锁，Unlock 解锁</li>
</ul>
</li>
<li>sync.RWMutex 读写分离锁<ul>
<li>不限制并发读，只限制并发写和并发读写</li>
</ul>
</li>
<li>sync.WaitGroup<ul>
<li>等待一组 goroutine 返回</li>
</ul>
</li>
<li>sync.Once<ul>
<li>保证某段代码只执行一次</li>
</ul>
</li>
<li>sync.Cond<ul>
<li>让一组 goroutine 在满足特定条件时被唤醒</li>
</ul>
</li>
</ul>
<h5 id="1-2-Mutex示例"><a href="#1-2-Mutex示例" class="headerlink" title="1.2 Mutex示例"></a><font color=DarkOrange>1.2 Mutex示例</font></h5><p>Kubernetes 中的 informer factory</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start initializes all requested informers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *sharedInformerFactory)</span></span> Start(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) &#123;</span><br><span class="line">  f.lock.Lock()</span><br><span class="line">  <span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line">  <span class="keyword">for</span> informerType, informer := <span class="keyword">range</span> f.informers &#123;</span><br><span class="line">    <span class="keyword">if</span> !f.startedInformers[informerType] &#123;</span><br><span class="line">      <span class="keyword">go</span> informer.Run(stopCh)</span><br><span class="line">      f.startedInformers[informerType] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-3-WaitGroup示例"><a href="#1-3-WaitGroup示例" class="headerlink" title="1.3 WaitGroup示例"></a><font color=DarkOrange>1.3 WaitGroup示例</font></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CreateBatch create a batch of pods. All pods are created before waiting.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *PodClient)</span></span> CreateBatch(pods []*v1.Pod) []*v1.Pod &#123;</span><br><span class="line">  ps := <span class="built_in">make</span>([]*v1.Pod, <span class="built_in">len</span>(pods))</span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  <span class="keyword">for</span> i, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>, pod *v1.Pod)</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> wg.Done()</span><br><span class="line">      <span class="keyword">defer</span> GinkgoRecover()</span><br><span class="line">      ps[i] = c.CreateSync(pod)</span><br><span class="line">    &#125;(i, pod)</span><br><span class="line">  &#125;</span><br><span class="line">  wg.Wait()</span><br><span class="line">  <span class="keyword">return</span> ps</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-4-Cond示例"><a href="#1-4-Cond示例" class="headerlink" title="1.4 Cond示例"></a><font color=DarkOrange>1.4 Cond示例</font></h5><p>Kubernetes 中的队列，标准的生产者消费者模式</p>
<p>cond: sync.NewCond(&amp;sync.Mutex{})</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add marks item as needing processing.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span></span> Add(item <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">  q.cond.L.Lock()</span><br><span class="line">  <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">  <span class="keyword">if</span> q.shuttingDown &#123;</span><br><span class="line">  	<span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> q.dirty.has(item) &#123;</span><br><span class="line">  	<span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  q.metrics.add(item)</span><br><span class="line">  q.dirty.insert(item)</span><br><span class="line">  <span class="keyword">if</span> q.processing.has(item) &#123;</span><br><span class="line">  	<span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  q.queue = <span class="built_in">append</span>(q.queue, item)</span><br><span class="line">  q.cond.Signal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get blocks until it can return an item to be processed. If shutdown = true,</span></span><br><span class="line"><span class="comment">// the caller should end their goroutine. You must call Done with item when you</span></span><br><span class="line"><span class="comment">// have finished processing it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span></span> Get() (item <span class="keyword">interface</span>&#123;&#125;, shutdown <span class="type">bool</span>) &#123;</span><br><span class="line">  q.cond.L.Lock()</span><br><span class="line">  <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">len</span>(q.queue) == <span class="number">0</span> &amp;&amp; !q.shuttingDown &#123;</span><br><span class="line">  	q.cond.Wait()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(q.queue) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// We must be shutting down.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  item, q.queue = q.queue[<span class="number">0</span>], q.queue[<span class="number">1</span>:]</span><br><span class="line">  q.metrics.get(item)</span><br><span class="line">  q.processing.insert(item)</span><br><span class="line">  q.dirty.<span class="built_in">delete</span>(item)</span><br><span class="line">  <span class="keyword">return</span> item, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-线程调度"><a href="#2-线程调度" class="headerlink" title="2. 线程调度"></a><font color=DarkOrange>2. 线程调度</font></h4><h5 id="2-1-深入理解Go语言线程调度"><a href="#2-1-深入理解Go语言线程调度" class="headerlink" title="2.1 深入理解Go语言线程调度"></a><font color=DarkOrange>2.1 深入理解Go语言线程调度</font></h5><ul>
<li>进程：资源分配的基本单位</li>
<li>线程：调度的基本单位</li>
<li>无论是线程还是进程，在 linux 中都以 task_struct 描述，从内核角度看，与进程无本质区别</li>
<li>Glibc 中的 pthread 库提供 NPTL（Native POSIX Threading Library）支持</li>
</ul>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d2s6imj8j31b60gutem.jpg" alt="image.png" style="zoom:50%;" /></div>

<h5 id="2-2-Linux进程的内存使用"><a href="#2-2-Linux进程的内存使用" class="headerlink" title="2.2 Linux进程的内存使用"></a><font color=DarkOrange>2.2 Linux进程的内存使用</font></h5><p><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d2tl546nj31n40o27fy.jpg" alt="image.png"></p>
<h5 id="2-3-CPU对内存的访问"><a href="#2-3-CPU对内存的访问" class="headerlink" title="2.3 CPU对内存的访问"></a><font color=DarkOrange>2.3 CPU对内存的访问</font></h5><ul>
<li>CPU 上有个 Memory Management Unit（MMU） 单元</li>
<li>CPU 把虚拟地址给 MMU，MMU 去物理内存中查询页表，得到实际的物理地址</li>
<li>CPU 维护一份缓存 Translation Lookaside Buffer（TLB），缓存虚拟地址和物理地址的映射关系</li>
</ul>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d2uw9hhqj31cy0jm40u.jpg" alt="image.png" style="zoom:50%;" /></div>

<h5 id="2-4-进程切换开销"><a href="#2-4-进程切换开销" class="headerlink" title="2.4 进程切换开销"></a><font color=DarkOrange>2.4 进程切换开销</font></h5><ul>
<li>直接开销<ul>
<li>切换页表全局目录（PGD）</li>
<li>切换内核态堆栈</li>
<li>切换硬件上下文（进程恢复前，必须装入寄存器的数据统称为硬件上下文）</li>
<li>刷新 TLB</li>
<li>系统调度器的代码执行</li>
</ul>
</li>
<li>间接开销<ul>
<li>CPU 缓存失效导致的进程需要到内存直接访问的 IO 操作变多</li>
</ul>
</li>
</ul>
<h5 id="2-5-线程切换开销"><a href="#2-5-线程切换开销" class="headerlink" title="2.5 线程切换开销"></a><font color=DarkOrange>2.5 线程切换开销</font></h5><ul>
<li>线程本质上只是一批共享资源的进程，线程切换本质上依然需要内核进行进程切换</li>
<li>一组线程因为共享内存资源，因此一个进程的所有线程共享虚拟地址空间，线程切换相比进程 切换，主要节省了虚拟地址空间的切换</li>
</ul>
<h5 id="2-6-用户线程"><a href="#2-6-用户线程" class="headerlink" title="2.6 用户线程"></a><font color=DarkOrange>2.6 用户线程</font></h5><p>无需内核帮助，应用程序在用户空间创建的可执行单元，创建销毁完全在用户态完成</p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d2zvpsctj31e80lon5k.jpg" alt="image.png" style="zoom:50%;" /></div>

<h5 id="2-7-Goroutine"><a href="#2-7-Goroutine" class="headerlink" title="2.7 Goroutine"></a><font color=DarkOrange>2.7 Goroutine</font></h5><p>Go 语言基于 GMP 模型实现用户态线程</p>
<ul>
<li>G：表示 goroutine，每个 goroutine 都有自己的栈空间，定时器， 初始化的栈空间在 2k 左右，空间会随着需求增长</li>
<li>M：抽象化代表内核线程，记录内核线程栈信息，当 goroutine 调度 到线程时，使用该 goroutine 自己的栈信息</li>
<li>P：代表调度器，负责调度 goroutine，维护一个本地 goroutine 队 列，M 从 P 上获得 goroutine 并执行，同时还负责部分内存的管理</li>
</ul>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d31hrzzjj30g608mwfr.jpg" alt="image.png" style="zoom:40%;" /></div>

<h5 id="2-8-GMP模型细节"><a href="#2-8-GMP模型细节" class="headerlink" title="2.8 GMP模型细节"></a><font color=DarkOrange>2.8 GMP模型细节</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d32u86bpj31ke0r8naq.jpg" alt="image.png" style="zoom:67%;" /></div>

<h5 id="2-9-G所处的位置"><a href="#2-9-G所处的位置" class="headerlink" title="2.9 G所处的位置"></a><font color=DarkOrange>2.9 G所处的位置</font></h5><ul>
<li>进程都有一个全局的 G 队列</li>
<li>每个 P 拥有自己的本地执行队列</li>
<li>有不在运行队列中的 G<ul>
<li>处于 channel 阻塞态的 G 被放在 sudog</li>
<li>脱离 P 绑定在 M 上的 G，如系统调用</li>
<li>为了复用，执行结束进入 P 的 gFree 列表中的 G</li>
</ul>
</li>
</ul>
<h5 id="2-10-Goroutine创建过程"><a href="#2-10-Goroutine创建过程" class="headerlink" title="2.10 Goroutine创建过程"></a><font color=DarkOrange>2.10 Goroutine创建过程</font></h5><ul>
<li>获取或者创建新的 Goroutine 结构体<ul>
<li>从处理器的 gFree 列表中查找空闲的 Goroutine</li>
<li>如果不存在空闲的 Goroutine，会通过 runtime.malg 创建一个栈大小足够的新结构体</li>
</ul>
</li>
<li>将函数传入的参数移到 Goroutine 的栈上</li>
<li>更新 Goroutine 调度相关的属性，更新状态为_Grunnable</li>
<li>返回的 Goroutine 会存储到全局变量 allgs 中</li>
</ul>
<h5 id="2-11-将Goroutine放到运行队列上"><a href="#2-11-将Goroutine放到运行队列上" class="headerlink" title="2.11 将Goroutine放到运行队列上"></a><font color=DarkOrange>2.11 将Goroutine放到运行队列上</font></h5><ul>
<li>Goroutine 设置到处理器的 runnext 作为下一个处理器执行的任务</li>
<li>当处理器的本地运行队列已经没有剩余空间时，就会把本地队列中的一部分 Goroutine 和待加入的 Goroutine通过 runtime.runqputslow 添加到调度器持有的全局运行队列上</li>
</ul>
<h5 id="2-12-调度器行为"><a href="#2-12-调度器行为" class="headerlink" title="2.12 调度器行为"></a><font color=DarkOrange>2.12 调度器行为</font></h5><ul>
<li>为了保证公平，当全局运行队列中有待执行的 Goroutine 时，通过 schedtick 保证有一定 几率会从全局的运行队列中查找对应的 Goroutine</li>
<li>从处理器本地的运行队列中查找待执行的 Goroutine</li>
<li>如果前两种方法都没有找到 Goroutine，会通过 runtime.findrunnable 进行阻塞地查找 Goroutine<ul>
<li>从本地运行队列、全局运行队列中查找</li>
<li>从网络轮询器中查找是否有 Goroutine 等待运行</li>
<li>通过 runtime.runqsteal 尝试从其他随机的处理器中窃取待运行的 Goroutine</li>
</ul>
</li>
</ul>
<h4 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3. 内存管理"></a><font color=DarkOrange>3. 内存管理</font></h4><h5 id="3-1-堆内存管理"><a href="#3-1-堆内存管理" class="headerlink" title="3.1 堆内存管理"></a><font color=DarkOrange>3.1 堆内存管理</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d372j1f5j31jw0isdn7.jpg" alt="image.png" style="zoom:50%;" /></div>

<ul>
<li>初始化连续内存块作为堆</li>
<li>有内存申请的时候，Allocator 从堆内存的未分配区域分割小内存块</li>
<li>用链表将已分配内存连接起来</li>
<li>需要信息描述每个内存块的元数据：大小，是否使用，下一个内存块的地址等</li>
</ul>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d38gftrpj316007uabs.jpg" alt="image.png" style="zoom:50%;" /></div>

<h5 id="3-2-TCMalloc"><a href="#3-2-TCMalloc" class="headerlink" title="3.2 TCMalloc"></a><font color=DarkOrange>3.2 TCMalloc</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d39qtrfpj31k00nu7fm.jpg" alt="image.png" style="zoom:67%;" /></div>

<ul>
<li><p>page:内存页，一块 8K 大小的内存空间。Go 与操作系统之间的内存申请和释放，都是以 page 为单位的</p>
</li>
<li><p>span: 内存块，一个或多个连续的 page 组成一个 span </p>
</li>
<li><p>sizeclass : 空间规格，每个 span 都带有一个 sizeclass ，标记着该 span 中的 page 应该如何 使用</p>
</li>
<li><p>object : 对象，用来存储一个变量数据内存空间，一个 span 在初始化时，会被切割成一堆等大 的 object ；假设 object 的大小是 16B ，span 大小是 8K ，那么就会把 span 中的 page 就会 被初始化 8K &#x2F; 16B &#x3D; 512 个 object 。所谓内存分配，就是分配一个 object 出去</p>
</li>
<li><p>对象大小定义</p>
<ul>
<li>小对象大小：0~256KB</li>
<li>中对象大小：256KB~1MB</li>
<li>大对象大小：&gt;1MB</li>
</ul>
</li>
<li><p>小对象的分配流程</p>
<ul>
<li>ThreadCache -&gt; CentralCache -&gt; HeapPage，大部分时候，ThreadCache 缓存都是足够的，不需要去访问 CentralCache 和 HeapPage，无系统调用配合无锁分配，分配效率是非常高的</li>
</ul>
</li>
<li><p>中对象分配流程</p>
<ul>
<li>直接在 PageHeap 中选择适当的大小即可，128 Page 的 Span 所保存的最大内存就是 1MB</li>
</ul>
</li>
<li><p>大对象分配流程</p>
<ul>
<li>从 large span set 选择合适数量的页面组成 span，用来存储数据</li>
</ul>
</li>
</ul>
<h5 id="3-3-Go语言内存分配"><a href="#3-3-Go语言内存分配" class="headerlink" title="3.3 Go语言内存分配"></a><font color=DarkOrange>3.3 Go语言内存分配</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d3d17knjj31kq0ni499.jpg" alt="image.png" style="zoom:67%;" /></div>

<ul>
<li><p>mcache：小对象的内存分配直接走</p>
<ul>
<li>size class 从 1 到 66，每个 class 两个 span</li>
<li>Span 大小是 8KB，按 span class 大小切分</li>
</ul>
</li>
<li><p>mcentral</p>
<ul>
<li>Span 内的所有内存块都被占用时，没有剩余空间继续分配对象，mcache 会向 mcentral 申请1个span，mcache 拿到 span 后继续分配对象</li>
<li>当 mcentral 向 mcache 提供 span 时，如果没有符合条件的 span，mcentral 会向 mheap 申请span</li>
</ul>
</li>
<li><p>mheap</p>
<ul>
<li>当 mheap 没有足够的内存时，mheap 会向 OS 申请内存</li>
<li>Mheap 把 Span 组织成了树结构，而不是链表</li>
<li>然后把 Span 分配到 heapArena 进行管理，它包含地址映射和 span 是否包含指针等位图<ul>
<li>为了更高效的分配、回收和再利用内存</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="3-4-内存回收"><a href="#3-4-内存回收" class="headerlink" title="3.4 内存回收"></a><font color=DarkOrange>3.4 内存回收</font></h5><ul>
<li>引用计数（Python，PHP，Swift）<ul>
<li>对每一个对象维护一个引用计数，当引用该对象的对象被销毁的时候，引用计数减 1，当引用计数为 0 的时候，回 收该对象</li>
<li>优点：对象可以很快的被回收，不会出现内存耗尽或达到某个阀值时才回收</li>
<li>缺点：不能很好的处理循环引用，而且实时维护引用计数，有也一定的代价</li>
</ul>
</li>
<li>标记-清除（Golang）<ul>
<li>从根变量开始遍历所有引用的对象，引用的对象标记为”被引用”，没有被标记的进行回收</li>
<li>优点：解决引用计数的缺点</li>
<li>缺点：需要 STW（stop the word），即要暂停程序运行</li>
</ul>
</li>
<li>分代收集（Java）<ul>
<li>按照生命周期进行划分不同的代空间，生命周期长的放入老年代，短的放入新生代，新生代的回收频率高于老年 代的频率</li>
</ul>
</li>
</ul>
<h5 id="3-5-mspan"><a href="#3-5-mspan" class="headerlink" title="3.5 mspan"></a><font color=DarkOrange>3.5 mspan</font></h5><ul>
<li>allocBits<ul>
<li>记录了每块内存分配的情况</li>
</ul>
</li>
<li>gcmarkBits<ul>
<li>记录了每块内存的引用情况，标记阶段对每块内存进行标记，有对象引用的内存标记为1，没有的标 记为 0</li>
</ul>
</li>
<li>这两个位图的数据结构是完全一致的，标记结束则进行内存回收，回收的时候，将 allocBits 指 向 gcmarkBits，标记过的则存在，未进行标记的则进行回收</li>
</ul>
<h5 id="3-6-GC工作流程"><a href="#3-6-GC工作流程" class="headerlink" title="3.6 GC工作流程"></a><font color=DarkOrange>3.6 GC工作流程</font></h5><p>Golang GC 的大部分处理是和用户代码并行的</p>
<ul>
<li>Mark：<ul>
<li>Mark Prepare: 初始化 GC 任务，包括开启写屏障 (write barrier) 和辅助 GC(mutator assist)，统计root对象的任 务数量等。这个过程需要STW</li>
<li>GC Drains: 扫描所有 root 对象，包括全局指针和 goroutine(G) 栈上的指针（扫描对应 G 栈时需停止该 G)，将其 加入标记队列(灰色队列)，并循环处理灰色队列的对象，直到灰色队列为空。该过程后台并行执行</li>
</ul>
</li>
<li>Mark Termination：完成标记工作，重新扫描(re-scan)全局指针和栈。因为 Mark 和用户程序是并行的，所以在 Mark 过 程中可能会有新的对象分配和指针赋值，这个时候就需要通过写屏障（write barrier）记录下来，re-scan 再检查一下，这 个过程也是会 STW 的</li>
<li>Sweep：按照标记结果回收所有的白色对象，该过程后台并行执行</li>
<li>Sweep Termination：对未清扫的 span 进行清扫, 只有上一轮的 GC 的清扫工作完成才可以开始新一轮的 GC</li>
</ul>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d3k484cmj31ci0ikwn9.jpg" alt="image.png" style="zoom:67%;" /></div>

<h5 id="3-7-三色标记"><a href="#3-7-三色标记" class="headerlink" title="3.7 三色标记"></a><font color=DarkOrange>3.7 三色标记</font></h5><ul>
<li>GC 开始时，认为所有 object 都是 白色，即垃圾</li>
<li>从 root 区开始遍历，被触达的 object 置成 灰色</li>
<li>遍历所有灰色 object，将他们内部的引用变量置成 灰色，自身置成 黑色</li>
<li>循环第 3 步，直到没有灰色 object 了，只剩下了黑白两种，白色的都是垃圾</li>
<li>对于黑色 object，如果在标记期间发生了写操作，写屏障会在真正赋值前将新对象标记为 灰色</li>
<li>标记过程中，mallocgc 新分配的 object，会先被标记成 黑色 再返回</li>
</ul>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d3lpvwr3j31bw0940tw.jpg" alt="image.png" style="zoom:50%;" /></div>

<h5 id="3-8-垃圾回收触发机制"><a href="#3-8-垃圾回收触发机制" class="headerlink" title="3.8 垃圾回收触发机制"></a><font color=DarkOrange>3.8 垃圾回收触发机制</font></h5><ul>
<li>内存分配量达到阀值触发 GC<ul>
<li>每次内存分配时都会检查当前内存分配量是否已达到阀值，如果达到阀值则立即启动 GC</li>
<li>阀值 &#x3D; 上次 GC 内存分配量 * 内存增长率</li>
<li>内存增长率由环境变量 GOGC 控制，默认为 100，即每当内存扩大一倍时启动 GC</li>
</ul>
</li>
<li>定期触发 GC<ul>
<li>默认情况下，最长 2 分钟触发一次 GC，这个间隔在 src&#x2F;runtime&#x2F;proc.go:forcegcperiod 变量中 被声明</li>
</ul>
</li>
<li>手动触发<ul>
<li>程序代码中也可以使用 runtime.GC()来手动触发 GC。这主要用于 GC 性能测试和统计</li>
</ul>
</li>
</ul>
<h4 id="4-包引用与依赖管理"><a href="#4-包引用与依赖管理" class="headerlink" title="4. 包引用与依赖管理"></a><font color=DarkOrange>4. 包引用与依赖管理</font></h4><h5 id="4-1-Go-语言依赖管理的演进"><a href="#4-1-Go-语言依赖管理的演进" class="headerlink" title="4.1 Go 语言依赖管理的演进"></a><font color=DarkOrange>4.1 Go 语言依赖管理的演进</font></h5><ul>
<li>回顾 GOPATH<ul>
<li>通过环境变量设置系统级的 Go 语言类库目录</li>
<li>GOPATH 的问题？<ul>
<li>不同项目可能依赖不同版本</li>
<li>代码被 clone 以后需要设置 GOPATH 才能编译</li>
</ul>
</li>
</ul>
</li>
<li>vendor<ul>
<li>自 1.6 版本，支持 vendor 目录，在每个 Go 语言项目中，创建一个名叫 vendor 的目录，并将依赖拷贝至该目录</li>
<li>Go 语言项目会自动将 vendor 目录作为自身的项目依赖路径</li>
<li>好处？<ul>
<li>每个项目的 vendor目录是独立的，可以灵活的选择版本</li>
<li>Vendor 目录与源代码一起 check in 到 github，其他人 checkout 以后可直接编译</li>
<li>无需在编译期间下载依赖包，所有依赖都已经与源代码保存在一起</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="4-2-vendor管理工具"><a href="#4-2-vendor管理工具" class="headerlink" title="4.2 vendor管理工具"></a><font color=DarkOrange>4.2 vendor管理工具</font></h5><p>通过声明式配置，实现 vendor 管理的自动化</p>
<ul>
<li>在早期，Go 语言无自带依赖管理工具，社区方案鱼龙混杂比较出名的包括<ul>
<li>Godeps, Glide</li>
</ul>
</li>
<li>Go 语言随后发布了自带的依赖管理工具 Gopkg</li>
<li>很快用新的工具 gomod 替换掉了 gopkg<ul>
<li>切换 mod 开启模式：export GO111MODULE&#x3D;on&#x2F;off&#x2F;auto</li>
<li>Go mod 相比之前的工具更灵活易用，以基本统一了 Go 语言依赖管理</li>
</ul>
</li>
</ul>
<h5 id="4-3-Go-mod使用"><a href="#4-3-Go-mod使用" class="headerlink" title="4.3 Go mod使用"></a><font color=DarkOrange>4.3 Go mod使用</font></h5><ul>
<li>创建项目</li>
<li>初始化 Go 模块<ul>
<li><code>go mod init</code></li>
</ul>
</li>
<li>下载依赖包<ul>
<li><code>go mod download</code>（下载的依赖包在$GOPATH&#x2F;pkg，如果没有设置 GOPATH，则下载在项目根目录&#x2F;pkg）</li>
<li>在源代码中使用某个依赖包，如 github.com&#x2F;emicklei&#x2F;go-restful</li>
</ul>
</li>
<li>添加缺少的依赖并为依赖包瘦身<ul>
<li><code>go mod tidy</code></li>
</ul>
</li>
<li>把 Go 依赖模块添加到 vendor 目录<ul>
<li><code>go mod vendor</code></li>
</ul>
</li>
</ul>
<p>配置细节会被保存在项目根目录的 go.mod 中</p>
<p>可在 require 或者 replacement 中指定版本</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">module k8s.io/apiserver</span><br><span class="line"><span class="keyword">go</span> <span class="number">1.13</span></span><br><span class="line">require (</span><br><span class="line">  github.com/evanphx/json-patch v4<span class="number">.9</span><span class="number">.0</span>+incompatible</span><br><span class="line">  github.com/<span class="keyword">go</span>-openapi/jsonreference v0<span class="number">.19</span><span class="number">.3</span> <span class="comment">// indirect</span></span><br><span class="line">  github.com/<span class="keyword">go</span>-openapi/spec v0<span class="number">.19</span><span class="number">.3</span></span><br><span class="line">  github.com/gogo/protobuf v1<span class="number">.3</span><span class="number">.2</span></span><br><span class="line">  github.com/google/<span class="keyword">go</span>-cmp v0<span class="number">.3</span><span class="number">.0</span></span><br><span class="line">  github.com/google/gofuzz v1<span class="number">.1</span><span class="number">.0</span></span><br><span class="line">  k8s.io/apimachinery v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20210518100737</span><span class="number">-44</span>f1264f7b6b</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">replace (</span><br><span class="line">  golang.org/x/crypto =&gt; golang.org/x/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200220183623</span>-bac4c82f6975</span><br><span class="line">  golang.org/x/text =&gt; golang.org/x/text v0<span class="number">.3</span><span class="number">.2</span></span><br><span class="line">  k8s.io/api =&gt; k8s.io/api v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20210518101910</span><span class="number">-53468e23</span>a787</span><br><span class="line">  k8s.io/apimachinery =&gt; k8s.io/apimachinery v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20210518100737</span><span class="number">-44</span>f1264f7b6b</span><br><span class="line">  k8s.io/client-<span class="keyword">go</span> =&gt; k8s.io/client-<span class="keyword">go</span> v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20210518104342</span>-fa3acefe68f3</span><br><span class="line">  k8s.io/component-base =&gt; k8s.io/component-base v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20210518111421</span><span class="number">-67</span>c12a31a26a</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h5 id="4-4-GOPROXY和GOPRIVATE"><a href="#4-4-GOPROXY和GOPRIVATE" class="headerlink" title="4.4 GOPROXY和GOPRIVATE"></a><font color=DarkOrange>4.4 GOPROXY和GOPRIVATE</font></h5><ul>
<li>GOPROXY<ul>
<li>为拉取 Go 依赖设置代理<ul>
<li><code>export GOPROXY=https://goproxy.cn</code></li>
</ul>
</li>
</ul>
</li>
<li>在设置 GOPROXY 以后，默认所有依赖拉取都需要经过 proxy 连接 git repo，拉取代码，并做 checksum 校验</li>
<li>某些私有代码仓库是 goproxy.cn 无法连接的，因此需要设置 GOPRIVATE 来声明私有代码仓库</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GOPRIVATE=*.corp.example.com</span><br><span class="line">GOPROXY=proxy.example.com</span><br><span class="line">GONOPROXY=myrepo.corp.example.com</span><br></pre></td></tr></table></figure>

<h4 id="5-Makefile"><a href="#5-Makefile" class="headerlink" title="5. Makefile"></a><font color=DarkOrange>5. Makefile</font></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root:</span><br><span class="line">	export ROOT=github.com/cncamp/golang;</span><br><span class="line">.PHONY: root</span><br><span class="line">release:</span><br><span class="line">  echo <span class="string">&quot;building httpserver binary&quot;</span></span><br><span class="line">  mkdir -p bin/amd64</span><br><span class="line">  CGO_ENABLED=<span class="number">0</span> GOOS=linux GOARCH=amd64 <span class="keyword">go</span> build -o bin/amd64 .</span><br><span class="line">.PHONY: release</span><br></pre></td></tr></table></figure>

<h4 id="6-动手编写一个HTTP-Server"><a href="#6-动手编写一个HTTP-Server" class="headerlink" title="6. 动手编写一个HTTP Server"></a><font color=DarkOrange>6. 动手编写一个HTTP Server</font></h4><h5 id="6-1-理解net-http包"><a href="#6-1-理解net-http包" class="headerlink" title="6.1 理解net.http包"></a><font color=DarkOrange>6.1 理解net.http包</font></h5><ul>
<li><p>注册 handle 处理函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">&quot;/healthz&quot;</span>, healthz)</span><br><span class="line"><span class="comment">//Use the default DefaultServeMux.</span></span><br><span class="line">ListenAndService</span><br><span class="line">err := http.ListenAndServe(<span class="string">&quot;:80&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义 handle 处理函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">healthz</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	io.WriteString(w, <span class="string">&quot;ok&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="6-2-阻塞IO模型"><a href="#6-2-阻塞IO模型" class="headerlink" title="6.2 阻塞IO模型"></a><font color=DarkOrange>6.2 阻塞IO模型</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d3y19ws9j31by0lin5s.jpg" alt="image.png" style="zoom:50%;" /></div>

<h5 id="6-3-非阻塞IO模型"><a href="#6-3-非阻塞IO模型" class="headerlink" title="6.3 非阻塞IO模型"></a><font color=DarkOrange>6.3 非阻塞IO模型</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d4695nkmj31dg0lmtjd.jpg" alt="image.png" style="zoom:50%;" /></div>

<h5 id="6-4-IO多路复用"><a href="#6-4-IO多路复用" class="headerlink" title="6.4 IO多路复用"></a><font color=DarkOrange>6.4 IO多路复用</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d477ndpqj31f20lo142.jpg" alt="image.png" style="zoom:50%;" /></div>

<h5 id="6-5-异步IO"><a href="#6-5-异步IO" class="headerlink" title="6.5 异步IO"></a><font color=DarkOrange>6.5 异步IO</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d4805ht4j318m0lmaif.jpg" alt="image.png" style="zoom:50%;" /></div>

<h5 id="6-6-Linux-epoll"><a href="#6-6-Linux-epoll" class="headerlink" title="6.6 Linux epoll"></a><font color=DarkOrange>6.6 Linux epoll</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d48xagndj31nm0tsqd5.jpg" alt="image.png" style="zoom:50%;" /></div>

<h5 id="6-7-Go-语言高性能httpserver的实现细节"><a href="#6-7-Go-语言高性能httpserver的实现细节" class="headerlink" title="6.7 Go 语言高性能httpserver的实现细节"></a><font color=DarkOrange>6.7 Go 语言高性能httpserver的实现细节</font></h5><p>Go 语言将协程与 fd 资源绑定</p>
<ul>
<li>一个 socket fd 与一个协程绑定</li>
<li>当 socket fd 未就绪时，将对应协程设置为 Gwaiting 状态，将 CPU 时间片让给其他协程</li>
<li>Go 语言 runtime 调度器进行调度唤醒协程时，检查 fd 是否就绪，如果就绪则将协程置为 Grunnable 并加入执行队列</li>
<li>协程被调度后处理 fd 数据</li>
</ul>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d4aae3tyj30vk0d60x7.jpg" alt="image.png" style="zoom:50%;" /></div>

<h4 id="7-调试"><a href="#7-调试" class="headerlink" title="7. 调试"></a><font color=DarkOrange>7. 调试</font></h4><h5 id="7-1-debug"><a href="#7-1-debug" class="headerlink" title="7.1 debug"></a><font color=DarkOrange>7.1 debug</font></h5><ul>
<li>gdb：<ul>
<li>Gccgo 原生支持 gdb，因此可以用 gdb 调试 Go 语言代码，但 dlv 对 Go 语言 debug 的支持比 gdb 更好</li>
<li>Gdb 对 Go 语言的栈管理，多线程支持等方面做的不够好，调试代码时可能有错乱现象</li>
</ul>
</li>
<li>dlv：<ul>
<li>Go 语言的专有 debugger</li>
</ul>
</li>
</ul>
<h5 id="7-2-dlv的配置"><a href="#7-2-dlv的配置" class="headerlink" title="7.2 dlv的配置"></a><font color=DarkOrange>7.2 dlv的配置</font></h5><ul>
<li>配置<ul>
<li>在 vscode 中配置 dlb</li>
<li>菜单：View -&gt; Command Palette</li>
<li>选择 Go : Install&#x2F;Update Tools，选择安装</li>
<li>安装完后，从改入口列表中可以看到 dlv 和 dlv-dap 已经安装好</li>
</ul>
</li>
<li>Debug 方法<ul>
<li>在代码中设置断点</li>
<li>菜单中选择 Run -&gt; Start Debugging 即可进入调试</li>
</ul>
</li>
</ul>
<h5 id="7-3-更多debug方法"><a href="#7-3-更多debug方法" class="headerlink" title="7.3 更多debug方法"></a><font color=DarkOrange>7.3 更多debug方法</font></h5><ul>
<li>添加日志<ul>
<li>在关键代码分支中加入日志</li>
<li>基于fmt包将日志输出到标准输出 stdout：<code>fmt.Println()</code></li>
<li>fmt 无日志重定向，无日志分级</li>
</ul>
</li>
<li>即与日志框架将日志输出到对应的 appender<ul>
<li>比如可利用 glog 进行日志输出<ul>
<li>可配置 appender，将标准输出转至文件</li>
<li>支持多级日志输出，可修改配置调整日志等级</li>
<li>自带时间戳和代码行，方便调试</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="7-4-Glog使用方法示例"><a href="#7-4-Glog使用方法示例" class="headerlink" title="7.4 Glog使用方法示例"></a><font color=DarkOrange>7.4 Glog使用方法示例</font></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/golang/glog&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Set(<span class="string">&quot;v&quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line">  glog.V(<span class="number">2</span>).Info(<span class="string">&quot;Starting http server...&quot;</span>)</span><br><span class="line">  mux := http.NewServeMux()</span><br><span class="line">  mux.HandleFunc(<span class="string">&quot;/&quot;</span>, rootHandler)</span><br><span class="line">  err := http.ListenAndServe(<span class="string">&quot;:80&quot;</span>, mux)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  	log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-5-性能分析（Performance-Profiling）"><a href="#7-5-性能分析（Performance-Profiling）" class="headerlink" title="7.5 性能分析（Performance Profiling）"></a><font color=DarkOrange>7.5 性能分析（Performance Profiling）</font></h5><p>CPU Profiling: 在代码中添加 CPUProfile 代码，runtime&#x2F;pprof 包提供支持</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cpuprofile = flag.String(<span class="string">&quot;cpuprofile&quot;</span>, <span class="string">&quot;&quot;</span> , <span class="string">&quot;write cpu profile to file&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Parse()</span><br><span class="line">  <span class="keyword">if</span> *cpuprofile != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    f, err := os.Create(*cpuprofile)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    	log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    pprof.StartCPUProfile(f)</span><br><span class="line">    <span class="keyword">defer</span> pprof.StopCPUProfile()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析 CPU 瓶颈</strong></p>
<ul>
<li><p>运行 cpuprofilie 代码后，会在 &#x2F;tmp&#x2F;cpuprofile 中记录 cpu 使用时间</p>
</li>
<li><p>运行 go tool pprof &#x2F;tmp&#x2F;cpuprofile 进入分析模式</p>
</li>
<li><p>运行 top10 查看 top 10线程，显示 30ms 花费在 main.main</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">30</span>ms, <span class="number">100</span>% of <span class="number">30</span>ms total</span><br><span class="line">flat flat% sum% cum cum%</span><br><span class="line"><span class="number">30</span>ms <span class="number">100</span>% <span class="number">100</span>% <span class="number">30</span>ms <span class="number">100</span>% main.main</span><br><span class="line"><span class="number">0</span> <span class="number">0</span>% <span class="number">100</span>% <span class="number">30</span>ms <span class="number">100</span>% runtime.main</span><br></pre></td></tr></table></figure>
</li>
<li><p>(pprof) list main.main 显示 30 毫秒都花费在循环上</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Total: <span class="number">30</span>ms</span><br><span class="line"><span class="number">30</span>ms <span class="number">30</span>ms (flat, cum) <span class="number">100</span>% of Total</span><br><span class="line"><span class="number">20</span>ms <span class="number">20</span>ms <span class="number">21</span>: <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++ &#123;</span><br><span class="line"><span class="number">10</span>ms <span class="number">10</span>ms <span class="number">22</span>: result += I</span><br></pre></td></tr></table></figure>
</li>
<li><p>可执行 web 命令生成 svg 文件，在通过浏览器打开 svg 文件查看图形化分析结果</p>
</li>
</ul>
<p><strong>其他可用 profiling 工具分析的问题</strong></p>
<ul>
<li>CPU profile<ul>
<li>程序的 CPU 使用情况，每 100 毫秒采集一次 CPU 使用情况</li>
</ul>
</li>
<li>Memory Profile<ul>
<li>程序的内存使用情况</li>
</ul>
</li>
<li>Block Profiling<ul>
<li>非运行态的 goroutine 细节，分析和查找死锁</li>
</ul>
</li>
<li>Goroutine Profiling<ul>
<li>所有 goroutines 的细节状态，有哪些 goroutine，它们的调用关系是怎样的</li>
</ul>
</li>
</ul>
<p><strong>针对 http 服务的 pprof</strong></p>
<ul>
<li><p>net&#x2F;http&#x2F;pprof 包提供支持</p>
</li>
<li><p>如果采用默认 mux handle，则只需 import _ “net&#x2F;http&#x2F;pprof”</p>
</li>
<li><p>如果采用自定义 mux handle，则需要注册 pprof handler</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startHTTP</span><span class="params">(addr <span class="type">string</span>, s *tnetd.Server)</span></span> &#123;</span><br><span class="line">  mux := http.NewServeMux()</span><br><span class="line">  mux.HandleFunc(“/debug/pprof/”, pprof.Index)</span><br><span class="line">  mux.HandleFunc(“/debug/pprof/profile”, pprof.Profile)</span><br><span class="line">  mux.HandleFunc(“/debug/pprof/symbol”, pprof.Symbol)</span><br><span class="line">  mux.HandleFunc(“/debug/pprof/trace”, pprof.Trace)</span><br><span class="line">  server := &amp;http.Server&#123;</span><br><span class="line">    Addr: addr,</span><br><span class="line">    Handler: mux,</span><br><span class="line">  &#125;</span><br><span class="line">  server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>分析 go profiling 结果</strong></p>
<p>在运行了开启 pprof 的服务器以后，可以通过访问对应的 URL 获得 profile 结果</p>
<ul>
<li>allocs: A sampling of all past memory allocations</li>
<li>block: Stack traces that led to blocking on synchronization primitives</li>
<li>cmdline: The command line invocation of the current program</li>
<li>goroutine: Stack traces of all current goroutines</li>
<li>heap: A sampling of memory allocations of live objects. You can specify the gc GET parameter to run GC before taking the heap sample</li>
</ul>
<p><strong>分析 go profiling 结果</strong></p>
<ul>
<li>mutex: Stack traces of holders of contended mutexes</li>
<li>profile: CPU profile. You can specify the duration in the seconds GET parameter. After you get the profile file, use the go tool pprof command to investigate the profile</li>
<li>threadcreate: Stack traces that led to the creation of new OS threads</li>
<li>trace: A trace of execution of the current program. You can specify the duration in the seconds GET parameter. After you get the trace file, use the go tool trace command to investigate the trace</li>
</ul>
<p><strong>结果分析示例</strong></p>
<ul>
<li>分析 goroutine 运行情况<ul>
<li><code>curl localhost/debug/pprof/goroutine?debug=2</code></li>
</ul>
</li>
<li>分析堆内存使用情况<ul>
<li><code>curl localhost/debug/pprof/heap?debug=2</code></li>
</ul>
</li>
</ul>
<h4 id="8-Kubernetes中常用代码解读"><a href="#8-Kubernetes中常用代码解读" class="headerlink" title="8. Kubernetes中常用代码解读"></a><font color=DarkOrange>8. Kubernetes中常用代码解读</font></h4><p>Rate Limit Queue</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ItemExponentialFailureRateLimiter)</span></span> When(item <span class="keyword">interface</span>&#123;&#125;) time.Duration &#123;</span><br><span class="line">  r.failuresLock.Lock()</span><br><span class="line">  <span class="keyword">defer</span> r.failuresLock.Unlock()</span><br><span class="line">  </span><br><span class="line">  exp := r.failures[item]</span><br><span class="line">  r.failures[item] = r.failures[item] + <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// The backoff is capped such that ‘calculated’ value never overflows.</span></span><br><span class="line">  backoff := <span class="type">float64</span>(r.baseDelay.Nanoseconds()) * math.Pow(<span class="number">2</span>, <span class="type">float64</span>(exp))</span><br><span class="line">  <span class="keyword">if</span> backoff &gt; math.MaxInt64 &#123;</span><br><span class="line">  	<span class="keyword">return</span> r.maxDelay</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  calculated := time.Duration(backoff)</span><br><span class="line">  <span class="keyword">if</span> calculated &gt; r.maxDelay &#123;</span><br><span class="line">  	<span class="keyword">return</span> r.maxDelay</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> calculated</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-Kubernetes日常运维中的代码调试场景"><a href="#9-Kubernetes日常运维中的代码调试场景" class="headerlink" title="9. Kubernetes日常运维中的代码调试场景"></a><font color=DarkOrange>9. Kubernetes日常运维中的代码调试场景</font></h4><h5 id="9-1-案例1：空指针"><a href="#9-1-案例1：空指针" class="headerlink" title="9.1 案例1：空指针"></a><font color=DarkOrange>9.1 案例1：空指针</font></h5><ul>
<li><p>问题描述</p>
<p>Kubenetes 调度器在调度有外挂存储需求的 pod 的时候，在获取节点信息失败 时会异常退出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic</span>: runtime <span class="type">error</span>: invalid memory address or <span class="literal">nil</span> pointer dereference [signal SIGSEGV: segmentation violation code=<span class="number">0x1</span> addr=<span class="number">0x0</span> pc=<span class="number">0x105e283</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>根因分析</p>
<p>nil pointe 是 Go 语言中最常出现的一类错误，也最容易判断，通常在 call stack 中就会告诉 你哪行代码有问题</p>
<p>在调度器 csi.go 中的如下代码，当 node 为 nil 的时候，对 node 的引用 node.Name 就会 引发空指针</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node := nodeInfo.Node()</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> framework.NewStatus(framework.Error, fmt.Sprintf(<span class="string">&quot;nodenot found: %s&quot;</span>, node.Name))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决办法</p>
<p>当指针为空时，不要继续引用</p>
<p>GitHub参考地址：<a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/pull/102229">点击跳转</a></p>
</li>
</ul>
<h5 id="9-2-案例2：Map-的读写冲突"><a href="#9-2-案例2：Map-的读写冲突" class="headerlink" title="9.2 案例2：Map 的读写冲突"></a><font color=DarkOrange>9.2 案例2：Map 的读写冲突</font></h5><ul>
<li><p>问题描述</p>
<p>程序在遍历 Kubernetes 对象的 Annotation 时异常退出</p>
</li>
<li><p>根因分析</p>
<p>Kubernetes 对象中 Label 和 Annotation 是 map[string]string</p>
<p>经常有代码需要修改这两个 Map</p>
<p>同时可能有其他线程 for…range 遍历</p>
</li>
<li><p>解决方法</p>
<ul>
<li>用 sync.RWMutex 加锁</li>
<li>使用线程安全 Map，比如 sync.Map{}</li>
</ul>
</li>
</ul>
<h5 id="9-3-案例3：kube-proxy消耗10个CPU"><a href="#9-3-案例3：kube-proxy消耗10个CPU" class="headerlink" title="9.3 案例3：kube-proxy消耗10个CPU"></a><font color=DarkOrange>9.3 案例3：kube-proxy消耗10个CPU</font></h5><ul>
<li><p>问题描述</p>
<p>客户汇报问题，kube-proxy 消耗了主机 10 个 CPU</p>
</li>
<li><p>根因分析</p>
<ul>
<li><p>登录问题机器，执行 top 命令查看 cpu 消耗，可以看到 kube-proxy 的 cpu 消耗和 pid 信息</p>
</li>
<li><p>对 kube-proxy 进程运行 System profiling tool，发现 10 个 CPU 中，超过 60% 的 CPU 都在做垃圾回收，这说明 GC 需要回收的对象太多了， 说明程序创建了大量可回收对象</p>
</li>
<li><p><code>perf top –p</code> </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Overhead Shared Obj Symbol</span><br><span class="line"><span class="number">26.48</span>% kube-proxy [.] runtime.gcDrain</span><br><span class="line"><span class="number">13.86</span>% kube-proxy [.] runtime.greyobject</span><br><span class="line"><span class="number">10.71</span>% kube-proxy [.] runtime.(*lfstack).pop</span><br><span class="line"><span class="number">10.04</span>% kube-proxy [.] runtime.scanobject</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 pprof 分析内存占用情况，<code>curl 127.0.0.1:10249/debug/pprof/heap?debug=2</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="number">245760</span> [<span class="number">301102</span>: <span class="number">73998827520</span>] @ <span class="number">0x11ddcda</span> <span class="number">0x11f306e</span> <span class="number">0x11f35f5</span> <span class="number">0x11fbdce</span> <span class="number">0x1204a8a</span> <span class="number">0x114ed76</span></span><br><span class="line"><span class="number">0x114eacb</span> <span class="number">0x11</span></span><br><span class="line"># &lt;font color=DarkOrange&gt;<span class="number">0x11ddcd9</span>&lt;/font&gt;</span><br><span class="line">k8s.io/kubernetes/vendor/github.com/vishvananda/netlink.(*Handle).RouteListFiltered+<span class="number">0x679</span></span><br><span class="line"># &lt;font color=DarkOrange&gt;<span class="number">0x11f306d</span> k8s.io/kubernetes/pkg/proxy/ipvs.(*netlinkHandle).GetLocalAddresses+<span class="number">0xed</span>&lt;/font&gt;</span><br><span class="line"># &lt;font color=DarkOrange&gt;<span class="number">0x11f35f4</span> k8s.io/kubernetes/pkg/proxy/ipvs.(*realIPGetter).NodeIPs+<span class="number">0x64</span>&lt;/font&gt;</span><br><span class="line"># &lt;font color=DarkOrange&gt;<span class="number">0x11fbdcd</span> k8s.io/kubernetes/pkg/proxy/ipvs.(*Proxier).syncProxyRules+<span class="number">0x47dd</span>&lt;/font&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>heap dump 分析</p>
<ul>
<li>GetLocalAddresses 函数调用创建了 301102 个对象，占用内存 73998827520</li>
<li>如此多的对象被创建，显然会导致 kube-proxy 进程忙于 GC，占用大量 CPU</li>
<li>对照代码分析 GetLocalAddresses 的实现，发现该函数的主要目的是获取节点本机 IP 地址，获取的方法是通过 ip route 命令获得当前节点所有 local 路由信息并转换成 go struct 并过滤掉 ipvs0网口上的路由信息</li>
<li><code>ip route show table local type local proto kernel</code></li>
<li>因为集群规模较大，该命令返回 5000 条左右记录，因此每次函数调用都会有数万个对象被生成</li>
<li>而 kube-proxy 在处理每一个服务的时候都会调用该方法，因为集群有数千个服务，因此，kube-proxy在反复调用该函数创建大量临时对象</li>
</ul>
</li>
<li><p>修复方法</p>
<p>函数调用提取到循环外</p>
<p>GitHub参考地址：<a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/pull/79444">点击跳转</a></p>
</li>
</ul>
<h5 id="9-4-案例4：线程池耗尽"><a href="#9-4-案例4：线程池耗尽" class="headerlink" title="9.4 案例4：线程池耗尽"></a><font color=DarkOrange>9.4 案例4：线程池耗尽</font></h5><ul>
<li><p>问题描述</p>
<p>在 Kubernetes 中有一个控制器，叫做 endpoint controller，该控制器符合生产者消费者模式，默认有5 个 worker 线程作为消费者。该消费者在处理请求时，可能调用的 LBaaS 的 API 更新负载均衡配置。我们 发现该控制器会时不时不工作，具体表现为，该做的配置变更没发生，相关日志也不打印了</p>
</li>
<li><p>根因分析</p>
<p>通过 pprof 打印出该进程的所有 go routine 信息，发现 worker 线程都卡在 http 请求调用处</p>
<p>当worker线程调用 LBaaS API 时，底层是 net&#x2F;http 包调用，而客户端在发起连接请求时，未设置客户端 超时时间。这导致当出现某些网络异常时，客户端会永远处于等待状态</p>
</li>
<li><p>解决方法</p>
<p>修改代码加入客户端超时控制</p>
</li>
</ul>
<hr>

      
      <blockquote>
        
        <strong>本文链接：</strong><br><a href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F02-%E7%BC%96%E5%86%99Go%E7%A8%8B%E5%BA%8F/">https://huajun-chen.github.io/2022/11/08/云原生02-编写Go程序/</a>
      </blockquote>
    </div>
    <footer class="mdui-card-actions">
      
        <a class="mdui-ripple article_categories-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
      
      
        <a class="mdui-ripple article_tags-link" href="/tags/Go/" rel="tag">Go</a><a class="mdui-ripple article_tags-link" href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" rel="tag">云原生</a>
      
    </footer>
    
  </article>
  
<script src="//cdn.bootcdn.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>

  <script>$("#main article .mdui-card-content img.fancybox").on("click",function(e){$.fancybox.open({src:$(this).attr("src")});});</script>


  <nav id="paginator">
    
      <a rel="prev" class="extend prev" href="/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F03-Docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/">
        <button aria-label="prev" class="mdui-btn mdui-btn-raised mdui-btn-icon mdui-color-theme-accent mdui-ripple"><i class="mdui-icon material-icons">arrow_back</i></button>
        <span class="mdui-p-x-3" mdui-tooltip="{content: '云原生03-Docker核心技术'}">上一篇</span>
      </a>
    
    <div class="spacer"></div>
    
      <a rel="next" class="extend next" href="/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F01-Go%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/">
        <span class="mdui-p-x-3" mdui-tooltip="{content: '云原生01-Go语言特性'}">下一篇</span>
        <button aria-label="next" class="mdui-btn mdui-btn-raised mdui-btn-icon mdui-color-theme-accent mdui-ripple"><i class="mdui-icon material-icons">arrow_forward</i></button>
      </a>
    
  </nav>




  <div style="position: fixed !important; left: 240px; top: 30%;">
    <button class="mdui-fab mdui-fab-mini mdui-ripple" mdui-menu="{target: '#toc'}"><i class="mdui-icon material-icons">toc</i></button>
    <ul class="mdui-menu" id="toc">
      <li class="mdui-menu-item" disabled><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E5%8A%A0%E9%94%81"><span class="toc-text">1. 线程加锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-%E9%94%81"><span class="toc-text">1.1 锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-Mutex%E7%A4%BA%E4%BE%8B"><span class="toc-text">1.2 Mutex示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-WaitGroup%E7%A4%BA%E4%BE%8B"><span class="toc-text">1.3 WaitGroup示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4-Cond%E7%A4%BA%E4%BE%8B"><span class="toc-text">1.4 Cond示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-text">2. 线程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-text">2.1 深入理解Go语言线程调度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-Linux%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8"><span class="toc-text">2.2 Linux进程的内存使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-CPU%E5%AF%B9%E5%86%85%E5%AD%98%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">2.3 CPU对内存的访问</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E5%BC%80%E9%94%80"><span class="toc-text">2.4 进程切换开销</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E5%BC%80%E9%94%80"><span class="toc-text">2.5 线程切换开销</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B"><span class="toc-text">2.6 用户线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-7-Goroutine"><span class="toc-text">2.7 Goroutine</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-8-GMP%E6%A8%A1%E5%9E%8B%E7%BB%86%E8%8A%82"><span class="toc-text">2.8 GMP模型细节</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-9-G%E6%89%80%E5%A4%84%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-text">2.9 G所处的位置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-10-Goroutine%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-text">2.10 Goroutine创建过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-11-%E5%B0%86Goroutine%E6%94%BE%E5%88%B0%E8%BF%90%E8%A1%8C%E9%98%9F%E5%88%97%E4%B8%8A"><span class="toc-text">2.11 将Goroutine放到运行队列上</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-12-%E8%B0%83%E5%BA%A6%E5%99%A8%E8%A1%8C%E4%B8%BA"><span class="toc-text">2.12 调度器行为</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">3. 内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">3.1 堆内存管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-TCMalloc"><span class="toc-text">3.2 TCMalloc</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-Go%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">3.3 Go语言内存分配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6"><span class="toc-text">3.4 内存回收</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-mspan"><span class="toc-text">3.5 mspan</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-6-GC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">3.6 GC工作流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-7-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0"><span class="toc-text">3.7 三色标记</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-8-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-text">3.8 垃圾回收触发机制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8C%85%E5%BC%95%E7%94%A8%E4%B8%8E%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86"><span class="toc-text">4. 包引用与依赖管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-Go-%E8%AF%AD%E8%A8%80%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="toc-text">4.1 Go 语言依赖管理的演进</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-vendor%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7"><span class="toc-text">4.2 vendor管理工具</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-Go-mod%E4%BD%BF%E7%94%A8"><span class="toc-text">4.3 Go mod使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-GOPROXY%E5%92%8CGOPRIVATE"><span class="toc-text">4.4 GOPROXY和GOPRIVATE</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Makefile"><span class="toc-text">5. Makefile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%8A%A8%E6%89%8B%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAHTTP-Server"><span class="toc-text">6. 动手编写一个HTTP Server</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-%E7%90%86%E8%A7%A3net-http%E5%8C%85"><span class="toc-text">6.1 理解net.http包</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B"><span class="toc-text">6.2 阻塞IO模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B"><span class="toc-text">6.3 非阻塞IO模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-4-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-text">6.4 IO多路复用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-5-%E5%BC%82%E6%AD%A5IO"><span class="toc-text">6.5 异步IO</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-Linux-epoll"><span class="toc-text">6.6 Linux epoll</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-7-Go-%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BDhttpserver%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-text">6.7 Go 语言高性能httpserver的实现细节</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E8%B0%83%E8%AF%95"><span class="toc-text">7. 调试</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1-debug"><span class="toc-text">7.1 debug</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-dlv%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-text">7.2 dlv的配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-%E6%9B%B4%E5%A4%9Adebug%E6%96%B9%E6%B3%95"><span class="toc-text">7.3 更多debug方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-4-Glog%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-text">7.4 Glog使用方法示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-5-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%EF%BC%88Performance-Profiling%EF%BC%89"><span class="toc-text">7.5 性能分析（Performance Profiling）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-Kubernetes%E4%B8%AD%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB"><span class="toc-text">8. Kubernetes中常用代码解读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-Kubernetes%E6%97%A5%E5%B8%B8%E8%BF%90%E7%BB%B4%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95%E5%9C%BA%E6%99%AF"><span class="toc-text">9. Kubernetes日常运维中的代码调试场景</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#9-1-%E6%A1%88%E4%BE%8B1%EF%BC%9A%E7%A9%BA%E6%8C%87%E9%92%88"><span class="toc-text">9.1 案例1：空指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-2-%E6%A1%88%E4%BE%8B2%EF%BC%9AMap-%E7%9A%84%E8%AF%BB%E5%86%99%E5%86%B2%E7%AA%81"><span class="toc-text">9.2 案例2：Map 的读写冲突</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-3-%E6%A1%88%E4%BE%8B3%EF%BC%9Akube-proxy%E6%B6%88%E8%80%9710%E4%B8%AACPU"><span class="toc-text">9.3 案例3：kube-proxy消耗10个CPU</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-4-%E6%A1%88%E4%BE%8B4%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%80%97%E5%B0%BD"><span class="toc-text">9.4 案例4：线程池耗尽</span></a></li></ol></li></ol></li>
    </ul>
  </div>


</main>
  <footer id="footer" class="mdui-m-t-5 mdui-p-y-3 mdui-color-theme">
  <div class="mdui-p-y-0 mdui-text-center">
    
    
    
    
    
    
    
    
    
    
    
    
  </div>
  <div class="mdui-p-y-1 mdui-text-center">
    Copyright &copy; 2022 可可西里<br>
    Powered by <a href="https://hexo.io/" target="_blank" class="mdui-text-color-theme-accent">Hexo</a>
    
  </div>
</footer>

  <button id="gotop" class="mdui-fab mdui-fab-fixed mdui-fab-hide mdui-color-theme-accent mdui-ripple"><i class="mdui-icon material-icons">arrow_upward</i></button>
  
  
<script src="/js/mdui.js"></script>
<script src="/js/script.js"></script>

  
<script src="/custom.js"></script>

</body>
</html>
