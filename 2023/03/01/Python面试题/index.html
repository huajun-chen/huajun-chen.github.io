<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <meta name="renderer" content="webkit">
<!--  <meta name="baidu-site-verification" content="code-ofAqabWYEE" />-->
  <meta name="google-site-verification" content="7_aCpLDu0s7bOCrqbIhiPhkHrFGEKMhTyXB5-my2L4g" />

  
  <title>Python面试题 | 可可西里-博客</title>

  <link rel="shortcut icon" href="/images/favicon.png">
  <link rel="alternate" href="/atom.xml" title="可可西里-博客" type="application/atom+xml">
  <meta name="description" content="Python常见面试题分享，涵盖了常见的Python面试八股文 Python语言特点 易学易用：Python语法简单明了，易于学习和上手，代码可读性强，使得开发效率高。 面向对象：Python支持面向对象编程（OOP），包括封装、继承、多态等OOP特性，可以更方便地组织代码和抽象问题。 解释型：Python是解释型语言，不需要编译过程，直接运行源代码，这使得开发和调试变得更加容易 动态类型：Pyt">
<meta property="og:type" content="article">
<meta property="og:title" content="Python面试题">
<meta property="og:url" content="https://huajun-chen.github.io/2023/03/01/Python%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="可可西里-博客">
<meta property="og:description" content="Python常见面试题分享，涵盖了常见的Python面试八股文 Python语言特点 易学易用：Python语法简单明了，易于学习和上手，代码可读性强，使得开发效率高。 面向对象：Python支持面向对象编程（OOP），包括封装、继承、多态等OOP特性，可以更方便地组织代码和抽象问题。 解释型：Python是解释型语言，不需要编译过程，直接运行源代码，这使得开发和调试变得更加容易 动态类型：Pyt">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-03-01T07:41:41.000Z">
<meta property="article:modified_time" content="2023-03-21T05:37:20.142Z">
<meta property="article:author" content="可可西里">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">

  <meta name="keywords" content=",Python">
  <meta name="format-detection" content="telephone=no,email=no">
  <meta name="theme-color" content="#9C27B0">

  <meta name="mobile-web-app-capable" content="yes">
  <meta name="application-name" content="可可西里-博客">
  <meta name="msapplication-starturl" content="https://huajun-chen.github.io/2023/03/01/Python%E9%9D%A2%E8%AF%95%E9%A2%98/">
  <meta name="msapplication-navbutton-color" content="#9C27B0">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="可可西里-博客">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="/images/favicon.png">

  
    <link rel="canonical" href="https://huajun-chen.github.io/2023/03/01/Python%E9%9D%A2%E8%AF%95%E9%A2%98/">
  

  
  

  
  
  

  
<link rel="stylesheet" href="/css/mdui.css">
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/custom.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body class="mdui-appbar-with-toolbar mdui-theme-primary-grey mdui-theme-accent-deep-purple">
  <script>var a=localStorage.getItem("mdui-theme-layout-dark");if(a){document.getElementsByTagName("body")[0].className+=" mdui-theme-layout-dark"};</script>
  <script>if(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches){document.getElementsByTagName("body")[0].className+=" mdui-theme-layout-dark"};</script>
  <script>var a=localStorage.getItem("mdui-drawer-close");if(!a){document.getElementsByTagName("body")[0].className+=" mdui-drawer-body-left"};</script>
  <header id="header" class="mdui-appbar mdui-appbar-fixed mdui-appbar-scroll-hide mdui-appbar-inset">
  <div class="mdui-toolbar mdui-color-theme">
    <a href="javascript:;" class="mdui-btn mdui-btn-icon" mdui-drawer="{target: '#sidebar', swipe: true}"><i class="mdui-icon material-icons">menu</i></a>
    <a href="/" class="mdui-typo-headline">可可西里-博客</a>
    <div class="mdui-toolbar-spacer"></div>
    <a href="javascript:;" class="mdui-btn mdui-btn-icon" mdui-dialog="{target: '#search'}" mdui-tooltip="{content: '搜索'}"><i class="mdui-icon material-icons">search</i></a>
    <a href="/atom.xml" class="mdui-btn mdui-btn-icon" mdui-tooltip="{content: 'RSS'}"><i class="mdui-icon material-icons">rss_feed</i></a>
<!--      <a href="javascript:;" class="mdui-btn mdui-btn-icon" mdui-drawer="{target: '#sidebar', swipe: true}" style="margin-right: 0px"><i class="mdui-icon material-icons" style="cursor:pointer">brightness_4</i></a>-->
      <a href="javascript:;" class="mdui-btn mdui-btn-icon" style="margin-right: 0px"><i class="mdui-icon material-icons" style="cursor:pointer">brightness_4</i></a>
      <div style="margin-left: 0px;cursor:pointer">长按切换</div>
  </div>
</header>
<div class="mdui-dialog" id="search">
  
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="请输入关键字"><input type="hidden" name="sitesearch" value="https://huajun-chen.github.io"></form>
    <div class="search-result"></div>
  
</div>

  <aside id="sidebar" class="mdui-drawer mdui-drawer-full-height">
  <script>var a=localStorage.getItem("mdui-drawer-close");if(a){document.getElementById("sidebar").className+=" mdui-drawer-close"};</script>
  <div class="mdui-grid-tile">
    <img src="/images/banner.png" style="height: 160px;">
    <img src="/images/avatar.png" class="avatar-animation" style="position: absolute; top: 10%; left: 24px; width: 64px; height: 64px; border: 2px solid #fff; border-radius: 50%;">
    <div class="mdui-grid-tile-actions">
      <div class="mdui-grid-tile-text">
        <div class="mdui-grid-tile-title">可可西里</div>
<!--        <div class="mdui-grid-tile-subtitle"><i class="mdui-icon material-icons">art_track</i>好好吃饭 好好睡觉 好好上班</div>-->
        <div class="mdui-grid-tile-subtitle">好好吃饭 好好睡觉 好好上班</div>
      </div>
      
        <div class="mdui-grid-tile-buttons">
          <a href="mailto:hellowuhan@protonmail.com" class="mdui-btn mdui-btn-icon" mdui-tooltip="{content: 'hellowuhan@protonmail.com'}"><i class="mdui-icon material-icons">email</i></a>
        </div>
      
    </div>
  </div>

  <div class="mdui-list" mdui-collapse="{accordion: true}">
    <a href="/" class="mdui-list-item mdui-ripple">
      <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-blue">home</i>
      <div class="mdui-list-item-content">主页</div>
    </a>
    <div class="mdui-collapse-item">
      <script>var a=localStorage.getItem("mdui-collapse-item-0");if(a){document.getElementsByClassName("mdui-collapse-item")[0].className+=" mdui-collapse-item-open"};</script>
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-deep-orange">archive</i>
        <div class="mdui-list-item-content">归档</div>
        <i class="mdui-collapse-item-arrow mdui-icon material-icons">keyboard_arrow_down</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
        
        <a class="mdui-ripple sidebar_archives-link" href="/archives/2023/03/">三月 2023<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2022/12/">十二月 2022<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2022/11/">十一月 2022<span class="mdui-ripple sidebar_archives-count">22</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2022/10/">十月 2022<span class="mdui-ripple sidebar_archives-count">10</span></a>
        
      </div>
    </div>
    <div class="mdui-collapse-item">
      <script>var a=localStorage.getItem("mdui-collapse-item-1");if(a){document.getElementsByClassName("mdui-collapse-item")[1].className+=" mdui-collapse-item-open"};</script>
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-green">class</i>
        <div class="mdui-list-item-content">分类</div>
        <i class="mdui-collapse-item-arrow mdui-icon material-icons">keyboard_arrow_down</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
        
        <a class="mdui-ripple sidebar_archives-link" href="/categories/%E5%8A%A0%E5%AF%86/">加密<span class="mdui-ripple sidebar_archives-count">3</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端<span class="mdui-ripple sidebar_archives-count">19</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试<span class="mdui-ripple sidebar_archives-count">14</span></a>
        
      </div>
    </div>
    <div class="mdui-collapse-item">
      <script>var a=localStorage.getItem("mdui-collapse-item-2");if(a){document.getElementsByClassName("mdui-collapse-item")[2].className+=" mdui-collapse-item-open"};</script>
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-brown">bookmark</i>
        <div class="mdui-list-item-content">标签</div>
        <i class="mdui-collapse-item-arrow mdui-icon material-icons">keyboard_arrow_down</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
        
        <a class="mdui-ripple sidebar_archives-link" href="/tags/ES/" rel="tag">ES<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/Go/" rel="tag">Go<span class="mdui-ripple sidebar_archives-count">6</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/Kafka/" rel="tag">Kafka<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/Linux/" rel="tag">Linux<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/Python/" rel="tag">Python<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" rel="tag">云原生<span class="mdui-ripple sidebar_archives-count">18</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%9E%B6%E6%9E%84/" rel="tag">系统设计与架构<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式<span class="mdui-ripple sidebar_archives-count">1</span></a>
        
      </div>
    </div>
    <a href="/about" class="mdui-list-item mdui-ripple">
      <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-purple">person</i>
      <div class="mdui-list-item-content">关于</div>
    </a>
  </div>

  <div class="mdui-divider"></div>

  <div class="mdui-list" mdui-collapse="{accordion: true}">
    
      <a href="/timeline" class="mdui-list-item mdui-ripple">时间轴</a>
    
      <a href="/tagcloud" class="mdui-list-item mdui-ripple">标签云</a>
    
      <a href="/gallery" class="mdui-list-item mdui-ripple">相册</a>
    
    <div class="mdui-collapse-item">
      <script>var a=localStorage.getItem("mdui-collapse-item-3");if(a){document.getElementsByClassName("mdui-collapse-item")[3].className+=" mdui-collapse-item-open"};</script>
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <div class="mdui-list-item-content">友情链接</div>
        <i class="mdui-list-item-icon mdui-icon material-icons">link</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
        
        
          <a href="javascript:;" class="mdui-list-item mdui-p-l-2 mdui-text-color-theme mdui-ripple" style="justify-content: center;">链接为空</a>
        
      </div>
    </div>
  </div>
</aside>

  <main id="main" class="mdui-m-t-5 fadeIn animated">
  
<link rel="stylesheet" href="//cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  <style>#main article .mdui-card-content .center-block{display:block!important;margin-right:auto!important;margin-left:auto!important}</style>
  <style>#main article .mdui-card-content .text-center{text-align:center!important}</style>
  <article class="mdui-card mdui-m-b-5">
    <header class="mdui-card-media">
      <img src="/images/random/material-12.png" style="max-height: 240px;">
      <div class="mdui-card-media-covered">
        <div class="mdui-card-primary">
          <div class="mdui-card-primary-title">Python面试题</div>
          <div class="mdui-card-primary-subtitle"><i class="iconfont">&#xe697;</i> 2023-03-01 / <i class="iconfont">&#xe601;</i> 可可西里</div>
        </div>
      </div>
      <div class="mdui-card-menu">
<!--        -->
<!--          <button class="mdui-btn mdui-btn-icon mdui-text-color-white" mdui-menu="{target: '#qrcode', align: 'right'}"><i class="mdui-icon material-icons">devices</i></button>-->
<!--          <ul class="mdui-menu" id="qrcode">-->
<!--            -->
<!--              <li class="mdui-menu-item"><a class="mdui-text-center mdui-ripple">发送到手机</a></li>-->
<!--            -->
<!--            <li class="mdui-menu-item" disabled>-->
<!--              -->
<!--                <img src="//qr.liantu.com/api.php?w=246&m=10&text=https://huajun-chen.github.io/2023/03/01/Python%E9%9D%A2%E8%AF%95%E9%A2%98/">-->
<!--              -->
<!--            </li>-->
<!--          </ul>-->
<!--        -->
        
          <button class="mdui-btn mdui-btn-icon mdui-text-color-white" mdui-menu="{target: '#share_menu', align: 'right'}"><i class="mdui-icon material-icons">share</i></button>
          <ul class="mdui-menu" id="share_menu">
            <li class="mdui-menu-item">
              <a href="https://service.weibo.com/share/share.php?appkey=&title=Python面试题&url=https://huajun-chen.github.io/2023/03/01/Python%E9%9D%A2%E8%AF%95%E9%A2%98/&pic=https://huajun-chen.github.io/images/favicon.png&searchPic=false&style=simple" target="_blank" class="mdui-ripple">分享到 Weibo</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://twitter.com/intent/tweet?text=Python面试题&url=https://huajun-chen.github.io/2023/03/01/Python%E9%9D%A2%E8%AF%95%E9%A2%98/&via=可可西里" target="_blank" class="mdui-ripple">分享到 Twitter</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://www.facebook.com/sharer/sharer.php?u=https://huajun-chen.github.io/2023/03/01/Python%E9%9D%A2%E8%AF%95%E9%A2%98/" target="_blank" class="mdui-ripple">分享到 Facebook</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://plus.google.com/share?url=https://huajun-chen.github.io/2023/03/01/Python%E9%9D%A2%E8%AF%95%E9%A2%98/" target="_blank" class="mdui-ripple">分享到 Google+</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://huajun-chen.github.io/2023/03/01/Python%E9%9D%A2%E8%AF%95%E9%A2%98/&title=Python面试题" target="_blank" class="mdui-ripple">分享到 LinkedIn</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://connect.qq.com/widget/shareqq/index.html?site=可可西里-博客&title=Python面试题&pics=https://huajun-chen.github.io/images/favicon.png&url=https://huajun-chen.github.io/2023/03/01/Python%E9%9D%A2%E8%AF%95%E9%A2%98/" target="_blank" class="mdui-ripple">分享到 QQ</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://telegram.me/share/url?url=https://huajun-chen.github.io/2023/03/01/Python%E9%9D%A2%E8%AF%95%E9%A2%98/&text=Python面试题" target="_blank" class="mdui-ripple">分享到 Telegram</a>
            </li>
          </ul>
        
      </div>
    </header>
    <div class="mdui-card-content mdui-typo">
      <p>Python常见面试题分享，涵盖了常见的Python面试八股文</p>
<h4 id="Python语言特点"><a href="#Python语言特点" class="headerlink" title="Python语言特点"></a><font color=DarkOrange>Python语言特点</font></h4><ol>
<li>易学易用：Python语法简单明了，易于学习和上手，代码可读性强，使得开发效率高。</li>
<li>面向对象：Python支持面向对象编程（OOP），包括封装、继承、多态等OOP特性，可以更方便地组织代码和抽象问题。</li>
<li>解释型：Python是解释型语言，不需要编译过程，直接运行源代码，这使得开发和调试变得更加容易</li>
<li>动态类型：Python是动态类型语言，不需要声明变量类型，可以根据需要动态改变变量类型，使得代码更加灵活。</li>
<li>跨平台：Python可以在各种操作系统上运行，包括Windows、Linux、Mac OS等，具有很强的跨平台性。</li>
<li>强大的标准库：Python标准库提供了大量的模块和函数，涵盖了网络编程、GUI编程、多线程编程、正则表达式等各种方面，开发者可以直接使用标准库来完成常见的任务，不需要从零开始编写</li>
<li>第三方库丰富：Python拥有众多的第三方库和框架，如NumPy、Pandas、Django等，可以快速实现各种功能，提高开发效率</li>
<li>可扩展性：Python可以通过C&#x2F;C++扩展模块来提高性能，还可以与其他语言进行混合编程。</li>
<li>开放源代码：Python是一种开放源代码语言，拥有大量的贡献者和用户社区，可以获得免费的开发工具和技术支持</li>
</ol>
<h4 id="1-Python的数据类型有哪些"><a href="#1-Python的数据类型有哪些" class="headerlink" title="1. Python的数据类型有哪些"></a><font color=DarkOrange>1. Python的数据类型有哪些</font></h4><ol>
<li>数字（number）：整数、浮点数和复数</li>
<li>字符串（string）：由字符组成的序列</li>
<li>列表（list）：由一组有序的值组成的序列，可修改</li>
<li>元组（tuple）：由一组有序的值组成的序列，不可修改</li>
<li>集合（set）：由一组唯一的、无序的值组成</li>
<li>字典（dict）：由一组键-值对组成的映射表</li>
<li>布尔值（bool）：表示True或False的值</li>
<li>空值（None）：表示没有值的对象，用None表示</li>
</ol>
<h4 id="2-Python可变与不可变数据类型的区别"><a href="#2-Python可变与不可变数据类型的区别" class="headerlink" title="2. Python可变与不可变数据类型的区别"></a><font color=DarkOrange>2. Python可变与不可变数据类型的区别</font></h4><ul>
<li>可变类型：可以修改其内容的数据类型，包括列表、集合和字典等。修改这些类型的值时，会直接在原始对象上进行修改，而不是创建一个新对象。例如，当向一个列表中添加一个元素时，列表的长度会发生变化，但其身份标识不会改变</li>
<li>不可变类型：一旦创建就不能更改其内容的数据类型，包括整数、浮点数、布尔值、元组和字符串等。如果对这些类型进行修改，将会创建一个新对象。例如，当对一个字符串进行切片或拼接时，会创建一个新的字符串对象</li>
</ul>
<p><strong>注意：</strong>可变类型的修改操作是原地修改，不可变类型的修改操作是创建一个新对象并返回</p>
<h4 id="3-Python列表和元组的区别"><a href="#3-Python列表和元组的区别" class="headerlink" title="3. Python列表和元组的区别"></a><font color=DarkOrange>3. Python列表和元组的区别</font></h4><ol>
<li>可变性：列表是可变的，可以在原地添加、删除或修改元素，而元组是不可变的，无法在原地进行修改操作。</li>
<li>语法：列表使用方括号 [] 来表示，元素之间用逗号分隔；元组使用圆括号 () 来表示，元素之间也用逗号分隔。如果元组只包含一个元素，需要在该元素后面添加一个逗号来表示它是一个元组而不是一个普通的值。</li>
<li>性能：元组相对于列表来说，在创建、遍历和访问元素时具有更高的性能，因为元组的结构是不可变的，因此在创建后不需要再进行修改，不会出现额外的开销</li>
<li>用途：列表通常用于需要添加、删除或修改元素的场景，如缓存数据、维护计数器、记录用户输入等；而元组通常用于存储一些固定的、不可变的数据，如坐标点、日期、时间等</li>
</ol>
<h4 id="4-Python列表的基本操作"><a href="#4-Python列表的基本操作" class="headerlink" title="4. Python列表的基本操作"></a><font color=DarkOrange>4. Python列表的基本操作</font></h4><ol>
<li>创建列表：使用方括号 [] 将一组元素括起来即可创建一个列表，例如：<code>a = [1, 2, 3, 4, 5]</code></li>
<li>索引和切片：可以使用索引和切片操作来访问列表中的元素，例如：<code>a[0]</code> 返回列表中的第一个元素，<code>a[1:3]</code> 返回列表中第二个到第四个元素。</li>
<li>修改元素：可以通过索引来修改列表中的元素，例如：<code>a[0] = 0</code> 将列表中的第一个元素修改为0</li>
<li>添加元素：可以使用 <code>append()</code> 方法向列表末尾添加一个元素，使用 <code>insert()</code> 方法在指定位置插入一个元素，例如：<code>a.append(6)</code>，<code>a.insert(0, 0)</code></li>
<li>删除元素：可以使用 <code>del</code> 语句、<code>remove()</code> 方法或 <code>pop()</code> 方法来删除列表中的元素，例如：<code>del a[0]</code> 删除列表中的第一个元素，<code>a.remove(3)</code> 删除列表中值为3的元素，<code>a.pop()</code> 删除并返回列表中的最后一个元素。</li>
<li>合并列表：可以使用 <code>+</code> 运算符将两个列表合并成一个新列表，例如：<code>a + [6, 7, 8]</code></li>
<li>复制列表：可以使用切片或 <code>copy()</code> 方法来复制一个列表，例如：<code>b = a[:]</code> 或 <code>b = a.copy()</code></li>
<li>获取列表长度：可以使用 <code>len()</code> 函数来获取列表的长度，例如：<code>len(a)</code> 返回列表 a 中元素的个数</li>
</ol>
<h4 id="5-Python中的列表推导式"><a href="#5-Python中的列表推导式" class="headerlink" title="5. Python中的列表推导式"></a><font color=DarkOrange>5. Python中的列表推导式</font></h4><p>Python中的列表推导式（List Comprehension）是一种简洁而强大的语法，可以快速地创建一个新的列表，语法形式为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[expression <span class="keyword">for</span> item <span class="keyword">in</span> iterable <span class="keyword">if</span> condition]</span><br></pre></td></tr></table></figure>

<p>其中，<code>expression</code> 是一个表达式，用于计算新列表中每个元素的值；<code>item</code> 是 iterable（可迭代对象）中的一个元素；<code>if condition</code> 是一个可选的条件语句，用于过滤 iterable 中的元素。</p>
<p>举个例子，假设我们需要创建一个列表，其中包含从 0 到 9 的所有偶数的平方，可以使用列表推导式来实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>上述代码首先使用 <code>range(10)</code> 函数生成一个从 0 到 9 的整数序列，然后通过 <code>if</code> 语句过滤出其中的偶数，最后对每个偶数进行平方运算并添加到新列表中。因此，<code>squares</code> 列表的值为 <code>[0, 4, 16, 36, 64]</code></p>
<p>除了基本形式外，列表推导式还支持嵌套、多个 <code>for</code> 循环和多个 <code>if</code> 条件语句的组合，可以根据需要进行组合和使用，以满足不同的需求。列表推导式具有简洁、高效和易读的特点</p>
<h4 id="6-Python删除list里的重复元素有几种方法"><a href="#6-Python删除list里的重复元素有几种方法" class="headerlink" title="6. Python删除list里的重复元素有几种方法"></a><font color=DarkOrange>6. Python删除list里的重复元素有几种方法</font></h4><ol>
<li><p>使用 set() 函数去重：将列表转换为 set 集合，再将其转换为列表即可，但是这种方法会改变列表元素的顺序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">lst = <span class="built_in">list</span>(<span class="built_in">set</span>(lst))</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># 输出 [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用列表推导式去重：利用列表推导式，遍历原列表，将不重复的元素添加到新列表中，缺点是需要额外的空间</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">new_lst = []</span><br><span class="line">[new_lst.append(i) <span class="keyword">for</span> i <span class="keyword">in</span> lst <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> new_lst]</span><br><span class="line"><span class="built_in">print</span>(new_lst)  <span class="comment"># 输出 [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 for 循环去重：利用 for 循环遍历原列表，将不重复的元素添加到新列表中，这种方法比较简单但速度较慢</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">new_lst = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lst:</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> new_lst:</span><br><span class="line">        new_lst.append(i)</span><br><span class="line"><span class="built_in">print</span>(new_lst)  <span class="comment"># 输出 [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用字典的 fromkeys() 方法去重：利用字典的键不能重复的特性，将列表中的元素作为字典的键，再将字典的键转换为列表即可，但是这种方法也会改变列表元素的顺序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">lst = <span class="built_in">list</span>(<span class="built_in">dict</span>.fromkeys(lst))</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># 输出 [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>注意：</strong>这些方法各有优缺点，可以根据实际情况选择使用，常见的方法有 set() 函数和列表推导式，因为它们简单、直观且效率高</p>
<h4 id="7-Python类型转换"><a href="#7-Python类型转换" class="headerlink" title="7. Python类型转换"></a><font color=DarkOrange>7. Python类型转换</font></h4><ol>
<li><code>int(x)</code>：将 x 转换为一个整数。如果 x 无法转换为整数，则会抛出 ValueError 异常</li>
<li><code>float(x)</code>：将 x 转换为一个浮点数。如果 x 无法转换为浮点数，则会抛出 ValueError 异常。</li>
<li><code>str(x)</code>：将 x 转换为一个字符串。如果 x 无法转换为字符串，则会抛出 TypeError 异常</li>
<li><code>bool(x)</code>：将 x 转换为一个布尔值。如果 x 为假值（如空字符串、0、False），则返回 False，否则返回 True。</li>
<li><code>list(x)</code>：将 x 转换为一个列表。如果 x 不可迭代或没有实现 <strong>iter</strong> 方法，则会抛出 TypeError 异常</li>
<li><code>tuple(x)</code>：将 x 转换为一个元组。如果 x 不可迭代或没有实现 <strong>iter</strong> 方法，则会抛出 TypeError 异常</li>
<li><code>set(x)</code>：将 x 转换为一个集合。如果 x 不可迭代或没有实现 <strong>iter</strong> 方法，则会抛出 TypeError 异常。</li>
<li><code>dict(x)</code>：将 x 转换为一个字典。如果 x 不是映射类型（如字典或实现了 <strong>getitem</strong> 方法的类），则会抛出 TypeError 异常</li>
</ol>
<p><strong>注意：</strong>类型转换时可能会出现异常，因此在进行类型转换时需要注意错误处理，避免程序崩溃。同时，Python 中还有其他一些类型转换函数，如 <code>complex()</code> 用于将字符串或数字转换为复数、<code>bytes()</code> 用于将字符串或整数转换为字节串等，可以根据需要进行使用</p>
<h4 id="8-Python字典以及基本操作"><a href="#8-Python字典以及基本操作" class="headerlink" title="8. Python字典以及基本操作"></a><font color=DarkOrange>8. Python字典以及基本操作</font></h4><p>Python 中的字典是一种无序的可变集合，它包含键和对应的值。字典中的键必须是不可变的类型，例如整数、字符串、元组等，而值可以是任何类型</p>
<ol>
<li><p>创建字典：可以使用花括号 {} 或 dict() 函数来创建一个空字典，或者使用键值对的方式来初始化一个字典</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建空字典</span></span><br><span class="line">my_dict = &#123;&#125;</span><br><span class="line">my_dict = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化字典</span></span><br><span class="line">my_dict = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;</span><br><span class="line">my_dict = <span class="built_in">dict</span>(name=<span class="string">&#x27;Alice&#x27;</span>, age=<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加或更新键值对：可以使用赋值运算符或 <code>update()</code> 方法来添加或更新字典中的键值对</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加键值对</span></span><br><span class="line">my_dict[<span class="string">&#x27;gender&#x27;</span>] = <span class="string">&#x27;female&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新键值对</span></span><br><span class="line">my_dict[<span class="string">&#x27;age&#x27;</span>] = <span class="number">21</span></span><br><span class="line">my_dict.update(&#123;<span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;female&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">21</span>&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除键值对：可以使用 <code>del</code> 关键字或 <code>pop()</code> 方法来删除字典中的键值对</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除键值对</span></span><br><span class="line"><span class="keyword">del</span> my_dict[<span class="string">&#x27;gender&#x27;</span>]</span><br><span class="line">my_dict.pop(<span class="string">&#x27;age&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问键值对：可以使用键来访问字典中的值，如果键不存在则会抛出 <code>KeyError</code> 异常。可以使用 <code>get()</code> 方法来避免这种情况，并返回一个默认值（默认为 <code>None</code>）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问键值对</span></span><br><span class="line">name = my_dict[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">age = my_dict.get(<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line">gender = my_dict.get(<span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;unknown&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历字典：可以使用 <code>for</code> 循环来遍历字典的键或值，或者使用 <code>items()</code> 方法来遍历键值对</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 遍历键</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> my_dict:</span><br><span class="line">    <span class="built_in">print</span>(key)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历值</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> my_dict.values():</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历键值对</span></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> my_dict.items():</span><br><span class="line">    <span class="built_in">print</span>(key, value)</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他方法：字典还提供了一些其他常用的方法，例如 <code>keys()</code> 方法用于获取所有键的视图，<code>values()</code> 方法用于获取所有值的视图，<code>clear()</code> 方法用于清空字典等</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取键的视图</span></span><br><span class="line">keys = my_dict.keys()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取值的视图</span></span><br><span class="line">values = my_dict.values()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空字典</span></span><br><span class="line">my_dict.clear()</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>注意：</strong>字典是一种无序的数据结构，因此不能通过下标来访问字典中的元素，而是需要使用键来访问相应的值。另外，字典中的键必须是唯一的，如果有多个相同的键，则后面的键值对会覆盖前面的</p>
<h4 id="9-Python中的list和dict是怎么实现的"><a href="#9-Python中的list和dict是怎么实现的" class="headerlink" title="9. Python中的list和dict是怎么实现的"></a><font color=DarkOrange>9. Python中的list和dict是怎么实现的</font></h4><ol>
<li>列表的实现方式：Python 中的列表是一种动态数组，它实际上是一个由一系列连续的内存块组成的结构。每个元素都存储在内存中的一个单独的位置，通过索引可以直接访问相应位置的元素。当列表的长度发生变化时，Python 会重新分配一块更大或更小的内存空间来存储新的元素，然后将原来的元素拷贝到新的内存空间中。由于这种实现方式需要频繁地分配和拷贝内存，因此当列表较大时会带来一定的性能开销。</li>
<li>字典：Python 中的字典采用了一种哈希表的实现方式，它通过将键映射到内存地址来实现快速的键值查找。具体来说，字典实际上是一个由哈希桶组成的数组，每个哈希桶中存储着一条链表，链表中的每个节点都包含了一个键值对。当插入一个新的键值对时，Python 会根据键的哈希值将其插入到对应的哈希桶中，如果发现冲突则会将新的节点插入到链表的末尾。当查找一个键值对时，Python 首先计算键的哈希值，然后在相应的哈希桶中查找对应的链表，最后在链表中遍历查找相应的节点。由于哈希表的查找操作复杂度为 O(1)，因此字典在查找键值对时具有很高的效率。当字典中的键值对数量变化时，Python 会根据需要动态调整哈希表的大小，以保证哈希桶的装载因子在一个合理的范围内</li>
</ol>
<p><strong>注意：</strong>列表和字典的实现方式不仅影响它们的性能，还影响了它们的特性和用法。例如，由于列表是一种连续的内存结构，因此可以使用切片和排序等操作来修改和排序列表中的元素；而由于字典是一种哈希表结构，因此它不支持切片和排序等操作，但支持键值查找和更新等操作</p>
<h4 id="10-Python字符串格式化的几种方式"><a href="#10-Python字符串格式化的几种方式" class="headerlink" title="10. Python字符串格式化的几种方式"></a><font color=DarkOrange>10. Python字符串格式化的几种方式</font></h4><ol>
<li><p>使用 % 运算符：可以使用 % 运算符将变量插入到字符串中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;Alice&quot;</span></span><br><span class="line">age = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My name is %s and I am %d years old.&quot;</span> % (name, age))</span><br></pre></td></tr></table></figure>

<p>输出结果为：<code>My name is Alice and I am 20 years old.</code></p>
</li>
<li><p>使用 format() 方法：可以使用 format() 方法将变量插入到字符串中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;Bob&quot;</span></span><br><span class="line">age = <span class="number">25</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My name is &#123;&#125; and I am &#123;&#125; years old.&quot;</span>.<span class="built_in">format</span>(name, age))</span><br></pre></td></tr></table></figure>

<p>输出结果为：<code>My name is Bob and I am 25 years old.</code></p>
</li>
<li><p>使用 f-string：可以使用 f-string 将变量插入到字符串中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;Charlie&quot;</span></span><br><span class="line">age = <span class="number">30</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;My name is <span class="subst">&#123;name&#125;</span> and I am <span class="subst">&#123;age&#125;</span> years old.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>输出结果为：<code>My name is Charlie and I am 30 years old.</code></p>
</li>
<li><p>使用模板字符串：可以使用模板字符串来格式化字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> Template</span><br><span class="line"></span><br><span class="line">name = <span class="string">&quot;Dave&quot;</span></span><br><span class="line">age = <span class="number">35</span></span><br><span class="line"></span><br><span class="line">template = Template(<span class="string">&quot;My name is $name and I am $age years old.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(template.substitute(name=name, age=age))</span><br></pre></td></tr></table></figure>

<p>输出结果为：<code>My name is Dave and I am 35 years old.</code></p>
</li>
</ol>
<h4 id="11-Python中-args和-kwargs"><a href="#11-Python中-args和-kwargs" class="headerlink" title="11. Python中*args和**kwargs"></a><font color=DarkOrange>11. Python中*args和**kwargs</font></h4><p>Python 中，<code>*args</code> 和 <code>**kwargs</code> 用于在函数定义时接受任意数量的参数，<strong>只能放在参数的最后位置</strong></p>
<ol>
<li><p><code>*args</code>：<code>*args</code> 表示接受任意数量的位置参数（Positional Arguments），这些参数将被作为元组传递给函数。具体来说，当函数定义时使用 <code>*args</code> 时，它可以接受任意数量的位置参数，这些参数将被打包成一个元组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        <span class="built_in">print</span>(arg)</span><br><span class="line"></span><br><span class="line">my_func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment"># 输出结果为：1 2 3</span></span><br><span class="line">my_func(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>)  <span class="comment"># 输出结果为：a b c d</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，函数 <code>my_func()</code> 使用了 <code>*args</code>，它可以接受任意数量的位置参数，并将它们打包成一个元组。在函数内部，我们可以使用 <code>for</code> 循环遍历元组中的每个元素</p>
</li>
<li><p><code>**kwargs</code>：<code>**kwargs</code> 表示接受任意数量的关键字参数（Keyword Arguments），这些参数将被作为字典传递给函数。具体来说，当函数定义时使用 <code>**kwargs</code> 时，它可以接受任意数量的关键字参数，这些参数将被打包成一个字典</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>(<span class="params">**kwargs</span>):</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;key&#125;</span> = <span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">my_func(name=<span class="string">&quot;Alice&quot;</span>, age=<span class="number">20</span>)  <span class="comment"># 输出结果为：name = Alice, age = 20</span></span><br><span class="line">my_func(country=<span class="string">&quot;USA&quot;</span>, city=<span class="string">&quot;New York&quot;</span>, language=<span class="string">&quot;English&quot;</span>)  <span class="comment"># 输出结果为：country = USA, city = New York, language = English</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，函数 <code>my_func()</code> 使用了 <code>**kwargs</code>，它可以接受任意数量的关键字参数，并将它们打包成一个字典。在函数内部，我们可以使用字典的 <code>items()</code> 方法遍历字典中的每个键值对</p>
</li>
<li><p>除了在函数定义时使用 <code>*args</code> 和 <code>**kwargs</code> 外，它们还可以在函数调用时使用。当在函数调用时使用 <code>*args</code> 和 <code>**kwargs</code> 时，它们的作用是将一个序列或字典拆包成多个参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;a = <span class="subst">&#123;a&#125;</span>, b = <span class="subst">&#123;b&#125;</span>, c = <span class="subst">&#123;c&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">my_func(*args)  <span class="comment"># 等价于 my_func(1, 2, 3)</span></span><br><span class="line"></span><br><span class="line">kwargs = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>, <span class="string">&quot;c&quot;</span>: <span class="number">3</span>&#125;</span><br><span class="line">my_func(**kwargs)  <span class="comment"># 等价于 my_func(a=1, b=2, c=3)</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们首先定义了一个函数 <code>my_func()</code>，它接受三个位置参数。然后，我们定义了一个元组 <code>args</code> 和一个字典 <code>kwargs</code>，分别包含三个元素和三个键值对</p>
</li>
</ol>
<h4 id="12-Python中深拷贝和浅拷贝的区别"><a href="#12-Python中深拷贝和浅拷贝的区别" class="headerlink" title="12. Python中深拷贝和浅拷贝的区别"></a><font color=DarkOrange>12. Python中深拷贝和浅拷贝的区别</font></h4><p>Python 中的拷贝操作分为浅拷贝（Shallow Copy）和深拷贝（Deep Copy），它们的主要区别在于复制后的对象是否共享内存</p>
<ol>
<li><p>浅拷贝：指创建一个新的对象，但是这个新对象只是原始对象的一个副本，它们共享相同的内存地址。也就是说，当我们修改其中一个对象时，另一个对象也会被修改。在 Python 中，可以使用 <code>copy()</code> 方法或切片操作来进行浅拷贝</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 浅拷贝示例</span></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">list2 = list1.copy()  <span class="comment"># 浅拷贝</span></span><br><span class="line">list1[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">list1[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">300</span></span><br><span class="line"><span class="built_in">print</span>(list1)  <span class="comment"># [100, 2, [300, 4]]</span></span><br><span class="line"><span class="built_in">print</span>(list2)  <span class="comment"># [1, 2, [300, 4]]</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们创建了一个包含三个元素的列表 <code>list1</code>，其中第三个元素是一个嵌套列表。然后，我们对 <code>list1</code> 进行了浅拷贝，得到了一个新的列表 <code>list2</code>。接着，我们修改了 <code>list1</code> 的第一个元素和第三个元素的第一个元素，然后打印出了 <code>list1</code> 和 <code>list2</code>。可以看到，虽然 <code>list1</code> 和 <code>list2</code> 是不同的对象，但是它们共享了第三个元素的内存地址，所以修改其中一个对象的值也会影响另一个对象的值</p>
</li>
<li><p>深拷贝：指创建一个新的对象，并且递归地复制它所包含的所有对象。也就是说，当我们修改其中一个对象时，另一个对象不会受到影响。在 Python 中，可以使用 <code>copy.deepcopy()</code> 方法进行深拷贝</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 深拷贝示例</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">list2 = copy.deepcopy(list1)  <span class="comment"># 深拷贝</span></span><br><span class="line">list1[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">list1[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">300</span></span><br><span class="line"><span class="built_in">print</span>(list1)  <span class="comment"># [100, 2, [300, 4]]</span></span><br><span class="line"><span class="built_in">print</span>(list2)  <span class="comment"># [1, 2, [3, 4]]</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们使用 <code>copy.deepcopy()</code> 方法对 <code>list1</code> 进行了深拷贝，得到了一个新的列表 <code>list2</code>。然后，我们修改了 <code>list1</code> 的第一个元素和第三个元素的第一个元素，然后打印出了 <code>list1</code> 和 <code>list2</code>。可以看到，虽然 <code>list1</code> 和 <code>list2</code> 是不同的对象，并且它们不共享任何内存地址，所以修改其中一个对象的值不会影响另一个对象的值</p>
</li>
</ol>
<h4 id="13-Python中的单引号和双引号的区别"><a href="#13-Python中的单引号和双引号的区别" class="headerlink" title="13. Python中的单引号和双引号的区别"></a><font color=DarkOrange>13. Python中的单引号和双引号的区别</font></h4><p>单引号和双引号都可以用来表示字符串，它们的主要区别在于字符串中是否包含了引号本身</p>
<p>单引号用来表示包含双引号的字符串，双引号用来表示包含单引号的字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用单引号表示包含双引号的字符串</span></span><br><span class="line">str1 = <span class="string">&#x27;I said, &quot;Hello!&quot;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(str1)  <span class="comment"># I said, &quot;Hello!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用双引号表示包含单引号的字符串</span></span><br><span class="line">str2 = <span class="string">&quot;It&#x27;s a beautiful day.&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str2)  <span class="comment"># It&#x27;s a beautiful day.</span></span><br></pre></td></tr></table></figure>

<p>在 Python 中，还有一种特殊的字符串格式，称为三引号（Triple quotes）。它可以用来表示包含多行文本的字符串，不需要在每行文本中使用转义字符</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用三引号表示多行字符串</span></span><br><span class="line">str3 = <span class="string">&#x27;&#x27;&#x27;Hello,</span></span><br><span class="line"><span class="string">           world!</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(str3)</span><br><span class="line"><span class="comment"># Hello,</span></span><br><span class="line"><span class="comment">#            world!</span></span><br></pre></td></tr></table></figure>

<p>上面的示例中，我们使用三引号来表示包含多行文本的字符串，这样可以避免在每行文本中使用转义字符，使代码更加简洁易读</p>
<h4 id="14-Python中append、insert和extend的区别"><a href="#14-Python中append、insert和extend的区别" class="headerlink" title="14. Python中append、insert和extend的区别"></a><font color=DarkOrange>14. Python中append、insert和extend的区别</font></h4><p>在 Python 中，<code>append()</code>、<code>insert()</code> 和 <code>extend()</code> 都是用来向列表（list）中添加元素的方法</p>
<ol>
<li><p><code>append</code>: 在列表末尾添加一个元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">lst.append(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>insert</code>: 在指定位置插入一个元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">lst.insert(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [1, 4, 2, 3]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>extend</code>: 将一个列表的所有元素添加到另一个列表的末尾</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lst1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">lst2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">lst1.extend(lst2)</span><br><span class="line"><span class="built_in">print</span>(lst1)  <span class="comment"># [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="15-Python中break、continue、pass是什么"><a href="#15-Python中break、continue、pass是什么" class="headerlink" title="15. Python中break、continue、pass是什么"></a><font color=DarkOrange>15. Python中break、continue、pass是什么</font></h4><p>在 Python 中，<code>break</code>、<code>continue</code> 和 <code>pass</code> 都是控制语句，用于控制循环的执行流程</p>
<ul>
<li><code>break</code> 语句用于终止循环，并跳出循环体。当循环条件不成立或者执行 <code>break</code> 语句时，循环会立即停止执行。</li>
<li><code>continue</code> 语句用于跳过当前循环中的某些语句，直接进入下一次循环的判断。当 <code>continue</code> 语句执行时，循环体中后续的语句都不会执行，而是直接跳到下一次循环的判断</li>
<li><code>pass</code> 语句用于占位，表示一个空语句。当需要在代码中添加一个空语句，但是又不能让 Python 报错时，就可以使用 <code>pass</code> 语句</li>
</ul>
<h4 id="16-Python中的remove、del和pop"><a href="#16-Python中的remove、del和pop" class="headerlink" title="16. Python中的remove、del和pop"></a><font color=DarkOrange>16. Python中的remove、del和pop</font></h4><p>在 Python 中，<code>remove</code>、<code>del</code> 和 <code>pop</code> 都是用来删除列表元素的方法</p>
<ol>
<li><p><code>remove</code> ：列表的内置函数，用于删除列表中指定的元素。如果列表中有多个相同的元素，它只会删除第一个匹配项，如果元素不存在则会抛出 <code>ValueError</code> 异常。如果要删除所有匹配项，可以使用循环或列表推导式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">lst.remove(<span class="number">3</span>)  <span class="comment"># 从列表中删除元素 3</span></span><br><span class="line"><span class="built_in">print</span>(lst)     <span class="comment"># [1, 2, 4, 5]</span></span><br><span class="line">lst.remove(<span class="number">6</span>)  <span class="comment"># 抛出 ValueError 异常，因为元素 6 不存在于列表中</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>del</code> ：Python的关键字，用于删除列表中指定位置的元素。它可以删除单个元素，也可以删除切片。如果删除的是切片，则删除的是切片中的所有元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">del</span> lst[<span class="number">2</span>]   <span class="comment"># 从列表中删除索引为 2 的元素，即元素 3</span></span><br><span class="line"><span class="built_in">print</span>(lst)   <span class="comment"># [1, 2, 4, 5]</span></span><br><span class="line"><span class="keyword">del</span> lst[<span class="number">10</span>]  <span class="comment"># 抛出 IndexError 异常，因为索引 10 超出了列表的长度</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>pop</code> ：列表的内置函数，用于删除列表中指定位置的元素并返回该元素。如果没有指定位置，则默认删除最后一个元素。如果要删除的位置不存在，则会引发IndexError异常</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">x = lst.pop(<span class="number">2</span>)  <span class="comment"># 删除索引为 2 的元素，即元素 3，并将其赋值给变量 x</span></span><br><span class="line"><span class="built_in">print</span>(x)        <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(lst)      <span class="comment"># [1, 2, 4, 5]</span></span><br><span class="line">x = lst.pop()   <span class="comment"># 删除最后一个元素，即元素 5，并将其赋值给变量 x</span></span><br><span class="line"><span class="built_in">print</span>(x)        <span class="comment"># 5</span></span><br><span class="line"><span class="built_in">print</span>(lst)      <span class="comment"># [1, 2, 4]</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>注意：</strong>如果需要删除列表中所有元素，可以使用 <code>lst.clear()</code> 方法</p>
<h4 id="17-Python中-x3D-x3D-和is的区别"><a href="#17-Python中-x3D-x3D-和is的区别" class="headerlink" title="17. Python中&#x3D;&#x3D;和is的区别"></a><font color=DarkOrange>17. Python中&#x3D;&#x3D;和is的区别</font></h4><ol>
<li><code>==</code> 运算符用于比较两个对象的值是否相等，它会比较对象的内容而不是它们的身份标识（内存地址）</li>
<li><code>is</code> 运算符用于比较两个对象的内存地址是否相等，也就是它们是否指向内存中的同一块地址</li>
</ol>
<h4 id="18-Python中-x3D-和is-not的区别"><a href="#18-Python中-x3D-和is-not的区别" class="headerlink" title="18. Python中!&#x3D;和is not的区别"></a><font color=DarkOrange>18. Python中!&#x3D;和is not的区别</font></h4><ol>
<li><code>!=</code> 运算符用于比较两个对象的值是否不相等，它与 <code>==</code> 运算符的作用相反</li>
<li><code>is not</code> 运算符用于比较两个对象的内存地址是否不相等，它与 <code>is</code> 运算符的作用相反</li>
</ol>
<h4 id="19-Python中iterables和iterators的区别"><a href="#19-Python中iterables和iterators的区别" class="headerlink" title="19. Python中iterables和iterators的区别"></a><font color=DarkOrange>19. Python中iterables和iterators的区别</font></h4><ol>
<li>Iterables（可迭代对象）是指那些可以被迭代的对象，例如列表、元组、字典等。这些对象可以通过 <code>for</code> 循环进行迭代，或者使用 <code>iter()</code> 函数将其转换为一个迭代器对象。</li>
<li>Iterators（迭代器）是指那些实现了 <code>__iter__()</code> 和 <code>__next__()</code> 方法的对象。<code>__iter__()</code> 方法返回迭代器对象自身，而 <code>__next__()</code> 方法返回下一个迭代值。迭代器可以用于访问集合中的元素，并且只能向前移动，一旦到达末尾就不能再次迭代</li>
</ol>
<p>因此，iterables 是一类对象，它们可以被迭代；而 iterators 是一类对象，它们是可迭代对象的具体实现，可以用于遍历可迭代对象中的元素。可以使用 <code>iter()</code> 函数将 iterables 转换为 iterators</p>
<p><strong>注意：</strong>只有实现了 <code>__iter__()</code> 方法的对象才是可迭代对象，而实现了 <code>__next__()</code> 方法的对象才是迭代器。如果一个对象既可以通过 <code>iter()</code> 函数转换为迭代器，又可以通过 <code>__iter__()</code> 方法返回迭代器对象自身，那么它就是一个迭代器</p>
<h4 id="20-Python解释器种类以及特点"><a href="#20-Python解释器种类以及特点" class="headerlink" title="20. Python解释器种类以及特点"></a><font color=DarkOrange>20. Python解释器种类以及特点</font></h4><ol>
<li>CPython：CPython 是 Python 官方实现，使用 C 语言编写。它是最常用的 Python 解释器，也是默认的解释器。CPython 的特点是运行速度较快，支持多种操作系统和平台，可以调用 C&#x2F;C++ 库，但占用资源较多。</li>
<li>Jython：Jython 是一种基于 Java 平台的 Python 解释器，它将 Python 代码转换为 Java 字节码执行。Jython 的特点是具有与 Java 平台相关的优点，例如垃圾回收、多线程等，但速度较慢，不支持一些 Python 特性和 C&#x2F;C++ 库。</li>
<li>IronPython：IronPython 是一种基于 .NET 平台的 Python 解释器，它将 Python 代码转换为 .NET 代码执行。IronPython 的特点是具有与 .NET 平台相关的优点，例如可重用性、可扩展性等，但速度较慢，不支持一些 Python 特性和 C&#x2F;C++ 库</li>
<li>PyPy：PyPy 是一种基于 Python 实现的解释器，它使用了即时编译技术，可以使 Python 代码的执行速度比 CPython 快 5-10 倍。PyPy 的特点是速度快，支持多种操作系统和平台，但不支持一些 Python 特性和 C&#x2F;C++ 库。</li>
<li>MicroPython：MicroPython 是一种专为嵌入式系统开发的 Python 解释器，它可以在资源受限的系统中运行 Python 代码。MicroPython 的特点是占用资源少、运行速度较快、支持硬件编程和网络编程等</li>
</ol>
<h4 id="21-Python面向对象三大特性"><a href="#21-Python面向对象三大特性" class="headerlink" title="21. Python面向对象三大特性"></a><font color=DarkOrange>21. Python面向对象三大特性</font></h4><ol>
<li><p>封装：封装是将数据和行为封装在一个单元中，通过接口来控制外部对内部的访问。Python 中的封装通过类的定义实现，将数据和方法定义在类中，并通过访问控制符号（public、private、protected）来控制访问权限</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.__age = age  <span class="comment"># 私有属性，外部无法直接访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;My name is &#123;0&#125;, and I&#x27;m &#123;1&#125; years old.&quot;</span>.<span class="built_in">format</span>(self.name, self.__age))</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(p.name)  <span class="comment"># 可以访问公有属性 name</span></span><br><span class="line"><span class="built_in">print</span>(p.__age)  <span class="comment"># 无法直接访问私有属性 __age，会抛出 AttributeError 异常</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>继承：继承是指一个类可以从另一个类中继承属性和方法，从而实现代码的复用和扩展。Python 中的继承通过在类定义中指定父类实现，子类可以继承父类的属性和方法，并可以在此基础上添加自己的属性和方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Woof!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Meow!&quot;</span>)</span><br><span class="line"></span><br><span class="line">dog = Dog(<span class="string">&quot;Rufus&quot;</span>)</span><br><span class="line">cat = Cat(<span class="string">&quot;Fluffy&quot;</span>)</span><br><span class="line">dog.speak()  <span class="comment"># 输出 &quot;Woof!&quot;</span></span><br><span class="line">cat.speak()  <span class="comment"># 输出 &quot;Meow!&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多态：多态是指同一种操作或函数可以有多种不同的实现方式，提高了代码的灵活性和可扩展性。Python 中的多态通过继承和方法重写实现，子类可以重写父类的方法，从而实现不同的行为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>(<span class="title class_ inherited__">Shape</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Draw a circle.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span>(<span class="title class_ inherited__">Shape</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Draw a square.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span>(<span class="title class_ inherited__">Shape</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Draw a triangle.&quot;</span>)</span><br><span class="line"></span><br><span class="line">shapes = [Circle(), Square(), Triangle()]</span><br><span class="line"><span class="keyword">for</span> shape <span class="keyword">in</span> shapes:</span><br><span class="line">    shape.draw()  <span class="comment"># 多态，根据不同的对象调用不同的实现方式</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="22-Python多重继承"><a href="#22-Python多重继承" class="headerlink" title="22. Python多重继承"></a><font color=DarkOrange>22. Python多重继承</font></h4><p>Python多重继承是指一个类可以同时继承多个父类的特性。在Python中，多重继承可以通过在类定义时在括号内列出多个父类来实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method_a</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method_b</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;B&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(A, B):  <span class="comment"># 多重继承</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method_c</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;C&quot;</span>)</span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line">c.method_a()  <span class="comment"># 输出 &quot;A&quot;</span></span><br><span class="line">c.method_b()  <span class="comment"># 输出 &quot;B&quot;</span></span><br><span class="line">c.method_c()  <span class="comment"># 输出 &quot;C&quot;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>方法解析顺序（MRO）：当一个类继承多个父类时，Python会按照一定的顺序来查找方法，这个顺序被称为方法解析顺序（MRO），MRO的计算方式是通过C3算法来实现的</li>
<li>调用父类方法：当一个类继承多个父类时，如果这些父类中有同名的方法，Python会按照MRO的顺序来调用这些方法。如果需要调用指定父类的方法，可以使用super()函数来实现。</li>
<li>Diamond继承问题：当一个类继承多个父类时，如果这些父类之间存在继承关系，就会出现Diamond继承问题，这个问题可以通过使用抽象基类（ABC）来解决</li>
</ol>
<p><strong>注意：</strong>多重继承也可能会导致一些问题，例如父类中有同名方法或属性时，可能会产生歧义；还可能会增加代码的复杂性和维护难度。因此，在使用多重继承时，需要谨慎设计和管理类的层次结构</p>
<h4 id="23-Python变量、函数、类的命名规则"><a href="#23-Python变量、函数、类的命名规则" class="headerlink" title="23. Python变量、函数、类的命名规则"></a><font color=DarkOrange>23. Python变量、函数、类的命名规则</font></h4><ol>
<li>只能包含字母、数字和下划线，不能以数字开头；</li>
<li>不允许使用 Python 的关键字和保留字，如 if、while、class、def 等</li>
<li>变量和函数名使用小写字母，多个单词用下划线连接，如 my_var、my_function</li>
<li>类名使用大写字母开头，多个单词使用驼峰命名法，如 MyClass、MyClassExample；</li>
<li>前导下划线表示私有属性或方法，双前导下划线表示强制私有，后续加上类名的前导下划线表示受保护的属性或方法，如 my_var、my_var、MyClass_my_var</li>
</ol>
<h4 id="4-Python中迭代器和生成器"><a href="#4-Python中迭代器和生成器" class="headerlink" title="4. Python中迭代器和生成器"></a><font color=DarkOrange>4. Python中迭代器和生成器</font></h4><ol>
<li><p>迭代器：是一种访问集合元素的方式，迭代器对象从集合的第一个元素开始访问，直到所有元素被访问完毕。迭代器只能往前不会后退，而且在迭代过程中无法修改集合元素</p>
<p>Python中的迭代器有两个基本的方法：iter() 和 next()</p>
<ul>
<li>iter(object[, sentinel]) 函数用来生成迭代器，object 是可迭代对象，sentinel 是可选的，如果传递了第二个参数，则参数 object 必须是一个可调用的对象（如函数），此时，iter 创建了一个迭代器对象，每次调用这个迭代器对象的 <code>__next__()</code> 方法时，都会调用 object</li>
<li>next(iterator[, default]) 函数用来获取迭代器的下一个元素，如果迭代器已经到了最后一个元素，再次调用 next() 函数会抛出 StopIteration 异常，default 是可选的，如果迭代器已经到了最后一个元素，返回 default 值</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 迭代器示例</span></span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">my_iterator = <span class="built_in">iter</span>(my_list)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_iterator))  <span class="comment"># 输出 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_iterator))  <span class="comment"># 输出 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_iterator))  <span class="comment"># 输出 3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生成器：是一种特殊的迭代器，它是通过函数来实现的，生成器函数在执行时会生成一个生成器对象，生成器对象是一个可迭代对象，每次调用生成器对象的 <code>__next__()</code> 方法时，都会执行生成器函数中的代码，直到遇到 yield 语句，yield 语句会返回一个值，并暂停生成器函数的执行，下次调用 <code>__next__()</code> 方法时，生成器函数会从 yield 语句暂停的位置继续执行</p>
<p>Python中的生成器有两种实现方式：生成器函数和生成器表达式</p>
<p>生成器函数是通过 def 关键字定义的函数，函数中包含 yield 语句，生成器函数在执行时会生成一个生成器对象</p>
<p>生成器可以帮助我们节省内存，因为生成器每次只会返回一个值，而不会一次性将所有值都存储在内存中。另外，生成器还可以用于实现协程等高级特性，提高代码的灵活性和可维护性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成器示例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_generator</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> my_generator():</span><br><span class="line">    <span class="built_in">print</span>(value)  <span class="comment"># 输出 1, 2, 3</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="25-Python中猴子补丁是什么"><a href="#25-Python中猴子补丁是什么" class="headerlink" title="25. Python中猴子补丁是什么"></a><font color=DarkOrange>25. Python中猴子补丁是什么</font></h4><p>猴子补丁是指在运行时动态修改类或模块的行为的技术。它允许在程序运行时更改代码，而不需要修改原始源代码。这种技术通常用于在测试或调试期间临时修改代码，或者在第三方库中添加或修改功能。使用猴子补丁时需要注意，它可能会导致代码的不稳定性和难以维护性，因此应该谨慎使用</p>
<h4 id="6-Python中的垃圾回收机制"><a href="#6-Python中的垃圾回收机制" class="headerlink" title="6. Python中的垃圾回收机制"></a><font color=DarkOrange>6. Python中的垃圾回收机制</font></h4><p>Python中的垃圾回收机制使用引用计数技术和垃圾回收器两种技术来实现。引用计数是一种轻量级的内存管理机制，当一个对象的引用计数变为0时，Python会立即回收它的内存。垃圾回收器是一种更高级别的机制，它会跟踪对象之间的引用，并回收不再使用的对象</p>
<p>Python中的垃圾回收器有两种实现方式：分代垃圾回收和循环垃圾回收。分代垃圾回收机制将对象根据其生命周期分成三代：0代、1代和2代。当一个对象经历了多次垃圾回收，其代数就会逐渐增加。Python垃圾回收器会根据代数来选择合适的回收策略</p>
<p>循环垃圾回收机制则会跟踪对象之间的引用关系，找到不再使用的对象，并将它们回收。这种机制需要更多的计算资源，因此只在必要时才会使用</p>
<h4 id="7-Python中的lambda表达式"><a href="#7-Python中的lambda表达式" class="headerlink" title="7. Python中的lambda表达式"></a><font color=DarkOrange>7. Python中的lambda表达式</font></h4><p>Lambda表达式是一种匿名函数，它可以在Python中快速定义简单的函数。它通常由一个单独的表达式组成，该表达式在调用时返回结果。Lambda表达式的语法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> arguments: expression</span><br></pre></td></tr></table></figure>

<p>其中，arguments是函数的参数，可以是任意数量的参数，用逗号分隔。expression是函数的返回值，通常是一个简单的表达式。</p>
<p>Lambda表达式通常用于需要一个简单函数的地方，例如在map()、filter()和reduce()等函数中。它们也可以用于定义回调函数和排序函数等</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个lambda表达式</span></span><br><span class="line">lambda_func = <span class="keyword">lambda</span> x, y: x + y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用lambda函数</span></span><br><span class="line">result = lambda_func(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出 7</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>虽然lambda表达式可以用来定义小型函数，但是如果函数体过于复杂，建议使用普通的函数定义语法，以提高代码可读性和可维护性</p>
<h4 id="28-Python中的反射"><a href="#28-Python中的反射" class="headerlink" title="28. Python中的反射"></a><font color=DarkOrange>28. Python中的反射</font></h4><p>Python中的反射是一种动态访问和修改对象属性和方法的机制，可以通过字符串的方式来访问对象的属性和方法。在Python中，每个对象都有一些基本的属性和方法，而反射机制可以通过这些属性和方法来实现动态访问和修改。</p>
<p>反射机制主要通过内置函数<code>getattr()</code>、<code>setattr()</code>、<code>hasattr()</code>和<code>delattr()</code>来实现。具体来说，这些函数的作用如下：</p>
<ul>
<li><code>getattr(object, name[, default])</code>: 获取对象的属性值。如果属性不存在，则会抛出AttributeError异常，或者返回default参数指定的默认值（如果提供了该参数）。</li>
<li><code>setattr(object, name, value)</code>: 设置对象的属性值。如果属性不存在，则会创建一个新属性</li>
<li><code>hasattr(object, name)</code>: 检查对象是否有指定的属性。如果对象有该属性，返回True，否则返回False。</li>
<li><code>delattr(object, name)</code>: 删除对象的指定属性。</li>
</ul>
<p>通过这些函数，可以实现访问、修改、创建和删除对象的属性和方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.x = <span class="number">10</span></span><br><span class="line">        self.y = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, a, b</span>):</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用getattr获取对象属性</span></span><br><span class="line">x = <span class="built_in">getattr</span>(obj, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 输出10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用setattr设置对象属性</span></span><br><span class="line"><span class="built_in">setattr</span>(obj, <span class="string">&#x27;y&#x27;</span>, <span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(obj.y)  <span class="comment"># 输出30</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用hasattr检查对象属性是否存在</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(obj, <span class="string">&#x27;z&#x27;</span>))  <span class="comment"># 输出False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用delattr删除对象属性</span></span><br><span class="line"><span class="built_in">delattr</span>(obj, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(obj.__dict__)  <span class="comment"># 输出 &#123;&#x27;y&#x27;: 30&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>反射机制可以让代码更加灵活，但同时也会增加代码的复杂性和运行开销，因此在实际使用中需要谨慎使用</p>
<h4 id="29-Python中的-new-和-init-的区别"><a href="#29-Python中的-new-和-init-的区别" class="headerlink" title="29. Python中的__new__和__init__的区别"></a><font color=DarkOrange>29. Python中的<code>__new__</code>和<code>__init__</code>的区别</font></h4><p>在Python中，每个类都有两个特殊方法<code>__new__()</code>和<code>__init__()</code>。这两个方法都是用来创建类实例的，但是它们的作用不同。</p>
<p><code>__new__()</code>方法是一个类方法，用于创建并返回一个新的类实例。它通常被用来控制对象的创建过程，可以在对象实例化之前做一些自定义的操作，比如修改对象的属性、改变对象的类型等。<code>__new__()</code>方法的返回值是一个对象实例，这个实例会传递给<code>__init__()</code>方法作为第一个参数self。</p>
<p><code>__init__()</code>方法是一个实例方法，用于初始化一个已经存在的对象实例。它通常被用来对对象的属性进行初始化和赋值。<code>__init__()</code>方法没有返回值，它只是对self进行修改，因为self已经被创建了并传递给这个方法了。</p>
<p>需要注意的是，<code>__new__()</code>方法是在<code>__init__()</code>方法之前调用的，所以在<code>__init__()</code>方法中可以使用<code>self</code>对象已经存在的属性，但是不能修改这些属性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;__new__ called&#x27;</span>)</span><br><span class="line">        instance = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">        instance.name = <span class="string">&#x27;MyClass&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, age</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;__init__ called&#x27;</span>)</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">obj = MyClass(<span class="number">18</span>)</span><br><span class="line"><span class="built_in">print</span>(obj.name)  <span class="comment"># 输出 MyClass</span></span><br><span class="line"><span class="built_in">print</span>(obj.age)  <span class="comment"># 输出 18</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>__new__()</code>方法被重写，创建了一个新的对象实例，并将<code>name</code>属性设置为<code>MyClass</code>，最后将实例返回给<code>__init__()</code>方法。<code>__init__()</code>方法接收到这个实例之后，对它进行了初始化，将<code>age</code>属性赋值为传入的参数18</p>
<h4 id="30-Python闭包"><a href="#30-Python闭包" class="headerlink" title="30. Python闭包"></a><font color=DarkOrange>30. Python闭包</font></h4><p>Python闭包是指在函数内部定义的函数，该函数可以访问外部函数的变量和参数，并且可以在外部函数返回后继续访问这些变量和参数。闭包可以用来实现一些高级的编程技巧，例如装饰器和函数工厂</p>
<p>在Python中，闭包是通过函数对象和函数属性来实现的。当一个函数定义在另一个函数内部时，它就可以访问外部函数的变量和参数。这些变量和参数被称为自由变量和自由参数。当外部函数返回时，闭包函数仍然可以访问这些自由变量和自由参数，因为它们被保存在闭包函数的函数对象中。这使得闭包函数可以在外部函数返回后继续执行，并且可以访问外部函数的状态</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer_func</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner_func</span>(<span class="params">y</span>):</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    <span class="keyword">return</span> inner_func</span><br><span class="line"></span><br><span class="line">closure = outer_func(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(closure(<span class="number">5</span>))  <span class="comment"># 输出 15</span></span><br><span class="line"><span class="built_in">print</span>(closure(<span class="number">10</span>))  <span class="comment"># 输出 20</span></span><br></pre></td></tr></table></figure>

<h4 id="31-Python元类"><a href="#31-Python元类" class="headerlink" title="31. Python元类"></a><font color=DarkOrange>31. Python元类</font></h4><p>Python中的元类是用于创建类的类。元类允许我们控制类的创建过程，可以在类被创建之前或之后修改类。元类是一种高级的Python编程技巧，通常用于框架和库的开发中，比如Django、Flask、Tornado等。</p>
<p>元类可以用来实现单例模式、注册表、插件系统等功能。在Python中，所有的类都是由type类创建的，因此type类是Python中的默认元类</p>
<h4 id="32-Python中的GIL"><a href="#32-Python中的GIL" class="headerlink" title="32. Python中的GIL"></a><font color=DarkOrange>32. Python中的GIL</font></h4><p>GIL（Global Interpreter Lock）是Python解释器中的一个特性，它是一种锁机制，用于保证在同一时刻只有一个线程可以执行Python字节码。这个锁是解释器级别的锁，也称为全局锁。在多线程环境下，GIL会导致线程无法真正并行执行，因为只有一个线程可以拥有GIL</p>
<p>GIL的存在是因为CPython解释器的内存管理不是线程安全的，当多个线程同时访问和修改Python对象的引用计数时，可能会出现竞争条件和数据一致性问题。因此，为了避免这些问题，CPython引入了GIL来限制同一时刻只有一个线程可以执行Python字节码。</p>
<p>GIL的存在会影响Python多线程程序的性能，因为多线程程序无法真正利用多核CPU的性能优势。在CPU密集型任务中，GIL会成为瓶颈，导致多线程程序的运行时间比单线程程序更长。但在I&#x2F;O密集型任务中，GIL的影响较小，因为线程在等待I&#x2F;O操作完成时，GIL会被释放，其他线程就可以执行Python字节码。</p>
<p>为了避免GIL的影响，可以使用多进程代替多线程，因为多个进程之间是相互独立的，各自拥有自己的解释器和GIL，可以真正并行执行。也可以使用其他语言编写CPU密集型任务的模块，然后在Python程序中调用这些模块，避免GIL的影响。另外，Python还提供了一些并发编程库和工具，如multiprocessing、concurrent.futures、asyncio等，可以在一定程度上缓解GIL的影响</p>
<h4 id="33-Python类和对象的区别"><a href="#33-Python类和对象的区别" class="headerlink" title="33. Python类和对象的区别"></a><font color=DarkOrange>33. Python类和对象的区别</font></h4><p>在Python中，类是一种数据类型，用于定义对象的属性和方法。对象是类的实例，也就是类的具体化。类是对象的抽象，而对象是类的具体实现。类是一种模板或者蓝图，用于创建对象。</p>
<p>具体来说，Python中的类是由属性和方法组成的，属性是类的变量，用于存储对象的状态，方法是类的函数，用于定义对象的行为。类可以看作是一种特殊的字典，类的属性和方法都保存在类的命名空间中。类属性是所有实例共享的，而实例属性是每个实例独有的。</p>
<p>对象是类的实例，是根据类创建的具体实体，每个对象都有自己的状态和行为。对象包含属性和方法，属性是对象的变量，用于存储对象的状态，方法是对象的函数，用于定义对象的行为。对象是在程序运行时创建的，每个对象都是独立的，有自己的属性和方法</p>
<p>在Python中，类和对象的关系可以用以下表格来描述：</p>
<table>
<thead>
<tr>
<th>类</th>
<th>对象</th>
</tr>
</thead>
<tbody><tr>
<td>模板</td>
<td>具体实体</td>
</tr>
<tr>
<td>定义</td>
<td>创建</td>
</tr>
<tr>
<td>属性和方法</td>
<td>属性和方法</td>
</tr>
<tr>
<td>类变量</td>
<td>实例变量</td>
</tr>
<tr>
<td>类方法</td>
<td>实例方法</td>
</tr>
<tr>
<td>类属性</td>
<td>实例属性</td>
</tr>
<tr>
<td>继承</td>
<td>实例化</td>
</tr>
</tbody></table>
<p><strong>总的来说，类是一种抽象的概念，对象是类的实例化，是具体的实体。类描述了对象的属性和方法，而对象则是类的具体实现</strong></p>
<h4 id="34-Python中的self的作用"><a href="#34-Python中的self的作用" class="headerlink" title="34. Python中的self的作用"></a><font color=DarkOrange>34. Python中的self的作用</font></h4><p>在Python中，self是一个约定俗成的命名方式，用于表示类实例对象本身。self作为第一个参数出现在类的方法中，它表示对类实例对象本身的引用。</p>
<p>当一个类的方法被调用时，它会自动传入类实例对象本身作为第一个参数，通常使用self作为参数名。这样，在方法内部就可以使用self来引用对象本身，从而访问对象的属性和调用对象的方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say_hello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello, my name is&quot;</span>, self.name, <span class="string">&quot;and I am&quot;</span>, self.age, <span class="string">&quot;years old.&quot;</span>)</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&quot;John&quot;</span>, <span class="number">30</span>)</span><br><span class="line">p.say_hello()  <span class="comment"># 输出：Hello, my name is John and I am 30 years old.</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>__init__</code>方法和<code>say_hello</code>方法都有一个<code>self</code>参数，它们用于引用类实例对象本身。在<code>__init__</code>方法中，使用<code>self</code>来初始化类实例对象的属性；在<code>say_hello</code>方法中，使用<code>self</code>来引用对象的属性和方法，从而输出对象的信息</p>
<p><strong>注意：</strong><code>self</code>不是Python的关键字，可以使用其他名称代替，但是约定俗成的做法是使用<code>self</code>。另外，<code>self</code>只在类的方法中出现，而在类的其他地方，如属性和方法的定义中，不需要使用<code>self</code></p>
<h4 id="35-Python2和Python3的区别"><a href="#35-Python2和Python3的区别" class="headerlink" title="35. Python2和Python3的区别"></a><font color=DarkOrange>35. Python2和Python3的区别</font></h4><ol>
<li>语法：Python3对语言的语法进行了一些改进，如print函数变成了print()函数，除法运算符变成了真正的浮点除法符号<code>/</code>，新增了非本地变量声明<code>nonlocal</code>等</li>
<li>编码：Python3默认采用UTF-8编码，而Python2采用的是ASCII编码。</li>
<li>兼容性：Python3不兼容Python2的代码，而Python2中的大多数代码可以在Python3中运行，但是需要进行一些修改</li>
<li>标准库：Python3的标准库中增加了一些新模块，如asyncio、enum、ipaddress等，同时还更新了一些模块，如pickle、tkinter等。</li>
<li>Unicode字符串：在Python3中，字符串是默认采用Unicode编码，而在Python2中，字符串采用的是ASCII编码。</li>
<li>整数除法：在Python2中，两个整数相除得到的是整数结果，而在Python3中，两个整数相除得到的是浮点数结果</li>
<li>range函数：在Python2中，range函数返回的是一个列表，而在Python3中，range函数返回的是一个可迭代对象</li>
<li>异常处理：在Python3中，异常处理语句需要使用as关键字来接收异常对象。</li>
<li>print函数：在Python2中，print语句可以不用括号，而在Python3中，print函数必须要用括号。</li>
</ol>
<h4 id="36-Python如何提高运行效率"><a href="#36-Python如何提高运行效率" class="headerlink" title="36. Python如何提高运行效率"></a><font color=DarkOrange>36. Python如何提高运行效率</font></h4><ol>
<li>使用算法和数据结构：在编写Python代码时，使用高效的算法和数据结构可以大大提高代码的运行效率。例如，在需要对大量数据进行排序时，使用快速排序算法比使用冒泡排序算法更加高效。</li>
<li>使用生成器：生成器是Python中的一种特殊类型的函数，可以逐个生成值，而不是一次生成所有值。使用生成器可以避免在内存中生成大量数据，从而提高运行效率。</li>
<li>使用列表推导式和生成器表达式：列表推导式和生成器表达式可以在一行代码中生成列表或生成器。它们通常比使用循环和条件语句生成列表或生成器更加高效</li>
<li>使用Cython或Numba等工具：Cython是一种将Python代码转换为C代码的工具，可以提高Python代码的运行效率。Numba是一种Python库，可以使用JIT（即时编译）技术将Python代码转换为机器码，从而提高代码的运行速度。</li>
<li>使用并行编程：Python提供了一些模块，如multiprocessing和concurrent.futures等，可以使用多进程或多线程并行执行代码，从而提高运行效率。</li>
<li>避免使用循环：在Python中，循环的执行效率较低，应尽量避免使用循环。可以使用NumPy等库中的矩阵运算等高效操作来替代循环</li>
<li>避免使用全局变量：在Python中，全局变量的访问速度较慢，应尽量避免使用全局变量，而使用局部变量来代替。</li>
</ol>
<h4 id="37-Python异常处理"><a href="#37-Python异常处理" class="headerlink" title="37. Python异常处理"></a><font color=DarkOrange>37. Python异常处理</font></h4><ol>
<li><p>异常处理是什么？<br>异常处理是指在程序运行过程中，当出现错误或异常时，程序能够捕获并处理这些异常，从而保证程序的正常运行。</p>
</li>
<li><p>Python中的异常类型有哪些？<br>Python中有很多内置的异常类型，比如NameError、TypeError、ValueError等等，还可以自定义异常类型。</p>
</li>
<li><p>如何捕获异常？<br>在Python中，可以使用try-except语句来捕获异常。try语句块中放置可能会出现异常的代码，如果出现异常，则会跳转到except语句块中进行处理</p>
</li>
<li><p>如何处理异常？<br>在except语句块中可以对异常进行处理，比如输出错误信息、记录日志、重新抛出异常等等。</p>
</li>
<li><p>finally语句的作用是什么？<br>finally语句块中的代码无论是否出现异常都会被执行，通常用于释放资源等操作。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 可能会出现异常的代码块</span></span><br><span class="line"><span class="keyword">except</span> ExceptionType:</span><br><span class="line">    <span class="comment"># 处理异常的代码块</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 最终执行的代码块</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>try</code>：表示要执行的代码块，这里是可能会出现异常的代码块</li>
<li><code>except</code>：表示当try语句块中出现指定类型的异常时，执行该语句块；</li>
<li><code>ExceptionType</code>：指定要处理的异常类型；</li>
<li><code>finally</code>：不管try语句块中是否有异常都会执行的代码块</li>
</ul>
<p>除了使用<code>except</code>语句来处理异常，还可以使用<code>else</code>语句块，当没有异常出现时，执行<code>else</code>语句块中的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 可能会出现异常的代码块</span></span><br><span class="line"><span class="keyword">except</span> ExceptionType:</span><br><span class="line">    <span class="comment"># 处理异常的代码块</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 没有异常时执行的代码块</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 最终执行的代码块</span></span><br></pre></td></tr></table></figure>

<h4 id="38-Python中的标准异常类"><a href="#38-Python中的标准异常类" class="headerlink" title="38. Python中的标准异常类"></a><font color=DarkOrange>38. Python中的标准异常类</font></h4><table>
<thead>
<tr>
<th>异常类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>Exception</code></td>
<td>所有标准异常类的基类</td>
</tr>
<tr>
<td><code>AssertionError</code></td>
<td>断言语句失败时引发</td>
</tr>
<tr>
<td><code>AttributeError</code></td>
<td>对象没有这个属性</td>
</tr>
<tr>
<td><code>EOFError</code></td>
<td>没有输入，输入流结束</td>
</tr>
<tr>
<td><code>FileNotFoundError</code></td>
<td>请求的文件或目录未找到</td>
</tr>
<tr>
<td><code>ImportError</code></td>
<td>导入模块或包失败</td>
</tr>
<tr>
<td><code>IndexError</code></td>
<td>序列中没有此索引（index）</td>
</tr>
<tr>
<td><code>KeyError</code></td>
<td>映射中没有这个键</td>
</tr>
<tr>
<td><code>KeyboardInterrupt</code></td>
<td>用户中断执行（通常是输入^C）</td>
</tr>
<tr>
<td><code>MemoryError</code></td>
<td>操作耗尽内存</td>
</tr>
<tr>
<td><code>NameError</code></td>
<td>未声明&#x2F;初始化对象（没有属性）</td>
</tr>
<tr>
<td><code>NotImplementedError</code></td>
<td>尚未实现的方法或函数</td>
</tr>
<tr>
<td><code>OSError</code></td>
<td>操作系统错误</td>
</tr>
<tr>
<td><code>OverflowError</code></td>
<td>数字运算超出最大限制</td>
</tr>
<tr>
<td><code>RecursionError</code></td>
<td>递归调用超出最大限制</td>
</tr>
<tr>
<td><code>RuntimeError</code></td>
<td>一般的运行时错误</td>
</tr>
<tr>
<td><code>StopIteration</code></td>
<td>迭代器没有更多的值</td>
</tr>
<tr>
<td><code>SyntaxError</code></td>
<td>Python 语法错误</td>
</tr>
<tr>
<td><code>IndentationError</code></td>
<td>缩进错误</td>
</tr>
<tr>
<td><code>TabError</code></td>
<td>Tab和空格混用</td>
</tr>
<tr>
<td><code>SystemError</code></td>
<td>一般的解释器系统错误</td>
</tr>
<tr>
<td><code>SystemExit</code></td>
<td>Python 解释器请求退出</td>
</tr>
<tr>
<td><code>TypeError</code></td>
<td>对类型无效的操作</td>
</tr>
<tr>
<td><code>UnboundLocalError</code></td>
<td>访问未初始化的本地变量</td>
</tr>
<tr>
<td><code>UnicodeError</code></td>
<td>Unicode 相关的错误</td>
</tr>
<tr>
<td><code>ValueError</code></td>
<td>传递给函数的参数类型不正确，或者值不合法</td>
</tr>
<tr>
<td><code>ZeroDivisionError</code></td>
<td>除数为零</td>
</tr>
</tbody></table>
<hr>

      
      <blockquote>
        
        <strong>本文链接：</strong><br><a href="https://huajun-chen.github.io/2023/03/01/Python%E9%9D%A2%E8%AF%95%E9%A2%98/">https://huajun-chen.github.io/2023/03/01/Python面试题/</a>
      </blockquote>
    </div>
    <footer class="mdui-card-actions">
      
        <a class="mdui-ripple article_categories-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
      
      
        <a class="mdui-ripple article_tags-link" href="/tags/Python/" rel="tag">Python</a>
      
    </footer>
    
  </article>
  
<script src="//cdn.bootcdn.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>

  <script>$("#main article .mdui-card-content img.fancybox").on("click",function(e){$.fancybox.open({src:$(this).attr("src")});});</script>


  <nav id="paginator">
    
      <a rel="prev" class="extend prev" href="/2023/03/05/%E5%B2%97%E4%BD%8D%E9%9D%A2%E8%AF%95/">
        <button aria-label="prev" class="mdui-btn mdui-btn-raised mdui-btn-icon mdui-color-theme-accent mdui-ripple"><i class="mdui-icon material-icons">arrow_back</i></button>
        <span class="mdui-p-x-3" mdui-tooltip="{content: '岗位面试'}">上一篇</span>
      </a>
    
    <div class="spacer"></div>
    
      <a rel="next" class="extend next" href="/2022/12/08/Go%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8Validator%E8%BF%9B%E8%A1%8C%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/">
        <span class="mdui-p-x-3" mdui-tooltip="{content: 'Go语言使用Validator进行参数校验'}">下一篇</span>
        <button aria-label="next" class="mdui-btn mdui-btn-raised mdui-btn-icon mdui-color-theme-accent mdui-ripple"><i class="mdui-icon material-icons">arrow_forward</i></button>
      </a>
    
  </nav>




  <div style="position: fixed !important; left: 240px; top: 30%;">
    <button class="mdui-fab mdui-fab-mini mdui-ripple" mdui-menu="{target: '#toc'}"><i class="mdui-icon material-icons">toc</i></button>
    <ul class="mdui-menu" id="toc">
      <li class="mdui-menu-item" disabled><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#Python%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9"><span class="toc-text">Python语言特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Python%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">1. Python的数据类型有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Python%E5%8F%AF%E5%8F%98%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2. Python可变与不可变数据类型的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">3. Python列表和元组的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Python%E5%88%97%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">4. Python列表的基本操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Python%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F"><span class="toc-text">5. Python中的列表推导式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Python%E5%88%A0%E9%99%A4list%E9%87%8C%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">6. Python删除list里的重复元素有几种方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-Python%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">7. Python类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-Python%E5%AD%97%E5%85%B8%E4%BB%A5%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">8. Python字典以及基本操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-Python%E4%B8%AD%E7%9A%84list%E5%92%8Cdict%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-text">9. Python中的list和dict是怎么实现的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">10. Python字符串格式化的几种方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-Python%E4%B8%AD-args%E5%92%8C-kwargs"><span class="toc-text">11. Python中*args和**kwargs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-Python%E4%B8%AD%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">12. Python中深拷贝和浅拷贝的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-Python%E4%B8%AD%E7%9A%84%E5%8D%95%E5%BC%95%E5%8F%B7%E5%92%8C%E5%8F%8C%E5%BC%95%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">13. Python中的单引号和双引号的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-Python%E4%B8%ADappend%E3%80%81insert%E5%92%8Cextend%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">14. Python中append、insert和extend的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-Python%E4%B8%ADbreak%E3%80%81continue%E3%80%81pass%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">15. Python中break、continue、pass是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-Python%E4%B8%AD%E7%9A%84remove%E3%80%81del%E5%92%8Cpop"><span class="toc-text">16. Python中的remove、del和pop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-Python%E4%B8%AD-x3D-x3D-%E5%92%8Cis%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">17. Python中&#x3D;&#x3D;和is的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-Python%E4%B8%AD-x3D-%E5%92%8Cis-not%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">18. Python中!&#x3D;和is not的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-Python%E4%B8%ADiterables%E5%92%8Citerators%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">19. Python中iterables和iterators的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-Python%E8%A7%A3%E9%87%8A%E5%99%A8%E7%A7%8D%E7%B1%BB%E4%BB%A5%E5%8F%8A%E7%89%B9%E7%82%B9"><span class="toc-text">20. Python解释器种类以及特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-text">21. Python面向对象三大特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-Python%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-text">22. Python多重继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-Python%E5%8F%98%E9%87%8F%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E7%B1%BB%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="toc-text">23. Python变量、函数、类的命名规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Python%E4%B8%AD%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-text">4. Python中迭代器和生成器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25-Python%E4%B8%AD%E7%8C%B4%E5%AD%90%E8%A1%A5%E4%B8%81%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">25. Python中猴子补丁是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Python%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">6. Python中的垃圾回收机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-Python%E4%B8%AD%E7%9A%84lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">7. Python中的lambda表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28-Python%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84"><span class="toc-text">28. Python中的反射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29-Python%E4%B8%AD%E7%9A%84-new-%E5%92%8C-init-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">29. Python中的__new__和__init__的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30-Python%E9%97%AD%E5%8C%85"><span class="toc-text">30. Python闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31-Python%E5%85%83%E7%B1%BB"><span class="toc-text">31. Python元类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32-Python%E4%B8%AD%E7%9A%84GIL"><span class="toc-text">32. Python中的GIL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33-Python%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">33. Python类和对象的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34-Python%E4%B8%AD%E7%9A%84self%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">34. Python中的self的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#35-Python2%E5%92%8CPython3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">35. Python2和Python3的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#36-Python%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E8%BF%90%E8%A1%8C%E6%95%88%E7%8E%87"><span class="toc-text">36. Python如何提高运行效率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#37-Python%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">37. Python异常处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#38-Python%E4%B8%AD%E7%9A%84%E6%A0%87%E5%87%86%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="toc-text">38. Python中的标准异常类</span></a></li></ol></li>
    </ul>
  </div>


</main>
  <footer id="footer" class="mdui-m-t-5 mdui-p-y-3 mdui-color-theme">
  <div class="mdui-p-y-0 mdui-text-center">
    
    
    
    
    
    
    
    
    
    
    
    
  </div>
  <div class="mdui-p-y-1 mdui-text-center">
    Copyright &copy; 2023 可可西里<br>
    Powered by <a href="https://hexo.io/" target="_blank" class="mdui-text-color-theme-accent">Hexo</a>
    
  </div>
</footer>

  <button id="gotop" class="mdui-fab mdui-fab-fixed mdui-fab-hide mdui-color-theme-accent mdui-ripple"><i class="mdui-icon material-icons">arrow_upward</i></button>
  
  
<script src="/js/mdui.js"></script>
<script src="/js/script.js"></script>

  
<script src="/custom.js"></script>

</body>
</html>
