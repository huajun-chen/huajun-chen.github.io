<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>可可西里-博客</title>
  
  <subtitle>好好吃饭 好好睡觉 好好上班</subtitle>
  <link href="https://huajun-chen.github.io/atom.xml" rel="self"/>
  
  <link href="https://huajun-chen.github.io/"/>
  <updated>2022-12-03T08:02:21.460Z</updated>
  <id>https://huajun-chen.github.io/</id>
  
  <author>
    <name>可可西里</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GitHub + Go + Gin创建RESTful风格的项目</title>
    <link href="https://huajun-chen.github.io/2022/12/03/GitHub%E5%88%9B%E5%BB%BAGo-Gin-RESTful%E9%A3%8E%E6%A0%BC%E9%A1%B9%E7%9B%AE/"/>
    <id>https://huajun-chen.github.io/2022/12/03/GitHub%E5%88%9B%E5%BB%BAGo-Gin-RESTful%E9%A3%8E%E6%A0%BC%E9%A1%B9%E7%9B%AE/</id>
    <published>2022-12-03T05:40:30.000Z</published>
    <updated>2022-12-03T08:02:21.460Z</updated>
    
    <content type="html"><![CDATA[<p>通过GitHub + Go + Gin创建RESTful风格的项目，搭建一个基础的脚手架</p><p>完整项目GitHub地址：<a href="https://github.com/huajun-chen/GinRESTful">点击跳转</a></p><h4 id="1-GutHub-New"><a href="#1-GutHub-New" class="headerlink" title="1. GutHub New"></a><font color=DarkOrange>1. GutHub New</font></h4><p>打开GitHub，进入首页，点击<code>New</code>开始创建新项目</p><p><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8qkp3xulaj328016g4qp.jpg" alt="image.png"></p><h4 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2. 创建项目"></a><font color=DarkOrange>2. 创建项目</font></h4><p>点击<code>New</code>之后，填写项目名、项目描述，填写完项目名之后，后面会显示此项目名是否可用，&amp;#10003;为可用，&amp;#10005;为不可用，其他选项默认即可，然后点击<code>Create repository</code>按钮创建项目</p><p><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8qky746qaj3280160ndf.jpg" alt="image.png"></p><h4 id="3-创建成功"><a href="#3-创建成功" class="headerlink" title="3. 创建成功"></a><font color=DarkOrange>3. 创建成功</font></h4><p>创建项目成功之后页面会跳转，在此页面复制项目地址</p><p><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8ql0g1krlj328016gauw.jpg" alt="image.png"></p><h4 id="4-克隆项目"><a href="#4-克隆项目" class="headerlink" title="4. 克隆项目"></a><font color=DarkOrange>4. 克隆项目</font></h4><p>在本地电脑，进行需要存放项目的目录下，将项目克隆到本地，并且在本地新建<code>dev</code>开发分支</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 项目地址 // 克隆项目</span><br><span class="line"><span class="built_in">cd</span> 项目名 // 进行项目目录</span><br><span class="line">git checkout -b 分支名 // 新建分支并切换到此分支</span><br></pre></td></tr></table></figure><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8ql7fxamdj30ua0v2qlc.jpg" alt="image.png" style="zoom:50%;" /></div><h4 id="5-打开项目"><a href="#5-打开项目" class="headerlink" title="5. 打开项目"></a><font color=DarkOrange>5. 打开项目</font></h4><p>使用本地<code>IDE</code>打开项目（这里以<code>Goland IDE</code>演示），在项目里添加<code>GOPROXY</code></p><p>路径：<code>Goland</code>-&gt;<code>Preferences...</code>-&gt;<code>Go</code>-&gt;<code>Go Modules</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOPROXY=https://goproxy.cn</span><br></pre></td></tr></table></figure><p><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8qlextrflj31ik13kwnl.jpg" alt="image.png"></p><h4 id="6-创建go-mod"><a href="#6-创建go-mod" class="headerlink" title="6. 创建go mod"></a><font color=DarkOrange>6. 创建go mod</font></h4><p>在编译器里，打开终端，在终端通过命令的方式创建<code>go mod</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init 项目名</span><br></pre></td></tr></table></figure><p><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8qlkroqh3j32801cgn9j.jpg" alt="image.png"></p><h4 id="7-安装Gin"><a href="#7-安装Gin" class="headerlink" title="7. 安装Gin"></a><font color=DarkOrange>7. 安装Gin</font></h4><p>在终端通过命令的方式下载并安装<code>Gin</code>包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure><p><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8qlpgvihqj32801cg1kx.jpg" alt="image.png"></p><h4 id="8-main程序"><a href="#8-main程序" class="headerlink" title="8. main程序"></a><font color=DarkOrange>8. main程序</font></h4><p>新建<code>main.go</code>文件，在<code>main</code>文件里编写第一个<code>Gin</code>示例</p><p>在<code>main</code>文件所在的目录下执行<code>go run main.go</code>运行<code>main</code>函数</p><p><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8qly589jgj32801ce1f4.jpg" alt="image.png"></p><h4 id="9-浏览器访问"><a href="#9-浏览器访问" class="headerlink" title="9. 浏览器访问"></a><font color=DarkOrange>9. 浏览器访问</font></h4><p>在浏览器通过访问<code>localhost:8080/ping</code>或<code>127.0.0.1:8080/ping</code>的方式访问服务</p><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8qlxcsj7bj30pc09040d.jpg" alt="image.png" style="zoom:67%;" /></div><h4 id="10-添加文件"><a href="#10-添加文件" class="headerlink" title="10. 添加文件"></a><font color=DarkOrange>10. 添加文件</font></h4><p>在项目里添加<code>.gitignore</code>和<code>README.md</code>文件</p><p><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8qm74jjgtj31880sw791.jpg" alt="image.png"></p><h4 id="11-提交代码"><a href="#11-提交代码" class="headerlink" title="11. 提交代码"></a><font color=DarkOrange>11. 提交代码</font></h4><p>编写代码之后，在本地进行代码提交</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git add 文件名</span><br><span class="line">git commit -m <span class="string">&quot;本次提交描述&quot;</span></span><br><span class="line">git push origin dev</span><br></pre></td></tr></table></figure><p><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8qmdi8artj32801cih82.jpg" alt="image.png"></p><h4 id="12-合并代码"><a href="#12-合并代码" class="headerlink" title="12. 合并代码"></a><font color=DarkOrange>12. 合并代码</font></h4><p>代码从本地提交到远程仓库之后，需要在远程仓库对代码进行合并</p><p><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8qn4b53z1j328016gdy4.jpg" alt="image.png"></p><p><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8qn5bc2u0j328016g7ma.jpg" alt="image.png"></p><p><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8qn67pkhaj328016i1ew.jpg" alt="image.png"></p><p>此项目会继续更新，敬请期待…</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;通过GitHub + Go + Gin创建RESTful风格的项目，搭建一个基础的脚手架&lt;/p&gt;
&lt;p&gt;完整项目GitHub地址：&lt;a href=&quot;https://github.com/huajun-chen/GinRESTful&quot;&gt;点击跳转&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Go" scheme="https://huajun-chen.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Docker、k8s面试题</title>
    <link href="https://huajun-chen.github.io/2022/11/24/Docker%E3%80%81k8s%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://huajun-chen.github.io/2022/11/24/Docker%E3%80%81k8s%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-11-24T10:10:56.000Z</published>
    <updated>2022-11-24T10:20:40.899Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接：<a href="https://dockone.io/article/2434304">点击跳转</a></p><p>阿里云开发者社区链接：<a href="https://developer.aliyun.com/article/873550">点击跳转</a></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考链接：&lt;a href=&quot;https://dockone.io/article/2434304&quot;&gt;点击跳转&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;阿里云开发者社区链接：&lt;a href=&quot;https://developer.aliyun.com/article/873550&quot;&gt;点击跳转&lt;/</summary>
      
    
    
    
    <category term="面试" scheme="https://huajun-chen.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>Go-设计模式</title>
    <link href="https://huajun-chen.github.io/2022/11/24/Go-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://huajun-chen.github.io/2022/11/24/Go-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-11-24T08:44:39.000Z</published>
    <updated>2022-11-24T14:55:50.445Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式是软件工程中各种常见问题的经典解决方案，设计模式不只是代码，而是组织代码的方式。假设一行行的代码是砖，设计模式就是蓝图</p><table><thead><tr><th><div style="width: 32pt">类型</div></th><th><div style="width: 63pt">设计模式</div></th><th>简述</th><th><div style="width: 25pt">常用</div></th></tr></thead><tbody><tr><td>创建型</td><td>工厂模式</td><td>定义一个创建对象的接口，让其子类自己决定范例化哪一个工厂类，是最常用的设计模式之一</td><td><font color=Forestgreen>yes</font></td></tr><tr><td></td><td>抽象工厂模式</td><td>为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构</td><td><font color=Forestgreen>yes</font></td></tr><tr><td></td><td>建造者模式</td><td>将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成</td><td><font color=Forestgreen>yes</font></td></tr><tr><td></td><td>原型模式</td><td>用一个已经创建的范例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象</td><td><font color=Red>no</font></td></tr><tr><td></td><td>单例模式</td><td>保证一个类仅有一个范例，并提供一个访问它的全局访问点单例模式只涉及到一个类，该类负责创建自己的对象，而且确保只有单个对象被创建</td><td><font color=Forestgreen>yes</font></td></tr><tr><td>结构型</td><td>适配器模式</td><td>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作</td><td><font color=Forestgreen>yes</font></td></tr><tr><td></td><td>桥接模式</td><td>将抽象与实现分离，使两者可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度</td><td><font color=Forestgreen>yes</font></td></tr><tr><td></td><td>组合模式</td><td><strong>对象树模式&#x2F;整体-部分模式</strong>。将对象组合成树状的层次结构的模式，用来表示“整体-部分”的关系，使用户对单个对象和组合对象具有一致的访问性</td><td><font color=Red>no</font></td></tr><tr><td></td><td>装饰器模式</td><td>动态地给一个对象添加一些额外的职责。允许向一个现有的对象添加新的功能，同时又不改变其结构</td><td><font color=Forestgreen>yes</font></td></tr><tr><td></td><td>外观模式</td><td>又称为门面模式，它为子系统中的接口提供一个一致的接口，来隐藏子系统内部的复杂性，使得子系统更加容易使用</td><td><font color=Red>no</font></td></tr><tr><td></td><td>享元模式</td><td>运用共享技术有效地支持大量细粒度的对象，减少对象的创建数量，以节省内存占用和提高性能</td><td><font color=Red>no</font></td></tr><tr><td></td><td>代理模式</td><td>由于某些原因需要为某对象提供一种代理以控制对该对象的访问当访问对象不适合或者不能直接引用目标对象的时候，可以通过代理对象作为访问对象和目标对象之间的中介</td><td><font color=Forestgreen>yes</font></td></tr><tr><td>行为型</td><td>责任链模式</td><td>为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止</td><td><font color=Forestgreen>yes</font></td></tr><tr><td></td><td>命令模式</td><td>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作</td><td><font color=Red>no</font></td></tr><tr><td></td><td>迭代器模式</td><td>提供了一种方法顺序访问一个聚合对象中的所有元素，而又不暴露该聚合对象的内部表示用于顺序访问集合对象的元素，调用者无需知道集合对象的底层表示，从而实现调用者和聚合对象的解耦</td><td><font color=Forestgreen>yes</font></td></tr><tr><td></td><td>中介者模式</td><td>用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护</td><td><font color=Red>no</font></td></tr><tr><td></td><td>备忘录模式</td><td>保存一个对象的某个状态，以便在适当的时候恢复对象</td><td><font color=Red>no</font></td></tr><tr><td></td><td>观察者模式</td><td>定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新</td><td><font color=Forestgreen>yes</font></td></tr><tr><td></td><td>状态模式</td><td>对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为</td><td><font color=Forestgreen>yes</font></td></tr><tr><td></td><td>策略模式</td><td>通过定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户</td><td><font color=Forestgreen>yes</font></td></tr><tr><td></td><td>模板方法模式</td><td>定义一个操作中的算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构,即可重定义该算法的某些特定步骤</td><td><font color=Forestgreen>yes</font></td></tr><tr><td></td><td>访问者模式</td><td>将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式</td><td><font color=Red>no</font></td></tr></tbody></table><h4 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1. 工厂模式"></a><font color=DarkOrange>1. 工厂模式</font></h4><p><strong>问题</strong></p><p><strong>解决</strong></p><h4 id="2-抽象工厂模式"><a href="#2-抽象工厂模式" class="headerlink" title="2. 抽象工厂模式"></a><font color=DarkOrange>2. 抽象工厂模式</font></h4><p><strong>问题</strong></p><p><strong>解决</strong></p><h4 id="3-建造者模式"><a href="#3-建造者模式" class="headerlink" title="3. 建造者模式"></a><font color=DarkOrange>3. 建造者模式</font></h4><p><strong>问题</strong></p><p><strong>解决</strong></p><h4 id="4-原型模式"><a href="#4-原型模式" class="headerlink" title="4. 原型模式"></a><font color=DarkOrange>4. 原型模式</font></h4><p><strong>问题</strong></p><p><strong>解决</strong></p><h4 id="5-单例模式"><a href="#5-单例模式" class="headerlink" title="5. 单例模式"></a><font color=DarkOrange>5. 单例模式</font></h4><p><strong>问题</strong></p><p><strong>解决</strong></p><h4 id="6-适配器模式"><a href="#6-适配器模式" class="headerlink" title="6. 适配器模式"></a><font color=DarkOrange>6. 适配器模式</font></h4><p><strong>问题</strong></p><p><strong>解决</strong></p><h4 id="7-桥接模式"><a href="#7-桥接模式" class="headerlink" title="7. 桥接模式"></a><font color=DarkOrange>7. 桥接模式</font></h4><p><strong>问题</strong></p><p><strong>解决</strong></p><h4 id="8-组合模式"><a href="#8-组合模式" class="headerlink" title="8. 组合模式"></a><font color=DarkOrange>8. 组合模式</font></h4><p><strong>问题</strong></p><p><strong>解决</strong></p><h4 id="9-装饰器模式"><a href="#9-装饰器模式" class="headerlink" title="9. 装饰器模式"></a><font color=DarkOrange>9. 装饰器模式</font></h4><p><strong>问题</strong></p><p><strong>解决</strong></p><h4 id="10-外观模式"><a href="#10-外观模式" class="headerlink" title="10. 外观模式"></a><font color=DarkOrange>10. 外观模式</font></h4><p><strong>问题</strong></p><p><strong>解决</strong></p><h4 id="11-享元模式"><a href="#11-享元模式" class="headerlink" title="11. 享元模式"></a><font color=DarkOrange>11. 享元模式</font></h4><p><strong>问题</strong></p><p><strong>解决</strong></p><h4 id="12-代理模式"><a href="#12-代理模式" class="headerlink" title="12. 代理模式"></a><font color=DarkOrange>12. 代理模式</font></h4><p><strong>问题</strong></p><p><strong>解决</strong></p><h4 id="13-责任链模式"><a href="#13-责任链模式" class="headerlink" title="13. 责任链模式"></a><font color=DarkOrange>13. 责任链模式</font></h4><p><strong>问题</strong></p><p><strong>解决</strong></p><h4 id="14-命令模式"><a href="#14-命令模式" class="headerlink" title="14. 命令模式"></a><font color=DarkOrange>14. 命令模式</font></h4><p><strong>问题</strong></p><p><strong>解决</strong></p><h4 id="15-迭代器模式"><a href="#15-迭代器模式" class="headerlink" title="15. 迭代器模式"></a><font color=DarkOrange>15. 迭代器模式</font></h4><p><strong>问题</strong></p><p><strong>解决</strong></p><h4 id="16-中介者模式"><a href="#16-中介者模式" class="headerlink" title="16. 中介者模式"></a><font color=DarkOrange>16. 中介者模式</font></h4><p><strong>问题</strong></p><p><strong>解决</strong></p><h4 id="17-备忘录模式"><a href="#17-备忘录模式" class="headerlink" title="17. 备忘录模式"></a><font color=DarkOrange>17. 备忘录模式</font></h4><p><strong>问题</strong></p><p><strong>解决</strong></p><h4 id="18-观察者模式"><a href="#18-观察者模式" class="headerlink" title="18. 观察者模式"></a><font color=DarkOrange>18. 观察者模式</font></h4><p><strong>问题</strong></p><p><strong>解决</strong></p><h4 id="19-状态模式"><a href="#19-状态模式" class="headerlink" title="19. 状态模式"></a><font color=DarkOrange>19. 状态模式</font></h4><p><strong>问题</strong></p><p><strong>解决</strong></p><h4 id="20-策略模式"><a href="#20-策略模式" class="headerlink" title="20. 策略模式"></a><font color=DarkOrange>20. 策略模式</font></h4><p><strong>问题</strong></p><p><strong>解决</strong></p><h4 id="21-模板方法模式"><a href="#21-模板方法模式" class="headerlink" title="21. 模板方法模式"></a><font color=DarkOrange>21. 模板方法模式</font></h4><p><strong>问题</strong></p><p><strong>解决</strong></p><h4 id="22-访问者模式"><a href="#22-访问者模式" class="headerlink" title="22. 访问者模式"></a><font color=DarkOrange>22. 访问者模式</font></h4><p><strong>问题</strong></p><p><strong>解决</strong></p><h4 id="23-设计模式的“道”"><a href="#23-设计模式的“道”" class="headerlink" title="23. 设计模式的“道”"></a><font color=DarkOrange>23. 设计模式的“道”</font></h4><p>设计模式分为“术”的部分和“道”的部分，上面那些设计模式就是“术”的部分，他们是一些围绕着设计模式核心思路的经典解决方案。换句话说，重要的是理解为什么要用那些设计模式，具体问题，具体分析，而不是把某种设计模式生搬硬套进代码</p><p>设计模式有6大原则，以上的设计模式目的就是为了使软件系统能达到这些原则：</p><ul><li>开闭原则<ul><li>软件应该对扩展开放，对修改关闭</li><li>对系统进行扩展，而无需修改现有的代码。这可以降低软件的维护成本，同时也增加可扩展性</li></ul></li><li>里氏替换原则<ul><li>任何基类可以出现的地方，子类一定可以出现</li><li>里氏替换原则是对开闭原则的补充，实现开闭原则的关键步骤就是抽象化，基类与子类的关系就是要尽可能的抽象化</li></ul></li><li>依赖倒置原则<ul><li>面向接口编程，抽象不应该依赖于具体类，具体类应当依赖于抽象</li><li>这是为了减少类间的耦合，使系统更适宜于扩展，也更便于维护</li></ul></li><li>单一职责原则<ul><li>一个类应该只有一个发生变化的原因</li><li>一个类承载的越多，耦合度就越高。如果类的职责单一，就可以降低出错的风险，也可以提高代码的可读性</li></ul></li><li>最少知道原则<ul><li>一个实体应当尽量少地与其他实体之间发生相互作用</li><li>还是为了降低耦合，一个类与其他类的关联越少，越易于扩展</li></ul></li><li>接口分离原则<ul><li>使用多个专门的接口，而不使用高耦合的单一接口</li><li>避免同一个接口占用过多的职责，更明确的划分，可以降低耦合。高耦合会导致程序不易扩展，提高出错的风险</li></ul></li></ul><hr><p>编程宝库链接：<a href="http://www.codebaoku.com/design-pattern/design-pattern-index.html">点击跳转</a></p><p>掘金链接：<a href="https://juejin.cn/post/7095581880200167432">点击跳转</a></p><p>华为云链接：<a href="https://bbs.huaweicloud.com/blogs/279505">点击跳转</a></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;设计模式是软件工程中各种常见问题的经典解决方案，设计模式不只是代码，而是组织代码的方式。假设一行行的代码是砖，设计模式就是蓝图&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;div style=&quot;width: 32pt&quot;&gt;类型&lt;/div&gt;&lt;/th&gt;
&lt;th&gt;&lt;</summary>
      
    
    
    
    <category term="面试" scheme="https://huajun-chen.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="Go" scheme="https://huajun-chen.github.io/tags/Go/"/>
    
    <category term="设计模式" scheme="https://huajun-chen.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>CodeTop算法题</title>
    <link href="https://huajun-chen.github.io/2022/11/14/CodeTop%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <id>https://huajun-chen.github.io/2022/11/14/CodeTop%E7%AE%97%E6%B3%95%E9%A2%98/</id>
    <published>2022-11-14T03:29:50.000Z</published>
    <updated>2022-11-25T02:32:58.887Z</updated>
    
    <content type="html"><![CDATA[<p>面试LeetCode算法题整理，按照出现的频率依次递减排序，题目类型包含：简单、中等、困难</p><p>CodeTop地址：<a href="https://codetop.cc/home">点击跳转</a></p><p><strong>备注：</strong>出现的频率会随时间变化而变化，具体以CodeTop出现频率为准，每个题目整理出<strong>题目</strong>、<strong>思路</strong>、<strong>代码</strong>三部分</p><h4 id="1-无重复字符的最长子串-中等"><a href="#1-无重复字符的最长子串-中等" class="headerlink" title="1. 无重复字符的最长子串-中等"></a><font color=DarkOrange>1. 无重复字符的最长子串-中等</font></h4><p><strong>题目：</strong></p><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度</p><p><strong>思路：</strong></p><p>滑动窗口</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-反转链表-简单"><a href="#2-反转链表-简单" class="headerlink" title="2. 反转链表-简单"></a><font color=DarkOrange>2. 反转链表-简单</font></h4><p><strong>题目：</strong></p><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表</p><p><strong>思路：</strong></p><p>方法一：迭代</p><p>方法二：递归</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-LRU缓存-中等"><a href="#3-LRU缓存-中等" class="headerlink" title="3. LRU缓存-中等"></a><font color=DarkOrange>3. LRU缓存-中等</font></h4><p><strong>题目：</strong></p><p>请你设计并实现一个满足LRU (最近最少使用) 缓存约束的数据结构</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> </li><li>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字</li></ul><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行</p><p><strong>思路：</strong></p><p>哈希表 + 双向链表</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-数组中的第K个最大元素-中等"><a href="#4-数组中的第K个最大元素-中等" class="headerlink" title="4. 数组中的第K个最大元素-中等"></a><font color=DarkOrange>4. 数组中的第K个最大元素-中等</font></h4><p><strong>题目：</strong></p><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素</p><p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题</p><p><strong>思路：</strong></p><p>方法一：基于快速排序的选择方法</p><p>方法二：基于堆排序的选择方法</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-K个一组翻转链表-困难"><a href="#5-K个一组翻转链表-困难" class="headerlink" title="5. K个一组翻转链表-困难"></a><font color=DarkOrange>5. K个一组翻转链表-困难</font></h4><p><strong>题目：</strong></p><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换</p><p><strong>思路：</strong></p><p>模拟</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-三数之和-中等"><a href="#6-三数之和-中等" class="headerlink" title="6. 三数之和-中等"></a><font color=DarkOrange>6. 三数之和-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数数组<code>nums</code> ，判断是否存在三元组<code>[nums[i], nums[j], nums[k]]</code>满足<code>i != j</code>、<code>i != k</code>且<code>j != k</code>，同时还满足<code>nums[i] + nums[j] + nums[k] == 0</code> </p><p>请你返回所有和为 <code>0</code> 且不重复的三元组</p><p><strong>注意：</strong>答案中不可以包含重复的三元组</p><p><strong>思路：</strong></p><p>排序 + 双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="7-最大子数组和-中等"><a href="#7-最大子数组和-中等" class="headerlink" title="7. 最大子数组和-中等"></a><font color=DarkOrange>7. 最大子数组和-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和</p><p><strong>子数组</strong> 是数组中的一个连续部分</p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：分治</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="8-排序数组-快排-中等"><a href="#8-排序数组-快排-中等" class="headerlink" title="8. 排序数组-快排-中等"></a><font color=DarkOrange>8. 排序数组-快排-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列</p><p><strong>思路：</strong></p><p>通过划分将待排序的序列分成前后两部分，其中前一部分的数据都比后一部分的数据要小，然后再递归调用函数对两部分的序列分别进行快速排序</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="9-合并两个有序链表-简单"><a href="#9-合并两个有序链表-简单" class="headerlink" title="9. 合并两个有序链表-简单"></a><font color=DarkOrange>9. 合并两个有序链表-简单</font></h4><p><strong>题目：</strong></p><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的</p><p><strong>思路：</strong></p><p>方法一：递归</p><p>方法二：迭代</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="10-两数之和-简单"><a href="#10-两数之和-简单" class="headerlink" title="10. 两数之和-简单"></a><font color=DarkOrange>10. 两数之和-简单</font></h4><p><strong>题目：</strong></p><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现</p><p>你可以按任意顺序返回答案</p><p><strong>思路：</strong></p><p>方法一：暴力枚举</p><p>方法二：哈希表</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="11-二叉树的层序遍历-中等"><a href="#11-二叉树的层序遍历-中等" class="headerlink" title="11. 二叉树的层序遍历-中等"></a><font color=DarkOrange>11. 二叉树的层序遍历-中等</font></h4><p><strong>题目：</strong></p><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）</p><p><strong>思路：</strong></p><p>广度优先搜索</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="12-搜索旋转排序数组-中等"><a href="#12-搜索旋转排序数组-中等" class="headerlink" title="12. 搜索旋转排序数组-中等"></a><font color=DarkOrange>12. 搜索旋转排序数组-中等</font></h4><p><strong>题目：</strong></p><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> </p><p>在传递给函数之前，<code>nums</code>在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 旋转，使数组变为<code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 从 0 开始 计数）。例如，<code> [0,1,2,4,5,6,7]</code>在下标<code>3</code>处经旋转后可能变为<code>[4,5,6,7,0,1,2]</code> </p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> </p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题</p><p><strong>思路：</strong></p><p>二分查找</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="13-买卖股票的最佳时机-简单"><a href="#13-买卖股票的最佳时机-简单" class="headerlink" title="13. 买卖股票的最佳时机-简单"></a><font color=DarkOrange>13. 买卖股票的最佳时机-简单</font></h4><p><strong>题目：</strong></p><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> </p><p><strong>思路：</strong></p><p>方法一：暴力法</p><p>方法二：一次遍历</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="14-有效的括号-简单"><a href="#14-有效的括号-简单" class="headerlink" title="14. 有效的括号-简单"></a><font color=DarkOrange>14. 有效的括号-简单</font></h4><p><strong>题目：</strong></p><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合</li><li>左括号必须以正确的顺序闭合</li><li>每个右括号都有一个对应的相同类型的左括号</li></ol><p><strong>思路：</strong></p><p>栈</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="15-岛屿数量-中等"><a href="#15-岛屿数量-中等" class="headerlink" title="15. 岛屿数量-中等"></a><font color=DarkOrange>15. 岛屿数量-中等</font></h4><p><strong>题目：</strong></p><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成</p><p>此外，你可以假设该网格的四条边均被水包围</p><p><strong>思路：</strong></p><p>方法一：深度优先搜索</p><p>方法二：广度优先搜索</p><p>方法三：并查集</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="16-环形链表-简单"><a href="#16-环形链表-简单" class="headerlink" title="16. 环形链表-简单"></a><font color=DarkOrange>16. 环形链表-简单</font></h4><p><strong>题目：</strong></p><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> </p><p><strong>思路：</strong></p><p>方法一：哈希表</p><p>方法二：快慢指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="17-最长回文子串-中等"><a href="#17-最长回文子串-中等" class="headerlink" title="17. 最长回文子串-中等"></a><font color=DarkOrange>17. 最长回文子串-中等</font></h4><p><strong>题目：</strong></p><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串</p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：中心扩展算法</p><p>方法三：Manacher 算法</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="18-二叉树的锯齿形层序遍历-中等"><a href="#18-二叉树的锯齿形层序遍历-中等" class="headerlink" title="18. 二叉树的锯齿形层序遍历-中等"></a><font color=DarkOrange>18. 二叉树的锯齿形层序遍历-中等</font></h4><p><strong>题目：</strong></p><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）</p><p><strong>思路：</strong></p><p>广度优先遍历</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="19-合并两个有序数组-简单"><a href="#19-合并两个有序数组-简单" class="headerlink" title="19. 合并两个有序数组-简单"></a><font color=DarkOrange>19. 合并两个有序数组-简单</font></h4><p><strong>题目：</strong></p><p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目</p><p>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列</p><p><strong>注意：</strong>最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> </p><p><strong>思路：</strong></p><p>方法一：直接合并后排序</p><p>方法二：双指针</p><p>方法三：逆向双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="20-二叉树的最近公共祖先-中等"><a href="#20-二叉树的最近公共祖先-中等" class="headerlink" title="20. 二叉树的最近公共祖先-中等"></a><font color=DarkOrange>20. 二叉树的最近公共祖先-中等</font></h4><p><strong>题目：</strong></p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）”</p><p><strong>思路：</strong></p><p>方法一：递归</p><p>方法二：存储父节点</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="21-全排列-中等"><a href="#21-全排列-中等" class="headerlink" title="21. 全排列-中等"></a><font color=DarkOrange>21. 全排列-中等</font></h4><p><strong>题目：</strong></p><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案</p><p><strong>思路：</strong></p><p>回溯</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="22-相交链表-简单"><a href="#22-相交链表-简单" class="headerlink" title="22. 相交链表-简单"></a><font color=DarkOrange>22. 相交链表-简单</font></h4><p><strong>题目：</strong></p><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h87c37dsm4j311m0q40zb.jpg" alt="image.png" style="zoom:50%;" /></div><p><strong>思路：</strong></p><p>方法一：哈希集合</p><p>方法二：双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="23-螺旋矩阵-中等"><a href="#23-螺旋矩阵-中等" class="headerlink" title="23. 螺旋矩阵-中等"></a><font color=DarkOrange>23. 螺旋矩阵-中等</font></h4><p><strong>题目：</strong></p><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素</p><p><strong>思路：</strong></p><p>方法一：模拟</p><p>方法二：按层模拟</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="24-合并K个升序链表-困难"><a href="#24-合并K个升序链表-困难" class="headerlink" title="24. 合并K个升序链表-困难"></a><font color=DarkOrange>24. 合并K个升序链表-困难</font></h4><p><strong>题目：</strong></p><p>给你一个链表数组，每个链表都已经按升序排列</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表</p><p><strong>思路：</strong></p><p>方法一：顺序合并</p><p>方法二：分治合并</p><p>方法三：使用优先队列合并</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="25-反转链表-II-中等"><a href="#25-反转链表-II-中等" class="headerlink" title="25. 反转链表 II-中等"></a><font color=DarkOrange>25. 反转链表 II-中等</font></h4><p><strong>题目：</strong></p><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code>的链表节点，返回 <strong>反转后的链表</strong> </p><p><strong>思路：</strong></p><p>方法一：穿针引线</p><p>方法二：一次遍历「穿针引线」反转链表（头插法）</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="26-字符串相加-简单"><a href="#26-字符串相加-简单" class="headerlink" title="26. 字符串相加-简单"></a><font color=DarkOrange>26. 字符串相加-简单</font></h4><p><strong>题目：</strong></p><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和并同样以字符串形式返回</p><p>你不能使用任何內建的用于处理大整数的库（比如 <code>BigInteger</code>）， 也不能直接将输入的字符串转换为整数形式</p><p><strong>思路：</strong></p><p>模拟</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="27-环形链表-II-中等"><a href="#27-环形链表-II-中等" class="headerlink" title="27. 环形链表 II-中等"></a><font color=DarkOrange>27. 环形链表 II-中等</font></h4><p><strong>题目：</strong></p><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 <code>null</code></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况</p><p><strong>思路：</strong></p><p>方法一：哈希表</p><p>方法二：快慢指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="28-长递增子序列-中等"><a href="#28-长递增子序列-中等" class="headerlink" title="28. 长递增子序列-中等"></a><font color=DarkOrange>28. 长递增子序列-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度</p><p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列</p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：贪心 + 二分查找</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="29-接雨水-困难"><a href="#29-接雨水-困难" class="headerlink" title="29. 接雨水-困难"></a><font color=DarkOrange>29. 接雨水-困难</font></h4><p><strong>题目：</strong></p><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水</p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：单调栈</p><p>方法三：双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="30-二叉树中的最大路径和-困难"><a href="#30-二叉树中的最大路径和-困难" class="headerlink" title="30. 二叉树中的最大路径和-困难"></a><font color=DarkOrange>30. 二叉树中的最大路径和-困难</font></h4><p><strong>题目：</strong></p><p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点</p><p><strong>路径和</strong> 是路径中各节点值的总和</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> </p><p><strong>思路：</strong></p><p>递归</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="31-重排链表-中等"><a href="#31-重排链表-中等" class="headerlink" title="31. 重排链表-中等"></a><font color=DarkOrange>31. 重排链表-中等</font></h4><p><strong>题目：</strong></p><p>给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L0 → L1 → … → Ln - 1 → Ln</span><br></pre></td></tr></table></figure><p>请将其重新排列后变为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</span><br></pre></td></tr></table></figure><p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换</p><p><strong>思路：</strong></p><p>方法一：线性表</p><p>方法二：寻找链表中点 + 链表逆序 + 合并链表</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="32-二叉树的中序遍历-简单"><a href="#32-二叉树的中序遍历-简单" class="headerlink" title="32. 二叉树的中序遍历-简单"></a><font color=DarkOrange>32. 二叉树的中序遍历-简单</font></h4><p><strong>题目：</strong></p><p>给定一个二叉树的根节点 <code>root</code> ，返回 它的 <strong>中序</strong>遍历</p><p><strong>思路：</strong></p><p>方法一：递归</p><p>方法二：迭代</p><p>方法三：Morris 中序遍历</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="33-二分查找-简单"><a href="#33-二分查找-简单" class="headerlink" title="33. 二分查找-简单"></a><font color=DarkOrange>33. 二分查找-简单</font></h4><p><strong>题目：</strong></p><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code></p><p><strong>思路：</strong></p><p>二分查找</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="34-编辑距离-困难"><a href="#34-编辑距离-困难" class="headerlink" title="34. 编辑距离-困难"></a><font color=DarkOrange>34. 编辑距离-困难</font></h4><p><strong>题目：</strong></p><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， 请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p><strong>思路：</strong></p><p>动态规划</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="35-用栈实现队列-简单"><a href="#35-用栈实现队列-简单" class="headerlink" title="35. 用栈实现队列-简单"></a><font color=DarkOrange>35. 用栈实现队列-简单</font></h4><p><strong>题目：</strong></p><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p><p>实现 <code>MyQueue</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><p>说明：</p><ul><li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可</li></ul><p><strong>思路：</strong></p><p>双栈</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="36-寻找两个正序数组的中位数-困难"><a href="#36-寻找两个正序数组的中位数-困难" class="headerlink" title="36. 寻找两个正序数组的中位数-困难"></a><font color=DarkOrange>36. 寻找两个正序数组的中位数-困难</font></h4><p><strong>题目：</strong></p><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> </p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> </p><p><strong>思路：</strong></p><p>方法一：二分查找</p><p>方法二：划分数组</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="37-二叉树的右视图-中等"><a href="#37-二叉树的右视图-中等" class="headerlink" title="37. 二叉树的右视图-中等"></a><font color=DarkOrange>37. 二叉树的右视图-中等</font></h4><p><strong>题目：</strong></p><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值</p><p><strong>思路：</strong></p><p>方法一：深度优先搜索</p><p>方法二：广度优先搜索</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="38-除链表的倒数第N个结点-中等"><a href="#38-除链表的倒数第N个结点-中等" class="headerlink" title="38. 除链表的倒数第N个结点-中等"></a><font color=DarkOrange>38. 除链表的倒数第N个结点-中等</font></h4><p><strong>题目：</strong></p><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点</p><p><strong>思路：</strong></p><p>方法一：计算链表长度</p><p>方法二：栈</p><p>方法三：双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="39-爬楼梯-简单"><a href="#39-爬楼梯-简单" class="headerlink" title="39. 爬楼梯-简单"></a><font color=DarkOrange>39. 爬楼梯-简单</font></h4><p><strong>题目：</strong></p><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢</p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：矩阵快速幂</p><p>方法三：通项公式</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="40-合并区间-中等"><a href="#40-合并区间-中等" class="headerlink" title="40. 合并区间-中等"></a><font color=DarkOrange>40. 合并区间-中等</font></h4><p><strong>题目：</strong></p><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</p><p><strong>思路：</strong></p><p>排序</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="41-排序链表-中等"><a href="#41-排序链表-中等" class="headerlink" title="41. 排序链表-中等"></a><font color=DarkOrange>41. 排序链表-中等</font></h4><p><strong>题目：</strong></p><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> </p><p><strong>思路：</strong></p><p>方法一：自顶向下归并排序</p><p>方法二：自底向上归并排序</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="42-删除排序链表中的重复元素-II-中等"><a href="#42-删除排序链表中的重复元素-II-中等" class="headerlink" title="42. 删除排序链表中的重复元素 II-中等"></a><font color=DarkOrange>42. 删除排序链表中的重复元素 II-中等</font></h4><p><strong>题目：</strong></p><p>给定一个已排序的链表的头<code>head</code>，删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表</p><p><strong>思路：</strong></p><p>一次遍历</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="43-下一个排列-中等"><a href="#43-下一个排列-中等" class="headerlink" title="43. 下一个排列-中等"></a><font color=DarkOrange>43. 下一个排列-中等</font></h4><p><strong>题目：</strong></p><p>整数数组的一个 <strong>排列</strong> 就是将其所有成员以序列或线性顺序排列</p><ul><li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code></li></ul><p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）</p><ul><li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> </li><li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> </li><li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列</li></ul><p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列</p><p>必须<strong>原地</strong>修改，只允许使用额外常数空间</p><p><strong>思路：</strong></p><p>两遍扫描</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="44-x-的平方根-简单"><a href="#44-x-的平方根-简单" class="headerlink" title="44. x 的平方根 -简单"></a><font color=DarkOrange>44. x 的平方根 -简单</font></h4><p><strong>题目：</strong></p><p>给你一个非负整数 <code>x</code> ，计算并返回 <code>x</code> 的 <strong>算术平方根</strong> </p><p>由于返回类型是整数，结果只保留 <strong>整数部分</strong> ，小数部分将被 **舍去 **</p><p><strong>注意：</strong>不允许使用任何内置指数函数和算符，例如 <code>pow(x, 0.5)</code> 或者 <code>x ** 0.5</code>  </p><p><strong>思路：</strong></p><p>方法一：袖珍计算器算法</p><p>方法二：二分查找</p><p>方法三：牛顿迭代</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="45-两数相加-中等"><a href="#45-两数相加-中等" class="headerlink" title="45. 两数相加-中等"></a><font color=DarkOrange>45. 两数相加-中等</font></h4><p><strong>题目：</strong></p><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头</p><p><strong>思路：</strong></p><p>模拟</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="46-字符串转换整数-atoi-中等"><a href="#46-字符串转换整数-atoi-中等" class="headerlink" title="46. 字符串转换整数 (atoi)-中等"></a><font color=DarkOrange>46. 字符串转换整数 (atoi)-中等</font></h4><p><strong>题目：</strong></p><p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C&#x2F;C++ 中的 <code>atoi</code> 函数）</p><p>函数 <code>myAtoi(string s)</code> 的算法如下：</p><ol><li>读入字符串并丢弃无用的前导空格</li><li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正</li><li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略</li><li>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）</li><li>如果整数数超过 32 位有符号整数范围 <code>[−231, 231 − 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <code>−231</code> 的整数应该被固定为 <code>−231</code> ，大于 <code>231 − 1</code> 的整数应该被固定为 <code>231 − 1</code> </li><li>返回整数作为最终结果</li></ol><p><strong>注意：</strong></p><ul><li>本题中的空白字符只包括空格字符 <code>&#39; &#39;</code> </li><li>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong> 任何其他字符</li></ul><p><strong>思路：</strong></p><p>自动机</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="47-最长公共子序列-中等"><a href="#47-最长公共子序列-中等" class="headerlink" title="47. 最长公共子序列-中等"></a><font color=DarkOrange>47. 最长公共子序列-中等</font></h4><p><strong>题目：</strong></p><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> </p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列</p><p><strong>思路：</strong></p><p>动态规划</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="48-括号生成-中等"><a href="#48-括号生成-中等" class="headerlink" title="48. 括号生成-中等"></a><font color=DarkOrange>48. 括号生成-中等</font></h4><p><strong>题目：</strong></p><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合</p><p><strong>思路：</strong></p><p>方法一：暴力法</p><p>方法二：回溯法</p><p>方法三：按括号序列的长度递归</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="49-滑动窗口最大值-困难"><a href="#49-滑动窗口最大值-困难" class="headerlink" title="49. 滑动窗口最大值-困难"></a><font color=DarkOrange>49. 滑动窗口最大值-困难</font></h4><p><strong>题目：</strong></p><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的<code>k</code> 个数字。滑动窗口每次只向右移动一位</p><p>返回 滑动窗口中的最大值</p><p><strong>思路：</strong></p><p>方法一：优先队列</p><p>方法二：单调队列</p><p>方法三：分块 + 预处理</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="50-复原-IP-地址-中等"><a href="#50-复原-IP-地址-中等" class="headerlink" title="50. 复原 IP 地址-中等"></a><font color=DarkOrange>50. 复原 IP 地址-中等</font></h4><p><strong>题目：</strong></p><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>&#39;.&#39;</code> 分隔</p><ul><li>例如：<code>&quot;0.1.2.201&quot;</code> 和<code> &quot;192.168.1.1&quot;</code> 是 <strong>有效</strong> IP 地址，但是 <code>&quot;0.011.255.245&quot;</code>、<code>&quot;192.168.1.312&quot;</code> 和<code>&quot;192.168@1.1&quot;</code> 是 <strong>无效</strong> IP 地址</li></ul><p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入 <code>&#39;.&#39;</code> 来形成。你 <strong>不能</strong> 重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案</p><p><strong>思路：</strong></p><p>回溯</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="51-缺失的第一个正数-困难"><a href="#51-缺失的第一个正数-困难" class="headerlink" title="51. 缺失的第一个正数-困难"></a><font color=DarkOrange>51. 缺失的第一个正数-困难</font></h4><p><strong>题目：</strong></p><p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数</p><p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案</p><p><strong>思路：</strong></p><p>方法一：哈希表</p><p>方法二：置换</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="52-链表中倒数第k个节点-简单"><a href="#52-链表中倒数第k个节点-简单" class="headerlink" title="52. 链表中倒数第k个节点-简单"></a><font color=DarkOrange>52. 链表中倒数第k个节点-简单</font></h4><p><strong>题目：</strong></p><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点</p><p>例如，一个链表有 <code>6</code> 个节点，从头节点开始，它们的值依次是 <code>1、2、3、4、5、6</code>。这个链表的倒数第 <code>3</code> 个节点是值为 <code>4</code> 的节点</p><p><strong>思路：</strong></p><p>方法一：顺序查找</p><p>方法二：双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="53-从前序与中序遍历序列构造二叉树-中等"><a href="#53-从前序与中序遍历序列构造二叉树-中等" class="headerlink" title="53. 从前序与中序遍历序列构造二叉树-中等"></a><font color=DarkOrange>53. 从前序与中序遍历序列构造二叉树-中等</font></h4><p><strong>题目：</strong></p><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点</p><p><strong>思路：</strong></p><p>方法一：递归</p><p>方法二：迭代</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="54-比较版本号-中等"><a href="#54-比较版本号-中等" class="headerlink" title="54. 比较版本号-中等"></a><font color=DarkOrange>54. 比较版本号-中等</font></h4><p><strong>题目：</strong></p><p>给你两个版本号 <code>version1</code> 和 <code>version2</code> ，请你比较它们</p><p>版本号由一个或多个修订号组成，各修订号由一个 <code>&#39;.&#39;</code> 连接。每个修订号由 <strong>多位数字</strong> 组成，可能包含 <strong>前导零</strong> 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，<code>2.5.33</code> 和 <code>0.1</code> 都是有效的版本号</p><p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 <strong>忽略任何前导零后的整数值</strong> 。也就是说，修订号 <code>1</code> 和修订号 <code>001</code> <strong>相等</strong> 。如果版本号没有指定某个下标处的修订号，则该修订号视为 <code>0</code> 。例如，版本 <code>1.0</code> 小于版本<code>1.1</code> ，因为它们下标为 <code>0</code> 的修订号相同，而下标为 <code>1</code> 的修订号分别为 <code>0</code> 和 <code>1</code> ，<code>0 &lt; 1</code> </p><p>返回规则如下：</p><ul><li>如果 <code>*version1* &gt; *version2*</code> 返回 <code>1</code></li><li>如果 <code>*version1* &lt; *version2*</code> 返回 <code>-1</code></li><li>除此之外返回 <code>0</code></li></ul><p><strong>思路：</strong></p><p>方法一：字符串分割</p><p>方法二：双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="55-零钱兑换-中等"><a href="#55-零钱兑换-中等" class="headerlink" title="55. 零钱兑换-中等"></a><font color=DarkOrange>55. 零钱兑换-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> </p><p>你可以认为每种硬币的数量是无限的</p><p><strong>思路：</strong></p><p>方法一：记忆化搜索</p><p>方法二：动态规划</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="56-最小覆盖子串-困难"><a href="#56-最小覆盖子串-困难" class="headerlink" title="56. 最小覆盖子串-困难"></a><font color=DarkOrange>56. 最小覆盖子串-困难</font></h4><p><strong>题目：</strong></p><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> </p><p><strong>注意：</strong></p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案</li></ul><p><strong>思路：</strong></p><p>滑动窗口</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="57-二叉树的前序遍历-简单"><a href="#57-二叉树的前序遍历-简单" class="headerlink" title="57. 二叉树的前序遍历-简单"></a><font color=DarkOrange>57. 二叉树的前序遍历-简单</font></h4><p><strong>题目：</strong></p><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历</p><p><strong>思路：</strong></p><p>方法一：递归</p><p>方法二：迭代</p><p>方法三：Morris 遍历</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="58-反转字符串中的单词-中等"><a href="#58-反转字符串中的单词-中等" class="headerlink" title="58. 反转字符串中的单词-中等"></a><font color=DarkOrange>58. 反转字符串中的单词-中等</font></h4><p><strong>题目：</strong></p><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序</p><p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开</p><p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串</p><p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格</p><p><strong>思路：</strong></p><p>方法一：使用语言特性</p><p>方法二：自行编写对应的函数</p><p>方法三：双端队列</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="59-字符串相乘-中等"><a href="#59-字符串相乘-中等" class="headerlink" title="59. 字符串相乘-中等"></a><font color=DarkOrange>59. 字符串相乘-中等</font></h4><p><strong>题目：</strong></p><p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式</p><p><strong>注意：</strong>不能使用任何内置的 BigInteger 库或直接将输入转换为整数</p><p><strong>思路：</strong></p><p>方法一：做加法</p><p>方法二：做乘法</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="60-最小栈-中等"><a href="#60-最小栈-中等" class="headerlink" title="60. 最小栈-中等"></a><font color=DarkOrange>60. 最小栈-中等</font></h4><p><strong>题目：</strong></p><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈</p><p>实现 <code>MinStack</code> 类：</p><ul><li><code>MinStack()</code> 初始化堆栈对象</li><li><code>void push(int val)</code> 将元素val推入堆栈</li><li><code>void pop()</code> 删除堆栈顶部的元素</li><li><code>int top()</code> 获取堆栈顶部的元素</li><li><code>int getMin()</code> 获取堆栈中的最小元素</li></ul><p><strong>思路：</strong></p><p>辅助栈</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="61-平衡二叉树-简单"><a href="#61-平衡二叉树-简单" class="headerlink" title="61. 平衡二叉树-简单"></a><font color=DarkOrange>61. 平衡二叉树-简单</font></h4><p><strong>题目：</strong></p><p>给定一个二叉树，判断它是否是高度平衡的二叉树</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 </p></blockquote><p><strong>思路：</strong></p><p>方法一：自顶向下的递归</p><p>方法二：自底向上的递归</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="62-子集-中等"><a href="#62-子集-中等" class="headerlink" title="62. 子集-中等"></a><font color=DarkOrange>62. 子集-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集</p><p><strong>思路：</strong></p><p>方法一：迭代法实现子集枚举</p><p>方法二：递归法实现子集枚举</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="63-二叉树的最大深度-简单"><a href="#63-二叉树的最大深度-简单" class="headerlink" title="63. 二叉树的最大深度-简单"></a><font color=DarkOrange>63. 二叉树的最大深度-简单</font></h4><p><strong>题目：</strong></p><p>给定一个二叉树，找出其最大深度</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点</p><p><strong>思路：</strong></p><p>方法一：深度优先搜索</p><p>方法二：广度优先搜索</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="64-求根节点到叶节点数字之和-中等"><a href="#64-求根节点到叶节点数字之和-中等" class="headerlink" title="64. 求根节点到叶节点数字之和-中等"></a><font color=DarkOrange>64. 求根节点到叶节点数字之和-中等</font></h4><p><strong>题目：</strong></p><p>给你一个二叉树的根节点 <code>root</code> ，树中每个节点都存放有一个 <code>0</code> 到 <code>9</code> 之间的数字</p><p>每条从根节点到叶节点的路径都代表一个数字：</p><ul><li>例如，从根节点到叶节点的路径 <code>1 -&gt; 2 -&gt; 3</code> 表示数字 <code>123</code></li></ul><p>计算从根节点到叶节点生成的 <strong>所有数字之和</strong> </p><p><strong>叶节点</strong> 是指没有子节点的节点</p><p><strong>思路：</strong></p><p>方法一：深度优先搜索</p><p>方法二：广度优先搜索</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="65-最长有效括号-困难"><a href="#65-最长有效括号-困难" class="headerlink" title="65. 最长有效括号-困难"></a><font color=DarkOrange>65. 最长有效括号-困难</font></h4><p><strong>题目：</strong></p><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度</p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：栈</p><p>方法三：不需要额外的空间</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="66-对称二叉树-简单"><a href="#66-对称二叉树-简单" class="headerlink" title="66. 对称二叉树-简单"></a><font color=DarkOrange>66. 对称二叉树-简单</font></h4><p><strong>题目：</strong></p><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称</p><p><strong>思路：</strong></p><p>方法一：递归</p><p>方法二：迭代</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="67-验证二叉搜索树-中等"><a href="#67-验证二叉搜索树-中等" class="headerlink" title="67. 验证二叉搜索树-中等"></a><font color=DarkOrange>67. 验证二叉搜索树-中等</font></h4><p><strong>题目：</strong></p><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数</li><li>所有左子树和右子树自身必须也是二叉搜索树</li></ul><p><strong>思路：</strong></p><p>方法一: 递归</p><p>方法二：中序遍历</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="68-最小路径和-中等"><a href="#68-最小路径和-中等" class="headerlink" title="68. 最小路径和-中等"></a><font color=DarkOrange>68. 最小路径和-中等</font></h4><p><strong>题目：</strong></p><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小</p><p><strong>说明：</strong>每次只能向下或者向右移动一步</p><p><strong>思路：</strong></p><p>动态规划</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="69-二叉树的直径-简单"><a href="#69-二叉树的直径-简单" class="headerlink" title="69. 二叉树的直径-简单"></a><font color=DarkOrange>69. 二叉树的直径-简单</font></h4><p><strong>题目：</strong></p><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点</p><p><strong>思路：</strong></p><p>深度优先搜索</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="70-路径总和-II-中等"><a href="#70-路径总和-II-中等" class="headerlink" title="70. 路径总和 II-中等"></a><font color=DarkOrange>70. 路径总和 II-中等</font></h4><p><strong>题目：</strong></p><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径</p><p><strong>叶子节点</strong> 是指没有子节点的节点</p><p><strong>思路：</strong></p><p>方法一：深度优先搜索</p><p>方法二：广度优先搜索</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="71-Rand7-实现-Rand10-简单"><a href="#71-Rand7-实现-Rand10-简单" class="headerlink" title="71.  Rand7() 实现 Rand10()-简单"></a><font color=DarkOrange>71.  Rand7() 实现 Rand10()-简单</font></h4><p><strong>题目：</strong></p><p>给定方法 <code>rand7</code> 可生成 <code>[1,7]</code> 范围内的均匀随机整数，试写一个方法 <code>rand10</code> 生成 <code>[1,10]</code> 范围内的均匀随机整数</p><p>你只能调用 <code>rand7()</code> 且不能调用其他方法。请不要使用系统的 <code>Math.random()</code> 方法</p><p>每个测试用例将有一个内部参数 <code>n</code>，即你实现的函数 <code>rand10()</code> 在测试时将被调用的次数。请注意，这不是传递给 <code>rand10()</code> 的参数</p><p><strong>思路：</strong></p><p>拒绝采样</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="72-组合总和-中等"><a href="#72-组合总和-中等" class="headerlink" title="72. 组合总和-中等"></a><font color=DarkOrange>72. 组合总和-中等</font></h4><p><strong>题目：</strong></p><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的</p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个</p><p><strong>思路：</strong></p><p>搜索回溯</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="73-旋转图像-中等"><a href="#73-旋转图像-中等" class="headerlink" title="73. 旋转图像-中等"></a><font color=DarkOrange>73. 旋转图像-中等</font></h4><p><strong>题目：</strong></p><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度</p><p>你必须在<strong>原地</strong> 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像</p><p><strong>思路：</strong></p><p>方法一：使用辅助数组</p><p>方法二：原地旋转</p><p>方法三：用翻转代替旋转</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="74-路径总和-简单"><a href="#74-路径总和-简单" class="headerlink" title="74. 路径总和-简单"></a><font color=DarkOrange>74. 路径总和-简单</font></h4><p><strong>题目：</strong></p><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> </p><p><strong>叶子节点</strong> 是指没有子节点的节点</p><p><strong>思路：</strong></p><p>方法一：广度优先搜索</p><p>方法二：递归</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="75-回文链表-简单"><a href="#75-回文链表-简单" class="headerlink" title="75. 回文链表-简单"></a><font color=DarkOrange>75. 回文链表-简单</font></h4><p><strong>题目：</strong></p><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> </p><p><strong>思路：</strong></p><p>方法一：将值复制到数组中后用双指针法</p><p>方法二：递归</p><p>方法三：快慢指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="76-多数元素-简单"><a href="#76-多数元素-简单" class="headerlink" title="76. 多数元素-简单"></a><font color=DarkOrange>76. 多数元素-简单</font></h4><p><strong>题目：</strong></p><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素</p><p><strong>思路：</strong></p><p>方法一：哈希表</p><p>方法二：排序</p><p>方法三：随机化</p><p>方法四：分治</p><p>方法五：Boyer-Moore 投票算法</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="77-最长重复子数组-中等"><a href="#77-最长重复子数组-中等" class="headerlink" title="77. 最长重复子数组-中等"></a><font color=DarkOrange>77. 最长重复子数组-中等</font></h4><p><strong>题目：</strong></p><p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度 </p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：滑动窗口</p><p>方法三：二分查找 + 哈希</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="78-最大正方形-中等"><a href="#78-最大正方形-中等" class="headerlink" title="78. 最大正方形-中等"></a><font color=DarkOrange>78. 最大正方形-中等</font></h4><p><strong>题目：</strong></p><p>在一个由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的二维矩阵内，找到只包含 <code>&#39;1&#39;</code> 的最大正方形，并返回其面积</p><p><strong>思路：</strong></p><p>方法一：暴力法</p><p>方法二：动态规划</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="79-字符串解码-中等"><a href="#79-字符串解码-中等" class="headerlink" title="79. 字符串解码-中等"></a><font color=DarkOrange>79. 字符串解码-中等</font></h4><p><strong>题目：</strong></p><p>给定一个经过编码的字符串，返回它解码后的字符串</p><p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入</p><p><strong>思路：</strong></p><p>方法一：栈操作</p><p>方法二：递归</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="80-搜索二维矩阵-II-中等"><a href="#80-搜索二维矩阵-II-中等" class="headerlink" title="80. 搜索二维矩阵 II-中等"></a><font color=DarkOrange>80. 搜索二维矩阵 II-中等</font></h4><p><strong>题目：</strong></p><p>编写一个高效的算法来搜索 <code>*m* x *n*</code> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p><ul><li>每行的元素从左到右升序排列</li><li>每列的元素从上到下升序排列</li></ul><p><strong>思路：</strong></p><p>方法一：直接查找</p><p>方法二：二分查找</p><p>方法三：Z 字形查找</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="81-翻转二叉树-简单"><a href="#81-翻转二叉树-简单" class="headerlink" title="81. 翻转二叉树-简单"></a><font color=DarkOrange>81. 翻转二叉树-简单</font></h4><p><strong>题目：</strong></p><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点</p><p><strong>思路：</strong></p><p>递归</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="82-在排序数组中查找元素的第一个和最后一个位置-中等"><a href="#82-在排序数组中查找元素的第一个和最后一个位置-中等" class="headerlink" title="82. 在排序数组中查找元素的第一个和最后一个位置-中等"></a><font color=DarkOrange>82. 在排序数组中查找元素的第一个和最后一个位置-中等</font></h4><p><strong>题目：</strong></p><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code></p><p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题</p><p><strong>思路：</strong></p><p>二分查找</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="83-最长公共前缀-简单"><a href="#83-最长公共前缀-简单" class="headerlink" title="83. 最长公共前缀-简单"></a><font color=DarkOrange>83. 最长公共前缀-简单</font></h4><p><strong>题目：</strong></p><p>编写一个函数来查找字符串数组中的最长公共前缀</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code></p><p><strong>思路：</strong></p><p>方法一：横向扫描</p><p>方法二：纵向扫描</p><p>方法三：分治</p><p>方法四：二分查找</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="84-寻找峰值-中等"><a href="#84-寻找峰值-中等" class="headerlink" title="84. 寻找峰值-中等"></a><font color=DarkOrange>84. 寻找峰值-中等</font></h4><p><strong>题目：</strong></p><p>峰值元素是指其值严格大于左右相邻值的元素</p><p>给你一个整数数组 <code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可</p><p>你可以假设 <code>nums[-1] = nums[n] = -∞</code> </p><p>你必须实现时间复杂度为 <code>O(log n)</code> 的算法来解决此问题</p><p><strong>思路：</strong></p><p>方法一：寻找最大值</p><p>方法二：迭代爬坡</p><p>方法三：方法二的二分查找优化</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="85-最长连续序列-中等"><a href="#85-最长连续序列-中等" class="headerlink" title="85. 最长连续序列-中等"></a><font color=DarkOrange>85. 最长连续序列-中等</font></h4><p><strong>题目：</strong></p><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度</p><p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题</p><p><strong>思路：</strong></p><p>哈希表</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="86-基本计算器-II-中等"><a href="#86-基本计算器-II-中等" class="headerlink" title="86. 基本计算器 II-中等"></a><font color=DarkOrange>86. 基本计算器 II-中等</font></h4><p><strong>题目：</strong></p><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值</p><p>整数除法仅保留整数部分</p><p>你可以假设给定的表达式总是有效的。所有中间结果将在 <code>[-2^31, 2^31 - 1]</code> 的范围内</p><p><strong>注意：</strong>不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval()</code> </p><p><strong>思路：</strong></p><p>栈</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="87-岛屿的最大面积-中等"><a href="#87-岛屿的最大面积-中等" class="headerlink" title="87. 岛屿的最大面积-中等"></a><font color=DarkOrange>87. 岛屿的最大面积-中等</font></h4><p><strong>题目：</strong></p><p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code> </p><p><strong>岛屿</strong> 是由一些相邻的 <code>1</code> (代表土地) 构成的组合，这里的「相邻」要求两个 <code>1</code> 必须在 <strong>水平或者竖直的四个方向上</strong> 相邻。你可以假设 <code>grid</code> 的四个边缘都被 <code>0</code>（代表水）包围着</p><p>岛屿的面积是岛上值为 <code>1</code> 的单元格的数目</p><p>计算并返回 <code>grid</code> 中最大的岛屿面积。如果没有岛屿，则返回面积为 <code>0</code> </p><p><strong>思路：</strong></p><p>方法一：深度优先搜索</p><p>方法二：深度优先搜索 + 栈</p><p>方法三：广度优先搜索</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="88-删除排序链表中的重复元素-简单"><a href="#88-删除排序链表中的重复元素-简单" class="headerlink" title="88. 删除排序链表中的重复元素-简单"></a><font color=DarkOrange>88. 删除排序链表中的重复元素-简单</font></h4><p><strong>题目：</strong></p><p>给定一个已排序的链表的头 <code>head</code> ， 删除所有重复的元素，使每个元素只出现一次 。返回已排序的链表</p><p><strong>思路：</strong></p><p>一次遍历</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="89-不同路径-中等"><a href="#89-不同路径-中等" class="headerlink" title="89. 不同路径-中等"></a><font color=DarkOrange>89. 不同路径-中等</font></h4><p><strong>题目：</strong></p><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）</p><p>问总共有多少条不同的路径？</p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：组合数学</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="90-打家劫舍-中等"><a href="#90-打家劫舍-中等" class="headerlink" title="90. 打家劫舍-中等"></a><font color=DarkOrange>90. 打家劫舍-中等</font></h4><p><strong>题目：</strong></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong></p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额</p><p><strong>思路：</strong></p><p>动态规划</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="91-买卖股票的最佳时机-II-中等"><a href="#91-买卖股票的最佳时机-II-中等" class="headerlink" title="91. 买卖股票的最佳时机 II-中等"></a><font color=DarkOrange>91. 买卖股票的最佳时机 II-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格</p><p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售</p><p>返回你能获得的 <strong>最大</strong> 利润</p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：贪心</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="92-两两交换链表中的节点-中等"><a href="#92-两两交换链表中的节点-中等" class="headerlink" title="92. 两两交换链表中的节点-中等"></a><font color=DarkOrange>92. 两两交换链表中的节点-中等</font></h4><p><strong>题目：</strong></p><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）</p><p><strong>思路：</strong></p><p>方法一：递归</p><p>方法二：迭代</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="93-乘积最大子数组-中等"><a href="#93-乘积最大子数组-中等" class="headerlink" title="93. 乘积最大子数组-中等"></a><font color=DarkOrange>93. 乘积最大子数组-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积</p><p>测试用例的答案是一个 <strong>32-位</strong> 整数</p><p><strong>子数组</strong> 是数组的连续子序列</p><p><strong>思路：</strong></p><p>动态规划</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="94-移动零-简单"><a href="#94-移动零-简单" class="headerlink" title="94. 移动零-简单"></a><font color=DarkOrange>94. 移动零-简单</font></h4><p><strong>题目：</strong></p><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作</p><p><strong>思路：</strong></p><p>双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="95-二叉树最大宽度-中等"><a href="#95-二叉树最大宽度-中等" class="headerlink" title="95. 二叉树最大宽度-中等"></a><font color=DarkOrange>95. 二叉树最大宽度-中等</font></h4><p><strong>题目：</strong></p><p>给你一棵二叉树的根节点 <code>root</code> ，返回树的 <strong>最大宽度</strong> </p><p>树的 <strong>最大宽度</strong> 是所有层中最大的 <strong>宽度</strong> </p><p>每一层的 <strong>宽度</strong> 被定义为该层最左和最右的非空节点（即，两个端点）之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的 <code>null</code> 节点，这些 <code>null</code> 节点也计入长度</p><p>题目数据保证答案将会在 <strong>32 位</strong> 带符号整数范围内</p><p><strong>思路：</strong></p><p>方法一：广度优先搜索</p><p>方法二：深度优先搜索</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="96-复制带随机指针的链表-中等"><a href="#96-复制带随机指针的链表-中等" class="headerlink" title="96. 复制带随机指针的链表-中等"></a><font color=DarkOrange>96. 复制带随机指针的链表-中等</font></h4><p><strong>题目：</strong></p><p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点</p><p>构造这个链表的 <strong><a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin">深拷贝</a><strong>。 深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong> 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的<code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。</strong>复制链表中的指针都不应指向原链表中的节点</strong> </p><p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 <code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> </p><p>返回复制链表的头节点</p><p>用一个由 <code>n</code> 个节点组成的链表来表示输入&#x2F;输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p><ul><li><code>val</code>：一个表示 <code>Node.val</code> 的整数</li><li><code>random_index</code>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为 <code>null</code></li></ul><p>你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code> 作为传入参数</p><p><strong>思路：</strong></p><p>方法一：回溯 + 哈希表</p><p>方法二：迭代 + 节点拆分</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="97-排序数组-堆排序-中等"><a href="#97-排序数组-堆排序-中等" class="headerlink" title="97. 排序数组-堆排序-中等"></a><font color=DarkOrange>97. 排序数组-堆排序-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列</p><p><strong>思路：</strong></p><p>先将待排序的序列建成大根堆，使得每个父节点的元素大于等于它的子节点</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="98-寻找旋转排序数组中的最小值-中等"><a href="#98-寻找旋转排序数组中的最小值-中等" class="headerlink" title="98. 寻找旋转排序数组中的最小值-中等"></a><font color=DarkOrange>98. 寻找旋转排序数组中的最小值-中等</font></h4><p><strong>题目：</strong></p><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p><ul><li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li><li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li></ul><p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> </p><p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> </p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题</p><p><strong>思路：</strong></p><p>二分查找</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="99-最大数-中等"><a href="#99-最大数-中等" class="headerlink" title="99. 最大数-中等"></a><font color=DarkOrange>99. 最大数-中等</font></h4><p><strong>题目：</strong></p><p>给定一组非负整数 <code>nums</code>，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数</p><p><strong>注意：</strong>输出结果可能非常大，所以你需要返回一个字符串而不是整数</p><p><strong>思路：</strong></p><p>排序</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="100-二叉树的序列化与反序列化-困难"><a href="#100-二叉树的序列化与反序列化-困难" class="headerlink" title="100. 二叉树的序列化与反序列化-困难"></a><font color=DarkOrange>100. 二叉树的序列化与反序列化-困难</font></h4><p><strong>题目：</strong></p><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 &#x2F; 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构</p><p><strong>思路：</strong></p><p>方法一：深度优先搜索</p><p>方法二：括号表示编码 + 递归下降解码</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="101-长度最小的子数组-中等"><a href="#101-长度最小的子数组-中等" class="headerlink" title="101. 长度最小的子数组-中等"></a><font color=DarkOrange>101. 长度最小的子数组-中等</font></h4><p><strong>题目：</strong></p><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> </p><p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> </p><p><strong>思路：</strong></p><p>方法一：暴力法</p><p>方法二：前缀和 + 二分查找</p><p>方法三：滑动窗口</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="102-单词拆分-中等"><a href="#102-单词拆分-中等" class="headerlink" title="102. 单词拆分-中等"></a><font color=DarkOrange>102. 单词拆分-中等</font></h4><p><strong>题目：</strong></p><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。请你判断是否可以利用字典中出现的单词拼接出 <code>s</code> </p><p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用</p><p><strong>思路：</strong></p><p>动态规划</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="103-验证IP地址-中等"><a href="#103-验证IP地址-中等" class="headerlink" title="103. 验证IP地址-中等"></a><font color=DarkOrange>103. 验证IP地址-中等</font></h4><p><strong>题目：</strong></p><p>给定一个字符串 <code>queryIP</code>。如果是有效的 IPv4 地址，返回 <code>&quot;IPv4&quot;</code> ；如果是有效的 IPv6 地址，返回 <code>&quot;IPv6&quot;</code> ；如果不是上述类型的 IP 地址，返回 <code>&quot;Neither&quot;</code> </p><p><strong>有效的IPv4地址</strong> 是 <code>“x1.x2.x3.x4”</code> 形式的IP地址。 其中 <code>0 &lt;= xi &lt;= 255</code> 且 <code>xi</code> <strong>不能包含</strong> 前导零。例如: <code>“192.168.1.1”</code> 、 <code>“192.168.1.0”</code> 为有效IPv4地址， <code>“192.168.01.1”</code> 为无效IPv4地址; <code>“192.168.1.00”</code> 、 <code>“192.168@1.1”</code> 为无效IPv4地址</p><p><strong>一个有效的IPv6地址</strong> 是一个格式为<code>“x1:x2:x3:x4:x5:x6:x7:x8”</code> 的IP地址，其中：</p><ul><li><code>1 &lt;= xi.length &lt;= 4</code></li><li><code>xi</code> 是一个 <strong>十六进制字符串</strong> ，可以包含数字、小写英文字母( <code>&#39;a&#39;</code> 到 <code>&#39;f&#39;</code> )和大写英文字母( <code>&#39;A&#39;</code> 到 <code>&#39;F&#39;</code> )</li><li>在 <code>xi</code> 中允许前导零</li></ul><p>例如 <code>&quot;2001:0db8:85a3:0000:0000:8a2e:0370:7334&quot;</code> 和<code>&quot;2001:db8:85a3:0:0:8A2E:0370:7334&quot;</code> 是有效的 IPv6地址，而 <code>&quot;2001:0db8:85a3::8A2E:037j:7334&quot;</code> 和 <code>&quot;02001:0db8:85a3:0000:0000:8a2e:0370:7334&quot;</code> 是无效的 IPv6 地址</p><p><strong>思路：</strong></p><p>依次判断</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="104-和为-K-的子数组-中等"><a href="#104-和为-K-的子数组-中等" class="headerlink" title="104. 和为 K 的子数组-中等"></a><font color=DarkOrange>104. 和为 K 的子数组-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回该数组中和为 <code>k</code> 的连续子数组的个数</p><p><strong>思路：</strong></p><p>方法一：枚举</p><p>方法二：前缀和 + 哈希表优化</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="105-只出现一次的数字-简单"><a href="#105-只出现一次的数字-简单" class="headerlink" title="105. 只出现一次的数字-简单"></a><font color=DarkOrange>105. 只出现一次的数字-简单</font></h4><p><strong>题目：</strong></p><p>给你一个 <strong>非空</strong> 整数数组 <code>nums</code> ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素</p><p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间</p><p><strong>思路：</strong></p><p>位运算</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="106-用两个栈实现队列-简单"><a href="#106-用两个栈实现队列-简单" class="headerlink" title="106. 用两个栈实现队列-简单"></a><font color=DarkOrange>106. 用两个栈实现队列-简单</font></h4><p><strong>题目：</strong></p><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 )</p><p><strong>思路：</strong></p><p>双栈</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="107-对角线遍历-中等"><a href="#107-对角线遍历-中等" class="headerlink" title="107. 对角线遍历-中等"></a><font color=DarkOrange>107. 对角线遍历-中等</font></h4><p><strong>题目：</strong></p><p>给你一个大小为 m x n 的矩阵 mat ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素</p><p><strong>思路：</strong></p><p>直接模拟</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="108-移掉-K-位数字-中等"><a href="#108-移掉-K-位数字-中等" class="headerlink" title="108. 移掉 K 位数字-中等"></a><font color=DarkOrange>108. 移掉 K 位数字-中等</font></h4><p><strong>题目：</strong></p><p>给你一个以字符串表示的非负整数 <code>num</code> 和一个整数 <code>k</code> ，移除这个数中的 <code>k</code> 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字</p><p><strong>思路：</strong></p><p>贪心 + 单调栈</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="109-基本计算器-困难"><a href="#109-基本计算器-困难" class="headerlink" title="109. 基本计算器-困难"></a><font color=DarkOrange>109. 基本计算器-困难</font></h4><p><strong>题目：</strong></p><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值</p><p>注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval()</code> </p><p><strong>思路：</strong></p><p>括号展开 + 栈</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="110-二叉搜索树与双向链表-中等"><a href="#110-二叉搜索树与双向链表-中等" class="headerlink" title="110. 二叉搜索树与双向链表-中等"></a><font color=DarkOrange>110. 二叉搜索树与双向链表-中等</font></h4><p><strong>题目：</strong></p><p><strong>思路：</strong></p><p><strong>代码：</strong></p><h4 id="111-排序数组-归并排序-中等"><a href="#111-排序数组-归并排序-中等" class="headerlink" title="111. 排序数组-归并排序-中等"></a><font color=DarkOrange>111. 排序数组-归并排序-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列</p><p><strong>思路：</strong></p><p>利用了分治的思想来对序列进行排序</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="112-LFU-缓存-困难"><a href="#112-LFU-缓存-困难" class="headerlink" title="112. LFU 缓存-困难"></a><font color=DarkOrange>112. LFU 缓存-困难</font></h4><p><strong>题目：</strong></p><p>请你为最不经常使用（LFU）缓存算法设计并实现数据结构</p><p>实现 <code>LFUCache</code> 类：</p><ul><li><code>LFUCache(int capacity)</code> - 用数据结构的容量 <code>capacity</code> 初始化对象</li><li><code>int get(int key)</code> - 如果键 <code>key</code> 存在于缓存中，则获取键的值，否则返回 <code>-1</code> </li><li><code>void put(int key, int value)</code> - 如果键 <code>key</code> 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 <code>capacity</code> 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 <strong>最近最久未使用</strong> 的键</li></ul><p>为了确定最不常使用的键，可以为缓存中的每个键维护一个 <strong>使用计数器</strong> 。使用计数最小的键是最久未使用的键</p><p>当一个键首次插入到缓存中时，它的使用计数器被设置为 <code>1</code> (由于 put 操作)。对缓存中的键执行 <code>get</code> 或 <code>put</code> 操作，使用计数器的值将会递增</p><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行</p><p><strong>思路：</strong></p><p>方法一：哈希表 + 平衡二叉树</p><p>方法二：双哈希表</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="113-每日温度-中等"><a href="#113-每日温度-中等" class="headerlink" title="113. 每日温度-中等"></a><font color=DarkOrange>113. 每日温度-中等</font></h4><p><strong>题目：</strong></p><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替</p><p><strong>思路：</strong></p><p>方法一：暴力</p><p>方法二：单调栈</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="114-课程表-中等"><a href="#114-课程表-中等" class="headerlink" title="114. 课程表-中等"></a><font color=DarkOrange>114. 课程表-中等</font></h4><p><strong>题目：</strong></p><p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> </p><p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 <strong>必须</strong> 先学习课程 <code>bi</code> </p><ul><li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code></li></ul><p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> </p><p><strong>思路：</strong></p><p>方法一：深度优先搜索</p><p>方法二: 广度优先搜索</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="115-排序奇升偶降链表-中等"><a href="#115-排序奇升偶降链表-中等" class="headerlink" title="115. 排序奇升偶降链表-中等"></a><font color=DarkOrange>115. 排序奇升偶降链表-中等</font></h4><p><strong>题目：</strong></p><p>字节跳动高频题</p><p><strong>思路：</strong></p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="116-二叉树的完全性检验-中等"><a href="#116-二叉树的完全性检验-中等" class="headerlink" title="116. 二叉树的完全性检验-中等"></a><font color=DarkOrange>116. 二叉树的完全性检验-中等</font></h4><p><strong>题目：</strong></p><p>给定一个二叉树的 <code>root</code> ，确定它是否是一个完全二叉树</p><p>在一个 <strong>完全二叉树</strong> 中，除了最后一个关卡外，所有关卡都是完全被填满的，并且最后一个关卡中的所有节点都是尽可能靠左的。它可以包含 <code>1</code> 到 <code>2h</code> 节点之间的最后一级 <code>h</code> </p><p><strong>思路：</strong></p><p>广度优先搜索</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="117-检测循环依赖-中等"><a href="#117-检测循环依赖-中等" class="headerlink" title="117. 检测循环依赖-中等"></a><font color=DarkOrange>117. 检测循环依赖-中等</font></h4><p><strong>题目：</strong></p><p>补充题</p><p><strong>思路：</strong></p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="118-二叉搜索树的第k大节点-简单"><a href="#118-二叉搜索树的第k大节点-简单" class="headerlink" title="118. 二叉搜索树的第k大节点-简单"></a><font color=DarkOrange>118. 二叉搜索树的第k大节点-简单</font></h4><p><strong>题目：</strong></p><p>给定一棵二叉搜索树，请找出其中第 k 大的节点的值</p><p><strong>思路：</strong></p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="119-盛最多水的容器-中等"><a href="#119-盛最多水的容器-中等" class="headerlink" title="119. 盛最多水的容器-中等"></a><font color=DarkOrange>119. 盛最多水的容器-中等</font></h4><p><strong>题目：</strong></p><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> </p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水</p><p>返回容器可以储存的最大水量</p><p><strong>说明：</strong>你不能倾斜容器</p><p><strong>思路：</strong></p><p>双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="120-单词搜索-中等"><a href="#120-单词搜索-中等" class="headerlink" title="120. 单词搜索-中等"></a><font color=DarkOrange>120. 单词搜索-中等</font></h4><p><strong>题目：</strong></p><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> </p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用</p><p><strong>思路：</strong></p><p>回溯</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="121-青蛙跳台阶问题-简单"><a href="#121-青蛙跳台阶问题-简单" class="headerlink" title="121. 青蛙跳台阶问题-简单"></a><font color=DarkOrange>121. 青蛙跳台阶问题-简单</font></h4><p><strong>题目：</strong></p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1</p><p><strong>思路：</strong></p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="122-组合总和-II-中等"><a href="#122-组合总和-II-中等" class="headerlink" title="122. 组合总和 II-中等"></a><font color=DarkOrange>122. 组合总和 II-中等</font></h4><p><strong>题目：</strong></p><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> </p><p><strong>注意：</strong>解集不能包含重复的组合</p><p><strong>思路：</strong></p><p>回溯</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="123-跳跃游戏-中等"><a href="#123-跳跃游戏-中等" class="headerlink" title="123. 跳跃游戏-中等"></a><font color=DarkOrange>123. 跳跃游戏-中等</font></h4><p><strong>题目：</strong></p><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> </p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度</p><p>判断你是否能够到达最后一个下标</p><p><strong>思路：</strong></p><p>贪心</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="124-二叉树的后序遍历-简单"><a href="#124-二叉树的后序遍历-简单" class="headerlink" title="124. 二叉树的后序遍历-简单"></a><font color=DarkOrange>124. 二叉树的后序遍历-简单</font></h4><p><strong>题目：</strong></p><p>给你一棵二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>后序遍历</strong> </p><p><strong>思路：</strong></p><p>方法一：递归</p><p>方法二：迭代</p><p>方法三：Morris 遍历</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="125-数组中的逆序对-困难"><a href="#125-数组中的逆序对-困难" class="headerlink" title="125. 数组中的逆序对-困难"></a><font color=DarkOrange>125. 数组中的逆序对-困难</font></h4><p><strong>题目：</strong></p><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数</p><p><strong>思路：</strong></p><p>方法一：归并排序</p><p>方法二：离散化树状数组</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="126-螺旋矩阵-II-中等"><a href="#126-螺旋矩阵-II-中等" class="headerlink" title="126. 螺旋矩阵 II-中等"></a><font color=DarkOrange>126. 螺旋矩阵 II-中等</font></h4><p><strong>题目：</strong></p><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> </p><p><strong>思路：</strong></p><p>模拟</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="127-搜索二维矩阵-中等"><a href="#127-搜索二维矩阵-中等" class="headerlink" title="127. 搜索二维矩阵-中等"></a><font color=DarkOrange>127. 搜索二维矩阵-中等</font></h4><p><strong>题目：</strong></p><p>编写一个高效的算法来判断 <code>m x n</code> 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><ul><li>每行中的整数从左到右按升序排列</li><li>每行的第一个整数大于前一行的最后一个整数</li></ul><p><strong>思路：</strong></p><p>方法一：两次二分查找</p><p>方法二：一次二分查找</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="128-删除有序数组中的重复项-简单"><a href="#128-删除有序数组中的重复项-简单" class="headerlink" title="128. 删除有序数组中的重复项-简单"></a><font color=DarkOrange>128. 删除有序数组中的重复项-简单</font></h4><p><strong>题目：</strong></p><p>给你一个 <strong>升序排列</strong> 的数组 <code>nums</code> ，请你<strong>原地</strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong></p><p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 <code>k</code> 个元素，那么 <code>nums</code> 的前 <code>k</code> 个元素应该保存最终结果</p><p>将最终结果插入 <code>nums</code> 的前 <code>k</code> 个位置后返回 <code>k</code> </p><p>不要使用额外的空间，你必须在 <strong>原地修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成</p><p><strong>思路：</strong></p><p>双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="129-圆环回原点问题-中等"><a href="#129-圆环回原点问题-中等" class="headerlink" title="129. 圆环回原点问题-中等"></a><font color=DarkOrange>129. 圆环回原点问题-中等</font></h4><p><strong>题目：</strong></p><p>字节跳动高频题</p><p><strong>思路：</strong></p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="130-全排列-II-中等"><a href="#130-全排列-II-中等" class="headerlink" title="130. 全排列 II-中等"></a><font color=DarkOrange>130. 全排列 II-中等</font></h4><p><strong>题目：</strong></p><p>给定一个可包含重复数字的序列 <code>nums</code> ，<strong>按任意顺序</strong> 返回所有不重复的全排列</p><p><strong>思路：</strong></p><p>搜索回溯</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="131-零钱兑换-II-中等"><a href="#131-零钱兑换-II-中等" class="headerlink" title="131. 零钱兑换 II-中等"></a><font color=DarkOrange>131. 零钱兑换 II-中等</font></h4><p><strong>题目：</strong></p><p><strong>思路：</strong></p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="132-斐波那契数列-简单"><a href="#132-斐波那契数列-简单" class="headerlink" title="132. 斐波那契数列-简单"></a><font color=DarkOrange>132. 斐波那契数列-简单</font></h4><p><strong>题目：</strong></p><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1</p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：矩阵快速幂</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="133-Pow-x-n-中等"><a href="#133-Pow-x-n-中等" class="headerlink" title="133. Pow(x, n)-中等"></a><font color=DarkOrange>133. Pow(x, n)-中等</font></h4><p><strong>题目：</strong></p><p>实现pow(x, n) ，即计算 <code>x</code> 的整数 <code>n</code> 次幂函数（即，<code>x^n</code> ）</p><p><strong>思路：</strong></p><p>方法一：快速幂 + 递归</p><p>方法二：快速幂 + 迭代</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="134-旋转链表-中等"><a href="#134-旋转链表-中等" class="headerlink" title="134. 旋转链表-中等"></a><font color=DarkOrange>134. 旋转链表-中等</font></h4><p><strong>题目：</strong></p><p>给你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动 <code>k</code> 个位置</p><p><strong>思路：</strong></p><p>闭合为环</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="135-删除二叉搜索树中的节点-中等"><a href="#135-删除二叉搜索树中的节点-中等" class="headerlink" title="135. 删除二叉搜索树中的节点-中等"></a><font color=DarkOrange>135. 删除二叉搜索树中的节点-中等</font></h4><p><strong>题目：</strong></p><p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点</li><li>如果找到了，删除它</li></ol><p><strong>思路：</strong></p><p>方法一：递归</p><p>方法二：迭代</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="136-最小的k个数-简单"><a href="#136-最小的k个数-简单" class="headerlink" title="136. 最小的k个数-简单"></a><font color=DarkOrange>136. 最小的k个数-简单</font></h4><p><strong>题目：</strong></p><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4</p><p><strong>思路：</strong></p><p>方法一：排序</p><p>方法二：堆</p><p>方法三：快排思想</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="137-卖股票的最佳时机-III-困难"><a href="#137-卖股票的最佳时机-III-困难" class="headerlink" title="137. 卖股票的最佳时机 III-困难"></a><font color=DarkOrange>137. 卖股票的最佳时机 III-困难</font></h4><p><strong>题目：</strong></p><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）</p><p><strong>思路：</strong></p><p>动态规划</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="138-整数反转-简单"><a href="#138-整数反转-简单" class="headerlink" title="138. 整数反转-简单"></a><font color=DarkOrange>138. 整数反转-简单</font></h4><p><strong>题目：</strong></p><p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果</p><p>如果反转后整数超过 32 位的有符号整数的范围 <code>[−2^31, 2^31 − 1]</code> ，就返回 0</p><p><strong>假设环境不允许存储 64 位整数（有符号或无符号）</strong></p><p><strong>思路：</strong></p><p>数学</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="139-连续子数组的最大和-简单"><a href="#139-连续子数组的最大和-简单" class="headerlink" title="139. 连续子数组的最大和-简单"></a><font color=DarkOrange>139. 连续子数组的最大和-简单</font></h4><p><strong>题目：</strong></p><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值</p><p>要求时间复杂度为O(n)</p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：分治</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="140-整数组顺序使奇数位于偶数前面-简单"><a href="#140-整数组顺序使奇数位于偶数前面-简单" class="headerlink" title="140. 整数组顺序使奇数位于偶数前面-简单"></a><font color=DarkOrange>140. 整数组顺序使奇数位于偶数前面-简单</font></h4><p><strong>题目：</strong></p><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分</p><p><strong>思路：</strong></p><p>方法一：两次遍历</p><p>方法二：双指针 + 一次遍历</p><p>方法三：原地交换</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="141-二叉搜索树中第K小的元素-中等"><a href="#141-二叉搜索树中第K小的元素-中等" class="headerlink" title="141. 二叉搜索树中第K小的元素-中等"></a><font color=DarkOrange>141. 二叉搜索树中第K小的元素-中等</font></h4><p><strong>题目：</strong></p><p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）</p><p><strong>思路：</strong></p><p>方法一：中序遍历</p><p>方法二：记录子树的结点数</p><p>方法三：平衡二叉搜索树</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="142-用队列实现栈-简单"><a href="#142-用队列实现栈-简单" class="headerlink" title="142. 用队列实现栈-简单"></a><font color=DarkOrange>142. 用队列实现栈-简单</font></h4><p><strong>题目：</strong></p><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）</p><p>实现 <code>MyStack</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 压入栈顶</li><li><code>int pop()</code> 移除并返回栈顶元素</li><li><code>int top()</code> 返回栈顶元素</li><li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><p><strong>注意：</strong></p><ul><li>你只能使用队列的基本操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作</li><li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可</li></ul><p><strong>思路：</strong></p><p>方法一：两个队列</p><p>方法二：一个队列</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="143-字典序的第K小数字-困难"><a href="#143-字典序的第K小数字-困难" class="headerlink" title="143. 字典序的第K小数字-困难"></a><font color=DarkOrange>143. 字典序的第K小数字-困难</font></h4><p><strong>题目：</strong></p><p>给定整数 <code>n</code> 和 <code>k</code>，返回 <code>[1, n]</code> 中字典序第 <code>k</code> 小的数字</p><p><strong>思路：</strong></p><p>字典树思想</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="144-分发糖果-困难"><a href="#144-分发糖果-困难" class="headerlink" title="144. 分发糖果-困难"></a><font color=DarkOrange>144. 分发糖果-困难</font></h4><p><strong>题目：</strong></p><p><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 <code>1</code> 个糖果</li><li>相邻两个孩子评分更高的孩子会获得更多的糖果</li></ul><p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> </p><p><strong>思路：</strong></p><p>方法一：两次遍历</p><p>方法二：常数空间遍历</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="145-圆圈中最后剩下的数字-简单"><a href="#145-圆圈中最后剩下的数字-简单" class="headerlink" title="145. 圆圈中最后剩下的数字-简单"></a><font color=DarkOrange>145. 圆圈中最后剩下的数字-简单</font></h4><p><strong>题目：</strong></p><p>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字</p><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3</p><p><strong>思路：</strong></p><p>方法一：数学 + 递归</p><p>方法二：数学 + 迭代</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="146-颜色分类-中等"><a href="#146-颜色分类-中等" class="headerlink" title="146. 颜色分类-中等"></a><font color=DarkOrange>146. 颜色分类-中等</font></h4><p><strong>题目：</strong></p><p>给定一个包含红色、白色和蓝色、共 <code>n</code> 个元素的数组 <code>nums</code> ，<strong>原地</strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列</p><p>我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色</p><p>必须在不使用库的sort函数的情况下解决这个问题</p><p><strong>思路：</strong></p><p>方法一：单指针</p><p>方法二：双指针</p><p>方法三：双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="147-矩阵中的最长递增路径-困难"><a href="#147-矩阵中的最长递增路径-困难" class="headerlink" title="147. 矩阵中的最长递增路径-困难"></a><font color=DarkOrange>147. 矩阵中的最长递增路径-困难</font></h4><p><strong>题目：</strong></p><p>给定一个 <code>m x n</code> 整数矩阵 <code>matrix</code> ，找出其中 <strong>最长递增路径</strong> 的长度</p><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你 <strong>不能</strong> 在 <strong>对角线</strong> 方向上移动或移动到 <strong>边界外</strong>（即不允许环绕）</p><p><strong>思路：</strong></p><p>方法一：记忆化深度优先搜索</p><p>方法二：拓扑排序</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="148-二维数组中的查找-中等"><a href="#148-二维数组中的查找-中等" class="headerlink" title="148. 二维数组中的查找-中等"></a><font color=DarkOrange>148. 二维数组中的查找-中等</font></h4><p><strong>题目：</strong></p><p>在一个 n * m 的二维数组中，每一行都按照从左到右 <strong>非递减</strong> 的顺序排序，每一列都按照从上到下 <strong>非递减</strong> 的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数</p><p><strong>思路：</strong></p><p>方法一：直接查找</p><p>方法二：二分查找</p><p>方法三：Z 字形查找</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="149-奇偶链表-中等"><a href="#149-奇偶链表-中等" class="headerlink" title="149. 奇偶链表-中等"></a><font color=DarkOrange>149. 奇偶链表-中等</font></h4><p><strong>题目：</strong></p><p>给定单链表的头节点 <code>head</code> ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表</p><p><strong>第一个</strong>节点的索引被认为是 <strong>奇数</strong> ， <strong>第二个</strong>节点的索引为 <strong>偶数</strong> ，以此类推</p><p>请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致</p><p>你必须在 <code>O(1)</code> 的额外空间复杂度和 <code>O(n)</code> 的时间复杂度下解决这个问题</p><p><strong>思路：</strong></p><p>分离节点后合并</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="150-解码方法-中等"><a href="#150-解码方法-中等" class="headerlink" title="150. 解码方法-中等"></a><font color=DarkOrange>150. 解码方法-中等</font></h4><p><strong>题目：</strong></p><p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;A&#x27;</span> -&gt; <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="string">&#x27;B&#x27;</span> -&gt; <span class="string">&quot;2&quot;</span></span><br><span class="line">...</span><br><span class="line"><span class="string">&#x27;Z&#x27;</span> -&gt; <span class="string">&quot;26&quot;</span></span><br></pre></td></tr></table></figure><p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>&quot;11106&quot;</code> 可以映射为：</p><ul><li><code>&quot;AAJF&quot;</code> ，将消息分组为 <code>(1 1 10 6)</code></li><li><code>&quot;KJF&quot;</code> ，将消息分组为 <code>(11 10 6)</code></li></ul><p>注意，消息不能分组为 <code>(1 11 06)</code> ，因为 <code>&quot;06&quot;</code> 不能映射为 <code>&quot;F&quot;</code> ，这是由于 <code>&quot;6&quot;</code> 和 <code>&quot;06&quot;</code> 在映射中并不等价</p><p>给你一个只含数字的 <strong>非空</strong> 字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> </p><p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数</p><p><strong>思路：</strong></p><p>动态规划</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="151-另一棵树的子树-简单"><a href="#151-另一棵树的子树-简单" class="headerlink" title="151. 另一棵树的子树-简单"></a><font color=DarkOrange>151. 另一棵树的子树-简单</font></h4><p><strong>题目：</strong></p><p>给你两棵二叉树 <code>root</code> 和 <code>subRoot</code> 。检验 <code>root</code> 中是否包含和 <code>subRoot</code> 具有相同结构和节点值的子树。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> </p><p>二叉树 <code>tree</code> 的一棵子树包括 <code>tree</code> 的某个节点和这个节点的所有后代节点。<code>tree</code> 也可以看做它自身的一棵子树</p><p><strong>思路：</strong></p><p>方法一：深度优先搜索暴力匹配</p><p>方法二：深度优先搜索序列上做串匹配</p><p>方法三：树哈希</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="152-打乱数组-中等"><a href="#152-打乱数组-中等" class="headerlink" title="152. 打乱数组-中等"></a><font color=DarkOrange>152. 打乱数组-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数数组 <code>nums</code> ，设计算法来打乱一个没有重复元素的数组。打乱后，数组的所有排列应该是 <strong>等可能</strong> 的</p><p>实现 <code>Solution</code> class：</p><ul><li><code>Solution(int[] nums)</code> 使用整数数组 <code>nums</code> 初始化对象</li><li><code>int[] reset()</code> 重设数组到它的初始状态并返回</li><li><code>int[] shuffle()</code> 返回数组随机打乱后的结果</li></ul><p><strong>思路：</strong></p><p>方法一：暴力</p><p>方法二：Fisher-Yates 洗牌算法</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="153-验证回文串-简单"><a href="#153-验证回文串-简单" class="headerlink" title="153. 验证回文串-简单"></a><font color=DarkOrange>153. 验证回文串-简单</font></h4><p><strong>题目：</strong></p><p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 <strong>回文串</strong> </p><p>字母和数字都属于字母数字字符</p><p>给你一个字符串 <code>s</code>，如果它是 <strong>回文串</strong> ，返回 <code>true</code> ；否则，返回 <code>false</code> </p><p><strong>思路：</strong></p><p>方法一：筛选 + 判断</p><p>方法二：在原字符串上直接判断</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="154-回文数-简单"><a href="#154-回文数-简单" class="headerlink" title="154. 回文数-简单"></a><font color=DarkOrange>154. 回文数-简单</font></h4><p><strong>题目：</strong></p><p>给你一个整数 <code>x</code> ，如果 <code>x</code> 是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code> </p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数</p><ul><li>例如，<code>121</code> 是回文，而 <code>123</code> 不是</li></ul><p><strong>思路：</strong></p><p>反转一半数字</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="154-轮转数组-中等"><a href="#154-轮转数组-中等" class="headerlink" title="154. 轮转数组-中等"></a><font color=DarkOrange>154. 轮转数组-中等</font></h4><p><strong>题目：</strong></p><p>给你一个数组，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数</p><p><strong>思路：</strong></p><p>方法一：使用额外的数组</p><p>方法二：环状替换</p><p>方法三：数组翻转</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="155-跳跃游戏-II-中等"><a href="#155-跳跃游戏-II-中等" class="headerlink" title="155. 跳跃游戏 II-中等"></a><font color=DarkOrange>155. 跳跃游戏 II-中等</font></h4><p><strong>题目：</strong></p><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的第一个位置</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置</p><p>假设你总是可以到达数组的最后一个位置</p><p><strong>思路：</strong></p><p>方法一：反向查找出发位置</p><p>方法二：正向查找可到达的最大位置</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="157-两数相加-II-中等"><a href="#157-两数相加-II-中等" class="headerlink" title="157. 两数相加 II-中等"></a><font color=DarkOrange>157. 两数相加 II-中等</font></h4><p><strong>题目：</strong></p><p>给你两个 <strong>非空</strong> 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头</p><p><strong>思路：</strong></p><p>栈</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="158-二叉树的镜像-简单"><a href="#158-二叉树的镜像-简单" class="headerlink" title="158. 二叉树的镜像-简单"></a><font color=DarkOrange>158. 二叉树的镜像-简单</font></h4><p><strong>题目：</strong></p><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h88ink6q3sj30hk0fi752.jpg" alt="image.png" style="zoom:67%;" /></div><p><strong>思路：</strong></p><p>递归</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="159-寻找重复数-中等"><a href="#159-寻找重复数-中等" class="headerlink" title="159. 寻找重复数-中等"></a><font color=DarkOrange>159. 寻找重复数-中等</font></h4><p><strong>题目：</strong></p><p>给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code> ，其数字都在 <code>[1, n]</code> 范围内（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数</p><p>假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，返回 <strong>这个重复的数</strong> </p><p>你设计的解决方案必须 <strong>不修改</strong> 数组 <code>nums</code> 且只用常量级 <code>O(1)</code> 的额外空间</p><p><strong>思路：</strong></p><p>方法一：二分查找</p><p>方法二：二进制</p><p>方法三：快慢指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="160-实现-Trie-前缀树-中等"><a href="#160-实现-Trie-前缀树-中等" class="headerlink" title="160. 实现 Trie (前缀树)-中等"></a><font color=DarkOrange>160. 实现 Trie (前缀树)-中等</font></h4><p><strong>题目：</strong></p><p><strong>Trie</strong>（发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查</p><p>请你实现 Trie 类：</p><ul><li><code>Trie()</code> 初始化前缀树对象</li><li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> </li><li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> </li><li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><p><strong>思路：</strong></p><p>字典树</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="161-数据流的中位数-困难"><a href="#161-数据流的中位数-困难" class="headerlink" title="161. 数据流的中位数-困难"></a><font color=DarkOrange>161. 数据流的中位数-困难</font></h4><p><strong>题目：</strong></p><p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><ul><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中</li><li>double findMedian() - 返回目前所有元素的中位数</li></ul><p><strong>思路：</strong></p><p>方法一：优先队列</p><p>方法二：有序集合 + 双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="162-二叉树展开为链表-中等"><a href="#162-二叉树展开为链表-中等" class="headerlink" title="162. 二叉树展开为链表-中等"></a><font color=DarkOrange>162. 二叉树展开为链表-中等</font></h4><p><strong>题目：</strong></p><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> </li><li>展开后的单链表应该与二叉树 <strong>先序遍历</strong> 顺序相同</li></ul><p><strong>思路：</strong></p><p>方法一：前序遍历</p><p>方法二：前序遍历和展开同步进行</p><p>方法三：寻找前驱节点</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="163-接近的三数之和-中等"><a href="#163-接近的三数之和-中等" class="headerlink" title="163. 接近的三数之和-中等"></a><font color=DarkOrange>163. 接近的三数之和-中等</font></h4><p><strong>题目：</strong></p><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 和 一个目标值 <code>target</code>。请你从 <code>nums</code> 中选出三个整数，使它们的和与 <code>target</code> 最接近</p><p>返回这三个数的和</p><p>假定每组输入只存在恰好一个解</p><p><strong>思路：</strong></p><p>排序 + 双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="164-打家劫舍-II-中等"><a href="#164-打家劫舍-II-中等" class="headerlink" title="164. 打家劫舍 II-中等"></a><font color=DarkOrange>164. 打家劫舍 II-中等</font></h4><p><strong>题目：</strong></p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> </p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额</p><p><strong>思路：</strong></p><p>动态规划</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="165-三角形最小路径和-中等"><a href="#165-三角形最小路径和-中等" class="headerlink" title="165. 三角形最小路径和-中等"></a><font color=DarkOrange>165. 三角形最小路径和-中等</font></h4><p><strong>题目：</strong></p><p>给定一个三角形 <code>triangle</code> ，找出自顶向下的最小路径和</p><p>每一步只能移动到下一行中相邻的结点上。<strong>相邻的结点</strong> 在这里指的是 <strong>下标</strong> 与 <strong>上一层结点下标</strong> 相同或者等于 <strong>上一层结点下标 + 1</strong> 的两个结点。也就是说，如果正位于当前行的下标 <code>i</code> ，那么下一步可以移动到下一行的下标 <code>i</code> 或 <code>i + 1</code> </p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：动态规划 + 空间优化</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="166-顺时针打印矩阵-简单"><a href="#166-顺时针打印矩阵-简单" class="headerlink" title="166. 顺时针打印矩阵-简单"></a><font color=DarkOrange>166. 顺时针打印矩阵-简单</font></h4><p><strong>题目：</strong></p><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字</p><p><strong>思路：</strong></p><p>方法一：模拟</p><p>方法二：按层模拟</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="167-正则表达式匹配-困难"><a href="#167-正则表达式匹配-困难" class="headerlink" title="167. 正则表达式匹配-困难"></a><font color=DarkOrange>167. 正则表达式匹配-困难</font></h4><p><strong>题目：</strong></p><p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配</p><ul><li><code>&#39;.&#39;</code> 匹配任意单个字符</li><li><code>&#39;*&#39;</code> 匹配零个或多个前面的那一个元素</li></ul><p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 <code>s</code>的，而不是部分字符串</p><p><strong>思路：</strong></p><p>动态规划</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="168-从中序与后序遍历序列构造二叉树-中等"><a href="#168-从中序与后序遍历序列构造二叉树-中等" class="headerlink" title="168. 从中序与后序遍历序列构造二叉树-中等"></a><font color=DarkOrange>168. 从中序与后序遍历序列构造二叉树-中等</font></h4><p><strong>题目：</strong></p><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗二叉树</p><p><strong>思路：</strong></p><p>方法一：递归</p><p>方法二：迭代</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="169-第-N-位数字-中等"><a href="#169-第-N-位数字-中等" class="headerlink" title="169. 第 N 位数字-中等"></a><font color=DarkOrange>169. 第 N 位数字-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数 <code>n</code> ，请你在无限的整数序列 <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...]</code> 中找出并返回第 <code>n</code> 位上的数字</p><p><strong>思路：</strong></p><p>方法一：二分查找</p><p>方法二：直接计算</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="170-树的子结构-中等"><a href="#170-树的子结构-中等" class="headerlink" title="170. 树的子结构-中等"></a><font color=DarkOrange>170. 树的子结构-中等</font></h4><p><strong>题目：</strong></p><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h88j43kz1xj30p60gw40b.jpg" alt="image.png" style="zoom:67%;" /></div><p><strong>思路：</strong></p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="171-链表求和-中等"><a href="#171-链表求和-中等" class="headerlink" title="171. 链表求和-中等"></a><font color=DarkOrange>171. 链表求和-中等</font></h4><p><strong>题目：</strong></p><p>给定两个用链表表示的整数，每个节点包含一个数位</p><p>这些数位是反向存放的，也就是个位排在链表首部</p><p>编写函数对这两个整数求和，并用链表形式返回结果</p><p><strong>思路：</strong></p><p>模拟</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="172-有效的括号字符串-中等"><a href="#172-有效的括号字符串-中等" class="headerlink" title="172. 有效的括号字符串-中等"></a><font color=DarkOrange>172. 有效的括号字符串-中等</font></h4><p><strong>题目：</strong></p><p>给定一个只包含三种字符的字符串：<code>（ </code>，<code>）</code> 和 <code>*</code>，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：</p><ol><li>任何左括号 <code>(</code> 必须有相应的右括号 <code>)</code></li><li>任何右括号 <code>)</code> 必须有相应的左括号 <code>(</code> </li><li>左括号 <code>(</code> 必须在对应的右括号之前 <code>)</code></li><li><code>*</code> 可以被视为单个右括号 <code>)</code> ，或单个左括号 <code>(</code> ，或一个空字符串</li><li>一个空字符串也被视为有效字符串</li></ol><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：栈</p><p>方法三：贪心</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="173-两个链表的第一个公共节点-简单"><a href="#173-两个链表的第一个公共节点-简单" class="headerlink" title="173. 两个链表的第一个公共节点-简单"></a><font color=DarkOrange>173. 两个链表的第一个公共节点-简单</font></h4><p><strong>题目：</strong></p><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h88j86dqzej30lk0c6myc.jpg" alt="image.png" style="zoom:67%;" /></div><p><strong>思路：</strong></p><p>方法一：哈希集合</p><p>方法二：双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="174-前-K-个高频元素-中等"><a href="#174-前-K-个高频元素-中等" class="headerlink" title="174. 前 K 个高频元素-中等"></a><font color=DarkOrange>174. 前 K 个高频元素-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案</p><p><strong>思路：</strong></p><p>方法一：堆</p><p>方法二：基于快速排序</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="175-不同的二叉搜索树-中等"><a href="#175-不同的二叉搜索树-中等" class="headerlink" title="175. 不同的二叉搜索树-中等"></a><font color=DarkOrange>175. 不同的二叉搜索树-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数</p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：数学</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="176-两个数组的交集-简单"><a href="#176-两个数组的交集-简单" class="headerlink" title="176. 两个数组的交集-简单"></a><font color=DarkOrange>176. 两个数组的交集-简单</font></h4><p><strong>题目：</strong></p><p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回它们的交集 。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> </p><p><strong>思路：</strong></p><p>方法一：两个集合</p><p>方法二：排序 + 双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="177-36进制加法-中等"><a href="#177-36进制加法-中等" class="headerlink" title="177. 36进制加法-中等"></a><font color=DarkOrange>177. 36进制加法-中等</font></h4><p><strong>题目：</strong></p><p>字节高频题</p><p><strong>思路：</strong><br><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="178-数组中出现次数超过一半的数字-简单"><a href="#178-数组中出现次数超过一半的数字-简单" class="headerlink" title="178. 数组中出现次数超过一半的数字-简单"></a><font color=DarkOrange>178. 数组中出现次数超过一半的数字-简单</font></h4><p><strong>题目：</strong></p><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素</p><p><strong>思路：</strong></p><p>方法一：哈希表</p><p>方法二：排序</p><p>方法三：随机化</p><p>方法四：分治</p><p>方法五：Boyer-Moore 投票算法</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="179-Excel表列名称-简单"><a href="#179-Excel表列名称-简单" class="headerlink" title="179. Excel表列名称-简单"></a><font color=DarkOrange>179. Excel表列名称-简单</font></h4><p><strong>题目：</strong></p><p>给你一个整数 <code>columnNumber</code> ，返回它在 Excel 表中相对应的列名称</p><p>例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>数学</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="180-扑克牌中的顺子-简单"><a href="#180-扑克牌中的顺子-简单" class="headerlink" title="180. 扑克牌中的顺子-简单"></a><font color=DarkOrange>180. 扑克牌中的顺子-简单</font></h4><p><strong>题目：</strong></p><p>从<strong>若干副扑克牌</strong>中随机抽 <code>5</code> 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14</p><p><strong>思路：</strong></p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="181-鸡蛋掉落-困难"><a href="#181-鸡蛋掉落-困难" class="headerlink" title="181. 鸡蛋掉落-困难"></a><font color=DarkOrange>181. 鸡蛋掉落-困难</font></h4><p><strong>题目：</strong></p><p>给你 <code>k</code> 枚相同的鸡蛋，并可以使用一栋从第 <code>1</code> 层到第 <code>n</code> 层共有 <code>n</code> 层楼的建筑</p><p>已知存在楼层 <code>f</code> ，满足 <code>0 &lt;= f &lt;= n</code> ，任何从 <strong>高于</strong> <code>f</code> 的楼层落下的鸡蛋都会碎，从 <code>f</code> 楼层或比它低的楼层落下的鸡蛋都不会破</p><p>每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 <code>x</code> 扔下（满足 <code>1 &lt;= x &lt;= n</code>）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 <strong>重复使用</strong> 这枚鸡蛋</p><p>请你计算并返回要确定 <code>f</code> <strong>确切的值</strong> 的 <strong>最小操作次数</strong> 是多少？</p><p><strong>思路：</strong></p><p>方法一：动态规划 + 二分查找</p><p>方法二：决策单调性</p><p>方法三：数学法</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="182-最长递增子序列的个数-中等"><a href="#182-最长递增子序列的个数-中等" class="headerlink" title="182. 最长递增子序列的个数-中等"></a><font color=DarkOrange>182. 最长递增子序列的个数-中等</font></h4><p><strong>题目：</strong></p><p>给定一个未排序的整数数组 <code>nums</code> ， 返回最长递增子序列的个数</p><p><strong>注意</strong> 这个数列必须是 <strong>严格</strong> 递增的</p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：贪心 + 前缀和 + 二分查找</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="183-简化路径-中等"><a href="#183-简化路径-中等" class="headerlink" title="183. 简化路径-中等"></a><font color=DarkOrange>183. 简化路径-中等</font></h4><p><strong>题目：</strong></p><p>给你一个字符串 <code>path</code> ，表示指向某一文件或目录的 Unix 风格 <strong>绝对路径</strong> （以 <code>&#39;/&#39;</code> 开头），请你将其转化为更加简洁的规范路径</p><p>在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，<code>&#39;//&#39;</code>）都被视为单个斜杠 <code>&#39;/&#39;</code> 。 对于此问题，任何其他格式的点（例如，<code>&#39;...&#39;</code>）均被视为文件&#x2F;目录名称</p><p>请注意，返回的 <strong>规范路径</strong> 必须遵循下述格式：</p><ul><li>始终以斜杠 <code>&#39;/&#39;</code> 开头</li><li>两个目录名之间必须只有一个斜杠 <code>&#39;/&#39;</code> </li><li>最后一个目录名（如果存在）<strong>不能</strong> 以 <code>&#39;/&#39;</code> 结尾</li><li>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 <code>&#39;.&#39;</code> 或 <code>&#39;..&#39;</code>）</li></ul><p>返回简化后得到的 <strong>规范路径</strong> </p><p><strong>思路：</strong></p><p>栈</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="184-数组中重复的数据-中等"><a href="#184-数组中重复的数据-中等" class="headerlink" title="184. 数组中重复的数据-中等"></a><font color=DarkOrange>184. 数组中重复的数据-中等</font></h4><p><strong>题目：</strong></p><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，其中 <code>nums</code> 的所有整数都在范围 <code>[1, n]</code> 内，且每个整数出现 <strong>一次</strong> 或 <strong>两次</strong> 。请你找出所有出现 <strong>两次</strong> 的整数，并以数组形式返回</p><p>你必须设计并实现一个时间复杂度为 <code>O(n)</code> 且仅使用常量额外空间的算法解决此问题</p><p><strong>思路：</strong></p><p>方法一：将元素交换到对应的位置</p><p>方法二：使用正负号作为标记</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="185-斐波那契数-简单"><a href="#185-斐波那契数-简单" class="headerlink" title="185. 斐波那契数-简单"></a><font color=DarkOrange>185. 斐波那契数-简单</font></h4><p><strong>题目：</strong></p><p><strong>斐波那契数</strong> （通常用 <code>F(n)</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0，F(1) = 1</span><br><span class="line">F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</span><br></pre></td></tr></table></figure><p>给定 <code>n</code> ，请计算 <code>F(n)</code> </p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：矩阵快速幂</p><p>方法三：通项公式</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="186-删除字符串中的所有相邻重复项-简单"><a href="#186-删除字符串中的所有相邻重复项-简单" class="headerlink" title="186. 删除字符串中的所有相邻重复项-简单"></a><font color=DarkOrange>186. 删除字符串中的所有相邻重复项-简单</font></h4><p><strong>题目：</strong></p><p>给出由小写字母组成的字符串 <code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一</p><p><strong>思路：</strong></p><p>栈</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="187-加油站-中等"><a href="#187-加油站-中等" class="headerlink" title="187. 加油站-中等"></a><font color=DarkOrange>187. 加油站-中等</font></h4><p><strong>题目：</strong></p><p>在一条环路上有 <code>n</code> 个加油站，其中第 <code>i</code> 个加油站有汽油 <code>gas[i]</code> 升</p><p>你有一辆油箱容量无限的的汽车，从第 <code>i</code> 个加油站开往第 <code>i+1</code> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空</p><p>给定两个整数数组 <code>gas</code> 和 <code>cost</code> ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 <code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的</p><p><strong>思路：</strong></p><p>一次遍历</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="188-有效三角形的个数-中等"><a href="#188-有效三角形的个数-中等" class="headerlink" title="188. 有效三角形的个数-中等"></a><font color=DarkOrange>188. 有效三角形的个数-中等</font></h4><p><strong>题目：</strong></p><p>给定一个包含非负整数的数组 <code>nums</code> ，返回其中可以组成三角形三条边的三元组个数</p><p><strong>思路：</strong></p><p>方法一：排序 + 二分查找</p><p>方法二：排序 + 双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="189-最大连续1的个数-III-中等"><a href="#189-最大连续1的个数-III-中等" class="headerlink" title="189. 最大连续1的个数 III-中等"></a><font color=DarkOrange>189. 最大连续1的个数 III-中等</font></h4><p><strong>题目：</strong></p><p>给定一个二进制数组 <code>nums</code> 和一个整数 <code>k</code>，如果可以翻转最多 <code>k</code> 个 <code>0</code> ，则返回数组中连续 <code>1</code> 的最大个数 </p><p><strong>思路：</strong></p><p>方法一：二分查找</p><p>方法二：滑动窗口</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="190-二叉树中和为某一值的路径-中等"><a href="#190-二叉树中和为某一值的路径-中等" class="headerlink" title="190. 二叉树中和为某一值的路径-中等"></a><font color=DarkOrange>190. 二叉树中和为某一值的路径-中等</font></h4><p><strong>题目：</strong></p><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径</p><p><strong>叶子节点</strong> 是指没有子节点的节点</p><p><strong>思路：</strong></p><p>方法一：深度优先搜索</p><p>方法二：广度优先搜索</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="191-在排序数组中查找数字-I-简单"><a href="#191-在排序数组中查找数字-I-简单" class="headerlink" title="191. 在排序数组中查找数字 I-简单"></a><font color=DarkOrange>191. 在排序数组中查找数字 I-简单</font></h4><p><strong>题目：</strong></p><p>统计一个数字在排序数组中出现的次数</p><p><strong>思路：</strong></p><p>二分查找</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="192-分隔链表-中等"><a href="#192-分隔链表-中等" class="headerlink" title="192. 分隔链表-中等"></a><font color=DarkOrange>192. 分隔链表-中等</font></h4><p><strong>题目：</strong></p><p>给你一个链表的头节点 <code>head</code> 和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有 <strong>小于</strong> <code>x</code> 的节点都出现在 <strong>大于或等于</strong> <code>x</code> 的节点之前</p><p>你应当 <strong>保留</strong> 两个分区中每个节点的初始相对位置</p><p><strong>思路：</strong></p><p>模拟</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="193-24-点游戏-困难"><a href="#193-24-点游戏-困难" class="headerlink" title="193. 24 点游戏-困难"></a><font color=DarkOrange>193. 24 点游戏-困难</font></h4><p><strong>题目：</strong></p><p>给定一个长度为4的整数数组 <code>cards</code> 。你有 <code>4</code> 张卡片，每张卡片上都包含一个范围在 <code>[1,9]</code> 的数字。您应该使用运算符 <code>[&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;]</code> 和括号 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 将这些卡片上的数字排列成数学表达式，以获得值24</p><p>你须遵守以下规则：</p><ul><li>除法运算符 <code>&#39;/&#39;</code> 表示实数除法，而不是整数除法<ul><li>例如， <code>4 /(1 - 2 / 3)= 4 /(1 / 3)= 12</code></li></ul></li><li>每个运算都在两个数字之间。特别是，不能使用 <code>“-”</code> 作为一元运算符<ul><li>例如，如果 <code>cards =[1,1,1,1]</code> ，则表达式 <code>“-1 -1 -1 -1”</code> 是 <strong>不允许</strong> 的</li></ul></li><li>你不能把数字串在一起<ul><li>例如，如果 <code>cards =[1,2,1,2]</code> ，则表达式 <code>“12 + 12”</code> 无效</li></ul></li></ul><p>如果可以得到这样的表达式，其计算结果为 <code>24</code> ，则返回 <code>true </code>，否则返回 <code>false</code> </p><p><strong>思路：</strong></p><p>回溯</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="194-二叉树的最小深度-简单"><a href="#194-二叉树的最小深度-简单" class="headerlink" title="194. 二叉树的最小深度-简单"></a><font color=DarkOrange>194. 二叉树的最小深度-简单</font></h4><p><strong>题目：</strong></p><p>给定一个二叉树，找出其最小深度</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量</p><p><strong>说明：</strong>叶子节点是指没有子节点的节点</p><p><strong>思路：</strong></p><p>方法一：深度优先搜索</p><p>方法二：广度优先搜索</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="195-下一个更大元素-III-中等"><a href="#195-下一个更大元素-III-中等" class="headerlink" title="195. 下一个更大元素 III-中等"></a><font color=DarkOrange>195. 下一个更大元素 III-中等</font></h4><p><strong>题目：</strong></p><p>给你一个正整数 <code>n</code> ，请你找出符合条件的最小整数，其由重新排列 <code>n</code> 中存在的每位数字组成，并且其值大于 <code>n</code> 。如果不存在这样的正整数，则返回 <code>-1</code> </p><p><strong>注意</strong> ，返回的整数应当是一个 <strong>32 位整数</strong> ，如果存在满足题意的答案，但不是 <strong>32 位整数</strong> ，同样返回 <code>-1</code> </p><p><strong>思路：</strong></p><p>方法一：下一个排列</p><p>方法二：数学</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="196-通配符匹配-困难"><a href="#196-通配符匹配-困难" class="headerlink" title="196. 通配符匹配-困难"></a><font color=DarkOrange>196. 通配符匹配-困难</font></h4><p><strong>题目：</strong></p><p>给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>) ，实现一个支持 <code>&#39;?&#39;</code> 和 <code>&#39;*&#39;</code> 的通配符匹配</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;?&#x27;</span> 可以匹配任何单个字符。</span><br><span class="line"><span class="string">&#x27;*&#x27;</span> 可以匹配任意字符串（包括空字符串）。</span><br></pre></td></tr></table></figure><p>两个字符串<strong>完全匹配</strong>才算匹配成功</p><p><strong>说明:</strong></p><ul><li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母</li><li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>?</code> 和 <code>*</code></li></ul><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：贪心算法</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="197-完全平方数-中等"><a href="#197-完全平方数-中等" class="headerlink" title="197. 完全平方数-中等"></a><font color=DarkOrange>197. 完全平方数-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数 <code>n</code> ，返回和为 <code>n</code> 的完全平方数的最少数量</p><p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是</p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：数学</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="198-解数独-困难"><a href="#198-解数独-困难" class="headerlink" title="198. 解数独-困难"></a><font color=DarkOrange>198. 解数独-困难</font></h4><p><strong>题目：</strong></p><p>编写一个程序，通过填充空格来解决数独问题</p><p>数独的解法需 <strong>遵循如下规则</strong>：</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次</li><li>数字 <code>1-9</code> 在每一列只能出现一次</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次</li></ol><p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示</p><p><strong>思路：</strong></p><p>方法一：回溯</p><p>方法二：位运算优化</p><p>方法三：枚举优化</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="199-阿拉伯数字转中文数字-中等"><a href="#199-阿拉伯数字转中文数字-中等" class="headerlink" title="199. 阿拉伯数字转中文数字-中等"></a><font color=DarkOrange>199. 阿拉伯数字转中文数字-中等</font></h4><p><strong>题目：</strong><br><strong>思路：</strong><br><strong>代码：</strong></p><h4 id="200-反转字符串-简单"><a href="#200-反转字符串-简单" class="headerlink" title="200. 反转字符串-简单"></a><font color=DarkOrange>200. 反转字符串-简单</font></h4><p><strong>题目：</strong></p><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出</p><p>不要给另外的数组分配额外的空间，你必须<strong>原地修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题</p><p><strong>思路：</strong></p><p>双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;面试LeetCode算法题整理，按照出现的频率依次递减排序，题目类型包含：简单、中等、困难&lt;/p&gt;
&lt;p&gt;CodeTop地址：&lt;a href=&quot;https://codetop.cc/home&quot;&gt;点击跳转&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备注：&lt;/strong&gt;出现的频</summary>
      
    
    
    
    <category term="面试" scheme="https://huajun-chen.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="算法" scheme="https://huajun-chen.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>云原生15-微服务项目的开发和部署案例</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F15-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%BC%80%E5%8F%91%E5%92%8C%E9%83%A8%E7%BD%B2%E6%A1%88%E4%BE%8B/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F15-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%BC%80%E5%8F%91%E5%92%8C%E9%83%A8%E7%BD%B2%E6%A1%88%E4%BE%8B/</id>
    <published>2022-11-08T15:30:00.000Z</published>
    <updated>2022-11-20T15:18:00.982Z</updated>
    
    <content type="html"><![CDATA[<p>待完成。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;待完成。。。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>云原生14-基于Kubernetes和Istio的安全保证</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F14-%E5%9F%BA%E4%BA%8EKubernetes%E5%92%8CIstio%E7%9A%84%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F14-%E5%9F%BA%E4%BA%8EKubernetes%E5%92%8CIstio%E7%9A%84%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81/</id>
    <published>2022-11-08T15:00:00.000Z</published>
    <updated>2022-11-20T15:17:54.758Z</updated>
    
    <content type="html"><![CDATA[<p>待完成。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;待完成。。。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>云原生13-Kubernetes集群联邦和Istio多集群管理</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F13-Kubernetes%E9%9B%86%E7%BE%A4%E8%81%94%E9%82%A6%E5%92%8CIstio%E5%A4%9A%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F13-Kubernetes%E9%9B%86%E7%BE%A4%E8%81%94%E9%82%A6%E5%92%8CIstio%E5%A4%9A%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86/</id>
    <published>2022-11-08T14:00:00.000Z</published>
    <updated>2022-11-20T15:17:47.605Z</updated>
    
    <content type="html"><![CDATA[<p>待完成。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;待完成。。。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>云原生12-基于Istio的高级流量管理</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F12-%E5%9F%BA%E4%BA%8EIstio%E7%9A%84%E9%AB%98%E7%BA%A7%E6%B5%81%E9%87%8F%E7%AE%A1%E7%90%86/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F12-%E5%9F%BA%E4%BA%8EIstio%E7%9A%84%E9%AB%98%E7%BA%A7%E6%B5%81%E9%87%8F%E7%AE%A1%E7%90%86/</id>
    <published>2022-11-08T13:00:00.000Z</published>
    <updated>2022-11-20T15:17:41.235Z</updated>
    
    <content type="html"><![CDATA[<p>待完成。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;待完成。。。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>云原生11-将应用迁移至Kubernetes平台</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F11-%E5%B0%86%E5%BA%94%E7%94%A8%E8%BF%81%E7%A7%BB%E8%87%B3Kubernetes%E5%B9%B3%E5%8F%B0/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F11-%E5%B0%86%E5%BA%94%E7%94%A8%E8%BF%81%E7%A7%BB%E8%87%B3Kubernetes%E5%B9%B3%E5%8F%B0/</id>
    <published>2022-11-08T12:00:00.000Z</published>
    <updated>2022-11-20T15:17:35.108Z</updated>
    
    <content type="html"><![CDATA[<p>待完成。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;待完成。。。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>云原生10-Kubernetes的生产化运维</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F10-Kubernetes%E7%9A%84%E7%94%9F%E4%BA%A7%E5%8C%96%E8%BF%90%E7%BB%B4/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F10-Kubernetes%E7%9A%84%E7%94%9F%E4%BA%A7%E5%8C%96%E8%BF%90%E7%BB%B4/</id>
    <published>2022-11-08T11:00:00.000Z</published>
    <updated>2022-11-20T15:17:28.578Z</updated>
    
    <content type="html"><![CDATA[<p>待完成。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;待完成。。。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>云原生09-生产化集群的管理</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F09-%E7%94%9F%E4%BA%A7%E5%8C%96%E9%9B%86%E7%BE%A4%E7%9A%84%E7%AE%A1%E7%90%86/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F09-%E7%94%9F%E4%BA%A7%E5%8C%96%E9%9B%86%E7%BE%A4%E7%9A%84%E7%AE%A1%E7%90%86/</id>
    <published>2022-11-08T10:00:00.000Z</published>
    <updated>2022-11-20T15:17:21.265Z</updated>
    
    <content type="html"><![CDATA[<p>待完成。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;待完成。。。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>云原生08-Kubernetes控制平面组件：生命周期管理和服务发现</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F08-Kubernetes%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%BB%84%E4%BB%B6%EF%BC%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F08-Kubernetes%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%BB%84%E4%BB%B6%EF%BC%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</id>
    <published>2022-11-08T09:00:00.000Z</published>
    <updated>2022-11-20T15:17:12.964Z</updated>
    
    <content type="html"><![CDATA[<p>待完成。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;待完成。。。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>云原生07-Kubernetes控制平面组件：调度器和控制器</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F07-Kubernetes%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%BB%84%E4%BB%B6%EF%BC%9A%E8%B0%83%E5%BA%A6%E5%99%A8%E5%92%8C%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F07-Kubernetes%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%BB%84%E4%BB%B6%EF%BC%9A%E8%B0%83%E5%BA%A6%E5%99%A8%E5%92%8C%E6%8E%A7%E5%88%B6%E5%99%A8/</id>
    <published>2022-11-08T08:00:00.000Z</published>
    <updated>2022-11-20T15:17:05.783Z</updated>
    
    <content type="html"><![CDATA[<p>待完成。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;待完成。。。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>云原生06-Kubernetes控制平面组件：API Server</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F06-Kubernetes%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%BB%84%E4%BB%B6%EF%BC%9AAPI-Server/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F06-Kubernetes%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%BB%84%E4%BB%B6%EF%BC%9AAPI-Server/</id>
    <published>2022-11-08T07:00:00.000Z</published>
    <updated>2022-11-20T15:16:59.453Z</updated>
    
    <content type="html"><![CDATA[<p>待完成。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;待完成。。。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>云原生05-Kubernetes控制平面组件：etcd</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F05-Kubernetes%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%BB%84%E4%BB%B6%EF%BC%9Aetcd/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F05-Kubernetes%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%BB%84%E4%BB%B6%EF%BC%9Aetcd/</id>
    <published>2022-11-08T06:00:00.000Z</published>
    <updated>2022-11-20T15:16:52.904Z</updated>
    
    <content type="html"><![CDATA[<p>待完成。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;待完成。。。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>云原生04-Kubernetes架构原则和对象设计</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F04-Kubernetes%E6%9E%B6%E6%9E%84%E5%8E%9F%E5%88%99%E5%92%8C%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F04-Kubernetes%E6%9E%B6%E6%9E%84%E5%8E%9F%E5%88%99%E5%92%8C%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-11-08T05:00:00.000Z</published>
    <updated>2022-11-20T15:16:46.692Z</updated>
    
    <content type="html"><![CDATA[<p>待完成。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;待完成。。。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>云原生03-Docker核心技术</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F03-Docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F03-Docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</id>
    <published>2022-11-08T04:00:00.000Z</published>
    <updated>2022-11-20T15:16:33.714Z</updated>
    
    <content type="html"><![CDATA[<p>待完成。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;待完成。。。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>云原生02-编写Go程序</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F02-%E7%BC%96%E5%86%99Go%E7%A8%8B%E5%BA%8F/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F02-%E7%BC%96%E5%86%99Go%E7%A8%8B%E5%BA%8F/</id>
    <published>2022-11-08T03:00:00.000Z</published>
    <updated>2022-11-24T08:53:30.297Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言进阶知识整理</p><h4 id="1-线程加锁"><a href="#1-线程加锁" class="headerlink" title="1. 线程加锁"></a><font color=DarkOrange>1. 线程加锁</font></h4><h5 id="1-1-锁"><a href="#1-1-锁" class="headerlink" title="1.1 锁"></a><font color=DarkOrange>1.1 锁</font></h5><ul><li>Go 语言不仅仅提供基于 CSP 的通讯模型，也支持基于共享内存的多线程数据访问</li><li>Sync 包提供了锁的基本原语</li><li>sync.Mutex 互斥锁<ul><li>Lock()加锁，Unlock 解锁</li></ul></li><li>sync.RWMutex 读写分离锁<ul><li>不限制并发读，只限制并发写和并发读写</li></ul></li><li>sync.WaitGroup<ul><li>等待一组 goroutine 返回</li></ul></li><li>sync.Once<ul><li>保证某段代码只执行一次</li></ul></li><li>sync.Cond<ul><li>让一组 goroutine 在满足特定条件时被唤醒</li></ul></li></ul><h5 id="1-2-Mutex示例"><a href="#1-2-Mutex示例" class="headerlink" title="1.2 Mutex示例"></a><font color=DarkOrange>1.2 Mutex示例</font></h5><p>Kubernetes 中的 informer factory</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start initializes all requested informers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *sharedInformerFactory)</span></span> Start(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) &#123;</span><br><span class="line">  f.lock.Lock()</span><br><span class="line">  <span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line">  <span class="keyword">for</span> informerType, informer := <span class="keyword">range</span> f.informers &#123;</span><br><span class="line">    <span class="keyword">if</span> !f.startedInformers[informerType] &#123;</span><br><span class="line">      <span class="keyword">go</span> informer.Run(stopCh)</span><br><span class="line">      f.startedInformers[informerType] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-3-WaitGroup示例"><a href="#1-3-WaitGroup示例" class="headerlink" title="1.3 WaitGroup示例"></a><font color=DarkOrange>1.3 WaitGroup示例</font></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CreateBatch create a batch of pods. All pods are created before waiting.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *PodClient)</span></span> CreateBatch(pods []*v1.Pod) []*v1.Pod &#123;</span><br><span class="line">  ps := <span class="built_in">make</span>([]*v1.Pod, <span class="built_in">len</span>(pods))</span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  <span class="keyword">for</span> i, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>, pod *v1.Pod)</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> wg.Done()</span><br><span class="line">      <span class="keyword">defer</span> GinkgoRecover()</span><br><span class="line">      ps[i] = c.CreateSync(pod)</span><br><span class="line">    &#125;(i, pod)</span><br><span class="line">  &#125;</span><br><span class="line">  wg.Wait()</span><br><span class="line">  <span class="keyword">return</span> ps</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-4-Cond示例"><a href="#1-4-Cond示例" class="headerlink" title="1.4 Cond示例"></a><font color=DarkOrange>1.4 Cond示例</font></h5><p>Kubernetes 中的队列，标准的生产者消费者模式</p><p>cond: sync.NewCond(&amp;sync.Mutex{})</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add marks item as needing processing.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span></span> Add(item <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">  q.cond.L.Lock()</span><br><span class="line">  <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">  <span class="keyword">if</span> q.shuttingDown &#123;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> q.dirty.has(item) &#123;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  q.metrics.add(item)</span><br><span class="line">  q.dirty.insert(item)</span><br><span class="line">  <span class="keyword">if</span> q.processing.has(item) &#123;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  q.queue = <span class="built_in">append</span>(q.queue, item)</span><br><span class="line">  q.cond.Signal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get blocks until it can return an item to be processed. If shutdown = true,</span></span><br><span class="line"><span class="comment">// the caller should end their goroutine. You must call Done with item when you</span></span><br><span class="line"><span class="comment">// have finished processing it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span></span> Get() (item <span class="keyword">interface</span>&#123;&#125;, shutdown <span class="type">bool</span>) &#123;</span><br><span class="line">  q.cond.L.Lock()</span><br><span class="line">  <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">len</span>(q.queue) == <span class="number">0</span> &amp;&amp; !q.shuttingDown &#123;</span><br><span class="line">  q.cond.Wait()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(q.queue) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// We must be shutting down.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  item, q.queue = q.queue[<span class="number">0</span>], q.queue[<span class="number">1</span>:]</span><br><span class="line">  q.metrics.get(item)</span><br><span class="line">  q.processing.insert(item)</span><br><span class="line">  q.dirty.<span class="built_in">delete</span>(item)</span><br><span class="line">  <span class="keyword">return</span> item, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-线程调度"><a href="#2-线程调度" class="headerlink" title="2. 线程调度"></a><font color=DarkOrange>2. 线程调度</font></h4><h5 id="2-1-深入理解Go语言线程调度"><a href="#2-1-深入理解Go语言线程调度" class="headerlink" title="2.1 深入理解Go语言线程调度"></a><font color=DarkOrange>2.1 深入理解Go语言线程调度</font></h5><ul><li>进程：资源分配的基本单位</li><li>线程：调度的基本单位</li><li>无论是线程还是进程，在 linux 中都以 task_struct 描述，从内核角度看，与进程无本质区别</li><li>Glibc 中的 pthread 库提供 NPTL（Native POSIX Threading Library）支持</li></ul><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d2s6imj8j31b60gutem.jpg" alt="image.png" style="zoom:50%;" /></div><h5 id="2-2-Linux进程的内存使用"><a href="#2-2-Linux进程的内存使用" class="headerlink" title="2.2 Linux进程的内存使用"></a><font color=DarkOrange>2.2 Linux进程的内存使用</font></h5><p><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d2tl546nj31n40o27fy.jpg" alt="image.png"></p><h5 id="2-3-CPU对内存的访问"><a href="#2-3-CPU对内存的访问" class="headerlink" title="2.3 CPU对内存的访问"></a><font color=DarkOrange>2.3 CPU对内存的访问</font></h5><ul><li>CPU 上有个 Memory Management Unit（MMU） 单元</li><li>CPU 把虚拟地址给 MMU，MMU 去物理内存中查询页表，得到实际的物理地址</li><li>CPU 维护一份缓存 Translation Lookaside Buffer（TLB），缓存虚拟地址和物理地址的映射关系</li></ul><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d2uw9hhqj31cy0jm40u.jpg" alt="image.png" style="zoom:50%;" /></div><h5 id="2-4-进程切换开销"><a href="#2-4-进程切换开销" class="headerlink" title="2.4 进程切换开销"></a><font color=DarkOrange>2.4 进程切换开销</font></h5><ul><li>直接开销<ul><li>切换页表全局目录（PGD）</li><li>切换内核态堆栈</li><li>切换硬件上下文（进程恢复前，必须装入寄存器的数据统称为硬件上下文）</li><li>刷新 TLB</li><li>系统调度器的代码执行</li></ul></li><li>间接开销<ul><li>CPU 缓存失效导致的进程需要到内存直接访问的 IO 操作变多</li></ul></li></ul><h5 id="2-5-线程切换开销"><a href="#2-5-线程切换开销" class="headerlink" title="2.5 线程切换开销"></a><font color=DarkOrange>2.5 线程切换开销</font></h5><ul><li>线程本质上只是一批共享资源的进程，线程切换本质上依然需要内核进行进程切换</li><li>一组线程因为共享内存资源，因此一个进程的所有线程共享虚拟地址空间，线程切换相比进程 切换，主要节省了虚拟地址空间的切换</li></ul><h5 id="2-6-用户线程"><a href="#2-6-用户线程" class="headerlink" title="2.6 用户线程"></a><font color=DarkOrange>2.6 用户线程</font></h5><p>无需内核帮助，应用程序在用户空间创建的可执行单元，创建销毁完全在用户态完成</p><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d2zvpsctj31e80lon5k.jpg" alt="image.png" style="zoom:50%;" /></div><h5 id="2-7-Goroutine"><a href="#2-7-Goroutine" class="headerlink" title="2.7 Goroutine"></a><font color=DarkOrange>2.7 Goroutine</font></h5><p>Go 语言基于 GMP 模型实现用户态线程</p><ul><li>G：表示 goroutine，每个 goroutine 都有自己的栈空间，定时器， 初始化的栈空间在 2k 左右，空间会随着需求增长</li><li>M：抽象化代表内核线程，记录内核线程栈信息，当 goroutine 调度 到线程时，使用该 goroutine 自己的栈信息</li><li>P：代表调度器，负责调度 goroutine，维护一个本地 goroutine 队 列，M 从 P 上获得 goroutine 并执行，同时还负责部分内存的管理</li></ul><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d31hrzzjj30g608mwfr.jpg" alt="image.png" style="zoom:40%;" /></div><h5 id="2-8-GMP模型细节"><a href="#2-8-GMP模型细节" class="headerlink" title="2.8 GMP模型细节"></a><font color=DarkOrange>2.8 GMP模型细节</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d32u86bpj31ke0r8naq.jpg" alt="image.png" style="zoom:67%;" /></div><h5 id="2-9-G所处的位置"><a href="#2-9-G所处的位置" class="headerlink" title="2.9 G所处的位置"></a><font color=DarkOrange>2.9 G所处的位置</font></h5><ul><li>进程都有一个全局的 G 队列</li><li>每个 P 拥有自己的本地执行队列</li><li>有不在运行队列中的 G<ul><li>处于 channel 阻塞态的 G 被放在 sudog</li><li>脱离 P 绑定在 M 上的 G，如系统调用</li><li>为了复用，执行结束进入 P 的 gFree 列表中的 G</li></ul></li></ul><h5 id="2-10-Goroutine创建过程"><a href="#2-10-Goroutine创建过程" class="headerlink" title="2.10 Goroutine创建过程"></a><font color=DarkOrange>2.10 Goroutine创建过程</font></h5><ul><li>获取或者创建新的 Goroutine 结构体<ul><li>从处理器的 gFree 列表中查找空闲的 Goroutine</li><li>如果不存在空闲的 Goroutine，会通过 runtime.malg 创建一个栈大小足够的新结构体</li></ul></li><li>将函数传入的参数移到 Goroutine 的栈上</li><li>更新 Goroutine 调度相关的属性，更新状态为_Grunnable</li><li>返回的 Goroutine 会存储到全局变量 allgs 中</li></ul><h5 id="2-11-将Goroutine放到运行队列上"><a href="#2-11-将Goroutine放到运行队列上" class="headerlink" title="2.11 将Goroutine放到运行队列上"></a><font color=DarkOrange>2.11 将Goroutine放到运行队列上</font></h5><ul><li>Goroutine 设置到处理器的 runnext 作为下一个处理器执行的任务</li><li>当处理器的本地运行队列已经没有剩余空间时，就会把本地队列中的一部分 Goroutine 和待加入的 Goroutine通过 runtime.runqputslow 添加到调度器持有的全局运行队列上</li></ul><h5 id="2-12-调度器行为"><a href="#2-12-调度器行为" class="headerlink" title="2.12 调度器行为"></a><font color=DarkOrange>2.12 调度器行为</font></h5><ul><li>为了保证公平，当全局运行队列中有待执行的 Goroutine 时，通过 schedtick 保证有一定 几率会从全局的运行队列中查找对应的 Goroutine</li><li>从处理器本地的运行队列中查找待执行的 Goroutine</li><li>如果前两种方法都没有找到 Goroutine，会通过 runtime.findrunnable 进行阻塞地查找 Goroutine<ul><li>从本地运行队列、全局运行队列中查找</li><li>从网络轮询器中查找是否有 Goroutine 等待运行</li><li>通过 runtime.runqsteal 尝试从其他随机的处理器中窃取待运行的 Goroutine</li></ul></li></ul><h4 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3. 内存管理"></a><font color=DarkOrange>3. 内存管理</font></h4><h5 id="3-1-堆内存管理"><a href="#3-1-堆内存管理" class="headerlink" title="3.1 堆内存管理"></a><font color=DarkOrange>3.1 堆内存管理</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d372j1f5j31jw0isdn7.jpg" alt="image.png" style="zoom:50%;" /></div><ul><li>初始化连续内存块作为堆</li><li>有内存申请的时候，Allocator 从堆内存的未分配区域分割小内存块</li><li>用链表将已分配内存连接起来</li><li>需要信息描述每个内存块的元数据：大小，是否使用，下一个内存块的地址等</li></ul><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d38gftrpj316007uabs.jpg" alt="image.png" style="zoom:50%;" /></div><h5 id="3-2-TCMalloc"><a href="#3-2-TCMalloc" class="headerlink" title="3.2 TCMalloc"></a><font color=DarkOrange>3.2 TCMalloc</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d39qtrfpj31k00nu7fm.jpg" alt="image.png" style="zoom:67%;" /></div><ul><li><p>page:内存页，一块 8K 大小的内存空间。Go 与操作系统之间的内存申请和释放，都是以 page 为单位的</p></li><li><p>span: 内存块，一个或多个连续的 page 组成一个 span </p></li><li><p>sizeclass : 空间规格，每个 span 都带有一个 sizeclass ，标记着该 span 中的 page 应该如何 使用</p></li><li><p>object : 对象，用来存储一个变量数据内存空间，一个 span 在初始化时，会被切割成一堆等大 的 object ；假设 object 的大小是 16B ，span 大小是 8K ，那么就会把 span 中的 page 就会 被初始化 8K &#x2F; 16B &#x3D; 512 个 object 。所谓内存分配，就是分配一个 object 出去</p></li><li><p>对象大小定义</p><ul><li>小对象大小：0~256KB</li><li>中对象大小：256KB~1MB</li><li>大对象大小：&gt;1MB</li></ul></li><li><p>小对象的分配流程</p><ul><li>ThreadCache -&gt; CentralCache -&gt; HeapPage，大部分时候，ThreadCache 缓存都是足够的，不需要去访问 CentralCache 和 HeapPage，无系统调用配合无锁分配，分配效率是非常高的</li></ul></li><li><p>中对象分配流程</p><ul><li>直接在 PageHeap 中选择适当的大小即可，128 Page 的 Span 所保存的最大内存就是 1MB</li></ul></li><li><p>大对象分配流程</p><ul><li>从 large span set 选择合适数量的页面组成 span，用来存储数据</li></ul></li></ul><h5 id="3-3-Go语言内存分配"><a href="#3-3-Go语言内存分配" class="headerlink" title="3.3 Go语言内存分配"></a><font color=DarkOrange>3.3 Go语言内存分配</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d3d17knjj31kq0ni499.jpg" alt="image.png" style="zoom:67%;" /></div><ul><li><p>mcache：小对象的内存分配直接走</p><ul><li>size class 从 1 到 66，每个 class 两个 span</li><li>Span 大小是 8KB，按 span class 大小切分</li></ul></li><li><p>mcentral</p><ul><li>Span 内的所有内存块都被占用时，没有剩余空间继续分配对象，mcache 会向 mcentral 申请1个span，mcache 拿到 span 后继续分配对象</li><li>当 mcentral 向 mcache 提供 span 时，如果没有符合条件的 span，mcentral 会向 mheap 申请span</li></ul></li><li><p>mheap</p><ul><li>当 mheap 没有足够的内存时，mheap 会向 OS 申请内存</li><li>Mheap 把 Span 组织成了树结构，而不是链表</li><li>然后把 Span 分配到 heapArena 进行管理，它包含地址映射和 span 是否包含指针等位图<ul><li>为了更高效的分配、回收和再利用内存</li></ul></li></ul></li></ul><h5 id="3-4-内存回收"><a href="#3-4-内存回收" class="headerlink" title="3.4 内存回收"></a><font color=DarkOrange>3.4 内存回收</font></h5><ul><li>引用计数（Python，PHP，Swift）<ul><li>对每一个对象维护一个引用计数，当引用该对象的对象被销毁的时候，引用计数减 1，当引用计数为 0 的时候，回 收该对象</li><li>优点：对象可以很快的被回收，不会出现内存耗尽或达到某个阀值时才回收</li><li>缺点：不能很好的处理循环引用，而且实时维护引用计数，有也一定的代价</li></ul></li><li>标记-清除（Golang）<ul><li>从根变量开始遍历所有引用的对象，引用的对象标记为”被引用”，没有被标记的进行回收</li><li>优点：解决引用计数的缺点</li><li>缺点：需要 STW（stop the word），即要暂停程序运行</li></ul></li><li>分代收集（Java）<ul><li>按照生命周期进行划分不同的代空间，生命周期长的放入老年代，短的放入新生代，新生代的回收频率高于老年 代的频率</li></ul></li></ul><h5 id="3-5-mspan"><a href="#3-5-mspan" class="headerlink" title="3.5 mspan"></a><font color=DarkOrange>3.5 mspan</font></h5><ul><li>allocBits<ul><li>记录了每块内存分配的情况</li></ul></li><li>gcmarkBits<ul><li>记录了每块内存的引用情况，标记阶段对每块内存进行标记，有对象引用的内存标记为1，没有的标 记为 0</li></ul></li><li>这两个位图的数据结构是完全一致的，标记结束则进行内存回收，回收的时候，将 allocBits 指 向 gcmarkBits，标记过的则存在，未进行标记的则进行回收</li></ul><h5 id="3-6-GC工作流程"><a href="#3-6-GC工作流程" class="headerlink" title="3.6 GC工作流程"></a><font color=DarkOrange>3.6 GC工作流程</font></h5><p>Golang GC 的大部分处理是和用户代码并行的</p><ul><li>Mark：<ul><li>Mark Prepare: 初始化 GC 任务，包括开启写屏障 (write barrier) 和辅助 GC(mutator assist)，统计root对象的任 务数量等。这个过程需要STW</li><li>GC Drains: 扫描所有 root 对象，包括全局指针和 goroutine(G) 栈上的指针（扫描对应 G 栈时需停止该 G)，将其 加入标记队列(灰色队列)，并循环处理灰色队列的对象，直到灰色队列为空。该过程后台并行执行</li></ul></li><li>Mark Termination：完成标记工作，重新扫描(re-scan)全局指针和栈。因为 Mark 和用户程序是并行的，所以在 Mark 过 程中可能会有新的对象分配和指针赋值，这个时候就需要通过写屏障（write barrier）记录下来，re-scan 再检查一下，这 个过程也是会 STW 的</li><li>Sweep：按照标记结果回收所有的白色对象，该过程后台并行执行</li><li>Sweep Termination：对未清扫的 span 进行清扫, 只有上一轮的 GC 的清扫工作完成才可以开始新一轮的 GC</li></ul><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d3k484cmj31ci0ikwn9.jpg" alt="image.png" style="zoom:67%;" /></div><h5 id="3-7-三色标记"><a href="#3-7-三色标记" class="headerlink" title="3.7 三色标记"></a><font color=DarkOrange>3.7 三色标记</font></h5><ul><li>GC 开始时，认为所有 object 都是 白色，即垃圾</li><li>从 root 区开始遍历，被触达的 object 置成 灰色</li><li>遍历所有灰色 object，将他们内部的引用变量置成 灰色，自身置成 黑色</li><li>循环第 3 步，直到没有灰色 object 了，只剩下了黑白两种，白色的都是垃圾</li><li>对于黑色 object，如果在标记期间发生了写操作，写屏障会在真正赋值前将新对象标记为 灰色</li><li>标记过程中，mallocgc 新分配的 object，会先被标记成 黑色 再返回</li></ul><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d3lpvwr3j31bw0940tw.jpg" alt="image.png" style="zoom:50%;" /></div><h5 id="3-8-垃圾回收触发机制"><a href="#3-8-垃圾回收触发机制" class="headerlink" title="3.8 垃圾回收触发机制"></a><font color=DarkOrange>3.8 垃圾回收触发机制</font></h5><ul><li>内存分配量达到阀值触发 GC<ul><li>每次内存分配时都会检查当前内存分配量是否已达到阀值，如果达到阀值则立即启动 GC</li><li>阀值 &#x3D; 上次 GC 内存分配量 * 内存增长率</li><li>内存增长率由环境变量 GOGC 控制，默认为 100，即每当内存扩大一倍时启动 GC</li></ul></li><li>定期触发 GC<ul><li>默认情况下，最长 2 分钟触发一次 GC，这个间隔在 src&#x2F;runtime&#x2F;proc.go:forcegcperiod 变量中 被声明</li></ul></li><li>手动触发<ul><li>程序代码中也可以使用 runtime.GC()来手动触发 GC。这主要用于 GC 性能测试和统计</li></ul></li></ul><h4 id="4-包引用与依赖管理"><a href="#4-包引用与依赖管理" class="headerlink" title="4. 包引用与依赖管理"></a><font color=DarkOrange>4. 包引用与依赖管理</font></h4><h5 id="4-1-Go-语言依赖管理的演进"><a href="#4-1-Go-语言依赖管理的演进" class="headerlink" title="4.1 Go 语言依赖管理的演进"></a><font color=DarkOrange>4.1 Go 语言依赖管理的演进</font></h5><ul><li>回顾 GOPATH<ul><li>通过环境变量设置系统级的 Go 语言类库目录</li><li>GOPATH 的问题？<ul><li>不同项目可能依赖不同版本</li><li>代码被 clone 以后需要设置 GOPATH 才能编译</li></ul></li></ul></li><li>vendor<ul><li>自 1.6 版本，支持 vendor 目录，在每个 Go 语言项目中，创建一个名叫 vendor 的目录，并将依赖拷贝至该目录</li><li>Go 语言项目会自动将 vendor 目录作为自身的项目依赖路径</li><li>好处？<ul><li>每个项目的 vendor目录是独立的，可以灵活的选择版本</li><li>Vendor 目录与源代码一起 check in 到 github，其他人 checkout 以后可直接编译</li><li>无需在编译期间下载依赖包，所有依赖都已经与源代码保存在一起</li></ul></li></ul></li></ul><h5 id="4-2-vendor管理工具"><a href="#4-2-vendor管理工具" class="headerlink" title="4.2 vendor管理工具"></a><font color=DarkOrange>4.2 vendor管理工具</font></h5><p>通过声明式配置，实现 vendor 管理的自动化</p><ul><li>在早期，Go 语言无自带依赖管理工具，社区方案鱼龙混杂比较出名的包括<ul><li>Godeps, Glide</li></ul></li><li>Go 语言随后发布了自带的依赖管理工具 Gopkg</li><li>很快用新的工具 gomod 替换掉了 gopkg<ul><li>切换 mod 开启模式：export GO111MODULE&#x3D;on&#x2F;off&#x2F;auto</li><li>Go mod 相比之前的工具更灵活易用，以基本统一了 Go 语言依赖管理</li></ul></li></ul><h5 id="4-3-Go-mod使用"><a href="#4-3-Go-mod使用" class="headerlink" title="4.3 Go mod使用"></a><font color=DarkOrange>4.3 Go mod使用</font></h5><ul><li>创建项目</li><li>初始化 Go 模块<ul><li><code>go mod init</code></li></ul></li><li>下载依赖包<ul><li><code>go mod download</code>（下载的依赖包在$GOPATH&#x2F;pkg，如果没有设置 GOPATH，则下载在项目根目录&#x2F;pkg）</li><li>在源代码中使用某个依赖包，如 github.com&#x2F;emicklei&#x2F;go-restful</li></ul></li><li>添加缺少的依赖并为依赖包瘦身<ul><li><code>go mod tidy</code></li></ul></li><li>把 Go 依赖模块添加到 vendor 目录<ul><li><code>go mod vendor</code></li></ul></li></ul><p>配置细节会被保存在项目根目录的 go.mod 中</p><p>可在 require 或者 replacement 中指定版本</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">module k8s.io/apiserver</span><br><span class="line"><span class="keyword">go</span> <span class="number">1.13</span></span><br><span class="line">require (</span><br><span class="line">  github.com/evanphx/json-patch v4<span class="number">.9</span><span class="number">.0</span>+incompatible</span><br><span class="line">  github.com/<span class="keyword">go</span>-openapi/jsonreference v0<span class="number">.19</span><span class="number">.3</span> <span class="comment">// indirect</span></span><br><span class="line">  github.com/<span class="keyword">go</span>-openapi/spec v0<span class="number">.19</span><span class="number">.3</span></span><br><span class="line">  github.com/gogo/protobuf v1<span class="number">.3</span><span class="number">.2</span></span><br><span class="line">  github.com/google/<span class="keyword">go</span>-cmp v0<span class="number">.3</span><span class="number">.0</span></span><br><span class="line">  github.com/google/gofuzz v1<span class="number">.1</span><span class="number">.0</span></span><br><span class="line">  k8s.io/apimachinery v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20210518100737</span><span class="number">-44</span>f1264f7b6b</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">replace (</span><br><span class="line">  golang.org/x/crypto =&gt; golang.org/x/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200220183623</span>-bac4c82f6975</span><br><span class="line">  golang.org/x/text =&gt; golang.org/x/text v0<span class="number">.3</span><span class="number">.2</span></span><br><span class="line">  k8s.io/api =&gt; k8s.io/api v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20210518101910</span><span class="number">-53468e23</span>a787</span><br><span class="line">  k8s.io/apimachinery =&gt; k8s.io/apimachinery v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20210518100737</span><span class="number">-44</span>f1264f7b6b</span><br><span class="line">  k8s.io/client-<span class="keyword">go</span> =&gt; k8s.io/client-<span class="keyword">go</span> v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20210518104342</span>-fa3acefe68f3</span><br><span class="line">  k8s.io/component-base =&gt; k8s.io/component-base v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20210518111421</span><span class="number">-67</span>c12a31a26a</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="4-4-GOPROXY和GOPRIVATE"><a href="#4-4-GOPROXY和GOPRIVATE" class="headerlink" title="4.4 GOPROXY和GOPRIVATE"></a><font color=DarkOrange>4.4 GOPROXY和GOPRIVATE</font></h5><ul><li>GOPROXY<ul><li>为拉取 Go 依赖设置代理<ul><li><code>export GOPROXY=https://goproxy.cn</code></li></ul></li></ul></li><li>在设置 GOPROXY 以后，默认所有依赖拉取都需要经过 proxy 连接 git repo，拉取代码，并做 checksum 校验</li><li>某些私有代码仓库是 goproxy.cn 无法连接的，因此需要设置 GOPRIVATE 来声明私有代码仓库</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GOPRIVATE=*.corp.example.com</span><br><span class="line">GOPROXY=proxy.example.com</span><br><span class="line">GONOPROXY=myrepo.corp.example.com</span><br></pre></td></tr></table></figure><h4 id="5-Makefile"><a href="#5-Makefile" class="headerlink" title="5. Makefile"></a><font color=DarkOrange>5. Makefile</font></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root:</span><br><span class="line">export ROOT=github.com/cncamp/golang;</span><br><span class="line">.PHONY: root</span><br><span class="line">release:</span><br><span class="line">  echo <span class="string">&quot;building httpserver binary&quot;</span></span><br><span class="line">  mkdir -p bin/amd64</span><br><span class="line">  CGO_ENABLED=<span class="number">0</span> GOOS=linux GOARCH=amd64 <span class="keyword">go</span> build -o bin/amd64 .</span><br><span class="line">.PHONY: release</span><br></pre></td></tr></table></figure><h4 id="6-动手编写一个HTTP-Server"><a href="#6-动手编写一个HTTP-Server" class="headerlink" title="6. 动手编写一个HTTP Server"></a><font color=DarkOrange>6. 动手编写一个HTTP Server</font></h4><h5 id="6-1-理解net-http包"><a href="#6-1-理解net-http包" class="headerlink" title="6.1 理解net.http包"></a><font color=DarkOrange>6.1 理解net.http包</font></h5><ul><li><p>注册 handle 处理函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">&quot;/healthz&quot;</span>, healthz)</span><br><span class="line"><span class="comment">//Use the default DefaultServeMux.</span></span><br><span class="line">ListenAndService</span><br><span class="line">err := http.ListenAndServe(<span class="string">&quot;:80&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义 handle 处理函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">healthz</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">io.WriteString(w, <span class="string">&quot;ok&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="6-2-阻塞IO模型"><a href="#6-2-阻塞IO模型" class="headerlink" title="6.2 阻塞IO模型"></a><font color=DarkOrange>6.2 阻塞IO模型</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d3y19ws9j31by0lin5s.jpg" alt="image.png" style="zoom:50%;" /></div><h5 id="6-3-非阻塞IO模型"><a href="#6-3-非阻塞IO模型" class="headerlink" title="6.3 非阻塞IO模型"></a><font color=DarkOrange>6.3 非阻塞IO模型</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d4695nkmj31dg0lmtjd.jpg" alt="image.png" style="zoom:50%;" /></div><h5 id="6-4-IO多路复用"><a href="#6-4-IO多路复用" class="headerlink" title="6.4 IO多路复用"></a><font color=DarkOrange>6.4 IO多路复用</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d477ndpqj31f20lo142.jpg" alt="image.png" style="zoom:50%;" /></div><h5 id="6-5-异步IO"><a href="#6-5-异步IO" class="headerlink" title="6.5 异步IO"></a><font color=DarkOrange>6.5 异步IO</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d4805ht4j318m0lmaif.jpg" alt="image.png" style="zoom:50%;" /></div><h5 id="6-6-Linux-epoll"><a href="#6-6-Linux-epoll" class="headerlink" title="6.6 Linux epoll"></a><font color=DarkOrange>6.6 Linux epoll</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d48xagndj31nm0tsqd5.jpg" alt="image.png" style="zoom:50%;" /></div><h5 id="6-7-Go-语言高性能httpserver的实现细节"><a href="#6-7-Go-语言高性能httpserver的实现细节" class="headerlink" title="6.7 Go 语言高性能httpserver的实现细节"></a><font color=DarkOrange>6.7 Go 语言高性能httpserver的实现细节</font></h5><p>Go 语言将协程与 fd 资源绑定</p><ul><li>一个 socket fd 与一个协程绑定</li><li>当 socket fd 未就绪时，将对应协程设置为 Gwaiting 状态，将 CPU 时间片让给其他协程</li><li>Go 语言 runtime 调度器进行调度唤醒协程时，检查 fd 是否就绪，如果就绪则将协程置为 Grunnable 并加入执行队列</li><li>协程被调度后处理 fd 数据</li></ul><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d4aae3tyj30vk0d60x7.jpg" alt="image.png" style="zoom:50%;" /></div><h4 id="7-调试"><a href="#7-调试" class="headerlink" title="7. 调试"></a><font color=DarkOrange>7. 调试</font></h4><h5 id="7-1-debug"><a href="#7-1-debug" class="headerlink" title="7.1 debug"></a><font color=DarkOrange>7.1 debug</font></h5><ul><li>gdb：<ul><li>Gccgo 原生支持 gdb，因此可以用 gdb 调试 Go 语言代码，但 dlv 对 Go 语言 debug 的支持比 gdb 更好</li><li>Gdb 对 Go 语言的栈管理，多线程支持等方面做的不够好，调试代码时可能有错乱现象</li></ul></li><li>dlv：<ul><li>Go 语言的专有 debugger</li></ul></li></ul><h5 id="7-2-dlv的配置"><a href="#7-2-dlv的配置" class="headerlink" title="7.2 dlv的配置"></a><font color=DarkOrange>7.2 dlv的配置</font></h5><ul><li>配置<ul><li>在 vscode 中配置 dlb</li><li>菜单：View -&gt; Command Palette</li><li>选择 Go : Install&#x2F;Update Tools，选择安装</li><li>安装完后，从改入口列表中可以看到 dlv 和 dlv-dap 已经安装好</li></ul></li><li>Debug 方法<ul><li>在代码中设置断点</li><li>菜单中选择 Run -&gt; Start Debugging 即可进入调试</li></ul></li></ul><h5 id="7-3-更多debug方法"><a href="#7-3-更多debug方法" class="headerlink" title="7.3 更多debug方法"></a><font color=DarkOrange>7.3 更多debug方法</font></h5><ul><li>添加日志<ul><li>在关键代码分支中加入日志</li><li>基于fmt包将日志输出到标准输出 stdout：<code>fmt.Println()</code></li><li>fmt 无日志重定向，无日志分级</li></ul></li><li>即与日志框架将日志输出到对应的 appender<ul><li>比如可利用 glog 进行日志输出<ul><li>可配置 appender，将标准输出转至文件</li><li>支持多级日志输出，可修改配置调整日志等级</li><li>自带时间戳和代码行，方便调试</li></ul></li></ul></li></ul><h5 id="7-4-Glog使用方法示例"><a href="#7-4-Glog使用方法示例" class="headerlink" title="7.4 Glog使用方法示例"></a><font color=DarkOrange>7.4 Glog使用方法示例</font></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/golang/glog&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Set(<span class="string">&quot;v&quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line">  glog.V(<span class="number">2</span>).Info(<span class="string">&quot;Starting http server...&quot;</span>)</span><br><span class="line">  mux := http.NewServeMux()</span><br><span class="line">  mux.HandleFunc(<span class="string">&quot;/&quot;</span>, rootHandler)</span><br><span class="line">  err := http.ListenAndServe(<span class="string">&quot;:80&quot;</span>, mux)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-5-性能分析（Performance-Profiling）"><a href="#7-5-性能分析（Performance-Profiling）" class="headerlink" title="7.5 性能分析（Performance Profiling）"></a><font color=DarkOrange>7.5 性能分析（Performance Profiling）</font></h5><p>CPU Profiling: 在代码中添加 CPUProfile 代码，runtime&#x2F;pprof 包提供支持</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cpuprofile = flag.String(<span class="string">&quot;cpuprofile&quot;</span>, <span class="string">&quot;&quot;</span> , <span class="string">&quot;write cpu profile to file&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Parse()</span><br><span class="line">  <span class="keyword">if</span> *cpuprofile != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    f, err := os.Create(*cpuprofile)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    pprof.StartCPUProfile(f)</span><br><span class="line">    <span class="keyword">defer</span> pprof.StopCPUProfile()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析 CPU 瓶颈</strong></p><ul><li><p>运行 cpuprofilie 代码后，会在 &#x2F;tmp&#x2F;cpuprofile 中记录 cpu 使用时间</p></li><li><p>运行 go tool pprof &#x2F;tmp&#x2F;cpuprofile 进入分析模式</p></li><li><p>运行 top10 查看 top 10线程，显示 30ms 花费在 main.main</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">30</span>ms, <span class="number">100</span>% of <span class="number">30</span>ms total</span><br><span class="line">flat flat% sum% cum cum%</span><br><span class="line"><span class="number">30</span>ms <span class="number">100</span>% <span class="number">100</span>% <span class="number">30</span>ms <span class="number">100</span>% main.main</span><br><span class="line"><span class="number">0</span> <span class="number">0</span>% <span class="number">100</span>% <span class="number">30</span>ms <span class="number">100</span>% runtime.main</span><br></pre></td></tr></table></figure></li><li><p>(pprof) list main.main 显示 30 毫秒都花费在循环上</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Total: <span class="number">30</span>ms</span><br><span class="line"><span class="number">30</span>ms <span class="number">30</span>ms (flat, cum) <span class="number">100</span>% of Total</span><br><span class="line"><span class="number">20</span>ms <span class="number">20</span>ms <span class="number">21</span>: <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++ &#123;</span><br><span class="line"><span class="number">10</span>ms <span class="number">10</span>ms <span class="number">22</span>: result += I</span><br></pre></td></tr></table></figure></li><li><p>可执行 web 命令生成 svg 文件，在通过浏览器打开 svg 文件查看图形化分析结果</p></li></ul><p><strong>其他可用 profiling 工具分析的问题</strong></p><ul><li>CPU profile<ul><li>程序的 CPU 使用情况，每 100 毫秒采集一次 CPU 使用情况</li></ul></li><li>Memory Profile<ul><li>程序的内存使用情况</li></ul></li><li>Block Profiling<ul><li>非运行态的 goroutine 细节，分析和查找死锁</li></ul></li><li>Goroutine Profiling<ul><li>所有 goroutines 的细节状态，有哪些 goroutine，它们的调用关系是怎样的</li></ul></li></ul><p><strong>针对 http 服务的 pprof</strong></p><ul><li><p>net&#x2F;http&#x2F;pprof 包提供支持</p></li><li><p>如果采用默认 mux handle，则只需 import _ “net&#x2F;http&#x2F;pprof”</p></li><li><p>如果采用自定义 mux handle，则需要注册 pprof handler</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startHTTP</span><span class="params">(addr <span class="type">string</span>, s *tnetd.Server)</span></span> &#123;</span><br><span class="line">  mux := http.NewServeMux()</span><br><span class="line">  mux.HandleFunc(“/debug/pprof/”, pprof.Index)</span><br><span class="line">  mux.HandleFunc(“/debug/pprof/profile”, pprof.Profile)</span><br><span class="line">  mux.HandleFunc(“/debug/pprof/symbol”, pprof.Symbol)</span><br><span class="line">  mux.HandleFunc(“/debug/pprof/trace”, pprof.Trace)</span><br><span class="line">  server := &amp;http.Server&#123;</span><br><span class="line">    Addr: addr,</span><br><span class="line">    Handler: mux,</span><br><span class="line">  &#125;</span><br><span class="line">  server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>分析 go profiling 结果</strong></p><p>在运行了开启 pprof 的服务器以后，可以通过访问对应的 URL 获得 profile 结果</p><ul><li>allocs: A sampling of all past memory allocations</li><li>block: Stack traces that led to blocking on synchronization primitives</li><li>cmdline: The command line invocation of the current program</li><li>goroutine: Stack traces of all current goroutines</li><li>heap: A sampling of memory allocations of live objects. You can specify the gc GET parameter to run GC before taking the heap sample</li></ul><p><strong>分析 go profiling 结果</strong></p><ul><li>mutex: Stack traces of holders of contended mutexes</li><li>profile: CPU profile. You can specify the duration in the seconds GET parameter. After you get the profile file, use the go tool pprof command to investigate the profile</li><li>threadcreate: Stack traces that led to the creation of new OS threads</li><li>trace: A trace of execution of the current program. You can specify the duration in the seconds GET parameter. After you get the trace file, use the go tool trace command to investigate the trace</li></ul><p><strong>结果分析示例</strong></p><ul><li>分析 goroutine 运行情况<ul><li><code>curl localhost/debug/pprof/goroutine?debug=2</code></li></ul></li><li>分析堆内存使用情况<ul><li><code>curl localhost/debug/pprof/heap?debug=2</code></li></ul></li></ul><h4 id="8-Kubernetes中常用代码解读"><a href="#8-Kubernetes中常用代码解读" class="headerlink" title="8. Kubernetes中常用代码解读"></a><font color=DarkOrange>8. Kubernetes中常用代码解读</font></h4><p>Rate Limit Queue</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ItemExponentialFailureRateLimiter)</span></span> When(item <span class="keyword">interface</span>&#123;&#125;) time.Duration &#123;</span><br><span class="line">  r.failuresLock.Lock()</span><br><span class="line">  <span class="keyword">defer</span> r.failuresLock.Unlock()</span><br><span class="line">  </span><br><span class="line">  exp := r.failures[item]</span><br><span class="line">  r.failures[item] = r.failures[item] + <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// The backoff is capped such that ‘calculated’ value never overflows.</span></span><br><span class="line">  backoff := <span class="type">float64</span>(r.baseDelay.Nanoseconds()) * math.Pow(<span class="number">2</span>, <span class="type">float64</span>(exp))</span><br><span class="line">  <span class="keyword">if</span> backoff &gt; math.MaxInt64 &#123;</span><br><span class="line">  <span class="keyword">return</span> r.maxDelay</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  calculated := time.Duration(backoff)</span><br><span class="line">  <span class="keyword">if</span> calculated &gt; r.maxDelay &#123;</span><br><span class="line">  <span class="keyword">return</span> r.maxDelay</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> calculated</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-Kubernetes日常运维中的代码调试场景"><a href="#9-Kubernetes日常运维中的代码调试场景" class="headerlink" title="9. Kubernetes日常运维中的代码调试场景"></a><font color=DarkOrange>9. Kubernetes日常运维中的代码调试场景</font></h4><h5 id="9-1-案例1：空指针"><a href="#9-1-案例1：空指针" class="headerlink" title="9.1 案例1：空指针"></a><font color=DarkOrange>9.1 案例1：空指针</font></h5><ul><li><p>问题描述</p><p>Kubenetes 调度器在调度有外挂存储需求的 pod 的时候，在获取节点信息失败 时会异常退出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic</span>: runtime <span class="type">error</span>: invalid memory address or <span class="literal">nil</span> pointer dereference [signal SIGSEGV: segmentation violation code=<span class="number">0x1</span> addr=<span class="number">0x0</span> pc=<span class="number">0x105e283</span>]</span><br></pre></td></tr></table></figure></li><li><p>根因分析</p><p>nil pointe 是 Go 语言中最常出现的一类错误，也最容易判断，通常在 call stack 中就会告诉 你哪行代码有问题</p><p>在调度器 csi.go 中的如下代码，当 node 为 nil 的时候，对 node 的引用 node.Name 就会 引发空指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node := nodeInfo.Node()</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> framework.NewStatus(framework.Error, fmt.Sprintf(<span class="string">&quot;nodenot found: %s&quot;</span>, node.Name))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解决办法</p><p>当指针为空时，不要继续引用</p><p>GitHub参考地址：<a href="https://github.com/kubernetes/kubernetes/pull/102229">点击跳转</a></p></li></ul><h5 id="9-2-案例2：Map-的读写冲突"><a href="#9-2-案例2：Map-的读写冲突" class="headerlink" title="9.2 案例2：Map 的读写冲突"></a><font color=DarkOrange>9.2 案例2：Map 的读写冲突</font></h5><ul><li><p>问题描述</p><p>程序在遍历 Kubernetes 对象的 Annotation 时异常退出</p></li><li><p>根因分析</p><p>Kubernetes 对象中 Label 和 Annotation 是 map[string]string</p><p>经常有代码需要修改这两个 Map</p><p>同时可能有其他线程 for…range 遍历</p></li><li><p>解决方法</p><ul><li>用 sync.RWMutex 加锁</li><li>使用线程安全 Map，比如 sync.Map{}</li></ul></li></ul><h5 id="9-3-案例3：kube-proxy消耗10个CPU"><a href="#9-3-案例3：kube-proxy消耗10个CPU" class="headerlink" title="9.3 案例3：kube-proxy消耗10个CPU"></a><font color=DarkOrange>9.3 案例3：kube-proxy消耗10个CPU</font></h5><ul><li><p>问题描述</p><p>客户汇报问题，kube-proxy 消耗了主机 10 个 CPU</p></li><li><p>根因分析</p><ul><li><p>登录问题机器，执行 top 命令查看 cpu 消耗，可以看到 kube-proxy 的 cpu 消耗和 pid 信息</p></li><li><p>对 kube-proxy 进程运行 System profiling tool，发现 10 个 CPU 中，超过 60% 的 CPU 都在做垃圾回收，这说明 GC 需要回收的对象太多了， 说明程序创建了大量可回收对象</p></li><li><p><code>perf top –p</code> </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Overhead Shared Obj Symbol</span><br><span class="line"><span class="number">26.48</span>% kube-proxy [.] runtime.gcDrain</span><br><span class="line"><span class="number">13.86</span>% kube-proxy [.] runtime.greyobject</span><br><span class="line"><span class="number">10.71</span>% kube-proxy [.] runtime.(*lfstack).pop</span><br><span class="line"><span class="number">10.04</span>% kube-proxy [.] runtime.scanobject</span><br></pre></td></tr></table></figure></li><li><p>通过 pprof 分析内存占用情况，<code>curl 127.0.0.1:10249/debug/pprof/heap?debug=2</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="number">245760</span> [<span class="number">301102</span>: <span class="number">73998827520</span>] @ <span class="number">0x11ddcda</span> <span class="number">0x11f306e</span> <span class="number">0x11f35f5</span> <span class="number">0x11fbdce</span> <span class="number">0x1204a8a</span> <span class="number">0x114ed76</span></span><br><span class="line"><span class="number">0x114eacb</span> <span class="number">0x11</span></span><br><span class="line"># &lt;font color=DarkOrange&gt;<span class="number">0x11ddcd9</span>&lt;/font&gt;</span><br><span class="line">k8s.io/kubernetes/vendor/github.com/vishvananda/netlink.(*Handle).RouteListFiltered+<span class="number">0x679</span></span><br><span class="line"># &lt;font color=DarkOrange&gt;<span class="number">0x11f306d</span> k8s.io/kubernetes/pkg/proxy/ipvs.(*netlinkHandle).GetLocalAddresses+<span class="number">0xed</span>&lt;/font&gt;</span><br><span class="line"># &lt;font color=DarkOrange&gt;<span class="number">0x11f35f4</span> k8s.io/kubernetes/pkg/proxy/ipvs.(*realIPGetter).NodeIPs+<span class="number">0x64</span>&lt;/font&gt;</span><br><span class="line"># &lt;font color=DarkOrange&gt;<span class="number">0x11fbdcd</span> k8s.io/kubernetes/pkg/proxy/ipvs.(*Proxier).syncProxyRules+<span class="number">0x47dd</span>&lt;/font&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>heap dump 分析</p><ul><li>GetLocalAddresses 函数调用创建了 301102 个对象，占用内存 73998827520</li><li>如此多的对象被创建，显然会导致 kube-proxy 进程忙于 GC，占用大量 CPU</li><li>对照代码分析 GetLocalAddresses 的实现，发现该函数的主要目的是获取节点本机 IP 地址，获取的方法是通过 ip route 命令获得当前节点所有 local 路由信息并转换成 go struct 并过滤掉 ipvs0网口上的路由信息</li><li><code>ip route show table local type local proto kernel</code></li><li>因为集群规模较大，该命令返回 5000 条左右记录，因此每次函数调用都会有数万个对象被生成</li><li>而 kube-proxy 在处理每一个服务的时候都会调用该方法，因为集群有数千个服务，因此，kube-proxy在反复调用该函数创建大量临时对象</li></ul></li><li><p>修复方法</p><p>函数调用提取到循环外</p><p>GitHub参考地址：<a href="https://github.com/kubernetes/kubernetes/pull/79444">点击跳转</a></p></li></ul><h5 id="9-4-案例4：线程池耗尽"><a href="#9-4-案例4：线程池耗尽" class="headerlink" title="9.4 案例4：线程池耗尽"></a><font color=DarkOrange>9.4 案例4：线程池耗尽</font></h5><ul><li><p>问题描述</p><p>在 Kubernetes 中有一个控制器，叫做 endpoint controller，该控制器符合生产者消费者模式，默认有5 个 worker 线程作为消费者。该消费者在处理请求时，可能调用的 LBaaS 的 API 更新负载均衡配置。我们 发现该控制器会时不时不工作，具体表现为，该做的配置变更没发生，相关日志也不打印了</p></li><li><p>根因分析</p><p>通过 pprof 打印出该进程的所有 go routine 信息，发现 worker 线程都卡在 http 请求调用处</p><p>当worker线程调用 LBaaS API 时，底层是 net&#x2F;http 包调用，而客户端在发起连接请求时，未设置客户端 超时时间。这导致当出现某些网络异常时，客户端会永远处于等待状态</p></li><li><p>解决方法</p><p>修改代码加入客户端超时控制</p></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Go语言进阶知识整理&lt;/p&gt;
&lt;h4 id=&quot;1-线程加锁&quot;&gt;&lt;a href=&quot;#1-线程加锁&quot; class=&quot;headerlink&quot; title=&quot;1. 线程加锁&quot;&gt;&lt;/a&gt;&lt;font color=DarkOrange&gt;1. 线程加锁&lt;/font&gt;&lt;/h4&gt;&lt;h5 id=</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    <category term="Go" scheme="https://huajun-chen.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>云原生01-Go语言特性</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F01-Go%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F01-Go%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/</id>
    <published>2022-11-08T02:00:00.000Z</published>
    <updated>2022-11-24T08:53:19.907Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言基础知识整理</p><h4 id="1-为什么需要另Go语言"><a href="#1-为什么需要另Go语言" class="headerlink" title="1. 为什么需要另Go语言"></a><font color=DarkOrange>1. 为什么需要另Go语言</font></h4><ul><li>其他编程语言的弊端<ul><li>硬件发展速度远远超过软件</li><li>C 语言等原生语言缺乏好的依赖管理 (依赖头文件）</li><li>Java 和 C++ 等语言过于笨重</li><li>系统语言对垃圾回收和并行计算等基础功能缺乏支持</li><li>对多核计算机缺乏支持</li></ul></li><li>Go 语言是一个可以编译高效，支持高并发的，面向垃圾回收的全新语言<ul><li>秒级完成大型程序的单节点编译</li><li>依赖管理清晰</li><li>不支持继承，程序员无需花费精力定义不同类型之间的关系</li><li>支持垃圾回收，支持并发执行，支持多线程通讯</li><li>对多核计算机支持友好</li></ul></li></ul><h5 id="1-1-Go-语言不支持的特性"><a href="#1-1-Go-语言不支持的特性" class="headerlink" title="1.1 Go 语言不支持的特性"></a><font color=DarkOrange>1.1 Go 语言不支持的特性</font></h5><ul><li>不支持函数重载和操作符重载</li><li>为了避免在 C&#x2F;C++ 开发中的一些 Bug 和混乱，不支持隐式转换</li><li>支持接口抽象，不支持继承</li><li>不支持动态加载代码</li><li>不支持动态链接库</li><li>通过 recover 和 panic 来替代异常机制</li><li>不支持断言</li><li>不支持静态变量</li></ul><h5 id="1-2-Go-语言特性衍生来源"><a href="#1-2-Go-语言特性衍生来源" class="headerlink" title="1.2 Go 语言特性衍生来源"></a><font color=DarkOrange>1.2 Go 语言特性衍生来源</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8aliy8674j31ey0pc11z.jpg" alt="image.png" style="zoom:45%;" /></div><h4 id="2-Go-语言编译环境设置"><a href="#2-Go-语言编译环境设置" class="headerlink" title="2. Go 语言编译环境设置"></a><font color=DarkOrange>2. Go 语言编译环境设置</font></h4><h5 id="2-1-下载-Go"><a href="#2-1-下载-Go" class="headerlink" title="2.1 下载 Go"></a><font color=DarkOrange>2.1 下载 Go</font></h5><ul><li>Go 安装文件以及源代码<ul><li>链接：<a href="https://golang.google.cn/dl/">点击跳转</a></li></ul></li><li>下载对应平台的二进制文件并安装</li><li>环境变量<ul><li>GOROOT<ul><li>go的安装目录</li></ul></li><li>GOPATH<ul><li>src：存放源代码</li><li>pkg：存放依赖包</li><li>bin：存放可执行文件</li></ul></li><li>其他常用变量<ul><li>GOOS，GOARCH，GOPROXY</li><li>国内用户建议设置 goproxy：<code>export GOPROXY=https://goproxy.cn</code></li></ul></li></ul></li></ul><h5 id="2-2-IDE-设置（VS-Code）"><a href="#2-2-IDE-设置（VS-Code）" class="headerlink" title="2.2 IDE 设置（VS Code）"></a><font color=DarkOrange>2.2 IDE 设置（VS Code）</font></h5><ul><li>下载并安装 Visual Studio Code<ul><li>VSCode：<a href="https://code.visualstudio.com/download">点击跳转</a></li></ul></li><li>安装 Go 语言插件<ul><li>插件：<a href="https://marketplace.visualstudio.com/items?itemName=golang.go">点击跳转</a></li></ul></li><li>其他可选项<ul><li>Intellj goland，收费软件，<a href="https://www.jetbrains.com/go/download/#section=mac">点击跳转</a></li><li>vim，sublime等</li></ul></li></ul><h5 id="2-3-一些基本命令"><a href="#2-3-一些基本命令" class="headerlink" title="2.3 一些基本命令"></a><font color=DarkOrange>2.3 一些基本命令</font></h5><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>bug</td><td>start a bug report</td></tr><tr><td>build</td><td>compile packages and dependencies</td></tr><tr><td>clean</td><td>remove object files and cached files</td></tr><tr><td>doc</td><td>show documentation for package or symbol</td></tr><tr><td>env</td><td>print Go environment information</td></tr><tr><td>fix</td><td>update packages to use new APIs</td></tr><tr><td>fmt</td><td>gofmt (reformat) package sources</td></tr><tr><td>generate</td><td>generate Go files by processing source</td></tr><tr><td>get</td><td>add dependencies to current module and install them</td></tr><tr><td>install</td><td>compile and install packages and dependencies</td></tr><tr><td>list</td><td>list packages or modules</td></tr><tr><td>mod</td><td>module maintenance</td></tr><tr><td>run</td><td>compile and run Go program</td></tr><tr><td>test</td><td>test packages</td></tr><tr><td>tool</td><td>run specified go tool</td></tr><tr><td>version</td><td>print Go version</td></tr><tr><td>vet</td><td>report likely mistakes in packages</td></tr></tbody></table><h5 id="2-4-Go-build"><a href="#2-4-Go-build" class="headerlink" title="2.4 Go build"></a><font color=DarkOrange>2.4 Go build</font></h5><ul><li>Go 语言不支持动态链接，因此编译时会将所有依赖编译进同一个二进制文件</li><li>指定输出目录<ul><li>go build –o bin&#x2F;mybinary</li></ul></li><li>常用环境变量设置编译操作系统和 CPU 架构<ul><li>GOOS&#x3D;linux GOARCH&#x3D;amd64 go build</li></ul></li><li>全支持列表<ul><li>$GOROOT&#x2F;src&#x2F;go&#x2F;build&#x2F;syslist.go</li></ul></li></ul><h5 id="2-6-Go-test"><a href="#2-6-Go-test" class="headerlink" title="2.6 Go test"></a><font color=DarkOrange>2.6 Go test</font></h5><p>Go 语言原生自带测试</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestIncrease</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">t.Log(<span class="string">&quot;Start testing&quot;</span>)</span><br><span class="line">increase(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go test .&#x2F;… -v 运行测试</p><p>go test 命令扫描所有*_test.go为结尾的文件，惯例是将测试代码与正式代码放在同目录， 如 foo.go 的测试代码一般写在 foo_test.go</p><h5 id="2-7-Go-vet"><a href="#2-7-Go-vet" class="headerlink" title="2.7 Go vet"></a><font color=DarkOrange>2.7 Go vet</font></h5><p>代码静态检查，发现可能的 bug 或者可疑的构造</p><ul><li><p>Print-format 错误，检查类型不匹配的print</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str := “hello world!”</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, str)</span><br></pre></td></tr></table></figure></li><li><p>Boolean 错误，检查一直为 true、false 或者冗余的表达式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(i != <span class="number">0</span> || i != <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>Range 循环，比如如下代码主协程会先退出，go routine无法被执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">words := []<span class="type">string</span>&#123;<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, word := <span class="keyword">range</span> words &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(word)</span><br><span class="line">  &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Unreachable的代码，如 return 之后的代码</p></li><li><p>其他错误，比如变量自赋值，error 检查滞后等</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">res, err := http.Get(<span class="string">&quot;https://www.spreadsheetdb.io/&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> res.Body.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-8-代码版本控制"><a href="#2-8-代码版本控制" class="headerlink" title="2.8 代码版本控制"></a><font color=DarkOrange>2.8 代码版本控制</font></h5><ul><li>下载并安装 Git Command Line<ul><li>Git，<a href="https://git-scm.com/downloads">点击跳转</a></li></ul></li><li>Github<ul><li>代码仓库</li></ul></li><li>创建代码目录<ul><li>mkdir –p $GOPATH&#x2F;src&#x2F;github.com&#x2F;cncamp</li><li>cd $GOPATH&#x2F;src&#x2F;github.com&#x2F;cncamp</li></ul></li><li>代码下载</li><li>修改代码</li><li>上传代码<ul><li>git add filename</li><li>git commit –m ‘change logs’</li><li>git push</li></ul></li></ul><h5 id="2-9-Golang-playground"><a href="#2-9-Golang-playground" class="headerlink" title="2.9 Golang playground"></a><font color=DarkOrange>2.9 Golang playground</font></h5><ul><li>官方 playground，<a href="https://play.golang.org/">点击跳转</a></li><li><strong>推荐：</strong> 国内可直接访问的 playground，<a href="https://goplay.tools/">点击跳转</a></li></ul><p>可直接编写和运行 Go 语言程序</p><h4 id="3-控制结构"><a href="#3-控制结构" class="headerlink" title="3. 控制结构"></a><font color=DarkOrange>3. 控制结构</font></h4><h5 id="3-1-if"><a href="#3-1-if" class="headerlink" title="3.1 if"></a><font color=DarkOrange>3.1 if</font></h5><ul><li><p>基本形式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1 &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> condition2 &#123;</span><br><span class="line">  <span class="comment">// do something else</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// catch-all or default</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>if 的简短语句</p><ul><li>for 一样， if 语句可以在条件表达式前执行一个简单的语句</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v := x - <span class="number">100</span>; v &lt; <span class="number">0</span>&#123;</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-2-switch"><a href="#3-2-switch" class="headerlink" title="3.2 switch"></a><font color=DarkOrange>3.2 switch</font></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> var1 &#123;</span><br><span class="line">  <span class="keyword">case</span> val1: <span class="comment">//空分支</span></span><br><span class="line">  <span class="keyword">case</span> val2:</span><br><span class="line">  <span class="keyword">fallthrough</span> <span class="comment">//执行case3中的f()</span></span><br><span class="line">  <span class="keyword">case</span> val3:</span><br><span class="line">  f()</span><br><span class="line">  <span class="keyword">default</span>: <span class="comment">//默认分支</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-for"><a href="#3-3-for" class="headerlink" title="3.3 for"></a><font color=DarkOrange>3.3 for</font></h5><p>Go 只有一种循环结构：for 循环</p><ul><li><p>计入计数器的循环</p><ul><li>for 初始化语句; 条件语句; 修饰语句 {}</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">sum += i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化语句和后置语句是可选的，此场景与 while 等价（Go 语言不支持 while）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>; &#123;</span><br><span class="line">sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>无限循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> condition1 &#123;</span><br><span class="line">  <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-4-for-range"><a href="#3-4-for-range" class="headerlink" title="3.4 for-range"></a><font color=DarkOrange>3.4 for-range</font></h5><p>遍历数组，切片，字符串，Map 等</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index, char := <span class="keyword">range</span> myString &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> MyMap &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> MyArray &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意：如果 for range 遍历指针数组，则 value 取出的指 针地址为原指针地址的拷贝</strong></p><h4 id="4-Go-语言常用数据结构"><a href="#4-Go-语言常用数据结构" class="headerlink" title="4. Go 语言常用数据结构"></a><font color=DarkOrange>4. Go 语言常用数据结构</font></h4><h5 id="4-1-变量与常量"><a href="#4-1-变量与常量" class="headerlink" title="4.1 变量与常量"></a><font color=DarkOrange>4.1 变量与常量</font></h5><ul><li>常量<ul><li>const identifier type</li></ul></li><li>变量<ul><li>var identifier type</li></ul></li></ul><h5 id="4-2-变量定义"><a href="#4-2-变量定义" class="headerlink" title="4.2 变量定义"></a><font color=DarkOrange>4.2 变量定义</font></h5><ul><li>变量<ul><li>var 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后</li><li>var c, python, java bool</li></ul></li><li>变量的初始化<ul><li>变量声明可以包含初始值，每个变量对应一个</li><li>如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型</li><li>var i, j int &#x3D; 1, 2</li></ul></li><li>短变量声明<ul><li>在函数中，简洁赋值语句 :&#x3D; 可在类型明确的地方代替 var 声明</li><li>函数外的每个语句都必须以关键字开始（var, func 等等），<strong>因此 :&#x3D; 结构不能在函数外使用</strong></li><li>c, python, java :&#x3D; true, false, “no!”</li></ul></li></ul><h5 id="4-3-类型转换与推导"><a href="#4-3-类型转换与推导" class="headerlink" title="4.3 类型转换与推导"></a><font color=DarkOrange>4.3 类型转换与推导</font></h5><ul><li>类型转换<ul><li>表达式 T(v) 将值 v 转换为类型 T<ul><li>一些关于数值的转换：<ul><li>var i int &#x3D; 42</li><li>var f float64 &#x3D; float64(i) </li><li>var u uint &#x3D; uint(f)</li></ul></li><li>或者，更加简单的形式：<ul><li>i :&#x3D; 42 </li><li>f :&#x3D; float64(i)</li><li>u :&#x3D; uint(f)</li></ul></li></ul></li></ul></li><li>类型推导<ul><li>在声明一个变量而不指定其类型时（即使用不带类型的 :&#x3D; 语法或 var &#x3D; 表达式语法），变量的类型由右值推导得出<ul><li>var i int </li><li>j :&#x3D; i &#x2F;&#x2F; j 也是一个 int</li></ul></li></ul></li></ul><h5 id="4-4-数组"><a href="#4-4-数组" class="headerlink" title="4.4 数组"></a><font color=DarkOrange>4.4 数组</font></h5><ul><li>相同类型且长度固定连续内存片段</li><li>以编号访问每个元素</li><li>定义方法<ul><li>var identifier [len]type</li></ul></li><li>示例<ul><li>myArray :&#x3D; [3]int{1,2,3}</li></ul></li></ul><h5 id="4-5-切片-slice"><a href="#4-5-切片-slice" class="headerlink" title="4.5 切片(slice)"></a><font color=DarkOrange>4.5 切片(slice)</font></h5><ul><li><p>切片是对数组一个连续片段的引用</p></li><li><p>数组定义中不指定长度即为切片</p><ul><li>var identifier []type</li></ul></li><li><p>切片在未初始化之前默认为nil， 长度为0</p></li><li><p>常用方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  myArray := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">  mySlice := myArray[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">  fmt.Printf(<span class="string">&quot;mySlice %+v\n&quot;</span>, mySlice)</span><br><span class="line">  fullSlice := myArray[:]</span><br><span class="line">  remove3rdItem := deleteItem(fullSlice, <span class="number">2</span>)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;remove3rdItem %+v\n&quot;</span>, remove3rdItem)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteItem</span><span class="params">(slice []<span class="type">int</span>, index <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">append</span>(slice[:index], slice[index+<span class="number">1</span>:]...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="4-6-make和new"><a href="#4-6-make和new" class="headerlink" title="4.6 make和new"></a><font color=DarkOrange>4.6 make和new</font></h5><ul><li><p>new 返回指针地址</p></li><li><p>make 返回第一个元素，可预设内存空间，避免未来的内存拷贝</p></li><li><p>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mySlice1 := <span class="built_in">new</span>([]<span class="type">int</span>)</span><br><span class="line">mySlice2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">mySlice3 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">mySlice4 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8au3yhk17j30rc08c0wm.jpg" alt="image.png" style="zoom: 50%;" /></li></ul><h5 id="4-7-关于切片的常见问题"><a href="#4-7-关于切片的常见问题" class="headerlink" title="4.7 关于切片的常见问题"></a><font color=DarkOrange>4.7 关于切片的常见问题</font></h5><ul><li><p>切片是连续内存并且可以动态扩展，由此引发的问题？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := []<span class="type">int</span></span><br><span class="line">b := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">c := a</span><br><span class="line">a = <span class="built_in">append</span>(b, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>修改切片的值？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mySlice := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> mySlice &#123;</span><br><span class="line">value *= <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;mySlice %+v\n&quot;</span>, mySlice)</span><br><span class="line"><span class="keyword">for</span> index, _ := <span class="keyword">range</span> mySlice &#123;</span><br><span class="line">mySlice[index] *= <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;mySlice %+v\n&quot;</span>, mySlice)</span><br></pre></td></tr></table></figure></li></ul><h5 id="4-8-Map"><a href="#4-8-Map" class="headerlink" title="4.8 Map"></a><font color=DarkOrange>4.8 Map</font></h5><ul><li><p>声明方法</p><ul><li>var map1 map[keytype]valuetype</li></ul></li><li><p>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">myMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">10</span>)</span><br><span class="line">myMap[<span class="string">&quot;a&quot;</span>] = <span class="string">&quot;b&quot;</span></span><br><span class="line">myFuncMap := <span class="keyword">map</span>[<span class="type">string</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span>&#123;</span><br><span class="line"><span class="string">&quot;funcA&quot;</span>: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(myFuncMap)</span><br><span class="line">f := myFuncMap[<span class="string">&quot;funcA&quot;</span>]</span><br><span class="line">fmt.Println(f())</span><br></pre></td></tr></table></figure></li></ul><h5 id="4-9-访问-Map-元素"><a href="#4-9-访问-Map-元素" class="headerlink" title="4.9 访问 Map 元素"></a><font color=DarkOrange>4.9 访问 Map 元素</font></h5><ul><li><p>按 Key 取值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value, exists := myMap[<span class="string">&quot;a&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> exists &#123;</span><br><span class="line"><span class="built_in">println</span>(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>遍历 Map</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> myMap &#123;</span><br><span class="line"><span class="built_in">println</span>(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="4-10-结构体和指针"><a href="#4-10-结构体和指针" class="headerlink" title="4.10 结构体和指针"></a><font color=DarkOrange>4.10 结构体和指针</font></h5><ul><li>通过 type … struct 关键字自定义结构体</li><li>Go 语言支持指针，但不支持指针运算<ul><li>指针变量的值为内存地址</li><li>未赋值的指针为 nil</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyType <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMyType</span><span class="params">(t *MyType)</span></span>&#123;</span><br><span class="line"><span class="built_in">println</span>(t.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  t := MyType&#123;Name: <span class="string">&quot;test&quot;</span>&#125;</span><br><span class="line">  printMyType(&amp;t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-11-结构体标签"><a href="#4-11-结构体标签" class="headerlink" title="4.11 结构体标签"></a><font color=DarkOrange>4.11 结构体标签</font></h5><ul><li>结构体中的字段除了有名字和类型外，还可以有一个可选的标签（tag）</li><li>使用场景：Kubernetes APIServer 对所有资源的定义都用 Json tag 和 protoBuff tag<ul><li>NodeName string <code>json:&quot;nodeName,omitempty&quot; protobuf:&quot;bytes,10,opt,name=nodeName&quot;</code></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyType <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  mt := MyType&#123;Name: <span class="string">&quot;test&quot;</span>&#125;</span><br><span class="line">  myType := reflect.TypeOf(mt)</span><br><span class="line">  name := myType.Field(<span class="number">0</span>)</span><br><span class="line">  tag := name.Tag.Get(<span class="string">&quot;json&quot;</span>)</span><br><span class="line">  <span class="built_in">println</span>(tag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-12-类型别名"><a href="#4-12-类型别名" class="headerlink" title="4.12 类型别名"></a><font color=DarkOrange>4.12 类型别名</font></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Service Type string describes ingress methods for a service</span></span><br><span class="line"><span class="keyword">type</span> ServiceType <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  <span class="comment">// ServiceTypeClusterIP means a service will only be accessible inside the</span></span><br><span class="line">  <span class="comment">// cluster, via the ClusterIP.</span></span><br><span class="line">  ServiceTypeClusterIP ServiceType = <span class="string">&quot;ClusterIP&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ServiceTypeNodePort means a service will be exposed on one port of</span></span><br><span class="line">  <span class="comment">// every node, in addition to &#x27;ClusterIP&#x27; type.</span></span><br><span class="line">  ServiceTypeNodePort ServiceType = <span class="string">&quot;NodePort&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ServiceTypeLoadBalancer means a service will be exposed via an</span></span><br><span class="line">  <span class="comment">// external load balancer (if the cloud provider supports it), in addition</span></span><br><span class="line">  <span class="comment">// to &#x27;NodePort&#x27; type.</span></span><br><span class="line">  ServiceTypeLoadBalancer ServiceType = <span class="string">&quot;LoadBalancer&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ServiceTypeExternalName means a service consists of only a reference to</span></span><br><span class="line">  <span class="comment">// an external name that kubedns or equivalent will return as a CNAME</span></span><br><span class="line">  <span class="comment">// record, with no exposing or proxying of any pods involved.</span></span><br><span class="line">  ServiceTypeExternalName ServiceType = <span class="string">&quot;ExternalName&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="5-Go-语言函数调用"><a href="#5-Go-语言函数调用" class="headerlink" title="5. Go 语言函数调用"></a><font color=DarkOrange>5. Go 语言函数调用</font></h4><h5 id="5-1-main函数"><a href="#5-1-main函数" class="headerlink" title="5.1 main函数"></a><font color=DarkOrange>5.1 main函数</font></h5><ul><li>每个 Go 语言程序都应该有个 main package</li><li>Main package 里的 main 函数是 Go 语言程序入口</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  args := os.Args</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;Do not accept any argument&quot;</span>)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-2-参数解析"><a href="#5-2-参数解析" class="headerlink" title="5.2 参数解析"></a><font color=DarkOrange>5.2 参数解析</font></h5><ul><li>请注意 main 函数与其他语言不同，没有类似 java 的 []string args 参数</li><li>Go 语言如何传入参数呢？<ul><li>方法1：<ul><li>fmt.Println(“os args is:”, os.Args)</li></ul></li><li>方法2：<ul><li>name :&#x3D; flag.String(“name”, “world”, “specify the name you want to say hi”)</li><li>flag.Parse()</li></ul></li></ul></li></ul><h5 id="5-3-init函数"><a href="#5-3-init函数" class="headerlink" title="5.3 init函数"></a><font color=DarkOrange>5.3 init函数</font></h5><ul><li>init 函数：会在包初始化时运行</li><li>谨慎使用 init 函数<ul><li>当多个依赖项目引用统一项目，且被引用项目的初始化在 init 中完成，并且不可重复运行时，会导 致启动错误</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myVariable = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">myVariable = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-4-返回值"><a href="#5-4-返回值" class="headerlink" title="5.4 返回值"></a><font color=DarkOrange>5.4 返回值</font></h5><ul><li>多值返回<ul><li>函数可以返回任意数量的返回值</li></ul></li><li>命名返回值<ul><li>Go 的返回值可被命名，它们会被视作定义在函数顶部的变量</li><li>返回值的名称应当具有一定的意义，它可以作为文档使用</li><li>没有参数的 return 语句返回已命名的返回值。也就是直接返回</li></ul></li><li>调用者忽略部分返回值<ul><li>result, _ &#x3D; strconv.Atoi(origStr)</li></ul></li></ul><h5 id="5-5-传递变长参数"><a href="#5-5-传递变长参数" class="headerlink" title="5.5 传递变长参数"></a><font color=DarkOrange>5.5 传递变长参数</font></h5><p>Go 语言中的可变长参数允许调用方传递任意多个相同类型的参数</p><ul><li><p>函数定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(slice []Type, elems ...Type)</span></span> []Type</span><br></pre></td></tr></table></figure></li><li><p>调用方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myArray := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">myArray = <span class="built_in">append</span>(myArray, <span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h5 id="5-6-内置函数"><a href="#5-6-内置函数" class="headerlink" title="5.6 内置函数"></a><font color=DarkOrange>5.6 内置函数</font></h5><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>close</td><td>管道关闭</td></tr><tr><td>len, cap</td><td>返回数组、切片，Map 的长度或容量</td></tr><tr><td>new, make</td><td>内存分配</td></tr><tr><td>copy, append</td><td>操作切片</td></tr><tr><td>panic, recover</td><td>错误处理</td></tr><tr><td>print, println</td><td>打印</td></tr><tr><td>complex, real, imag</td><td>操作复数</td></tr></tbody></table><h5 id="5-7-回调函数-Callback"><a href="#5-7-回调函数-Callback" class="headerlink" title="5.7 回调函数(Callback)"></a><font color=DarkOrange>5.7 回调函数(Callback)</font></h5><p>函数作为参数传入其它函数，并在其他函数内部调用执行</p><ul><li>strings.IndexFunc(line, unicode.IsSpace)</li><li>Kubernetes controller的leaderelection</li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  DoOperation(<span class="number">1</span>, increase)</span><br><span class="line">  DoOperation(<span class="number">1</span>, decrease)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increase</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(“increase result is:”, a+b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoOperation</span><span class="params">(y <span class="type">int</span>, f <span class="keyword">func</span>(<span class="type">int</span>, <span class="type">int</span>)</span></span>) &#123;</span><br><span class="line">f(y, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decrease</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;decrease result is:&quot;</span>, a-b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-8-闭包"><a href="#5-8-闭包" class="headerlink" title="5.8 闭包"></a><font color=DarkOrange>5.8 闭包</font></h5><p>匿名函数</p><ul><li><p>不能独立存在</p></li><li><p>可以赋值给其他变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x:= <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以直接调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(x,y <span class="type">int</span>)</span></span>&#123;<span class="built_in">println</span>(x+y)&#125;(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li><li><p>可作为函数返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">()</span></span> (<span class="function"><span class="keyword">func</span><span class="params">(b <span class="type">int</span>)</span></span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure></li><li><p>使用场景</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">println</span>(“recovered in FuncX”)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></li></ul><h5 id="5-9-方法"><a href="#5-9-方法" class="headerlink" title="5.9 方法"></a><font color=DarkOrange>5.9 方法</font></h5><ul><li><p>方法：作用在接收者上的函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">• <span class="function"><span class="keyword">func</span> <span class="params">(recv receiver_type)</span></span> methodName(parameter_list) (return_value_list)</span><br></pre></td></tr></table></figure></li><li><p>使用场景</p><ul><li>很多场景下，函数需要的上下文可以保存在receiver属性中，通过定义 receiver 的方法，该方法可以直接 访问 receiver 属性，减少参数传递需求</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StartTLS starts TLS on a server from NewUnstartedServer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> StartTLS() &#123;</span><br><span class="line">  <span class="keyword">if</span> s.URL != “” &#123;</span><br><span class="line">  <span class="built_in">panic</span>(“Server already started”)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.client == <span class="literal">nil</span> &#123;</span><br><span class="line">  s.client = &amp;http.Client&#123;Transport: &amp;http.Transport&#123;&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="5-10-传值还是传指针"><a href="#5-10-传值还是传指针" class="headerlink" title="5.10 传值还是传指针"></a><font color=DarkOrange>5.10 传值还是传指针</font></h5><ul><li>Go 语言只有一种规则-传值</li><li>函数内修改参数的值不会影响函数外原始变量的值</li><li>可以传递指针参数将变量地址传递给调用函数，Go 语言会复制该指针作为函数内的地址，但指向同一地址</li></ul><p><strong>思考：当我们写代码的时候，函数的参数传递应该用struct 还是pointer？</strong></p><h5 id="5-11-接口"><a href="#5-11-接口" class="headerlink" title="5.11 接口"></a><font color=DarkOrange>5.11 接口</font></h5><ul><li><p>接口定义一组方法集合</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IF <span class="keyword">interface</span> &#123;</span><br><span class="line">Method1(param_list) return_type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>适用场景：Kubernetes 中有大量的接口抽象和多种实现</p></li><li><p>Struct 无需显示声明实现 interface，只需直接实现方法</p></li><li><p>Struct 除实现 interface 定义的接口外，还可以有额外的方法</p></li><li><p>一个类型可实现多个接口（Go 语言的多重继承）</p></li><li><p>Go 语言中接口不接受属性定义</p></li><li><p>接口可以嵌套其他接口</p></li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IF <span class="keyword">interface</span> &#123;</span><br><span class="line">getName() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">firstName, lastName <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> getName() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> h.firstName + <span class="string">&quot;,&quot;</span> + h.lastName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">factory, model <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Car)</span></span> getName() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.factory + <span class="string">&quot;-&quot;</span> + c.model</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  interfaces := []IF&#123;&#125;</span><br><span class="line">  h := <span class="built_in">new</span>(Human)</span><br><span class="line">  h.firstName = <span class="string">&quot;first&quot;</span></span><br><span class="line">  h.lastName = <span class="string">&quot;last&quot;</span></span><br><span class="line">  interfaces = <span class="built_in">append</span>(interfaces, h)</span><br><span class="line">  c := <span class="built_in">new</span>(Car)</span><br><span class="line">  c.factory = <span class="string">&quot;benz&quot;</span></span><br><span class="line">  c.model = <span class="string">&quot;s&quot;</span></span><br><span class="line">  interfaces = <span class="built_in">append</span>(interfaces, c)</span><br><span class="line">  <span class="keyword">for</span> _, f := <span class="keyword">range</span> interfaces &#123;</span><br><span class="line">  fmt.Println(f.getName())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>Interface 是可能为 nil 的，所以针对 interface 的使用一定要预 先判空，否则会引起程序 crash(nil panic)</li><li>Struct 初始化意味着空间分配，对 struct 的引用不会出现空指针</li></ul><h5 id="5-12-反射机制"><a href="#5-12-反射机制" class="headerlink" title="5.12 反射机制"></a><font color=DarkOrange>5.12 反射机制</font></h5><ul><li>reflect.TypeOf ()返回被检查对象的类型</li><li>reflect.ValueOf()返回被检查对象的值</li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">10</span>)</span><br><span class="line">myMap[<span class="string">&quot;a&quot;</span>] = <span class="string">&quot;b&quot;</span></span><br><span class="line">t := reflect.TypeOf(myMap)</span><br><span class="line">fmt.Println(<span class="string">&quot;type:&quot;</span>, t)</span><br><span class="line">v := reflect.ValueOf(myMap)</span><br><span class="line">fmt.Println(<span class="string">&quot;value:&quot;</span>, v)</span><br></pre></td></tr></table></figure><h5 id="5-13-基于struct的反射"><a href="#5-13-基于struct的反射" class="headerlink" title="5.13 基于struct的反射"></a><font color=DarkOrange>5.13 基于struct的反射</font></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// struct</span></span><br><span class="line">myStruct := T&#123;A: <span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line">v1 := reflect.ValueOf(myStruct)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v1.NumField(); i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Field %d: %v\n&quot;</span>, i, v1.Field(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v1.NumMethod(); i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Method %d: %v\n&quot;</span>, i, v1.Method(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要注意 receive 是 struct 还是指针</span></span><br><span class="line">result := v1.Method(<span class="number">0</span>).Call(<span class="literal">nil</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;result:&quot;</span>, result)</span><br></pre></td></tr></table></figure><h5 id="5-14-Go语言中的面向对象编程"><a href="#5-14-Go语言中的面向对象编程" class="headerlink" title="5.14 Go语言中的面向对象编程"></a><font color=DarkOrange>5.14 Go语言中的面向对象编程</font></h5><ul><li>可见性控制<ul><li>public - 常量、变量、类型、接口、结构、函数等的名称大写</li><li>private - 非大写就只能在包内使用</li></ul></li><li>继承<ul><li>通过组合实现，内嵌一个或多个 struct</li></ul></li><li>多态<ul><li>通过接口实现，通过接口定义方法集，编写多套实现</li></ul></li></ul><h5 id="5-15-json编解码"><a href="#5-15-json编解码" class="headerlink" title="5.15 json编解码"></a><font color=DarkOrange>5.15 json编解码</font></h5><ul><li><p>Unmarshal: 从 string 转换至 struct</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unmarshal2Struct</span><span class="params">(humanStr <span class="type">string</span>)</span></span>Human &#123;</span><br><span class="line">  h := Human&#123;&#125;</span><br><span class="line">  err := json.Unmarshal([]<span class="type">byte</span>(humanStr), &amp;h)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">println</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Marshal: 从 struct 转换至 string</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">marshal2JsonString</span><span class="params">(h Human)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  h.Age = <span class="number">30</span></span><br><span class="line">  updatedBytes, err := json.Marshal(&amp;h)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">println</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">string</span>(updatedBytes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>json 包使用 map[string]interface{} 和 []interface{} 类型保存任意对象</p></li><li><p>可通过如下逻辑解析任意 json</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">err := json.Unmarshal([]<span class="type">byte</span>(humanStr), &amp;obj)</span><br><span class="line">objMap, ok := obj.(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> objMap &#123;</span><br><span class="line">  <span class="keyword">switch</span> value := v.(<span class="keyword">type</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">  fmt.Printf(<span class="string">&quot;type of %s is string, value is %v\n&quot;</span>, k, value)</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line">  fmt.Printf(<span class="string">&quot;type of %s is interface&#123;&#125;, value is %v\n&quot;</span>, k, value)</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  fmt.Printf(<span class="string">&quot;type of %s is wrong, value is %v\n&quot;</span>, k, value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-常用语法"><a href="#6-常用语法" class="headerlink" title="6. 常用语法"></a><font color=DarkOrange>6. 常用语法</font></h4><h5 id="6-1-错误处理"><a href="#6-1-错误处理" class="headerlink" title="6.1 错误处理"></a><font color=DarkOrange>6.1 错误处理</font></h5><ul><li><p>Go 语言无内置 exceptio 机制，只提供 error 接口供定义错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可通过 errors.New 或 fmt.Errorf 创建新的 error</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> errNotFound <span class="type">error</span> = errors.New(<span class="string">&quot;NotFound&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>通常应用程序对 error 的处理大部分是判断 error 是否为 nil</p></li></ul><p>如需将 error 归类，通常交给应用程序自定义，比如 kubernetes 自定义了与 apiserver 交互的不同类型错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StatusError <span class="keyword">struct</span> &#123;</span><br><span class="line">ErrStatus metav1.Status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ <span class="type">error</span> = &amp;StatusError&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error implements the Error interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *StatusError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> e.ErrStatus.Message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-2-defer"><a href="#6-2-defer" class="headerlink" title="6.2 defer"></a><font color=DarkOrange>6.2 defer</font></h5><ul><li>函数返回之前执行某个语句或函数</li><li>常见的 defer 使用场景：记得关闭你打开的资源<ul><li>defer file.Close()</li><li>defer mu.Unlock()</li><li>defer println(“”)</li></ul></li></ul><h5 id="6-3-panic和recover"><a href="#6-3-panic和recover" class="headerlink" title="6.3 panic和recover"></a><font color=DarkOrange>6.3 panic和recover</font></h5><ul><li>panic: 可在系统出现不可恢复错误时主动调用 panic, panic 会使当前线程直接 crash</li><li>defer: 保证执行并把控制权交还给接收到 panic 的函数调用者</li><li>recover: 函数从 panic 或 错误场景中恢复</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;defer func is called&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  fmt.Println(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;a panic is triggered&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="7-多线程"><a href="#7-多线程" class="headerlink" title="7. 多线程"></a><font color=DarkOrange>7. 多线程</font></h4><h5 id="7-1-并发和并行"><a href="#7-1-并发和并行" class="headerlink" title="7.1 并发和并行"></a><font color=DarkOrange>7.1 并发和并行</font></h5><ul><li><p>并发（concurrency）</p><ul><li>两个或多个事件在同一时间间隔发生</li></ul><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8bzcerzeej30zw02yjsm.jpg" alt="image.png" style="zoom: 50%;" /></li><li><p>并行（parallellism）</p><ul><li>两个或者多个事件在同一时刻发生</li></ul><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8bzd7setzj30zu0aadh9.jpg" alt="image.png" style="zoom: 50%;" /></li></ul><h5 id="7-2-协程"><a href="#7-2-协程" class="headerlink" title="7.2 协程"></a><font color=DarkOrange>7.2 协程</font></h5><ul><li>进程<ul><li>分配系统资源（CPU 时间、内存等）基本单位</li><li>有独立的内存空间，切换开销大</li></ul></li><li>线程<ul><li>进程的一个执行流，是 CPU 调度并能独立运行的的基本单位</li><li>同一进程中的多线程共享内存空间，线程切换代价小</li><li>多线程通信方便</li><li>从内核层面来看线程其实也是一种特殊的进程，它跟父进程共享了打开的文件和文件系统信息，共<br>享了地址空间和信号处理函数</li></ul></li><li>协程<ul><li>Go 语言中的轻量级线程实现</li><li>Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，当遇到长时间执行<br>或者进行系统调用时，会主动把当前 goroutine 的 CPU (P) 转让出去，让其他 goroutine 能被调度<br>并执行，也就是 Golang 从语言层面支持了协程</li></ul></li></ul><h5 id="7-3-CSP"><a href="#7-3-CSP" class="headerlink" title="7.3 CSP"></a><font color=DarkOrange>7.3 CSP</font></h5><ul><li><p>CSP</p><ul><li>描述两个独立的并发实体通过共享的通讯 channel 进行通信的并发模型</li></ul></li><li><p>Go 协程 goroutine</p><ul><li>是一种轻量线程，它不是操作系统的线程，而是将一个操作系统线程分段使用，通过调度器实现协<br>作式调度</li><li>是一种绿色线程，微线程，它与 Coroutine 协程也有区别，能够在发现堵塞后启动新的微线程</li></ul></li><li><p>通道 channel</p><ul><li>类似 Unix 的 Pipe，用于协程之间通讯和同步</li><li>协程之间虽然解耦，但是它们和 Channel 有着耦合</li></ul></li></ul><h5 id="7-4-线程和协程的差异"><a href="#7-4-线程和协程的差异" class="headerlink" title="7.4 线程和协程的差异"></a><font color=DarkOrange>7.4 线程和协程的差异</font></h5><ul><li><p>每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少</p><ul><li>goroutine：2KB</li><li>线程：8MB</li></ul></li><li><p>线程&#x2F;goroutine 切换开销方面，goroutine 远比线程小</p><ul><li>线程：涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP…等寄存器的刷新</li><li>goroutine：只有三个寄存器的值修改 - PC &#x2F; SP &#x2F; DX</li></ul></li><li><p>GOMAXPROCS</p><ul><li>控制并行线程数量</li></ul></li><li><p>启动新协程：go functionName()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">go</span> fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br></pre></td></tr></table></figure></li></ul><h5 id="7-5-channel-多线程通信"><a href="#7-5-channel-多线程通信" class="headerlink" title="7.5 channel-多线程通信"></a><font color=DarkOrange>7.5 channel-多线程通信</font></h5><ul><li>Channel 是多个协程之间通讯的管道<ul><li>一端发送数据，一端接收数据</li><li>同一时间只有一个协程可以访问数据，无共享内存模式可能出现的内存竞争</li><li>协调协程的执行顺序</li></ul></li><li>声明方式<ul><li><code>var identifier chan datatype</code></li><li>操作符&lt;-</li></ul></li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;hello from goroutine&quot;</span>)</span><br><span class="line">  ch &lt;- <span class="number">0</span> <span class="comment">//数据写入Channel</span></span><br><span class="line">&#125;()</span><br><span class="line">i := &lt;-ch<span class="comment">//从Channel中取数据并赋值</span></span><br></pre></td></tr></table></figure><h5 id="7-6-通道缓冲"><a href="#7-6-通道缓冲" class="headerlink" title="7.6 通道缓冲"></a><font color=DarkOrange>7.6 通道缓冲</font></h5><ul><li>基于 Channel 的通信是同步的</li><li>当缓冲区满时，数据的发送是阻塞的</li><li>通过 make 关键字创建通道时可定义缓冲区容量，默认缓冲区容量为 0</li></ul><h5 id="7-7-遍历通道缓冲区"><a href="#7-7-遍历通道缓冲区" class="headerlink" title="7.7 遍历通道缓冲区"></a><font color=DarkOrange>7.7 遍历通道缓冲区</font></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    n := rand.Intn(<span class="number">10</span>) <span class="comment">// n will be between 0 and 10</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;putting: &quot;</span>, n)</span><br><span class="line">    ch &lt;- n</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">close</span>(ch)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;hello from main&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;receiving: &quot;</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-8-单向通道"><a href="#7-8-单向通道" class="headerlink" title="7.8 单向通道"></a><font color=DarkOrange>7.8 单向通道</font></h5><ul><li><p>只发送通道</p><ul><li><code>var sendOnly chan&lt;- int</code></li></ul></li><li><p>只接收通道</p><ul><li><code>var readOnly &lt;-chan int</code></li></ul></li><li><p>Istio webhook controller</p><ul><li><code>func (w *WebhookCertPatcher) runWebhookController(stopChan &lt;-chan struct&#123;&#125;) &#123;&#125;</code></li></ul></li><li><p>如何用: 双向通道转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> prod(c)</span><br><span class="line"><span class="keyword">go</span> consume(c)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prod</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> &#123; ch &lt;- <span class="number">1</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123; &lt;-ch &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="7-9-关闭通道"><a href="#7-9-关闭通道" class="headerlink" title="7.9 关闭通道"></a><font color=DarkOrange>7.9 关闭通道</font></h5><ul><li>通道无需每次关闭</li><li>关闭的作用是告诉接收者该通道再无新数据发送</li><li>只有发送方需要关闭通道</li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(ch)</span><br><span class="line"><span class="keyword">if</span> v, notClosed := &lt;-ch; notClosed &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-10-select"><a href="#7-10-select" class="headerlink" title="7.10 select"></a><font color=DarkOrange>7.10 select</font></h5><ul><li>当多个协程同时运行时，可通过 select 轮询多个通道<ul><li>如果所有通道都阻塞则等待，如定义了 default 则执行 default</li><li>如多个通道就绪则随机选择</li></ul></li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v:= &lt;- ch1:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> v:= &lt;- ch2:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-11-定时器timer"><a href="#7-11-定时器timer" class="headerlink" title="7.11 定时器timer"></a><font color=DarkOrange>7.11 定时器timer</font></h5><ul><li>time.Ticker 以指定的时间间隔重复的向通道 C 发送时间值</li><li>使用场景<ul><li>为协程设定超时时间</li></ul></li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">timer := time.NewTimer(time.Second)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="comment">// check normal channel</span></span><br><span class="line">  <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">  fmt.Println(<span class="string">&quot;received from ch&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">  fmt.Println(<span class="string">&quot;timeout waiting from channel ch&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-12-上下文context"><a href="#7-12-上下文context" class="headerlink" title="7.12 上下文context"></a><font color=DarkOrange>7.12 上下文context</font></h5><ul><li><p>超时、取消操作或者一些异常情况，往往需要进行抢占操作或者中断后续操作</p></li><li><p>Context 是设置截止日期、同步信号，传递请求相关值的结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">Err() <span class="type">error</span></span><br><span class="line">Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用法</p><ul><li>context.Background</li><li>context.TODO</li><li>context.WithDeadline</li><li>context.WithValue</li><li>context.WithCancel</li></ul></li></ul><h5 id="7-13-如何停止一个子协程"><a href="#7-13-如何停止一个子协程" class="headerlink" title="7.13 如何停止一个子协程"></a><font color=DarkOrange>7.13 如何停止一个子协程</font></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-done:</span><br><span class="line">    fmt.Println(<span class="string">&quot;done channel is triggerred, exit child go routine&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">close</span>(done)</span><br></pre></td></tr></table></figure><h5 id="7-14-基于context停止子协程"><a href="#7-14-基于context停止子协程" class="headerlink" title="7.14 基于context停止子协程"></a><font color=DarkOrange>7.14 基于context停止子协程</font></h5><p>Context 是 Go 语言对 go routine 和 timer 的封装</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"><span class="keyword">go</span> process(ctx, <span class="number">100</span>*time.Millisecond)</span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line">fmt.Println(<span class="string">&quot;main:&quot;</span>, ctx.Err())</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Go语言基础知识整理&lt;/p&gt;
&lt;h4 id=&quot;1-为什么需要另Go语言&quot;&gt;&lt;a href=&quot;#1-为什么需要另Go语言&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么需要另Go语言&quot;&gt;&lt;/a&gt;&lt;font color=DarkOrange&gt;1. 为什么需要</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    <category term="Go" scheme="https://huajun-chen.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>云原生00-什么是云原生</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F00-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F00-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%91%E5%8E%9F%E7%94%9F/</id>
    <published>2022-11-08T01:00:00.000Z</published>
    <updated>2022-11-19T09:55:32.415Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-什么是云原生"><a href="#1-什么是云原生" class="headerlink" title="1. 什么是云原生"></a><font color=DarkOrange>1. 什么是云原生</font></h4><ul><li><p>在包括公有云、私有云、混合云等动态环境中构建和运行规模化应用的能力</p></li><li><p>云原生是一种思想，是技术、企业管理方法的集合</p><ul><li>技术层面<ul><li>应用程序从设计之初就为在云上运行而做好准备</li><li>云平台基于自动化体系</li></ul></li><li>流程层面<ul><li>基于 DevOps，CI&#x2F;CD</li></ul></li></ul></li><li><p>基于多种手段</p><ul><li>应用容器化封装</li><li>服务网格</li><li>不可变基础架构</li><li>声明式 API</li></ul></li><li><p>云原生的意义</p><ul><li>提升系统的适应性、可管理性、可观察性</li><li>使工程师能以最小成本进行频繁和可预测的系统变更</li><li>提升速度和效率，助力业务成长，缩短 I2M（Idea to Market）</li></ul></li></ul><h4 id="2-云原生核心项目概览"><a href="#2-云原生核心项目概览" class="headerlink" title="2. 云原生核心项目概览"></a><font color=DarkOrange>2. 云原生核心项目概览</font></h4><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8akra0wvmj30yk0qgdvy.jpg" alt="image.png" style="zoom:50%;" /></div><h4 id="3-kube-proxy-是干啥用的"><a href="#3-kube-proxy-是干啥用的" class="headerlink" title="3. kube-proxy 是干啥用的"></a><font color=DarkOrange>3. kube-proxy 是干啥用的</font></h4><h5 id="3-1-官方文档"><a href="#3-1-官方文档" class="headerlink" title="3.1 官方文档"></a><font color=DarkOrange>3.1 官方文档</font></h5><p>官方文档：<a href="https://kubernetes.io/docs/concepts/overview/components/">点击跳转</a></p><p>kube-proxy uses the operating system packet filtering layer if there is one and it’s available. Otherwise, kube-proxy forwards the traffic itself.</p><h5 id="3-2-看看前人是怎么解读的"><a href="#3-2-看看前人是怎么解读的" class="headerlink" title="3.2 看看前人是怎么解读的"></a><font color=DarkOrange>3.2 看看前人是怎么解读的</font></h5><p>搜中文文档，知乎，CSDN，简书都有比较高质量的文章，可以多看一些文档，并理解不同人 的理解差异</p><p>知乎：<a href="https://zhuanlan.zhihu.com/p/337806843">点击跳转</a></p><p>中文世界Kubernetes非常活跃，不少文档质量超过英文。但中文搬运转载问题比较严重，需要自己甄别</p><h5 id="3-3-找关键知识点"><a href="#3-3-找关键知识点" class="headerlink" title="3.3 找关键知识点"></a><font color=DarkOrange>3.3 找关键知识点</font></h5><ul><li>先对大概的框架有认识</li><li>kube-proxy 监听 API server 中 资源对象的变化情况，包括以下三种：<ul><li>service</li><li>endpoint&#x2F;endpointslices</li><li>node</li></ul></li><li>目前 Kube-proxy 支持4中代理模式：<ul><li>userspace</li><li>iptables</li><li>ipvs</li><li>kernelspace（windows）</li></ul></li></ul><h5 id="3-4-由点到面稍稍展开一下"><a href="#3-4-由点到面稍稍展开一下" class="headerlink" title="3.4 由点到面稍稍展开一下"></a><font color=DarkOrange>3.4 由点到面稍稍展开一下</font></h5><p>由浅入深的理解，成为专家</p><ul><li>入门：可以使用，知道怎么用，大概做了什么</li><li>初级：粗略理解配置方法</li><li>高级：理解不同模式的差异，理解为什么要有多种模式，理解配置细节</li><li>专家级：理解完整的内核协议栈处理数据包的流程，能够举一反三</li></ul><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8akygl1nyj31qi0fe46c.jpg" alt="image.png" style="zoom:67%;" /></div><h4 id="4-如何学习云原生技术"><a href="#4-如何学习云原生技术" class="headerlink" title="4. 如何学习云原生技术"></a><font color=DarkOrange>4. 如何学习云原生技术</font></h4><ul><li><p>代码驱动</p><ul><li>掌握 Go 语言编程能力</li></ul></li><li><p>从点到面</p><ul><li>cgroup、namespace</li><li>网络协议栈</li><li>文件系统</li></ul></li><li><p>抓住核心掌控全局</p><ul><li>深入理解 Kubernetes<ul><li>API 定义</li><li>控制器模式</li><li>核心组件</li></ul></li></ul></li><li><p>大规模生产化</p><ul><li>多集群</li><li>服务网格和多网格</li></ul></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-什么是云原生&quot;&gt;&lt;a href=&quot;#1-什么是云原生&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是云原生&quot;&gt;&lt;/a&gt;&lt;font color=DarkOrange&gt;1. 什么是云原生&lt;/font&gt;&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在包括公有</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
</feed>
