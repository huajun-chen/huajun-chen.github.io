<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>可可西里-博客</title>
  
  <subtitle>好好吃饭 好好睡觉 好好上班</subtitle>
  <link href="https://huajun-chen.github.io/atom.xml" rel="self"/>
  
  <link href="https://huajun-chen.github.io/"/>
  <updated>2022-11-17T15:47:21.288Z</updated>
  <id>https://huajun-chen.github.io/</id>
  
  <author>
    <name>可可西里</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CodeTop算法题</title>
    <link href="https://huajun-chen.github.io/2022/11/14/CodeTop%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <id>https://huajun-chen.github.io/2022/11/14/CodeTop%E7%AE%97%E6%B3%95%E9%A2%98/</id>
    <published>2022-11-14T03:29:50.000Z</published>
    <updated>2022-11-17T15:47:21.288Z</updated>
    
    <content type="html"><![CDATA[<p>面试LeetCode算法题整理，按照出现的频率依次递减排序，题目类型包含：简单、中等、困难</p><p>CodeTop地址：<a href="https://codetop.cc/home">点击跳转</a></p><p><strong>备注：</strong>出现的频率会随时间变化而变化，具体以CodeTop出现频率为准，每个题目整理出<strong>题目</strong>、<strong>思路</strong>、<strong>代码</strong>三部分</p><h4 id="1-无重复字符的最长子串-中等"><a href="#1-无重复字符的最长子串-中等" class="headerlink" title="1. 无重复字符的最长子串-中等"></a><font color=DarkOrange>1. 无重复字符的最长子串-中等</font></h4><p><strong>题目：</strong></p><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度</p><p><strong>思路：</strong></p><p>滑动窗口</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-反转链表-简单"><a href="#2-反转链表-简单" class="headerlink" title="2. 反转链表-简单"></a><font color=DarkOrange>2. 反转链表-简单</font></h4><p><strong>题目：</strong></p><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表</p><p><strong>思路：</strong></p><p>方法一：迭代</p><p>方法二：递归</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-LRU缓存-中等"><a href="#3-LRU缓存-中等" class="headerlink" title="3. LRU缓存-中等"></a><font color=DarkOrange>3. LRU缓存-中等</font></h4><p><strong>题目：</strong></p><p>请你设计并实现一个满足LRU (最近最少使用) 缓存约束的数据结构</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> </li><li>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字</li></ul><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行</p><p><strong>思路：</strong></p><p>哈希表 + 双向链表</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-数组中的第K个最大元素-中等"><a href="#4-数组中的第K个最大元素-中等" class="headerlink" title="4. 数组中的第K个最大元素-中等"></a><font color=DarkOrange>4. 数组中的第K个最大元素-中等</font></h4><p><strong>题目：</strong></p><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素</p><p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题</p><p><strong>思路：</strong></p><p>方法一：基于快速排序的选择方法</p><p>方法二：基于堆排序的选择方法</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-K个一组翻转链表-困难"><a href="#5-K个一组翻转链表-困难" class="headerlink" title="5. K个一组翻转链表-困难"></a><font color=DarkOrange>5. K个一组翻转链表-困难</font></h4><p><strong>题目：</strong></p><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换</p><p><strong>思路：</strong></p><p>模拟</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-三数之和-中等"><a href="#6-三数之和-中等" class="headerlink" title="6. 三数之和-中等"></a><font color=DarkOrange>6. 三数之和-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数数组<code>nums</code> ，判断是否存在三元组<code>[nums[i], nums[j], nums[k]]</code>满足<code>i != j</code>、<code>i != k</code>且<code>j != k</code>，同时还满足<code>nums[i] + nums[j] + nums[k] == 0</code> </p><p>请你返回所有和为 <code>0</code> 且不重复的三元组</p><p><strong>注意：</strong>答案中不可以包含重复的三元组</p><p><strong>思路：</strong></p><p>排序 + 双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="7-最大子数组和-中等"><a href="#7-最大子数组和-中等" class="headerlink" title="7. 最大子数组和-中等"></a><font color=DarkOrange>7. 最大子数组和-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和</p><p><strong>子数组</strong> 是数组中的一个连续部分</p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：分治</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="8-排序数组-快排-中等"><a href="#8-排序数组-快排-中等" class="headerlink" title="8. 排序数组-快排-中等"></a><font color=DarkOrange>8. 排序数组-快排-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列</p><p><strong>思路：</strong></p><p>通过划分将待排序的序列分成前后两部分，其中前一部分的数据都比后一部分的数据要小，然后再递归调用函数对两部分的序列分别进行快速排序</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="9-合并两个有序链表-简单"><a href="#9-合并两个有序链表-简单" class="headerlink" title="9. 合并两个有序链表-简单"></a><font color=DarkOrange>9. 合并两个有序链表-简单</font></h4><p><strong>题目：</strong></p><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的</p><p><strong>思路：</strong></p><p>方法一：递归</p><p>方法二：迭代</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="10-两数之和-简单"><a href="#10-两数之和-简单" class="headerlink" title="10. 两数之和-简单"></a><font color=DarkOrange>10. 两数之和-简单</font></h4><p><strong>题目：</strong></p><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现</p><p>你可以按任意顺序返回答案</p><p><strong>思路：</strong></p><p>方法一：暴力枚举</p><p>方法二：哈希表</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="11-二叉树的层序遍历-中等"><a href="#11-二叉树的层序遍历-中等" class="headerlink" title="11. 二叉树的层序遍历-中等"></a><font color=DarkOrange>11. 二叉树的层序遍历-中等</font></h4><p><strong>题目：</strong></p><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）</p><p><strong>思路：</strong></p><p>广度优先搜索</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="12-搜索旋转排序数组-中等"><a href="#12-搜索旋转排序数组-中等" class="headerlink" title="12. 搜索旋转排序数组-中等"></a><font color=DarkOrange>12. 搜索旋转排序数组-中等</font></h4><p><strong>题目：</strong></p><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> </p><p>在传递给函数之前，<code>nums</code>在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 旋转，使数组变为<code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 从 0 开始 计数）。例如，<code> [0,1,2,4,5,6,7]</code>在下标<code>3</code>处经旋转后可能变为<code>[4,5,6,7,0,1,2]</code> </p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> </p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题</p><p><strong>思路：</strong></p><p>二分查找</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="13-买卖股票的最佳时机-简单"><a href="#13-买卖股票的最佳时机-简单" class="headerlink" title="13. 买卖股票的最佳时机-简单"></a><font color=DarkOrange>13. 买卖股票的最佳时机-简单</font></h4><p><strong>题目：</strong></p><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> </p><p><strong>思路：</strong></p><p>方法一：暴力法</p><p>方法二：一次遍历</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="14-有效的括号-简单"><a href="#14-有效的括号-简单" class="headerlink" title="14. 有效的括号-简单"></a><font color=DarkOrange>14. 有效的括号-简单</font></h4><p><strong>题目：</strong></p><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合</li><li>左括号必须以正确的顺序闭合</li><li>每个右括号都有一个对应的相同类型的左括号</li></ol><p><strong>思路：</strong></p><p>栈</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="15-岛屿数量-中等"><a href="#15-岛屿数量-中等" class="headerlink" title="15. 岛屿数量-中等"></a><font color=DarkOrange>15. 岛屿数量-中等</font></h4><p><strong>题目：</strong></p><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成</p><p>此外，你可以假设该网格的四条边均被水包围</p><p><strong>思路：</strong></p><p>方法一：深度优先搜索</p><p>方法二：广度优先搜索</p><p>方法三：并查集</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="16-环形链表-简单"><a href="#16-环形链表-简单" class="headerlink" title="16. 环形链表-简单"></a><font color=DarkOrange>16. 环形链表-简单</font></h4><p><strong>题目：</strong></p><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> </p><p><strong>思路：</strong></p><p>方法一：哈希表</p><p>方法二：快慢指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="17-最长回文子串-中等"><a href="#17-最长回文子串-中等" class="headerlink" title="17. 最长回文子串-中等"></a><font color=DarkOrange>17. 最长回文子串-中等</font></h4><p><strong>题目：</strong></p><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串</p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：中心扩展算法</p><p>方法三：Manacher 算法</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="18-二叉树的锯齿形层序遍历-中等"><a href="#18-二叉树的锯齿形层序遍历-中等" class="headerlink" title="18. 二叉树的锯齿形层序遍历-中等"></a><font color=DarkOrange>18. 二叉树的锯齿形层序遍历-中等</font></h4><p><strong>题目：</strong></p><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）</p><p><strong>思路：</strong></p><p>广度优先遍历</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="19-合并两个有序数组-简单"><a href="#19-合并两个有序数组-简单" class="headerlink" title="19. 合并两个有序数组-简单"></a><font color=DarkOrange>19. 合并两个有序数组-简单</font></h4><p><strong>题目：</strong></p><p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目</p><p>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列</p><p><strong>注意：</strong>最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> </p><p><strong>思路：</strong></p><p>方法一：直接合并后排序</p><p>方法二：双指针</p><p>方法三：逆向双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="20-二叉树的最近公共祖先-中等"><a href="#20-二叉树的最近公共祖先-中等" class="headerlink" title="20. 二叉树的最近公共祖先-中等"></a><font color=DarkOrange>20. 二叉树的最近公共祖先-中等</font></h4><p><strong>题目：</strong></p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）”</p><p><strong>思路：</strong></p><p>方法一：递归</p><p>方法二：存储父节点</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="21-全排列-中等"><a href="#21-全排列-中等" class="headerlink" title="21. 全排列-中等"></a><font color=DarkOrange>21. 全排列-中等</font></h4><p><strong>题目：</strong></p><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案</p><p><strong>思路：</strong></p><p>回溯</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="22-相交链表-简单"><a href="#22-相交链表-简单" class="headerlink" title="22. 相交链表-简单"></a><font color=DarkOrange>22. 相交链表-简单</font></h4><p><strong>题目：</strong></p><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h87c37dsm4j311m0q40zb.jpg" alt="image.png" style="zoom:50%;" /></div><p><strong>思路：</strong></p><p>方法一：哈希集合</p><p>方法二：双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="23-螺旋矩阵-中等"><a href="#23-螺旋矩阵-中等" class="headerlink" title="23. 螺旋矩阵-中等"></a><font color=DarkOrange>23. 螺旋矩阵-中等</font></h4><p><strong>题目：</strong></p><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素</p><p><strong>思路：</strong></p><p>方法一：模拟</p><p>方法二：按层模拟</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="24-合并K个升序链表-困难"><a href="#24-合并K个升序链表-困难" class="headerlink" title="24. 合并K个升序链表-困难"></a><font color=DarkOrange>24. 合并K个升序链表-困难</font></h4><p><strong>题目：</strong></p><p>给你一个链表数组，每个链表都已经按升序排列</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表</p><p><strong>思路：</strong></p><p>方法一：顺序合并</p><p>方法二：分治合并</p><p>方法三：使用优先队列合并</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="25-反转链表-II-中等"><a href="#25-反转链表-II-中等" class="headerlink" title="25. 反转链表 II-中等"></a><font color=DarkOrange>25. 反转链表 II-中等</font></h4><p><strong>题目：</strong></p><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code>的链表节点，返回 <strong>反转后的链表</strong> </p><p><strong>思路：</strong></p><p>方法一：穿针引线</p><p>方法二：一次遍历「穿针引线」反转链表（头插法）</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="26-字符串相加-简单"><a href="#26-字符串相加-简单" class="headerlink" title="26. 字符串相加-简单"></a><font color=DarkOrange>26. 字符串相加-简单</font></h4><p><strong>题目：</strong></p><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和并同样以字符串形式返回</p><p>你不能使用任何內建的用于处理大整数的库（比如 <code>BigInteger</code>）， 也不能直接将输入的字符串转换为整数形式</p><p><strong>思路：</strong></p><p>模拟</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="27-环形链表-II-中等"><a href="#27-环形链表-II-中等" class="headerlink" title="27. 环形链表 II-中等"></a><font color=DarkOrange>27. 环形链表 II-中等</font></h4><p><strong>题目：</strong></p><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 <code>null</code></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况</p><p><strong>思路：</strong></p><p>方法一：哈希表</p><p>方法二：快慢指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="28-长递增子序列-中等"><a href="#28-长递增子序列-中等" class="headerlink" title="28. 长递增子序列-中等"></a><font color=DarkOrange>28. 长递增子序列-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度</p><p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列</p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：贪心 + 二分查找</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="29-接雨水-困难"><a href="#29-接雨水-困难" class="headerlink" title="29. 接雨水-困难"></a><font color=DarkOrange>29. 接雨水-困难</font></h4><p><strong>题目：</strong></p><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水</p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：单调栈</p><p>方法三：双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="30-二叉树中的最大路径和-困难"><a href="#30-二叉树中的最大路径和-困难" class="headerlink" title="30. 二叉树中的最大路径和-困难"></a><font color=DarkOrange>30. 二叉树中的最大路径和-困难</font></h4><p><strong>题目：</strong></p><p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点</p><p><strong>路径和</strong> 是路径中各节点值的总和</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> </p><p><strong>思路：</strong></p><p>递归</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="31-重排链表-中等"><a href="#31-重排链表-中等" class="headerlink" title="31. 重排链表-中等"></a><font color=DarkOrange>31. 重排链表-中等</font></h4><p><strong>题目：</strong></p><p>给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L0 → L1 → … → Ln - 1 → Ln</span><br></pre></td></tr></table></figure><p>请将其重新排列后变为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</span><br></pre></td></tr></table></figure><p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换</p><p><strong>思路：</strong></p><p>方法一：线性表</p><p>方法二：寻找链表中点 + 链表逆序 + 合并链表</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="32-二叉树的中序遍历-简单"><a href="#32-二叉树的中序遍历-简单" class="headerlink" title="32. 二叉树的中序遍历-简单"></a><font color=DarkOrange>32. 二叉树的中序遍历-简单</font></h4><p><strong>题目：</strong></p><p>给定一个二叉树的根节点 <code>root</code> ，返回 它的 <strong>中序</strong>遍历</p><p><strong>思路：</strong></p><p>方法一：递归</p><p>方法二：迭代</p><p>方法三：Morris 中序遍历</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="33-二分查找-简单"><a href="#33-二分查找-简单" class="headerlink" title="33. 二分查找-简单"></a><font color=DarkOrange>33. 二分查找-简单</font></h4><p><strong>题目：</strong></p><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code></p><p><strong>思路：</strong></p><p>二分查找</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="34-编辑距离-困难"><a href="#34-编辑距离-困难" class="headerlink" title="34. 编辑距离-困难"></a><font color=DarkOrange>34. 编辑距离-困难</font></h4><p><strong>题目：</strong></p><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， 请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p><strong>思路：</strong></p><p>动态规划</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="35-用栈实现队列-简单"><a href="#35-用栈实现队列-简单" class="headerlink" title="35. 用栈实现队列-简单"></a><font color=DarkOrange>35. 用栈实现队列-简单</font></h4><p><strong>题目：</strong></p><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p><p>实现 <code>MyQueue</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><p>说明：</p><ul><li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可</li></ul><p><strong>思路：</strong></p><p>双栈</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="36-寻找两个正序数组的中位数-困难"><a href="#36-寻找两个正序数组的中位数-困难" class="headerlink" title="36. 寻找两个正序数组的中位数-困难"></a><font color=DarkOrange>36. 寻找两个正序数组的中位数-困难</font></h4><p><strong>题目：</strong></p><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> </p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> </p><p><strong>思路：</strong></p><p>方法一：二分查找</p><p>方法二：划分数组</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="37-二叉树的右视图-中等"><a href="#37-二叉树的右视图-中等" class="headerlink" title="37. 二叉树的右视图-中等"></a><font color=DarkOrange>37. 二叉树的右视图-中等</font></h4><p><strong>题目：</strong></p><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值</p><p><strong>思路：</strong></p><p>方法一：深度优先搜索</p><p>方法二：广度优先搜索</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="38-除链表的倒数第N个结点-中等"><a href="#38-除链表的倒数第N个结点-中等" class="headerlink" title="38. 除链表的倒数第N个结点-中等"></a><font color=DarkOrange>38. 除链表的倒数第N个结点-中等</font></h4><p><strong>题目：</strong></p><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点</p><p><strong>思路：</strong></p><p>方法一：计算链表长度</p><p>方法二：栈</p><p>方法三：双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="39-爬楼梯-简单"><a href="#39-爬楼梯-简单" class="headerlink" title="39. 爬楼梯-简单"></a><font color=DarkOrange>39. 爬楼梯-简单</font></h4><p><strong>题目：</strong></p><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢</p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：矩阵快速幂</p><p>方法三：通项公式</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="40-合并区间-中等"><a href="#40-合并区间-中等" class="headerlink" title="40. 合并区间-中等"></a><font color=DarkOrange>40. 合并区间-中等</font></h4><p><strong>题目：</strong></p><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</p><p><strong>思路：</strong></p><p>排序</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="41-排序链表-中等"><a href="#41-排序链表-中等" class="headerlink" title="41. 排序链表-中等"></a><font color=DarkOrange>41. 排序链表-中等</font></h4><p><strong>题目：</strong></p><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> </p><p><strong>思路：</strong></p><p>方法一：自顶向下归并排序</p><p>方法二：自底向上归并排序</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="42-删除排序链表中的重复元素-II-中等"><a href="#42-删除排序链表中的重复元素-II-中等" class="headerlink" title="42. 删除排序链表中的重复元素 II-中等"></a><font color=DarkOrange>42. 删除排序链表中的重复元素 II-中等</font></h4><p><strong>题目：</strong></p><p>给定一个已排序的链表的头<code>head</code>，删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表</p><p><strong>思路：</strong></p><p>一次遍历</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="43-下一个排列-中等"><a href="#43-下一个排列-中等" class="headerlink" title="43. 下一个排列-中等"></a><font color=DarkOrange>43. 下一个排列-中等</font></h4><p><strong>题目：</strong></p><p>整数数组的一个 <strong>排列</strong> 就是将其所有成员以序列或线性顺序排列</p><ul><li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code></li></ul><p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）</p><ul><li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> </li><li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> </li><li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列</li></ul><p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列</p><p>必须<strong>原地</strong>修改，只允许使用额外常数空间</p><p><strong>思路：</strong></p><p>两遍扫描</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="44-x-的平方根-简单"><a href="#44-x-的平方根-简单" class="headerlink" title="44. x 的平方根 -简单"></a><font color=DarkOrange>44. x 的平方根 -简单</font></h4><p><strong>题目：</strong></p><p>给你一个非负整数 <code>x</code> ，计算并返回 <code>x</code> 的 <strong>算术平方根</strong> </p><p>由于返回类型是整数，结果只保留 <strong>整数部分</strong> ，小数部分将被 **舍去 **</p><p><strong>注意：</strong>不允许使用任何内置指数函数和算符，例如 <code>pow(x, 0.5)</code> 或者 <code>x ** 0.5</code>  </p><p><strong>思路：</strong></p><p>方法一：袖珍计算器算法</p><p>方法二：二分查找</p><p>方法三：牛顿迭代</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="45-两数相加-中等"><a href="#45-两数相加-中等" class="headerlink" title="45. 两数相加-中等"></a><font color=DarkOrange>45. 两数相加-中等</font></h4><p><strong>题目：</strong></p><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头</p><p><strong>思路：</strong></p><p>模拟</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="46-字符串转换整数-atoi-中等"><a href="#46-字符串转换整数-atoi-中等" class="headerlink" title="46. 字符串转换整数 (atoi)-中等"></a><font color=DarkOrange>46. 字符串转换整数 (atoi)-中等</font></h4><p><strong>题目：</strong></p><p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C&#x2F;C++ 中的 <code>atoi</code> 函数）</p><p>函数 <code>myAtoi(string s)</code> 的算法如下：</p><ol><li>读入字符串并丢弃无用的前导空格</li><li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正</li><li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略</li><li>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）</li><li>如果整数数超过 32 位有符号整数范围 <code>[−231, 231 − 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <code>−231</code> 的整数应该被固定为 <code>−231</code> ，大于 <code>231 − 1</code> 的整数应该被固定为 <code>231 − 1</code> </li><li>返回整数作为最终结果</li></ol><p><strong>注意：</strong></p><ul><li>本题中的空白字符只包括空格字符 <code>&#39; &#39;</code> </li><li>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong> 任何其他字符</li></ul><p><strong>思路：</strong></p><p>自动机</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="47-最长公共子序列-中等"><a href="#47-最长公共子序列-中等" class="headerlink" title="47. 最长公共子序列-中等"></a><font color=DarkOrange>47. 最长公共子序列-中等</font></h4><p><strong>题目：</strong></p><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> </p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列</p><p><strong>思路：</strong></p><p>动态规划</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="48-括号生成-中等"><a href="#48-括号生成-中等" class="headerlink" title="48. 括号生成-中等"></a><font color=DarkOrange>48. 括号生成-中等</font></h4><p><strong>题目：</strong></p><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合</p><p><strong>思路：</strong></p><p>方法一：暴力法</p><p>方法二：回溯法</p><p>方法三：按括号序列的长度递归</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="49-滑动窗口最大值-困难"><a href="#49-滑动窗口最大值-困难" class="headerlink" title="49. 滑动窗口最大值-困难"></a><font color=DarkOrange>49. 滑动窗口最大值-困难</font></h4><p><strong>题目：</strong></p><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的<code>k</code> 个数字。滑动窗口每次只向右移动一位</p><p>返回 滑动窗口中的最大值</p><p><strong>思路：</strong></p><p>方法一：优先队列</p><p>方法二：单调队列</p><p>方法三：分块 + 预处理</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="50-复原-IP-地址-中等"><a href="#50-复原-IP-地址-中等" class="headerlink" title="50. 复原 IP 地址-中等"></a><font color=DarkOrange>50. 复原 IP 地址-中等</font></h4><p><strong>题目：</strong></p><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>&#39;.&#39;</code> 分隔</p><ul><li>例如：<code>&quot;0.1.2.201&quot;</code> 和<code> &quot;192.168.1.1&quot;</code> 是 <strong>有效</strong> IP 地址，但是 <code>&quot;0.011.255.245&quot;</code>、<code>&quot;192.168.1.312&quot;</code> 和<code>&quot;192.168@1.1&quot;</code> 是 <strong>无效</strong> IP 地址</li></ul><p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入 <code>&#39;.&#39;</code> 来形成。你 <strong>不能</strong> 重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案</p><p><strong>思路：</strong></p><p>回溯</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="51-缺失的第一个正数-困难"><a href="#51-缺失的第一个正数-困难" class="headerlink" title="51. 缺失的第一个正数-困难"></a><font color=DarkOrange>51. 缺失的第一个正数-困难</font></h4><p><strong>题目：</strong></p><p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数</p><p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案</p><p><strong>思路：</strong></p><p>方法一：哈希表</p><p>方法二：置换</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="52-链表中倒数第k个节点-简单"><a href="#52-链表中倒数第k个节点-简单" class="headerlink" title="52. 链表中倒数第k个节点-简单"></a><font color=DarkOrange>52. 链表中倒数第k个节点-简单</font></h4><p><strong>题目：</strong></p><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点</p><p>例如，一个链表有 <code>6</code> 个节点，从头节点开始，它们的值依次是 <code>1、2、3、4、5、6</code>。这个链表的倒数第 <code>3</code> 个节点是值为 <code>4</code> 的节点</p><p><strong>思路：</strong></p><p>方法一：顺序查找</p><p>方法二：双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="53-从前序与中序遍历序列构造二叉树-中等"><a href="#53-从前序与中序遍历序列构造二叉树-中等" class="headerlink" title="53. 从前序与中序遍历序列构造二叉树-中等"></a><font color=DarkOrange>53. 从前序与中序遍历序列构造二叉树-中等</font></h4><p><strong>题目：</strong></p><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点</p><p><strong>思路：</strong></p><p>方法一：递归</p><p>方法二：迭代</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="54-比较版本号-中等"><a href="#54-比较版本号-中等" class="headerlink" title="54. 比较版本号-中等"></a><font color=DarkOrange>54. 比较版本号-中等</font></h4><p><strong>题目：</strong></p><p>给你两个版本号 <code>version1</code> 和 <code>version2</code> ，请你比较它们</p><p>版本号由一个或多个修订号组成，各修订号由一个 <code>&#39;.&#39;</code> 连接。每个修订号由 <strong>多位数字</strong> 组成，可能包含 <strong>前导零</strong> 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，<code>2.5.33</code> 和 <code>0.1</code> 都是有效的版本号</p><p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 <strong>忽略任何前导零后的整数值</strong> 。也就是说，修订号 <code>1</code> 和修订号 <code>001</code> <strong>相等</strong> 。如果版本号没有指定某个下标处的修订号，则该修订号视为 <code>0</code> 。例如，版本 <code>1.0</code> 小于版本<code>1.1</code> ，因为它们下标为 <code>0</code> 的修订号相同，而下标为 <code>1</code> 的修订号分别为 <code>0</code> 和 <code>1</code> ，<code>0 &lt; 1</code> </p><p>返回规则如下：</p><ul><li>如果 <code>*version1* &gt; *version2*</code> 返回 <code>1</code></li><li>如果 <code>*version1* &lt; *version2*</code> 返回 <code>-1</code></li><li>除此之外返回 <code>0</code></li></ul><p><strong>思路：</strong></p><p>方法一：字符串分割</p><p>方法二：双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="55-零钱兑换-中等"><a href="#55-零钱兑换-中等" class="headerlink" title="55. 零钱兑换-中等"></a><font color=DarkOrange>55. 零钱兑换-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> </p><p>你可以认为每种硬币的数量是无限的</p><p><strong>思路：</strong></p><p>方法一：记忆化搜索</p><p>方法二：动态规划</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="56-最小覆盖子串-困难"><a href="#56-最小覆盖子串-困难" class="headerlink" title="56. 最小覆盖子串-困难"></a><font color=DarkOrange>56. 最小覆盖子串-困难</font></h4><p><strong>题目：</strong></p><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> </p><p><strong>注意：</strong></p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案</li></ul><p><strong>思路：</strong></p><p>滑动窗口</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="57-二叉树的前序遍历-简单"><a href="#57-二叉树的前序遍历-简单" class="headerlink" title="57. 二叉树的前序遍历-简单"></a><font color=DarkOrange>57. 二叉树的前序遍历-简单</font></h4><p><strong>题目：</strong></p><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历</p><p><strong>思路：</strong></p><p>方法一：递归</p><p>方法二：迭代</p><p>方法三：Morris 遍历</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="58-反转字符串中的单词-中等"><a href="#58-反转字符串中的单词-中等" class="headerlink" title="58. 反转字符串中的单词-中等"></a><font color=DarkOrange>58. 反转字符串中的单词-中等</font></h4><p><strong>题目：</strong></p><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序</p><p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开</p><p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串</p><p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格</p><p><strong>思路：</strong></p><p>方法一：使用语言特性</p><p>方法二：自行编写对应的函数</p><p>方法三：双端队列</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="59-字符串相乘-中等"><a href="#59-字符串相乘-中等" class="headerlink" title="59. 字符串相乘-中等"></a><font color=DarkOrange>59. 字符串相乘-中等</font></h4><p><strong>题目：</strong></p><p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式</p><p><strong>注意：</strong>不能使用任何内置的 BigInteger 库或直接将输入转换为整数</p><p><strong>思路：</strong></p><p>方法一：做加法</p><p>方法二：做乘法</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="60-最小栈-中等"><a href="#60-最小栈-中等" class="headerlink" title="60. 最小栈-中等"></a><font color=DarkOrange>60. 最小栈-中等</font></h4><p><strong>题目：</strong></p><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈</p><p>实现 <code>MinStack</code> 类：</p><ul><li><code>MinStack()</code> 初始化堆栈对象</li><li><code>void push(int val)</code> 将元素val推入堆栈</li><li><code>void pop()</code> 删除堆栈顶部的元素</li><li><code>int top()</code> 获取堆栈顶部的元素</li><li><code>int getMin()</code> 获取堆栈中的最小元素</li></ul><p><strong>思路：</strong></p><p>辅助栈</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="61-平衡二叉树-简单"><a href="#61-平衡二叉树-简单" class="headerlink" title="61. 平衡二叉树-简单"></a><font color=DarkOrange>61. 平衡二叉树-简单</font></h4><p><strong>题目：</strong></p><p>给定一个二叉树，判断它是否是高度平衡的二叉树</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 </p></blockquote><p><strong>思路：</strong></p><p>方法一：自顶向下的递归</p><p>方法二：自底向上的递归</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="62-子集-中等"><a href="#62-子集-中等" class="headerlink" title="62. 子集-中等"></a><font color=DarkOrange>62. 子集-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集</p><p><strong>思路：</strong></p><p>方法一：迭代法实现子集枚举</p><p>方法二：递归法实现子集枚举</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="63-二叉树的最大深度-简单"><a href="#63-二叉树的最大深度-简单" class="headerlink" title="63. 二叉树的最大深度-简单"></a><font color=DarkOrange>63. 二叉树的最大深度-简单</font></h4><p><strong>题目：</strong></p><p>给定一个二叉树，找出其最大深度</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点</p><p><strong>思路：</strong></p><p>方法一：深度优先搜索</p><p>方法二：广度优先搜索</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="64-求根节点到叶节点数字之和-中等"><a href="#64-求根节点到叶节点数字之和-中等" class="headerlink" title="64. 求根节点到叶节点数字之和-中等"></a><font color=DarkOrange>64. 求根节点到叶节点数字之和-中等</font></h4><p><strong>题目：</strong></p><p>给你一个二叉树的根节点 <code>root</code> ，树中每个节点都存放有一个 <code>0</code> 到 <code>9</code> 之间的数字</p><p>每条从根节点到叶节点的路径都代表一个数字：</p><ul><li>例如，从根节点到叶节点的路径 <code>1 -&gt; 2 -&gt; 3</code> 表示数字 <code>123</code></li></ul><p>计算从根节点到叶节点生成的 <strong>所有数字之和</strong> </p><p><strong>叶节点</strong> 是指没有子节点的节点</p><p><strong>思路：</strong></p><p>方法一：深度优先搜索</p><p>方法二：广度优先搜索</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="65-最长有效括号-困难"><a href="#65-最长有效括号-困难" class="headerlink" title="65. 最长有效括号-困难"></a><font color=DarkOrange>65. 最长有效括号-困难</font></h4><p><strong>题目：</strong></p><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度</p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：栈</p><p>方法三：不需要额外的空间</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="66-对称二叉树-简单"><a href="#66-对称二叉树-简单" class="headerlink" title="66. 对称二叉树-简单"></a><font color=DarkOrange>66. 对称二叉树-简单</font></h4><p><strong>题目：</strong></p><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称</p><p><strong>思路：</strong></p><p>方法一：递归</p><p>方法二：迭代</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="67-验证二叉搜索树-中等"><a href="#67-验证二叉搜索树-中等" class="headerlink" title="67. 验证二叉搜索树-中等"></a><font color=DarkOrange>67. 验证二叉搜索树-中等</font></h4><p><strong>题目：</strong></p><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数</li><li>所有左子树和右子树自身必须也是二叉搜索树</li></ul><p><strong>思路：</strong></p><p>方法一: 递归</p><p>方法二：中序遍历</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="68-最小路径和-中等"><a href="#68-最小路径和-中等" class="headerlink" title="68. 最小路径和-中等"></a><font color=DarkOrange>68. 最小路径和-中等</font></h4><p><strong>题目：</strong></p><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小</p><p><strong>说明：</strong>每次只能向下或者向右移动一步</p><p><strong>思路：</strong></p><p>动态规划</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="69-二叉树的直径-简单"><a href="#69-二叉树的直径-简单" class="headerlink" title="69. 二叉树的直径-简单"></a><font color=DarkOrange>69. 二叉树的直径-简单</font></h4><p><strong>题目：</strong></p><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点</p><p><strong>思路：</strong></p><p>深度优先搜索</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="70-路径总和-II-中等"><a href="#70-路径总和-II-中等" class="headerlink" title="70. 路径总和 II-中等"></a><font color=DarkOrange>70. 路径总和 II-中等</font></h4><p><strong>题目：</strong></p><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径</p><p><strong>叶子节点</strong> 是指没有子节点的节点</p><p><strong>思路：</strong></p><p>方法一：深度优先搜索</p><p>方法二：广度优先搜索</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="71-Rand7-实现-Rand10-简单"><a href="#71-Rand7-实现-Rand10-简单" class="headerlink" title="71.  Rand7() 实现 Rand10()-简单"></a><font color=DarkOrange>71.  Rand7() 实现 Rand10()-简单</font></h4><p><strong>题目：</strong></p><p>给定方法 <code>rand7</code> 可生成 <code>[1,7]</code> 范围内的均匀随机整数，试写一个方法 <code>rand10</code> 生成 <code>[1,10]</code> 范围内的均匀随机整数</p><p>你只能调用 <code>rand7()</code> 且不能调用其他方法。请不要使用系统的 <code>Math.random()</code> 方法</p><p>每个测试用例将有一个内部参数 <code>n</code>，即你实现的函数 <code>rand10()</code> 在测试时将被调用的次数。请注意，这不是传递给 <code>rand10()</code> 的参数</p><p><strong>思路：</strong></p><p>拒绝采样</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="72-组合总和-中等"><a href="#72-组合总和-中等" class="headerlink" title="72. 组合总和-中等"></a><font color=DarkOrange>72. 组合总和-中等</font></h4><p><strong>题目：</strong></p><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的</p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个</p><p><strong>思路：</strong></p><p>搜索回溯</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="73-旋转图像-中等"><a href="#73-旋转图像-中等" class="headerlink" title="73. 旋转图像-中等"></a><font color=DarkOrange>73. 旋转图像-中等</font></h4><p><strong>题目：</strong></p><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度</p><p>你必须在<strong>原地</strong> 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像</p><p><strong>思路：</strong></p><p>方法一：使用辅助数组</p><p>方法二：原地旋转</p><p>方法三：用翻转代替旋转</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="74-路径总和-简单"><a href="#74-路径总和-简单" class="headerlink" title="74. 路径总和-简单"></a><font color=DarkOrange>74. 路径总和-简单</font></h4><p><strong>题目：</strong></p><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> </p><p><strong>叶子节点</strong> 是指没有子节点的节点</p><p><strong>思路：</strong></p><p>方法一：广度优先搜索</p><p>方法二：递归</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="75-回文链表-简单"><a href="#75-回文链表-简单" class="headerlink" title="75. 回文链表-简单"></a><font color=DarkOrange>75. 回文链表-简单</font></h4><p><strong>题目：</strong></p><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> </p><p><strong>思路：</strong></p><p>方法一：将值复制到数组中后用双指针法</p><p>方法二：递归</p><p>方法三：快慢指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="76-多数元素-简单"><a href="#76-多数元素-简单" class="headerlink" title="76. 多数元素-简单"></a><font color=DarkOrange>76. 多数元素-简单</font></h4><p><strong>题目：</strong></p><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素</p><p><strong>思路：</strong></p><p>方法一：哈希表</p><p>方法二：排序</p><p>方法三：随机化</p><p>方法四：分治</p><p>方法五：Boyer-Moore 投票算法</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="77-最长重复子数组-中等"><a href="#77-最长重复子数组-中等" class="headerlink" title="77. 最长重复子数组-中等"></a><font color=DarkOrange>77. 最长重复子数组-中等</font></h4><p><strong>题目：</strong></p><p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度 </p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：滑动窗口</p><p>方法三：二分查找 + 哈希</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="78-最大正方形-中等"><a href="#78-最大正方形-中等" class="headerlink" title="78. 最大正方形-中等"></a><font color=DarkOrange>78. 最大正方形-中等</font></h4><p><strong>题目：</strong></p><p>在一个由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的二维矩阵内，找到只包含 <code>&#39;1&#39;</code> 的最大正方形，并返回其面积</p><p><strong>思路：</strong></p><p>方法一：暴力法</p><p>方法二：动态规划</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="79-字符串解码-中等"><a href="#79-字符串解码-中等" class="headerlink" title="79. 字符串解码-中等"></a><font color=DarkOrange>79. 字符串解码-中等</font></h4><p><strong>题目：</strong></p><p>给定一个经过编码的字符串，返回它解码后的字符串</p><p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入</p><p><strong>思路：</strong></p><p>方法一：栈操作</p><p>方法二：递归</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="80-搜索二维矩阵-II-中等"><a href="#80-搜索二维矩阵-II-中等" class="headerlink" title="80. 搜索二维矩阵 II-中等"></a><font color=DarkOrange>80. 搜索二维矩阵 II-中等</font></h4><p><strong>题目：</strong></p><p>编写一个高效的算法来搜索 <code>*m* x *n*</code> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p><ul><li>每行的元素从左到右升序排列</li><li>每列的元素从上到下升序排列</li></ul><p><strong>思路：</strong></p><p>方法一：直接查找</p><p>方法二：二分查找</p><p>方法三：Z 字形查找</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="81-翻转二叉树-简单"><a href="#81-翻转二叉树-简单" class="headerlink" title="81. 翻转二叉树-简单"></a><font color=DarkOrange>81. 翻转二叉树-简单</font></h4><p><strong>题目：</strong></p><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点</p><p><strong>思路：</strong></p><p>递归</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="82-在排序数组中查找元素的第一个和最后一个位置-中等"><a href="#82-在排序数组中查找元素的第一个和最后一个位置-中等" class="headerlink" title="82. 在排序数组中查找元素的第一个和最后一个位置-中等"></a><font color=DarkOrange>82. 在排序数组中查找元素的第一个和最后一个位置-中等</font></h4><p><strong>题目：</strong></p><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code></p><p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题</p><p><strong>思路：</strong></p><p>二分查找</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="83-最长公共前缀-简单"><a href="#83-最长公共前缀-简单" class="headerlink" title="83. 最长公共前缀-简单"></a><font color=DarkOrange>83. 最长公共前缀-简单</font></h4><p><strong>题目：</strong></p><p>编写一个函数来查找字符串数组中的最长公共前缀</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code></p><p><strong>思路：</strong></p><p>方法一：横向扫描</p><p>方法二：纵向扫描</p><p>方法三：分治</p><p>方法四：二分查找</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="84-寻找峰值-中等"><a href="#84-寻找峰值-中等" class="headerlink" title="84. 寻找峰值-中等"></a><font color=DarkOrange>84. 寻找峰值-中等</font></h4><p><strong>题目：</strong></p><p>峰值元素是指其值严格大于左右相邻值的元素</p><p>给你一个整数数组 <code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可</p><p>你可以假设 <code>nums[-1] = nums[n] = -∞</code> </p><p>你必须实现时间复杂度为 <code>O(log n)</code> 的算法来解决此问题</p><p><strong>思路：</strong></p><p>方法一：寻找最大值</p><p>方法二：迭代爬坡</p><p>方法三：方法二的二分查找优化</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="85-最长连续序列-中等"><a href="#85-最长连续序列-中等" class="headerlink" title="85. 最长连续序列-中等"></a><font color=DarkOrange>85. 最长连续序列-中等</font></h4><p><strong>题目：</strong></p><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度</p><p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题</p><p><strong>思路：</strong></p><p>哈希表</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="86-基本计算器-II-中等"><a href="#86-基本计算器-II-中等" class="headerlink" title="86. 基本计算器 II-中等"></a><font color=DarkOrange>86. 基本计算器 II-中等</font></h4><p><strong>题目：</strong></p><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值</p><p>整数除法仅保留整数部分</p><p>你可以假设给定的表达式总是有效的。所有中间结果将在 <code>[-2^31, 2^31 - 1]</code> 的范围内</p><p><strong>注意：</strong>不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval()</code> </p><p><strong>思路：</strong></p><p>栈</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="87-岛屿的最大面积-中等"><a href="#87-岛屿的最大面积-中等" class="headerlink" title="87. 岛屿的最大面积-中等"></a><font color=DarkOrange>87. 岛屿的最大面积-中等</font></h4><p><strong>题目：</strong></p><p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code> </p><p><strong>岛屿</strong> 是由一些相邻的 <code>1</code> (代表土地) 构成的组合，这里的「相邻」要求两个 <code>1</code> 必须在 <strong>水平或者竖直的四个方向上</strong> 相邻。你可以假设 <code>grid</code> 的四个边缘都被 <code>0</code>（代表水）包围着</p><p>岛屿的面积是岛上值为 <code>1</code> 的单元格的数目</p><p>计算并返回 <code>grid</code> 中最大的岛屿面积。如果没有岛屿，则返回面积为 <code>0</code> </p><p><strong>思路：</strong></p><p>方法一：深度优先搜索</p><p>方法二：深度优先搜索 + 栈</p><p>方法三：广度优先搜索</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="88-删除排序链表中的重复元素-简单"><a href="#88-删除排序链表中的重复元素-简单" class="headerlink" title="88. 删除排序链表中的重复元素-简单"></a><font color=DarkOrange>88. 删除排序链表中的重复元素-简单</font></h4><p><strong>题目：</strong></p><p>给定一个已排序的链表的头 <code>head</code> ， 删除所有重复的元素，使每个元素只出现一次 。返回已排序的链表</p><p><strong>思路：</strong></p><p>一次遍历</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="89-不同路径-中等"><a href="#89-不同路径-中等" class="headerlink" title="89. 不同路径-中等"></a><font color=DarkOrange>89. 不同路径-中等</font></h4><p><strong>题目：</strong></p><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）</p><p>问总共有多少条不同的路径？</p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：组合数学</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="90-打家劫舍-中等"><a href="#90-打家劫舍-中等" class="headerlink" title="90. 打家劫舍-中等"></a><font color=DarkOrange>90. 打家劫舍-中等</font></h4><p><strong>题目：</strong></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong></p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额</p><p><strong>思路：</strong></p><p>动态规划</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="91-买卖股票的最佳时机-II-中等"><a href="#91-买卖股票的最佳时机-II-中等" class="headerlink" title="91. 买卖股票的最佳时机 II-中等"></a><font color=DarkOrange>91. 买卖股票的最佳时机 II-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格</p><p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售</p><p>返回你能获得的 <strong>最大</strong> 利润</p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：贪心</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="92-两两交换链表中的节点-中等"><a href="#92-两两交换链表中的节点-中等" class="headerlink" title="92. 两两交换链表中的节点-中等"></a><font color=DarkOrange>92. 两两交换链表中的节点-中等</font></h4><p><strong>题目：</strong></p><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）</p><p><strong>思路：</strong></p><p>方法一：递归</p><p>方法二：迭代</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="93-乘积最大子数组-中等"><a href="#93-乘积最大子数组-中等" class="headerlink" title="93. 乘积最大子数组-中等"></a><font color=DarkOrange>93. 乘积最大子数组-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积</p><p>测试用例的答案是一个 <strong>32-位</strong> 整数</p><p><strong>子数组</strong> 是数组的连续子序列</p><p><strong>思路：</strong></p><p>动态规划</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="94-移动零-简单"><a href="#94-移动零-简单" class="headerlink" title="94. 移动零-简单"></a><font color=DarkOrange>94. 移动零-简单</font></h4><p><strong>题目：</strong></p><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作</p><p><strong>思路：</strong></p><p>双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="95-二叉树最大宽度-中等"><a href="#95-二叉树最大宽度-中等" class="headerlink" title="95. 二叉树最大宽度-中等"></a><font color=DarkOrange>95. 二叉树最大宽度-中等</font></h4><p><strong>题目：</strong></p><p>给你一棵二叉树的根节点 <code>root</code> ，返回树的 <strong>最大宽度</strong> </p><p>树的 <strong>最大宽度</strong> 是所有层中最大的 <strong>宽度</strong> </p><p>每一层的 <strong>宽度</strong> 被定义为该层最左和最右的非空节点（即，两个端点）之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的 <code>null</code> 节点，这些 <code>null</code> 节点也计入长度</p><p>题目数据保证答案将会在 <strong>32 位</strong> 带符号整数范围内</p><p><strong>思路：</strong></p><p>方法一：广度优先搜索</p><p>方法二：深度优先搜索</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="96-复制带随机指针的链表-中等"><a href="#96-复制带随机指针的链表-中等" class="headerlink" title="96. 复制带随机指针的链表-中等"></a><font color=DarkOrange>96. 复制带随机指针的链表-中等</font></h4><p><strong>题目：</strong></p><p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点</p><p>构造这个链表的 <strong><a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin">深拷贝</a><strong>。 深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong> 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的<code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。</strong>复制链表中的指针都不应指向原链表中的节点</strong> </p><p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 <code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> </p><p>返回复制链表的头节点</p><p>用一个由 <code>n</code> 个节点组成的链表来表示输入&#x2F;输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p><ul><li><code>val</code>：一个表示 <code>Node.val</code> 的整数</li><li><code>random_index</code>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为 <code>null</code></li></ul><p>你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code> 作为传入参数</p><p><strong>思路：</strong></p><p>方法一：回溯 + 哈希表</p><p>方法二：迭代 + 节点拆分</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="97-排序数组-堆排序-中等"><a href="#97-排序数组-堆排序-中等" class="headerlink" title="97. 排序数组-堆排序-中等"></a><font color=DarkOrange>97. 排序数组-堆排序-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列</p><p><strong>思路：</strong></p><p>先将待排序的序列建成大根堆，使得每个父节点的元素大于等于它的子节点</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="98-寻找旋转排序数组中的最小值-中等"><a href="#98-寻找旋转排序数组中的最小值-中等" class="headerlink" title="98. 寻找旋转排序数组中的最小值-中等"></a><font color=DarkOrange>98. 寻找旋转排序数组中的最小值-中等</font></h4><p><strong>题目：</strong></p><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p><ul><li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li><li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li></ul><p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> </p><p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> </p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题</p><p><strong>思路：</strong></p><p>二分查找</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="99-最大数-中等"><a href="#99-最大数-中等" class="headerlink" title="99. 最大数-中等"></a><font color=DarkOrange>99. 最大数-中等</font></h4><p><strong>题目：</strong></p><p>给定一组非负整数 <code>nums</code>，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数</p><p><strong>注意：</strong>输出结果可能非常大，所以你需要返回一个字符串而不是整数</p><p><strong>思路：</strong></p><p>排序</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="100-二叉树的序列化与反序列化-困难"><a href="#100-二叉树的序列化与反序列化-困难" class="headerlink" title="100. 二叉树的序列化与反序列化-困难"></a><font color=DarkOrange>100. 二叉树的序列化与反序列化-困难</font></h4><p><strong>题目：</strong></p><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 &#x2F; 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构</p><p><strong>思路：</strong></p><p>方法一：深度优先搜索</p><p>方法二：括号表示编码 + 递归下降解码</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="101-长度最小的子数组-中等"><a href="#101-长度最小的子数组-中等" class="headerlink" title="101. 长度最小的子数组-中等"></a><font color=DarkOrange>101. 长度最小的子数组-中等</font></h4><p><strong>题目：</strong></p><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> </p><p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> </p><p><strong>思路：</strong></p><p>方法一：暴力法</p><p>方法二：前缀和 + 二分查找</p><p>方法三：滑动窗口</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="102-单词拆分-中等"><a href="#102-单词拆分-中等" class="headerlink" title="102. 单词拆分-中等"></a><font color=DarkOrange>102. 单词拆分-中等</font></h4><p><strong>题目：</strong></p><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。请你判断是否可以利用字典中出现的单词拼接出 <code>s</code> </p><p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用</p><p><strong>思路：</strong></p><p>动态规划</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="103-验证IP地址-中等"><a href="#103-验证IP地址-中等" class="headerlink" title="103. 验证IP地址-中等"></a><font color=DarkOrange>103. 验证IP地址-中等</font></h4><p><strong>题目：</strong></p><p>给定一个字符串 <code>queryIP</code>。如果是有效的 IPv4 地址，返回 <code>&quot;IPv4&quot;</code> ；如果是有效的 IPv6 地址，返回 <code>&quot;IPv6&quot;</code> ；如果不是上述类型的 IP 地址，返回 <code>&quot;Neither&quot;</code> </p><p><strong>有效的IPv4地址</strong> 是 <code>“x1.x2.x3.x4”</code> 形式的IP地址。 其中 <code>0 &lt;= xi &lt;= 255</code> 且 <code>xi</code> <strong>不能包含</strong> 前导零。例如: <code>“192.168.1.1”</code> 、 <code>“192.168.1.0”</code> 为有效IPv4地址， <code>“192.168.01.1”</code> 为无效IPv4地址; <code>“192.168.1.00”</code> 、 <code>“192.168@1.1”</code> 为无效IPv4地址</p><p><strong>一个有效的IPv6地址</strong> 是一个格式为<code>“x1:x2:x3:x4:x5:x6:x7:x8”</code> 的IP地址，其中：</p><ul><li><code>1 &lt;= xi.length &lt;= 4</code></li><li><code>xi</code> 是一个 <strong>十六进制字符串</strong> ，可以包含数字、小写英文字母( <code>&#39;a&#39;</code> 到 <code>&#39;f&#39;</code> )和大写英文字母( <code>&#39;A&#39;</code> 到 <code>&#39;F&#39;</code> )</li><li>在 <code>xi</code> 中允许前导零</li></ul><p>例如 <code>&quot;2001:0db8:85a3:0000:0000:8a2e:0370:7334&quot;</code> 和<code>&quot;2001:db8:85a3:0:0:8A2E:0370:7334&quot;</code> 是有效的 IPv6地址，而 <code>&quot;2001:0db8:85a3::8A2E:037j:7334&quot;</code> 和 <code>&quot;02001:0db8:85a3:0000:0000:8a2e:0370:7334&quot;</code> 是无效的 IPv6 地址</p><p><strong>思路：</strong></p><p>依次判断</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="104-和为-K-的子数组-中等"><a href="#104-和为-K-的子数组-中等" class="headerlink" title="104. 和为 K 的子数组-中等"></a><font color=DarkOrange>104. 和为 K 的子数组-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回该数组中和为 <code>k</code> 的连续子数组的个数</p><p><strong>思路：</strong></p><p>方法一：枚举</p><p>方法二：前缀和 + 哈希表优化</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="105-只出现一次的数字-简单"><a href="#105-只出现一次的数字-简单" class="headerlink" title="105. 只出现一次的数字-简单"></a><font color=DarkOrange>105. 只出现一次的数字-简单</font></h4><p><strong>题目：</strong></p><p>给你一个 <strong>非空</strong> 整数数组 <code>nums</code> ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素</p><p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间</p><p><strong>思路：</strong></p><p>位运算</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="106-用两个栈实现队列-简单"><a href="#106-用两个栈实现队列-简单" class="headerlink" title="106. 用两个栈实现队列-简单"></a><font color=DarkOrange>106. 用两个栈实现队列-简单</font></h4><p><strong>题目：</strong></p><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 )</p><p><strong>思路：</strong></p><p>双栈</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="107-对角线遍历-中等"><a href="#107-对角线遍历-中等" class="headerlink" title="107. 对角线遍历-中等"></a><font color=DarkOrange>107. 对角线遍历-中等</font></h4><p><strong>题目：</strong></p><p>给你一个大小为 m x n 的矩阵 mat ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素</p><p><strong>思路：</strong></p><p>直接模拟</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="108-移掉-K-位数字-中等"><a href="#108-移掉-K-位数字-中等" class="headerlink" title="108. 移掉 K 位数字-中等"></a><font color=DarkOrange>108. 移掉 K 位数字-中等</font></h4><p><strong>题目：</strong></p><p>给你一个以字符串表示的非负整数 <code>num</code> 和一个整数 <code>k</code> ，移除这个数中的 <code>k</code> 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字</p><p><strong>思路：</strong></p><p>贪心 + 单调栈</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="109-基本计算器-困难"><a href="#109-基本计算器-困难" class="headerlink" title="109. 基本计算器-困难"></a><font color=DarkOrange>109. 基本计算器-困难</font></h4><p><strong>题目：</strong></p><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值</p><p>注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval()</code> </p><p><strong>思路：</strong></p><p>括号展开 + 栈</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="110-二叉搜索树与双向链表-中等"><a href="#110-二叉搜索树与双向链表-中等" class="headerlink" title="110. 二叉搜索树与双向链表-中等"></a><font color=DarkOrange>110. 二叉搜索树与双向链表-中等</font></h4><p><strong>题目：</strong></p><p><strong>思路：</strong></p><p><strong>代码：</strong></p><h4 id="111-排序数组-归并排序-中等"><a href="#111-排序数组-归并排序-中等" class="headerlink" title="111. 排序数组-归并排序-中等"></a><font color=DarkOrange>111. 排序数组-归并排序-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列</p><p><strong>思路：</strong></p><p>利用了分治的思想来对序列进行排序</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="112-LFU-缓存-困难"><a href="#112-LFU-缓存-困难" class="headerlink" title="112. LFU 缓存-困难"></a><font color=DarkOrange>112. LFU 缓存-困难</font></h4><p><strong>题目：</strong></p><p>请你为最不经常使用（LFU）缓存算法设计并实现数据结构</p><p>实现 <code>LFUCache</code> 类：</p><ul><li><code>LFUCache(int capacity)</code> - 用数据结构的容量 <code>capacity</code> 初始化对象</li><li><code>int get(int key)</code> - 如果键 <code>key</code> 存在于缓存中，则获取键的值，否则返回 <code>-1</code> </li><li><code>void put(int key, int value)</code> - 如果键 <code>key</code> 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 <code>capacity</code> 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 <strong>最近最久未使用</strong> 的键</li></ul><p>为了确定最不常使用的键，可以为缓存中的每个键维护一个 <strong>使用计数器</strong> 。使用计数最小的键是最久未使用的键</p><p>当一个键首次插入到缓存中时，它的使用计数器被设置为 <code>1</code> (由于 put 操作)。对缓存中的键执行 <code>get</code> 或 <code>put</code> 操作，使用计数器的值将会递增</p><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行</p><p><strong>思路：</strong></p><p>方法一：哈希表 + 平衡二叉树</p><p>方法二：双哈希表</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="113-每日温度-中等"><a href="#113-每日温度-中等" class="headerlink" title="113. 每日温度-中等"></a><font color=DarkOrange>113. 每日温度-中等</font></h4><p><strong>题目：</strong></p><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替</p><p><strong>思路：</strong></p><p>方法一：暴力</p><p>方法二：单调栈</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="114-课程表-中等"><a href="#114-课程表-中等" class="headerlink" title="114. 课程表-中等"></a><font color=DarkOrange>114. 课程表-中等</font></h4><p><strong>题目：</strong></p><p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> </p><p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 <strong>必须</strong> 先学习课程 <code>bi</code> </p><ul><li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code></li></ul><p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> </p><p><strong>思路：</strong></p><p>方法一：深度优先搜索</p><p>方法二: 广度优先搜索</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="115-排序奇升偶降链表-中等"><a href="#115-排序奇升偶降链表-中等" class="headerlink" title="115. 排序奇升偶降链表-中等"></a><font color=DarkOrange>115. 排序奇升偶降链表-中等</font></h4><p><strong>题目：</strong></p><p>字节跳动高频题</p><p><strong>思路：</strong></p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="116-二叉树的完全性检验-中等"><a href="#116-二叉树的完全性检验-中等" class="headerlink" title="116. 二叉树的完全性检验-中等"></a><font color=DarkOrange>116. 二叉树的完全性检验-中等</font></h4><p><strong>题目：</strong></p><p>给定一个二叉树的 <code>root</code> ，确定它是否是一个完全二叉树</p><p>在一个 <strong>完全二叉树</strong> 中，除了最后一个关卡外，所有关卡都是完全被填满的，并且最后一个关卡中的所有节点都是尽可能靠左的。它可以包含 <code>1</code> 到 <code>2h</code> 节点之间的最后一级 <code>h</code> </p><p><strong>思路：</strong></p><p>广度优先搜索</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="117-检测循环依赖-中等"><a href="#117-检测循环依赖-中等" class="headerlink" title="117. 检测循环依赖-中等"></a><font color=DarkOrange>117. 检测循环依赖-中等</font></h4><p><strong>题目：</strong></p><p>补充题</p><p><strong>思路：</strong></p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="118-二叉搜索树的第k大节点-简单"><a href="#118-二叉搜索树的第k大节点-简单" class="headerlink" title="118. 二叉搜索树的第k大节点-简单"></a><font color=DarkOrange>118. 二叉搜索树的第k大节点-简单</font></h4><p><strong>题目：</strong></p><p>给定一棵二叉搜索树，请找出其中第 k 大的节点的值</p><p><strong>思路：</strong></p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="119-盛最多水的容器-中等"><a href="#119-盛最多水的容器-中等" class="headerlink" title="119. 盛最多水的容器-中等"></a><font color=DarkOrange>119. 盛最多水的容器-中等</font></h4><p><strong>题目：</strong></p><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> </p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水</p><p>返回容器可以储存的最大水量</p><p><strong>说明：</strong>你不能倾斜容器</p><p><strong>思路：</strong></p><p>双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="120-单词搜索-中等"><a href="#120-单词搜索-中等" class="headerlink" title="120. 单词搜索-中等"></a><font color=DarkOrange>120. 单词搜索-中等</font></h4><p><strong>题目：</strong></p><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> </p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用</p><p><strong>思路：</strong></p><p>回溯</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="121-青蛙跳台阶问题-简单"><a href="#121-青蛙跳台阶问题-简单" class="headerlink" title="121. 青蛙跳台阶问题-简单"></a><font color=DarkOrange>121. 青蛙跳台阶问题-简单</font></h4><p><strong>题目：</strong></p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1</p><p><strong>思路：</strong></p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="122-组合总和-II-中等"><a href="#122-组合总和-II-中等" class="headerlink" title="122. 组合总和 II-中等"></a><font color=DarkOrange>122. 组合总和 II-中等</font></h4><p><strong>题目：</strong></p><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> </p><p><strong>注意：</strong>解集不能包含重复的组合</p><p><strong>思路：</strong></p><p>回溯</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="123-跳跃游戏-中等"><a href="#123-跳跃游戏-中等" class="headerlink" title="123. 跳跃游戏-中等"></a><font color=DarkOrange>123. 跳跃游戏-中等</font></h4><p><strong>题目：</strong></p><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> </p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度</p><p>判断你是否能够到达最后一个下标</p><p><strong>思路：</strong></p><p>贪心</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="124-二叉树的后序遍历-简单"><a href="#124-二叉树的后序遍历-简单" class="headerlink" title="124. 二叉树的后序遍历-简单"></a><font color=DarkOrange>124. 二叉树的后序遍历-简单</font></h4><p><strong>题目：</strong></p><p>给你一棵二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>后序遍历</strong> </p><p><strong>思路：</strong></p><p>方法一：递归</p><p>方法二：迭代</p><p>方法三：Morris 遍历</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="125-数组中的逆序对-困难"><a href="#125-数组中的逆序对-困难" class="headerlink" title="125. 数组中的逆序对-困难"></a><font color=DarkOrange>125. 数组中的逆序对-困难</font></h4><p><strong>题目：</strong></p><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数</p><p><strong>思路：</strong></p><p>方法一：归并排序</p><p>方法二：离散化树状数组</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="126-螺旋矩阵-II-中等"><a href="#126-螺旋矩阵-II-中等" class="headerlink" title="126. 螺旋矩阵 II-中等"></a><font color=DarkOrange>126. 螺旋矩阵 II-中等</font></h4><p><strong>题目：</strong></p><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> </p><p><strong>思路：</strong></p><p>模拟</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="127-搜索二维矩阵-中等"><a href="#127-搜索二维矩阵-中等" class="headerlink" title="127. 搜索二维矩阵-中等"></a><font color=DarkOrange>127. 搜索二维矩阵-中等</font></h4><p><strong>题目：</strong></p><p>编写一个高效的算法来判断 <code>m x n</code> 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><ul><li>每行中的整数从左到右按升序排列</li><li>每行的第一个整数大于前一行的最后一个整数</li></ul><p><strong>思路：</strong></p><p>方法一：两次二分查找</p><p>方法二：一次二分查找</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="128-删除有序数组中的重复项-简单"><a href="#128-删除有序数组中的重复项-简单" class="headerlink" title="128. 删除有序数组中的重复项-简单"></a><font color=DarkOrange>128. 删除有序数组中的重复项-简单</font></h4><p><strong>题目：</strong></p><p>给你一个 <strong>升序排列</strong> 的数组 <code>nums</code> ，请你<strong>原地</strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong></p><p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 <code>k</code> 个元素，那么 <code>nums</code> 的前 <code>k</code> 个元素应该保存最终结果</p><p>将最终结果插入 <code>nums</code> 的前 <code>k</code> 个位置后返回 <code>k</code> </p><p>不要使用额外的空间，你必须在 <strong>原地修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成</p><p><strong>思路：</strong></p><p>双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="129-圆环回原点问题-中等"><a href="#129-圆环回原点问题-中等" class="headerlink" title="129. 圆环回原点问题-中等"></a><font color=DarkOrange>129. 圆环回原点问题-中等</font></h4><p><strong>题目：</strong></p><p>字节跳动高频题</p><p><strong>思路：</strong></p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="130-全排列-II-中等"><a href="#130-全排列-II-中等" class="headerlink" title="130. 全排列 II-中等"></a><font color=DarkOrange>130. 全排列 II-中等</font></h4><p><strong>题目：</strong></p><p>给定一个可包含重复数字的序列 <code>nums</code> ，<strong>按任意顺序</strong> 返回所有不重复的全排列</p><p><strong>思路：</strong></p><p>搜索回溯</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="131-零钱兑换-II-中等"><a href="#131-零钱兑换-II-中等" class="headerlink" title="131. 零钱兑换 II-中等"></a><font color=DarkOrange>131. 零钱兑换 II-中等</font></h4><p><strong>题目：</strong></p><p><strong>思路：</strong></p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="132-斐波那契数列-简单"><a href="#132-斐波那契数列-简单" class="headerlink" title="132. 斐波那契数列-简单"></a><font color=DarkOrange>132. 斐波那契数列-简单</font></h4><p><strong>题目：</strong></p><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1</p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：矩阵快速幂</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="133-Pow-x-n-中等"><a href="#133-Pow-x-n-中等" class="headerlink" title="133. Pow(x, n)-中等"></a><font color=DarkOrange>133. Pow(x, n)-中等</font></h4><p><strong>题目：</strong></p><p>实现pow(x, n) ，即计算 <code>x</code> 的整数 <code>n</code> 次幂函数（即，<code>x^n</code> ）</p><p><strong>思路：</strong></p><p>方法一：快速幂 + 递归</p><p>方法二：快速幂 + 迭代</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="134-旋转链表-中等"><a href="#134-旋转链表-中等" class="headerlink" title="134. 旋转链表-中等"></a><font color=DarkOrange>134. 旋转链表-中等</font></h4><p><strong>题目：</strong></p><p>给你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动 <code>k</code> 个位置</p><p><strong>思路：</strong></p><p>闭合为环</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="135-删除二叉搜索树中的节点-中等"><a href="#135-删除二叉搜索树中的节点-中等" class="headerlink" title="135. 删除二叉搜索树中的节点-中等"></a><font color=DarkOrange>135. 删除二叉搜索树中的节点-中等</font></h4><p><strong>题目：</strong></p><p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点</li><li>如果找到了，删除它</li></ol><p><strong>思路：</strong></p><p>方法一：递归</p><p>方法二：迭代</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="136-最小的k个数-简单"><a href="#136-最小的k个数-简单" class="headerlink" title="136. 最小的k个数-简单"></a><font color=DarkOrange>136. 最小的k个数-简单</font></h4><p><strong>题目：</strong></p><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4</p><p><strong>思路：</strong></p><p>方法一：排序</p><p>方法二：堆</p><p>方法三：快排思想</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="137-卖股票的最佳时机-III-困难"><a href="#137-卖股票的最佳时机-III-困难" class="headerlink" title="137. 卖股票的最佳时机 III-困难"></a><font color=DarkOrange>137. 卖股票的最佳时机 III-困难</font></h4><p><strong>题目：</strong></p><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）</p><p><strong>思路：</strong></p><p>动态规划</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="138-整数反转-简单"><a href="#138-整数反转-简单" class="headerlink" title="138. 整数反转-简单"></a><font color=DarkOrange>138. 整数反转-简单</font></h4><p><strong>题目：</strong></p><p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果</p><p>如果反转后整数超过 32 位的有符号整数的范围 <code>[−2^31, 2^31 − 1]</code> ，就返回 0</p><p><strong>假设环境不允许存储 64 位整数（有符号或无符号）</strong></p><p><strong>思路：</strong></p><p>数学</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="139-连续子数组的最大和-简单"><a href="#139-连续子数组的最大和-简单" class="headerlink" title="139. 连续子数组的最大和-简单"></a><font color=DarkOrange>139. 连续子数组的最大和-简单</font></h4><p><strong>题目：</strong></p><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值</p><p>要求时间复杂度为O(n)</p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：分治</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="140-整数组顺序使奇数位于偶数前面-简单"><a href="#140-整数组顺序使奇数位于偶数前面-简单" class="headerlink" title="140. 整数组顺序使奇数位于偶数前面-简单"></a><font color=DarkOrange>140. 整数组顺序使奇数位于偶数前面-简单</font></h4><p><strong>题目：</strong></p><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分</p><p><strong>思路：</strong></p><p>方法一：两次遍历</p><p>方法二：双指针 + 一次遍历</p><p>方法三：原地交换</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="141-二叉搜索树中第K小的元素-中等"><a href="#141-二叉搜索树中第K小的元素-中等" class="headerlink" title="141. 二叉搜索树中第K小的元素-中等"></a><font color=DarkOrange>141. 二叉搜索树中第K小的元素-中等</font></h4><p><strong>题目：</strong></p><p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）</p><p><strong>思路：</strong></p><p>方法一：中序遍历</p><p>方法二：记录子树的结点数</p><p>方法三：平衡二叉搜索树</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="142-用队列实现栈-简单"><a href="#142-用队列实现栈-简单" class="headerlink" title="142. 用队列实现栈-简单"></a><font color=DarkOrange>142. 用队列实现栈-简单</font></h4><p><strong>题目：</strong></p><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）</p><p>实现 <code>MyStack</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 压入栈顶</li><li><code>int pop()</code> 移除并返回栈顶元素</li><li><code>int top()</code> 返回栈顶元素</li><li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><p><strong>注意：</strong></p><ul><li>你只能使用队列的基本操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作</li><li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可</li></ul><p><strong>思路：</strong></p><p>方法一：两个队列</p><p>方法二：一个队列</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="143-字典序的第K小数字-困难"><a href="#143-字典序的第K小数字-困难" class="headerlink" title="143. 字典序的第K小数字-困难"></a><font color=DarkOrange>143. 字典序的第K小数字-困难</font></h4><p><strong>题目：</strong></p><p>给定整数 <code>n</code> 和 <code>k</code>，返回 <code>[1, n]</code> 中字典序第 <code>k</code> 小的数字</p><p><strong>思路：</strong></p><p>字典树思想</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="144-分发糖果-困难"><a href="#144-分发糖果-困难" class="headerlink" title="144. 分发糖果-困难"></a><font color=DarkOrange>144. 分发糖果-困难</font></h4><p><strong>题目：</strong></p><p><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 <code>1</code> 个糖果</li><li>相邻两个孩子评分更高的孩子会获得更多的糖果</li></ul><p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> </p><p><strong>思路：</strong></p><p>方法一：两次遍历</p><p>方法二：常数空间遍历</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="145-圆圈中最后剩下的数字-简单"><a href="#145-圆圈中最后剩下的数字-简单" class="headerlink" title="145. 圆圈中最后剩下的数字-简单"></a><font color=DarkOrange>145. 圆圈中最后剩下的数字-简单</font></h4><p><strong>题目：</strong></p><p>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字</p><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3</p><p><strong>思路：</strong></p><p>方法一：数学 + 递归</p><p>方法二：数学 + 迭代</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="146-颜色分类-中等"><a href="#146-颜色分类-中等" class="headerlink" title="146. 颜色分类-中等"></a><font color=DarkOrange>146. 颜色分类-中等</font></h4><p><strong>题目：</strong></p><p>给定一个包含红色、白色和蓝色、共 <code>n</code> 个元素的数组 <code>nums</code> ，<strong>原地</strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列</p><p>我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色</p><p>必须在不使用库的sort函数的情况下解决这个问题</p><p><strong>思路：</strong></p><p>方法一：单指针</p><p>方法二：双指针</p><p>方法三：双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="147-矩阵中的最长递增路径-困难"><a href="#147-矩阵中的最长递增路径-困难" class="headerlink" title="147. 矩阵中的最长递增路径-困难"></a><font color=DarkOrange>147. 矩阵中的最长递增路径-困难</font></h4><p><strong>题目：</strong></p><p>给定一个 <code>m x n</code> 整数矩阵 <code>matrix</code> ，找出其中 <strong>最长递增路径</strong> 的长度</p><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你 <strong>不能</strong> 在 <strong>对角线</strong> 方向上移动或移动到 <strong>边界外</strong>（即不允许环绕）</p><p><strong>思路：</strong></p><p>方法一：记忆化深度优先搜索</p><p>方法二：拓扑排序</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="148-二维数组中的查找-中等"><a href="#148-二维数组中的查找-中等" class="headerlink" title="148. 二维数组中的查找-中等"></a><font color=DarkOrange>148. 二维数组中的查找-中等</font></h4><p><strong>题目：</strong></p><p>在一个 n * m 的二维数组中，每一行都按照从左到右 <strong>非递减</strong> 的顺序排序，每一列都按照从上到下 <strong>非递减</strong> 的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数</p><p><strong>思路：</strong></p><p>方法一：直接查找</p><p>方法二：二分查找</p><p>方法三：Z 字形查找</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="149-奇偶链表-中等"><a href="#149-奇偶链表-中等" class="headerlink" title="149. 奇偶链表-中等"></a><font color=DarkOrange>149. 奇偶链表-中等</font></h4><p><strong>题目：</strong></p><p>给定单链表的头节点 <code>head</code> ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表</p><p><strong>第一个</strong>节点的索引被认为是 <strong>奇数</strong> ， <strong>第二个</strong>节点的索引为 <strong>偶数</strong> ，以此类推</p><p>请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致</p><p>你必须在 <code>O(1)</code> 的额外空间复杂度和 <code>O(n)</code> 的时间复杂度下解决这个问题</p><p><strong>思路：</strong></p><p>分离节点后合并</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="150-解码方法-中等"><a href="#150-解码方法-中等" class="headerlink" title="150. 解码方法-中等"></a><font color=DarkOrange>150. 解码方法-中等</font></h4><p><strong>题目：</strong></p><p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;A&#x27;</span> -&gt; <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="string">&#x27;B&#x27;</span> -&gt; <span class="string">&quot;2&quot;</span></span><br><span class="line">...</span><br><span class="line"><span class="string">&#x27;Z&#x27;</span> -&gt; <span class="string">&quot;26&quot;</span></span><br></pre></td></tr></table></figure><p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>&quot;11106&quot;</code> 可以映射为：</p><ul><li><code>&quot;AAJF&quot;</code> ，将消息分组为 <code>(1 1 10 6)</code></li><li><code>&quot;KJF&quot;</code> ，将消息分组为 <code>(11 10 6)</code></li></ul><p>注意，消息不能分组为 <code>(1 11 06)</code> ，因为 <code>&quot;06&quot;</code> 不能映射为 <code>&quot;F&quot;</code> ，这是由于 <code>&quot;6&quot;</code> 和 <code>&quot;06&quot;</code> 在映射中并不等价</p><p>给你一个只含数字的 <strong>非空</strong> 字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> </p><p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数</p><p><strong>思路：</strong></p><p>动态规划</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="151-另一棵树的子树-简单"><a href="#151-另一棵树的子树-简单" class="headerlink" title="151. 另一棵树的子树-简单"></a><font color=DarkOrange>151. 另一棵树的子树-简单</font></h4><p><strong>题目：</strong></p><p>给你两棵二叉树 <code>root</code> 和 <code>subRoot</code> 。检验 <code>root</code> 中是否包含和 <code>subRoot</code> 具有相同结构和节点值的子树。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> </p><p>二叉树 <code>tree</code> 的一棵子树包括 <code>tree</code> 的某个节点和这个节点的所有后代节点。<code>tree</code> 也可以看做它自身的一棵子树</p><p><strong>思路：</strong></p><p>方法一：深度优先搜索暴力匹配</p><p>方法二：深度优先搜索序列上做串匹配</p><p>方法三：树哈希</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="152-打乱数组-中等"><a href="#152-打乱数组-中等" class="headerlink" title="152. 打乱数组-中等"></a><font color=DarkOrange>152. 打乱数组-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数数组 <code>nums</code> ，设计算法来打乱一个没有重复元素的数组。打乱后，数组的所有排列应该是 <strong>等可能</strong> 的</p><p>实现 <code>Solution</code> class：</p><ul><li><code>Solution(int[] nums)</code> 使用整数数组 <code>nums</code> 初始化对象</li><li><code>int[] reset()</code> 重设数组到它的初始状态并返回</li><li><code>int[] shuffle()</code> 返回数组随机打乱后的结果</li></ul><p><strong>思路：</strong></p><p>方法一：暴力</p><p>方法二：Fisher-Yates 洗牌算法</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="153-验证回文串-简单"><a href="#153-验证回文串-简单" class="headerlink" title="153. 验证回文串-简单"></a><font color=DarkOrange>153. 验证回文串-简单</font></h4><p><strong>题目：</strong></p><p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 <strong>回文串</strong> </p><p>字母和数字都属于字母数字字符</p><p>给你一个字符串 <code>s</code>，如果它是 <strong>回文串</strong> ，返回 <code>true</code> ；否则，返回 <code>false</code> </p><p><strong>思路：</strong></p><p>方法一：筛选 + 判断</p><p>方法二：在原字符串上直接判断</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="154-回文数-简单"><a href="#154-回文数-简单" class="headerlink" title="154. 回文数-简单"></a><font color=DarkOrange>154. 回文数-简单</font></h4><p><strong>题目：</strong></p><p>给你一个整数 <code>x</code> ，如果 <code>x</code> 是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code> </p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数</p><ul><li>例如，<code>121</code> 是回文，而 <code>123</code> 不是</li></ul><p><strong>思路：</strong></p><p>反转一半数字</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="154-轮转数组-中等"><a href="#154-轮转数组-中等" class="headerlink" title="154. 轮转数组-中等"></a><font color=DarkOrange>154. 轮转数组-中等</font></h4><p><strong>题目：</strong></p><p>给你一个数组，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数</p><p><strong>思路：</strong></p><p>方法一：使用额外的数组</p><p>方法二：环状替换</p><p>方法三：数组翻转</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="155-跳跃游戏-II-中等"><a href="#155-跳跃游戏-II-中等" class="headerlink" title="155. 跳跃游戏 II-中等"></a><font color=DarkOrange>155. 跳跃游戏 II-中等</font></h4><p><strong>题目：</strong></p><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的第一个位置</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置</p><p>假设你总是可以到达数组的最后一个位置</p><p><strong>思路：</strong></p><p>方法一：反向查找出发位置</p><p>方法二：正向查找可到达的最大位置</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="157-两数相加-II-中等"><a href="#157-两数相加-II-中等" class="headerlink" title="157. 两数相加 II-中等"></a><font color=DarkOrange>157. 两数相加 II-中等</font></h4><p><strong>题目：</strong></p><p>给你两个 <strong>非空</strong> 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头</p><p><strong>思路：</strong></p><p>栈</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="158-二叉树的镜像-简单"><a href="#158-二叉树的镜像-简单" class="headerlink" title="158. 二叉树的镜像-简单"></a><font color=DarkOrange>158. 二叉树的镜像-简单</font></h4><p><strong>题目：</strong></p><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h88ink6q3sj30hk0fi752.jpg" alt="image.png" style="zoom:67%;" /></div><p><strong>思路：</strong></p><p>递归</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="159-寻找重复数-中等"><a href="#159-寻找重复数-中等" class="headerlink" title="159. 寻找重复数-中等"></a><font color=DarkOrange>159. 寻找重复数-中等</font></h4><p><strong>题目：</strong></p><p>给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code> ，其数字都在 <code>[1, n]</code> 范围内（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数</p><p>假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，返回 <strong>这个重复的数</strong> </p><p>你设计的解决方案必须 <strong>不修改</strong> 数组 <code>nums</code> 且只用常量级 <code>O(1)</code> 的额外空间</p><p><strong>思路：</strong></p><p>方法一：二分查找</p><p>方法二：二进制</p><p>方法三：快慢指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="160-实现-Trie-前缀树-中等"><a href="#160-实现-Trie-前缀树-中等" class="headerlink" title="160. 实现 Trie (前缀树)-中等"></a><font color=DarkOrange>160. 实现 Trie (前缀树)-中等</font></h4><p><strong>题目：</strong></p><p><strong>Trie</strong>（发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查</p><p>请你实现 Trie 类：</p><ul><li><code>Trie()</code> 初始化前缀树对象</li><li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> </li><li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> </li><li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><p><strong>思路：</strong></p><p>字典树</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="161-数据流的中位数-困难"><a href="#161-数据流的中位数-困难" class="headerlink" title="161. 数据流的中位数-困难"></a><font color=DarkOrange>161. 数据流的中位数-困难</font></h4><p><strong>题目：</strong></p><p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><ul><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中</li><li>double findMedian() - 返回目前所有元素的中位数</li></ul><p><strong>思路：</strong></p><p>方法一：优先队列</p><p>方法二：有序集合 + 双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="162-二叉树展开为链表-中等"><a href="#162-二叉树展开为链表-中等" class="headerlink" title="162. 二叉树展开为链表-中等"></a><font color=DarkOrange>162. 二叉树展开为链表-中等</font></h4><p><strong>题目：</strong></p><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> </li><li>展开后的单链表应该与二叉树 <strong>先序遍历</strong> 顺序相同</li></ul><p><strong>思路：</strong></p><p>方法一：前序遍历</p><p>方法二：前序遍历和展开同步进行</p><p>方法三：寻找前驱节点</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="163-接近的三数之和-中等"><a href="#163-接近的三数之和-中等" class="headerlink" title="163. 接近的三数之和-中等"></a><font color=DarkOrange>163. 接近的三数之和-中等</font></h4><p><strong>题目：</strong></p><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 和 一个目标值 <code>target</code>。请你从 <code>nums</code> 中选出三个整数，使它们的和与 <code>target</code> 最接近</p><p>返回这三个数的和</p><p>假定每组输入只存在恰好一个解</p><p><strong>思路：</strong></p><p>排序 + 双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="164-打家劫舍-II-中等"><a href="#164-打家劫舍-II-中等" class="headerlink" title="164. 打家劫舍 II-中等"></a><font color=DarkOrange>164. 打家劫舍 II-中等</font></h4><p><strong>题目：</strong></p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> </p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额</p><p><strong>思路：</strong></p><p>动态规划</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="165-三角形最小路径和-中等"><a href="#165-三角形最小路径和-中等" class="headerlink" title="165. 三角形最小路径和-中等"></a><font color=DarkOrange>165. 三角形最小路径和-中等</font></h4><p><strong>题目：</strong></p><p>给定一个三角形 <code>triangle</code> ，找出自顶向下的最小路径和</p><p>每一步只能移动到下一行中相邻的结点上。<strong>相邻的结点</strong> 在这里指的是 <strong>下标</strong> 与 <strong>上一层结点下标</strong> 相同或者等于 <strong>上一层结点下标 + 1</strong> 的两个结点。也就是说，如果正位于当前行的下标 <code>i</code> ，那么下一步可以移动到下一行的下标 <code>i</code> 或 <code>i + 1</code> </p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：动态规划 + 空间优化</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="166-顺时针打印矩阵-简单"><a href="#166-顺时针打印矩阵-简单" class="headerlink" title="166. 顺时针打印矩阵-简单"></a><font color=DarkOrange>166. 顺时针打印矩阵-简单</font></h4><p><strong>题目：</strong></p><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字</p><p><strong>思路：</strong></p><p>方法一：模拟</p><p>方法二：按层模拟</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="167-正则表达式匹配-困难"><a href="#167-正则表达式匹配-困难" class="headerlink" title="167. 正则表达式匹配-困难"></a><font color=DarkOrange>167. 正则表达式匹配-困难</font></h4><p><strong>题目：</strong></p><p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配</p><ul><li><code>&#39;.&#39;</code> 匹配任意单个字符</li><li><code>&#39;*&#39;</code> 匹配零个或多个前面的那一个元素</li></ul><p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 <code>s</code>的，而不是部分字符串</p><p><strong>思路：</strong></p><p>动态规划</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="168-从中序与后序遍历序列构造二叉树-中等"><a href="#168-从中序与后序遍历序列构造二叉树-中等" class="headerlink" title="168. 从中序与后序遍历序列构造二叉树-中等"></a><font color=DarkOrange>168. 从中序与后序遍历序列构造二叉树-中等</font></h4><p><strong>题目：</strong></p><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗二叉树</p><p><strong>思路：</strong></p><p>方法一：递归</p><p>方法二：迭代</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="169-第-N-位数字-中等"><a href="#169-第-N-位数字-中等" class="headerlink" title="169. 第 N 位数字-中等"></a><font color=DarkOrange>169. 第 N 位数字-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数 <code>n</code> ，请你在无限的整数序列 <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...]</code> 中找出并返回第 <code>n</code> 位上的数字</p><p><strong>思路：</strong></p><p>方法一：二分查找</p><p>方法二：直接计算</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="170-树的子结构-中等"><a href="#170-树的子结构-中等" class="headerlink" title="170. 树的子结构-中等"></a><font color=DarkOrange>170. 树的子结构-中等</font></h4><p><strong>题目：</strong></p><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h88j43kz1xj30p60gw40b.jpg" alt="image.png" style="zoom:67%;" /></div><p><strong>思路：</strong></p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="171-链表求和-中等"><a href="#171-链表求和-中等" class="headerlink" title="171. 链表求和-中等"></a><font color=DarkOrange>171. 链表求和-中等</font></h4><p><strong>题目：</strong></p><p>给定两个用链表表示的整数，每个节点包含一个数位</p><p>这些数位是反向存放的，也就是个位排在链表首部</p><p>编写函数对这两个整数求和，并用链表形式返回结果</p><p><strong>思路：</strong></p><p>模拟</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="172-有效的括号字符串-中等"><a href="#172-有效的括号字符串-中等" class="headerlink" title="172. 有效的括号字符串-中等"></a><font color=DarkOrange>172. 有效的括号字符串-中等</font></h4><p><strong>题目：</strong></p><p>给定一个只包含三种字符的字符串：<code>（ </code>，<code>）</code> 和 <code>*</code>，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：</p><ol><li>任何左括号 <code>(</code> 必须有相应的右括号 <code>)</code></li><li>任何右括号 <code>)</code> 必须有相应的左括号 <code>(</code> </li><li>左括号 <code>(</code> 必须在对应的右括号之前 <code>)</code></li><li><code>*</code> 可以被视为单个右括号 <code>)</code> ，或单个左括号 <code>(</code> ，或一个空字符串</li><li>一个空字符串也被视为有效字符串</li></ol><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：栈</p><p>方法三：贪心</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="173-两个链表的第一个公共节点-简单"><a href="#173-两个链表的第一个公共节点-简单" class="headerlink" title="173. 两个链表的第一个公共节点-简单"></a><font color=DarkOrange>173. 两个链表的第一个公共节点-简单</font></h4><p><strong>题目：</strong></p><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h88j86dqzej30lk0c6myc.jpg" alt="image.png" style="zoom:67%;" /></div><p><strong>思路：</strong></p><p>方法一：哈希集合</p><p>方法二：双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="174-前-K-个高频元素-中等"><a href="#174-前-K-个高频元素-中等" class="headerlink" title="174. 前 K 个高频元素-中等"></a><font color=DarkOrange>174. 前 K 个高频元素-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案</p><p><strong>思路：</strong></p><p>方法一：堆</p><p>方法二：基于快速排序</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="175-不同的二叉搜索树-中等"><a href="#175-不同的二叉搜索树-中等" class="headerlink" title="175. 不同的二叉搜索树-中等"></a><font color=DarkOrange>175. 不同的二叉搜索树-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数</p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：数学</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="176-两个数组的交集-简单"><a href="#176-两个数组的交集-简单" class="headerlink" title="176. 两个数组的交集-简单"></a><font color=DarkOrange>176. 两个数组的交集-简单</font></h4><p><strong>题目：</strong></p><p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回它们的交集 。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> </p><p><strong>思路：</strong></p><p>方法一：两个集合</p><p>方法二：排序 + 双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="177-36进制加法-中等"><a href="#177-36进制加法-中等" class="headerlink" title="177. 36进制加法-中等"></a><font color=DarkOrange>177. 36进制加法-中等</font></h4><p><strong>题目：</strong></p><p>字节高频题</p><p><strong>思路：</strong><br><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="178-数组中出现次数超过一半的数字-简单"><a href="#178-数组中出现次数超过一半的数字-简单" class="headerlink" title="178. 数组中出现次数超过一半的数字-简单"></a><font color=DarkOrange>178. 数组中出现次数超过一半的数字-简单</font></h4><p><strong>题目：</strong></p><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素</p><p><strong>思路：</strong></p><p>方法一：哈希表</p><p>方法二：排序</p><p>方法三：随机化</p><p>方法四：分治</p><p>方法五：Boyer-Moore 投票算法</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="179-Excel表列名称-简单"><a href="#179-Excel表列名称-简单" class="headerlink" title="179. Excel表列名称-简单"></a><font color=DarkOrange>179. Excel表列名称-简单</font></h4><p><strong>题目：</strong></p><p>给你一个整数 <code>columnNumber</code> ，返回它在 Excel 表中相对应的列名称</p><p>例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>数学</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="180-扑克牌中的顺子-简单"><a href="#180-扑克牌中的顺子-简单" class="headerlink" title="180. 扑克牌中的顺子-简单"></a><font color=DarkOrange>180. 扑克牌中的顺子-简单</font></h4><p><strong>题目：</strong></p><p>从<strong>若干副扑克牌</strong>中随机抽 <code>5</code> 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14</p><p><strong>思路：</strong></p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="181-鸡蛋掉落-困难"><a href="#181-鸡蛋掉落-困难" class="headerlink" title="181. 鸡蛋掉落-困难"></a><font color=DarkOrange>181. 鸡蛋掉落-困难</font></h4><p><strong>题目：</strong></p><p>给你 <code>k</code> 枚相同的鸡蛋，并可以使用一栋从第 <code>1</code> 层到第 <code>n</code> 层共有 <code>n</code> 层楼的建筑</p><p>已知存在楼层 <code>f</code> ，满足 <code>0 &lt;= f &lt;= n</code> ，任何从 <strong>高于</strong> <code>f</code> 的楼层落下的鸡蛋都会碎，从 <code>f</code> 楼层或比它低的楼层落下的鸡蛋都不会破</p><p>每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 <code>x</code> 扔下（满足 <code>1 &lt;= x &lt;= n</code>）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 <strong>重复使用</strong> 这枚鸡蛋</p><p>请你计算并返回要确定 <code>f</code> <strong>确切的值</strong> 的 <strong>最小操作次数</strong> 是多少？</p><p><strong>思路：</strong></p><p>方法一：动态规划 + 二分查找</p><p>方法二：决策单调性</p><p>方法三：数学法</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="182-最长递增子序列的个数-中等"><a href="#182-最长递增子序列的个数-中等" class="headerlink" title="182. 最长递增子序列的个数-中等"></a><font color=DarkOrange>182. 最长递增子序列的个数-中等</font></h4><p><strong>题目：</strong></p><p>给定一个未排序的整数数组 <code>nums</code> ， 返回最长递增子序列的个数</p><p><strong>注意</strong> 这个数列必须是 <strong>严格</strong> 递增的</p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：贪心 + 前缀和 + 二分查找</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="183-简化路径-中等"><a href="#183-简化路径-中等" class="headerlink" title="183. 简化路径-中等"></a><font color=DarkOrange>183. 简化路径-中等</font></h4><p><strong>题目：</strong></p><p>给你一个字符串 <code>path</code> ，表示指向某一文件或目录的 Unix 风格 <strong>绝对路径</strong> （以 <code>&#39;/&#39;</code> 开头），请你将其转化为更加简洁的规范路径</p><p>在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，<code>&#39;//&#39;</code>）都被视为单个斜杠 <code>&#39;/&#39;</code> 。 对于此问题，任何其他格式的点（例如，<code>&#39;...&#39;</code>）均被视为文件&#x2F;目录名称</p><p>请注意，返回的 <strong>规范路径</strong> 必须遵循下述格式：</p><ul><li>始终以斜杠 <code>&#39;/&#39;</code> 开头</li><li>两个目录名之间必须只有一个斜杠 <code>&#39;/&#39;</code> </li><li>最后一个目录名（如果存在）<strong>不能</strong> 以 <code>&#39;/&#39;</code> 结尾</li><li>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 <code>&#39;.&#39;</code> 或 <code>&#39;..&#39;</code>）</li></ul><p>返回简化后得到的 <strong>规范路径</strong> </p><p><strong>思路：</strong></p><p>栈</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="184-数组中重复的数据-中等"><a href="#184-数组中重复的数据-中等" class="headerlink" title="184. 数组中重复的数据-中等"></a><font color=DarkOrange>184. 数组中重复的数据-中等</font></h4><p><strong>题目：</strong></p><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，其中 <code>nums</code> 的所有整数都在范围 <code>[1, n]</code> 内，且每个整数出现 <strong>一次</strong> 或 <strong>两次</strong> 。请你找出所有出现 <strong>两次</strong> 的整数，并以数组形式返回</p><p>你必须设计并实现一个时间复杂度为 <code>O(n)</code> 且仅使用常量额外空间的算法解决此问题</p><p><strong>思路：</strong></p><p>方法一：将元素交换到对应的位置</p><p>方法二：使用正负号作为标记</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="185-斐波那契数-简单"><a href="#185-斐波那契数-简单" class="headerlink" title="185. 斐波那契数-简单"></a><font color=DarkOrange>185. 斐波那契数-简单</font></h4><p><strong>题目：</strong></p><p><strong>斐波那契数</strong> （通常用 <code>F(n)</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0，F(1) = 1</span><br><span class="line">F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</span><br></pre></td></tr></table></figure><p>给定 <code>n</code> ，请计算 <code>F(n)</code> </p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：矩阵快速幂</p><p>方法三：通项公式</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="186-删除字符串中的所有相邻重复项-简单"><a href="#186-删除字符串中的所有相邻重复项-简单" class="headerlink" title="186. 删除字符串中的所有相邻重复项-简单"></a><font color=DarkOrange>186. 删除字符串中的所有相邻重复项-简单</font></h4><p><strong>题目：</strong></p><p>给出由小写字母组成的字符串 <code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一</p><p><strong>思路：</strong></p><p>栈</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="187-加油站-中等"><a href="#187-加油站-中等" class="headerlink" title="187. 加油站-中等"></a><font color=DarkOrange>187. 加油站-中等</font></h4><p><strong>题目：</strong></p><p>在一条环路上有 <code>n</code> 个加油站，其中第 <code>i</code> 个加油站有汽油 <code>gas[i]</code> 升</p><p>你有一辆油箱容量无限的的汽车，从第 <code>i</code> 个加油站开往第 <code>i+1</code> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空</p><p>给定两个整数数组 <code>gas</code> 和 <code>cost</code> ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 <code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的</p><p><strong>思路：</strong></p><p>一次遍历</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="188-有效三角形的个数-中等"><a href="#188-有效三角形的个数-中等" class="headerlink" title="188. 有效三角形的个数-中等"></a><font color=DarkOrange>188. 有效三角形的个数-中等</font></h4><p><strong>题目：</strong></p><p>给定一个包含非负整数的数组 <code>nums</code> ，返回其中可以组成三角形三条边的三元组个数</p><p><strong>思路：</strong></p><p>方法一：排序 + 二分查找</p><p>方法二：排序 + 双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="189-最大连续1的个数-III-中等"><a href="#189-最大连续1的个数-III-中等" class="headerlink" title="189. 最大连续1的个数 III-中等"></a><font color=DarkOrange>189. 最大连续1的个数 III-中等</font></h4><p><strong>题目：</strong></p><p>给定一个二进制数组 <code>nums</code> 和一个整数 <code>k</code>，如果可以翻转最多 <code>k</code> 个 <code>0</code> ，则返回数组中连续 <code>1</code> 的最大个数 </p><p><strong>思路：</strong></p><p>方法一：二分查找</p><p>方法二：滑动窗口</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="190-二叉树中和为某一值的路径-中等"><a href="#190-二叉树中和为某一值的路径-中等" class="headerlink" title="190. 二叉树中和为某一值的路径-中等"></a><font color=DarkOrange>190. 二叉树中和为某一值的路径-中等</font></h4><p><strong>题目：</strong></p><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径</p><p><strong>叶子节点</strong> 是指没有子节点的节点</p><p><strong>思路：</strong></p><p>方法一：深度优先搜索</p><p>方法二：广度优先搜索</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="191-在排序数组中查找数字-I-简单"><a href="#191-在排序数组中查找数字-I-简单" class="headerlink" title="191. 在排序数组中查找数字 I-简单"></a><font color=DarkOrange>191. 在排序数组中查找数字 I-简单</font></h4><p><strong>题目：</strong></p><p>统计一个数字在排序数组中出现的次数</p><p><strong>思路：</strong></p><p>二分查找</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="192-分隔链表-中等"><a href="#192-分隔链表-中等" class="headerlink" title="192. 分隔链表-中等"></a><font color=DarkOrange>192. 分隔链表-中等</font></h4><p><strong>题目：</strong></p><p>给你一个链表的头节点 <code>head</code> 和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有 <strong>小于</strong> <code>x</code> 的节点都出现在 <strong>大于或等于</strong> <code>x</code> 的节点之前</p><p>你应当 <strong>保留</strong> 两个分区中每个节点的初始相对位置</p><p><strong>思路：</strong></p><p>模拟</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="193-24-点游戏-困难"><a href="#193-24-点游戏-困难" class="headerlink" title="193. 24 点游戏-困难"></a><font color=DarkOrange>193. 24 点游戏-困难</font></h4><p><strong>题目：</strong></p><p>给定一个长度为4的整数数组 <code>cards</code> 。你有 <code>4</code> 张卡片，每张卡片上都包含一个范围在 <code>[1,9]</code> 的数字。您应该使用运算符 <code>[&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;]</code> 和括号 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 将这些卡片上的数字排列成数学表达式，以获得值24</p><p>你须遵守以下规则：</p><ul><li>除法运算符 <code>&#39;/&#39;</code> 表示实数除法，而不是整数除法<ul><li>例如， <code>4 /(1 - 2 / 3)= 4 /(1 / 3)= 12</code></li></ul></li><li>每个运算都在两个数字之间。特别是，不能使用 <code>“-”</code> 作为一元运算符<ul><li>例如，如果 <code>cards =[1,1,1,1]</code> ，则表达式 <code>“-1 -1 -1 -1”</code> 是 <strong>不允许</strong> 的</li></ul></li><li>你不能把数字串在一起<ul><li>例如，如果 <code>cards =[1,2,1,2]</code> ，则表达式 <code>“12 + 12”</code> 无效</li></ul></li></ul><p>如果可以得到这样的表达式，其计算结果为 <code>24</code> ，则返回 <code>true </code>，否则返回 <code>false</code> </p><p><strong>思路：</strong></p><p>回溯</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="194-二叉树的最小深度-简单"><a href="#194-二叉树的最小深度-简单" class="headerlink" title="194. 二叉树的最小深度-简单"></a><font color=DarkOrange>194. 二叉树的最小深度-简单</font></h4><p><strong>题目：</strong></p><p>给定一个二叉树，找出其最小深度</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量</p><p><strong>说明：</strong>叶子节点是指没有子节点的节点</p><p><strong>思路：</strong></p><p>方法一：深度优先搜索</p><p>方法二：广度优先搜索</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="195-下一个更大元素-III-中等"><a href="#195-下一个更大元素-III-中等" class="headerlink" title="195. 下一个更大元素 III-中等"></a><font color=DarkOrange>195. 下一个更大元素 III-中等</font></h4><p><strong>题目：</strong></p><p>给你一个正整数 <code>n</code> ，请你找出符合条件的最小整数，其由重新排列 <code>n</code> 中存在的每位数字组成，并且其值大于 <code>n</code> 。如果不存在这样的正整数，则返回 <code>-1</code> </p><p><strong>注意</strong> ，返回的整数应当是一个 <strong>32 位整数</strong> ，如果存在满足题意的答案，但不是 <strong>32 位整数</strong> ，同样返回 <code>-1</code> </p><p><strong>思路：</strong></p><p>方法一：下一个排列</p><p>方法二：数学</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="196-通配符匹配-困难"><a href="#196-通配符匹配-困难" class="headerlink" title="196. 通配符匹配-困难"></a><font color=DarkOrange>196. 通配符匹配-困难</font></h4><p><strong>题目：</strong></p><p>给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>) ，实现一个支持 <code>&#39;?&#39;</code> 和 <code>&#39;*&#39;</code> 的通配符匹配</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;?&#x27;</span> 可以匹配任何单个字符。</span><br><span class="line"><span class="string">&#x27;*&#x27;</span> 可以匹配任意字符串（包括空字符串）。</span><br></pre></td></tr></table></figure><p>两个字符串<strong>完全匹配</strong>才算匹配成功</p><p><strong>说明:</strong></p><ul><li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母</li><li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>?</code> 和 <code>*</code></li></ul><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：贪心算法</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="197-完全平方数-中等"><a href="#197-完全平方数-中等" class="headerlink" title="197. 完全平方数-中等"></a><font color=DarkOrange>197. 完全平方数-中等</font></h4><p><strong>题目：</strong></p><p>给你一个整数 <code>n</code> ，返回和为 <code>n</code> 的完全平方数的最少数量</p><p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是</p><p><strong>思路：</strong></p><p>方法一：动态规划</p><p>方法二：数学</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="198-解数独-困难"><a href="#198-解数独-困难" class="headerlink" title="198. 解数独-困难"></a><font color=DarkOrange>198. 解数独-困难</font></h4><p><strong>题目：</strong></p><p>编写一个程序，通过填充空格来解决数独问题</p><p>数独的解法需 <strong>遵循如下规则</strong>：</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次</li><li>数字 <code>1-9</code> 在每一列只能出现一次</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次</li></ol><p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示</p><p><strong>思路：</strong></p><p>方法一：回溯</p><p>方法二：位运算优化</p><p>方法三：枚举优化</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="199-阿拉伯数字转中文数字-中等"><a href="#199-阿拉伯数字转中文数字-中等" class="headerlink" title="199. 阿拉伯数字转中文数字-中等"></a><font color=DarkOrange>199. 阿拉伯数字转中文数字-中等</font></h4><p><strong>题目：</strong><br><strong>思路：</strong><br><strong>代码：</strong></p><h4 id="200-反转字符串-简单"><a href="#200-反转字符串-简单" class="headerlink" title="200. 反转字符串-简单"></a><font color=DarkOrange>200. 反转字符串-简单</font></h4><p><strong>题目：</strong></p><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出</p><p>不要给另外的数组分配额外的空间，你必须<strong>原地修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题</p><p><strong>思路：</strong></p><p>双指针</p><p><strong>代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;面试LeetCode算法题整理，按照出现的频率依次递减排序，题目类型包含：简单、中等、困难&lt;/p&gt;
&lt;p&gt;CodeTop地址：&lt;a href=&quot;https://codetop.cc/home&quot;&gt;点击跳转&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备注：&lt;/strong&gt;出现的频</summary>
      
    
    
    
    <category term="面试" scheme="https://huajun-chen.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="算法" scheme="https://huajun-chen.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>云原生15-微服务项目的开发和部署案例</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F15-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%BC%80%E5%8F%91%E5%92%8C%E9%83%A8%E7%BD%B2%E6%A1%88%E4%BE%8B/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F15-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%BC%80%E5%8F%91%E5%92%8C%E9%83%A8%E7%BD%B2%E6%A1%88%E4%BE%8B/</id>
    <published>2022-11-08T15:30:00.000Z</published>
    <updated>2022-11-20T15:18:00.982Z</updated>
    
    <content type="html"><![CDATA[<p>待完成。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;待完成。。。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>云原生14-基于Kubernetes和Istio的安全保证</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F14-%E5%9F%BA%E4%BA%8EKubernetes%E5%92%8CIstio%E7%9A%84%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F14-%E5%9F%BA%E4%BA%8EKubernetes%E5%92%8CIstio%E7%9A%84%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81/</id>
    <published>2022-11-08T15:00:00.000Z</published>
    <updated>2022-11-20T15:17:54.758Z</updated>
    
    <content type="html"><![CDATA[<p>待完成。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;待完成。。。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>云原生13-Kubernetes集群联邦和Istio多集群管理</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F13-Kubernetes%E9%9B%86%E7%BE%A4%E8%81%94%E9%82%A6%E5%92%8CIstio%E5%A4%9A%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F13-Kubernetes%E9%9B%86%E7%BE%A4%E8%81%94%E9%82%A6%E5%92%8CIstio%E5%A4%9A%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86/</id>
    <published>2022-11-08T14:00:00.000Z</published>
    <updated>2022-11-20T15:17:47.605Z</updated>
    
    <content type="html"><![CDATA[<p>待完成。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;待完成。。。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>云原生12-基于Istio的高级流量管理</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F12-%E5%9F%BA%E4%BA%8EIstio%E7%9A%84%E9%AB%98%E7%BA%A7%E6%B5%81%E9%87%8F%E7%AE%A1%E7%90%86/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F12-%E5%9F%BA%E4%BA%8EIstio%E7%9A%84%E9%AB%98%E7%BA%A7%E6%B5%81%E9%87%8F%E7%AE%A1%E7%90%86/</id>
    <published>2022-11-08T13:00:00.000Z</published>
    <updated>2022-11-20T15:17:41.235Z</updated>
    
    <content type="html"><![CDATA[<p>待完成。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;待完成。。。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>云原生11-将应用迁移至Kubernetes平台</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F11-%E5%B0%86%E5%BA%94%E7%94%A8%E8%BF%81%E7%A7%BB%E8%87%B3Kubernetes%E5%B9%B3%E5%8F%B0/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F11-%E5%B0%86%E5%BA%94%E7%94%A8%E8%BF%81%E7%A7%BB%E8%87%B3Kubernetes%E5%B9%B3%E5%8F%B0/</id>
    <published>2022-11-08T12:00:00.000Z</published>
    <updated>2022-11-20T15:17:35.108Z</updated>
    
    <content type="html"><![CDATA[<p>待完成。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;待完成。。。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>云原生10-Kubernetes的生产化运维</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F10-Kubernetes%E7%9A%84%E7%94%9F%E4%BA%A7%E5%8C%96%E8%BF%90%E7%BB%B4/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F10-Kubernetes%E7%9A%84%E7%94%9F%E4%BA%A7%E5%8C%96%E8%BF%90%E7%BB%B4/</id>
    <published>2022-11-08T11:00:00.000Z</published>
    <updated>2022-11-20T15:17:28.578Z</updated>
    
    <content type="html"><![CDATA[<p>待完成。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;待完成。。。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>云原生09-生产化集群的管理</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F09-%E7%94%9F%E4%BA%A7%E5%8C%96%E9%9B%86%E7%BE%A4%E7%9A%84%E7%AE%A1%E7%90%86/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F09-%E7%94%9F%E4%BA%A7%E5%8C%96%E9%9B%86%E7%BE%A4%E7%9A%84%E7%AE%A1%E7%90%86/</id>
    <published>2022-11-08T10:00:00.000Z</published>
    <updated>2022-11-20T15:17:21.265Z</updated>
    
    <content type="html"><![CDATA[<p>待完成。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;待完成。。。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>云原生08-Kubernetes控制平面组件：生命周期管理和服务发现</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F08-Kubernetes%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%BB%84%E4%BB%B6%EF%BC%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F08-Kubernetes%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%BB%84%E4%BB%B6%EF%BC%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</id>
    <published>2022-11-08T09:00:00.000Z</published>
    <updated>2022-11-20T15:17:12.964Z</updated>
    
    <content type="html"><![CDATA[<p>待完成。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;待完成。。。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>云原生07-Kubernetes控制平面组件：调度器和控制器</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F07-Kubernetes%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%BB%84%E4%BB%B6%EF%BC%9A%E8%B0%83%E5%BA%A6%E5%99%A8%E5%92%8C%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F07-Kubernetes%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%BB%84%E4%BB%B6%EF%BC%9A%E8%B0%83%E5%BA%A6%E5%99%A8%E5%92%8C%E6%8E%A7%E5%88%B6%E5%99%A8/</id>
    <published>2022-11-08T08:00:00.000Z</published>
    <updated>2022-11-20T15:17:05.783Z</updated>
    
    <content type="html"><![CDATA[<p>待完成。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;待完成。。。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>云原生06-Kubernetes控制平面组件：API Server</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F06-Kubernetes%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%BB%84%E4%BB%B6%EF%BC%9AAPI-Server/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F06-Kubernetes%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%BB%84%E4%BB%B6%EF%BC%9AAPI-Server/</id>
    <published>2022-11-08T07:00:00.000Z</published>
    <updated>2022-11-20T15:16:59.453Z</updated>
    
    <content type="html"><![CDATA[<p>待完成。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;待完成。。。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>云原生05-Kubernetes控制平面组件：etcd</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F05-Kubernetes%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%BB%84%E4%BB%B6%EF%BC%9Aetcd/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F05-Kubernetes%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%BB%84%E4%BB%B6%EF%BC%9Aetcd/</id>
    <published>2022-11-08T06:00:00.000Z</published>
    <updated>2022-11-20T15:16:52.904Z</updated>
    
    <content type="html"><![CDATA[<p>待完成。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;待完成。。。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>云原生04-Kubernetes架构原则和对象设计</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F04-Kubernetes%E6%9E%B6%E6%9E%84%E5%8E%9F%E5%88%99%E5%92%8C%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F04-Kubernetes%E6%9E%B6%E6%9E%84%E5%8E%9F%E5%88%99%E5%92%8C%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-11-08T05:00:00.000Z</published>
    <updated>2022-11-20T15:16:46.692Z</updated>
    
    <content type="html"><![CDATA[<p>待完成。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;待完成。。。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>云原生03-Docker核心技术</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F03-Docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F03-Docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</id>
    <published>2022-11-08T04:00:00.000Z</published>
    <updated>2022-11-20T15:16:33.714Z</updated>
    
    <content type="html"><![CDATA[<p>待完成。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;待完成。。。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>云原生02-编写Go程序</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F02-%E7%BC%96%E5%86%99Go%E7%A8%8B%E5%BA%8F/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F02-%E7%BC%96%E5%86%99Go%E7%A8%8B%E5%BA%8F/</id>
    <published>2022-11-08T03:00:00.000Z</published>
    <updated>2022-11-20T15:16:27.557Z</updated>
    
    <content type="html"><![CDATA[<p>待完成。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;待完成。。。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Golang" scheme="https://huajun-chen.github.io/tags/Golang/"/>
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>云原生01-Go语言特性</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F01-Go%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F01-Go%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/</id>
    <published>2022-11-08T02:00:00.000Z</published>
    <updated>2022-11-20T15:18:35.995Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言基础知识整理</p><h4 id="1-为什么需要另Go语言"><a href="#1-为什么需要另Go语言" class="headerlink" title="1. 为什么需要另Go语言"></a><font color=DarkOrange>1. 为什么需要另Go语言</font></h4><ul><li>其他编程语言的弊端<ul><li>硬件发展速度远远超过软件</li><li>C 语言等原生语言缺乏好的依赖管理 (依赖头文件）</li><li>Java 和 C++ 等语言过于笨重</li><li>系统语言对垃圾回收和并行计算等基础功能缺乏支持</li><li>对多核计算机缺乏支持</li></ul></li><li>Go 语言是一个可以编译高效，支持高并发的，面向垃圾回收的全新语言<ul><li>秒级完成大型程序的单节点编译</li><li>依赖管理清晰</li><li>不支持继承，程序员无需花费精力定义不同类型之间的关系</li><li>支持垃圾回收，支持并发执行，支持多线程通讯</li><li>对多核计算机支持友好</li></ul></li></ul><h5 id="1-1-Go-语言不支持的特性"><a href="#1-1-Go-语言不支持的特性" class="headerlink" title="1.1 Go 语言不支持的特性"></a><font color=DarkOrange>1.1 Go 语言不支持的特性</font></h5><ul><li>不支持函数重载和操作符重载</li><li>为了避免在 C&#x2F;C++ 开发中的一些 Bug 和混乱，不支持隐式转换</li><li>支持接口抽象，不支持继承</li><li>不支持动态加载代码</li><li>不支持动态链接库</li><li>通过 recover 和 panic 来替代异常机制</li><li>不支持断言</li><li>不支持静态变量</li></ul><h5 id="1-2-Go-语言特性衍生来源"><a href="#1-2-Go-语言特性衍生来源" class="headerlink" title="1.2 Go 语言特性衍生来源"></a><font color=DarkOrange>1.2 Go 语言特性衍生来源</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8aliy8674j31ey0pc11z.jpg" alt="image.png" style="zoom:45%;" /></div><h4 id="2-Go-语言编译环境设置"><a href="#2-Go-语言编译环境设置" class="headerlink" title="2. Go 语言编译环境设置"></a><font color=DarkOrange>2. Go 语言编译环境设置</font></h4><h5 id="2-1-下载-Go"><a href="#2-1-下载-Go" class="headerlink" title="2.1 下载 Go"></a><font color=DarkOrange>2.1 下载 Go</font></h5><ul><li>Go 安装文件以及源代码<ul><li>链接：<a href="https://golang.google.cn/dl/">点击跳转</a></li></ul></li><li>下载对应平台的二进制文件并安装</li><li>环境变量<ul><li>GOROOT<ul><li>go的安装目录</li></ul></li><li>GOPATH<ul><li>src：存放源代码</li><li>pkg：存放依赖包</li><li>bin：存放可执行文件</li></ul></li><li>其他常用变量<ul><li>GOOS，GOARCH，GOPROXY</li><li>国内用户建议设置 goproxy：<code>export GOPROXY=https://goproxy.cn</code></li></ul></li></ul></li></ul><h5 id="2-2-IDE-设置（VS-Code）"><a href="#2-2-IDE-设置（VS-Code）" class="headerlink" title="2.2 IDE 设置（VS Code）"></a><font color=DarkOrange>2.2 IDE 设置（VS Code）</font></h5><ul><li>下载并安装 Visual Studio Code<ul><li>VSCode：<a href="https://code.visualstudio.com/download">点击跳转</a></li></ul></li><li>安装 Go 语言插件<ul><li>插件：<a href="https://marketplace.visualstudio.com/items?itemName=golang.go">点击跳转</a></li></ul></li><li>其他可选项<ul><li>Intellj goland，收费软件，<a href="https://www.jetbrains.com/go/download/#section=mac">点击跳转</a></li><li>vim，sublime等</li></ul></li></ul><h5 id="2-3-一些基本命令"><a href="#2-3-一些基本命令" class="headerlink" title="2.3 一些基本命令"></a><font color=DarkOrange>2.3 一些基本命令</font></h5><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>bug</td><td>start a bug report</td></tr><tr><td>build</td><td>compile packages and dependencies</td></tr><tr><td>clean</td><td>remove object files and cached files</td></tr><tr><td>doc</td><td>show documentation for package or symbol</td></tr><tr><td>env</td><td>print Go environment information</td></tr><tr><td>fix</td><td>update packages to use new APIs</td></tr><tr><td>fmt</td><td>gofmt (reformat) package sources</td></tr><tr><td>generate</td><td>generate Go files by processing source</td></tr><tr><td>get</td><td>add dependencies to current module and install them</td></tr><tr><td>install</td><td>compile and install packages and dependencies</td></tr><tr><td>list</td><td>list packages or modules</td></tr><tr><td>mod</td><td>module maintenance</td></tr><tr><td>run</td><td>compile and run Go program</td></tr><tr><td>test</td><td>test packages</td></tr><tr><td>tool</td><td>run specified go tool</td></tr><tr><td>version</td><td>print Go version</td></tr><tr><td>vet</td><td>report likely mistakes in packages</td></tr></tbody></table><h5 id="2-4-Go-build"><a href="#2-4-Go-build" class="headerlink" title="2.4 Go build"></a><font color=DarkOrange>2.4 Go build</font></h5><ul><li>Go 语言不支持动态链接，因此编译时会将所有依赖编译进同一个二进制文件</li><li>指定输出目录<ul><li>go build –o bin&#x2F;mybinary</li></ul></li><li>常用环境变量设置编译操作系统和 CPU 架构<ul><li>GOOS&#x3D;linux GOARCH&#x3D;amd64 go build</li></ul></li><li>全支持列表<ul><li>$GOROOT&#x2F;src&#x2F;go&#x2F;build&#x2F;syslist.go</li></ul></li></ul><h5 id="2-6-Go-test"><a href="#2-6-Go-test" class="headerlink" title="2.6 Go test"></a><font color=DarkOrange>2.6 Go test</font></h5><p>Go 语言原生自带测试</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestIncrease</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">t.Log(<span class="string">&quot;Start testing&quot;</span>)</span><br><span class="line">increase(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go test .&#x2F;… -v 运行测试</p><p>go test 命令扫描所有*_test.go为结尾的文件，惯例是将测试代码与正式代码放在同目录， 如 foo.go 的测试代码一般写在 foo_test.go</p><h5 id="2-7-Go-vet"><a href="#2-7-Go-vet" class="headerlink" title="2.7 Go vet"></a><font color=DarkOrange>2.7 Go vet</font></h5><p>代码静态检查，发现可能的 bug 或者可疑的构造</p><ul><li><p>Print-format 错误，检查类型不匹配的print</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str := “hello world!”</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, str)</span><br></pre></td></tr></table></figure></li><li><p>Boolean 错误，检查一直为 true、false 或者冗余的表达式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(i != <span class="number">0</span> || i != <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>Range 循环，比如如下代码主协程会先退出，go routine无法被执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">words := []<span class="type">string</span>&#123;<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, word := <span class="keyword">range</span> words &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(word)</span><br><span class="line">  &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Unreachable的代码，如 return 之后的代码</p></li><li><p>其他错误，比如变量自赋值，error 检查滞后等</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">res, err := http.Get(<span class="string">&quot;https://www.spreadsheetdb.io/&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> res.Body.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-8-代码版本控制"><a href="#2-8-代码版本控制" class="headerlink" title="2.8 代码版本控制"></a><font color=DarkOrange>2.8 代码版本控制</font></h5><ul><li>下载并安装 Git Command Line<ul><li>Git，<a href="https://git-scm.com/downloads">点击跳转</a></li></ul></li><li>Github<ul><li>代码仓库</li></ul></li><li>创建代码目录<ul><li>mkdir –p $GOPATH&#x2F;src&#x2F;github.com&#x2F;cncamp</li><li>cd $GOPATH&#x2F;src&#x2F;github.com&#x2F;cncamp</li></ul></li><li>代码下载</li><li>修改代码</li><li>上传代码<ul><li>git add filename</li><li>git commit –m ‘change logs’</li><li>git push</li></ul></li></ul><h5 id="2-9-Golang-playground"><a href="#2-9-Golang-playground" class="headerlink" title="2.9 Golang playground"></a><font color=DarkOrange>2.9 Golang playground</font></h5><ul><li>官方 playground，<a href="https://play.golang.org/">点击跳转</a></li><li><strong>推荐：</strong> 国内可直接访问的 playground，<a href="https://goplay.tools/">点击跳转</a></li></ul><p>可直接编写和运行 Go 语言程序</p><h4 id="3-控制结构"><a href="#3-控制结构" class="headerlink" title="3. 控制结构"></a><font color=DarkOrange>3. 控制结构</font></h4><h5 id="3-1-if"><a href="#3-1-if" class="headerlink" title="3.1 if"></a><font color=DarkOrange>3.1 if</font></h5><ul><li><p>基本形式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1 &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> condition2 &#123;</span><br><span class="line">  <span class="comment">// do something else</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// catch-all or default</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>if 的简短语句</p><ul><li>for 一样， if 语句可以在条件表达式前执行一个简单的语句</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v := x - <span class="number">100</span>; v &lt; <span class="number">0</span>&#123;</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-2-switch"><a href="#3-2-switch" class="headerlink" title="3.2 switch"></a><font color=DarkOrange>3.2 switch</font></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> var1 &#123;</span><br><span class="line">  <span class="keyword">case</span> val1: <span class="comment">//空分支</span></span><br><span class="line">  <span class="keyword">case</span> val2:</span><br><span class="line">  <span class="keyword">fallthrough</span> <span class="comment">//执行case3中的f()</span></span><br><span class="line">  <span class="keyword">case</span> val3:</span><br><span class="line">  f()</span><br><span class="line">  <span class="keyword">default</span>: <span class="comment">//默认分支</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-for"><a href="#3-3-for" class="headerlink" title="3.3 for"></a><font color=DarkOrange>3.3 for</font></h5><p>Go 只有一种循环结构：for 循环</p><ul><li><p>计入计数器的循环</p><ul><li>for 初始化语句; 条件语句; 修饰语句 {}</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">sum += i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化语句和后置语句是可选的，此场景与 while 等价（Go 语言不支持 while）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>; &#123;</span><br><span class="line">sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>无限循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> condition1 &#123;</span><br><span class="line">  <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-4-for-range"><a href="#3-4-for-range" class="headerlink" title="3.4 for-range"></a><font color=DarkOrange>3.4 for-range</font></h5><p>遍历数组，切片，字符串，Map 等</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index, char := <span class="keyword">range</span> myString &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> MyMap &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> MyArray &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意：如果 for range 遍历指针数组，则 value 取出的指 针地址为原指针地址的拷贝</strong></p><h4 id="4-Go-语言常用数据结构"><a href="#4-Go-语言常用数据结构" class="headerlink" title="4. Go 语言常用数据结构"></a><font color=DarkOrange>4. Go 语言常用数据结构</font></h4><h5 id="4-1-变量与常量"><a href="#4-1-变量与常量" class="headerlink" title="4.1 变量与常量"></a><font color=DarkOrange>4.1 变量与常量</font></h5><ul><li>常量<ul><li>const identifier type</li></ul></li><li>变量<ul><li>var identifier type</li></ul></li></ul><h5 id="4-2-变量定义"><a href="#4-2-变量定义" class="headerlink" title="4.2 变量定义"></a><font color=DarkOrange>4.2 变量定义</font></h5><ul><li>变量<ul><li>var 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后</li><li>var c, python, java bool</li></ul></li><li>变量的初始化<ul><li>变量声明可以包含初始值，每个变量对应一个</li><li>如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型</li><li>var i, j int &#x3D; 1, 2</li></ul></li><li>短变量声明<ul><li>在函数中，简洁赋值语句 :&#x3D; 可在类型明确的地方代替 var 声明</li><li>函数外的每个语句都必须以关键字开始（var, func 等等），<strong>因此 :&#x3D; 结构不能在函数外使用</strong></li><li>c, python, java :&#x3D; true, false, “no!”</li></ul></li></ul><h5 id="4-3-类型转换与推导"><a href="#4-3-类型转换与推导" class="headerlink" title="4.3 类型转换与推导"></a><font color=DarkOrange>4.3 类型转换与推导</font></h5><ul><li>类型转换<ul><li>表达式 T(v) 将值 v 转换为类型 T<ul><li>一些关于数值的转换：<ul><li>var i int &#x3D; 42</li><li>var f float64 &#x3D; float64(i) </li><li>var u uint &#x3D; uint(f)</li></ul></li><li>或者，更加简单的形式：<ul><li>i :&#x3D; 42 </li><li>f :&#x3D; float64(i)</li><li>u :&#x3D; uint(f)</li></ul></li></ul></li></ul></li><li>类型推导<ul><li>在声明一个变量而不指定其类型时（即使用不带类型的 :&#x3D; 语法或 var &#x3D; 表达式语法），变量的类型由右值推导得出<ul><li>var i int </li><li>j :&#x3D; i &#x2F;&#x2F; j 也是一个 int</li></ul></li></ul></li></ul><h5 id="4-4-数组"><a href="#4-4-数组" class="headerlink" title="4.4 数组"></a><font color=DarkOrange>4.4 数组</font></h5><ul><li>相同类型且长度固定连续内存片段</li><li>以编号访问每个元素</li><li>定义方法<ul><li>var identifier [len]type</li></ul></li><li>示例<ul><li>myArray :&#x3D; [3]int{1,2,3}</li></ul></li></ul><h5 id="4-5-切片-slice"><a href="#4-5-切片-slice" class="headerlink" title="4.5 切片(slice)"></a><font color=DarkOrange>4.5 切片(slice)</font></h5><ul><li><p>切片是对数组一个连续片段的引用</p></li><li><p>数组定义中不指定长度即为切片</p><ul><li>var identifier []type</li></ul></li><li><p>切片在未初始化之前默认为nil， 长度为0</p></li><li><p>常用方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  myArray := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">  mySlice := myArray[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">  fmt.Printf(<span class="string">&quot;mySlice %+v\n&quot;</span>, mySlice)</span><br><span class="line">  fullSlice := myArray[:]</span><br><span class="line">  remove3rdItem := deleteItem(fullSlice, <span class="number">2</span>)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;remove3rdItem %+v\n&quot;</span>, remove3rdItem)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteItem</span><span class="params">(slice []<span class="type">int</span>, index <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">append</span>(slice[:index], slice[index+<span class="number">1</span>:]...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="4-6-make和new"><a href="#4-6-make和new" class="headerlink" title="4.6 make和new"></a><font color=DarkOrange>4.6 make和new</font></h5><ul><li><p>new 返回指针地址</p></li><li><p>make 返回第一个元素，可预设内存空间，避免未来的内存拷贝</p></li><li><p>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mySlice1 := <span class="built_in">new</span>([]<span class="type">int</span>)</span><br><span class="line">mySlice2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">mySlice3 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">mySlice4 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8au3yhk17j30rc08c0wm.jpg" alt="image.png" style="zoom: 50%;" /></li></ul><h5 id="4-7-关于切片的常见问题"><a href="#4-7-关于切片的常见问题" class="headerlink" title="4.7 关于切片的常见问题"></a><font color=DarkOrange>4.7 关于切片的常见问题</font></h5><ul><li><p>切片是连续内存并且可以动态扩展，由此引发的问题？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := []<span class="type">int</span></span><br><span class="line">b := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">c := a</span><br><span class="line">a = <span class="built_in">append</span>(b, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>修改切片的值？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mySlice := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> mySlice &#123;</span><br><span class="line">value *= <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;mySlice %+v\n&quot;</span>, mySlice)</span><br><span class="line"><span class="keyword">for</span> index, _ := <span class="keyword">range</span> mySlice &#123;</span><br><span class="line">mySlice[index] *= <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;mySlice %+v\n&quot;</span>, mySlice)</span><br></pre></td></tr></table></figure></li></ul><h5 id="4-8-Map"><a href="#4-8-Map" class="headerlink" title="4.8 Map"></a><font color=DarkOrange>4.8 Map</font></h5><ul><li><p>声明方法</p><ul><li>var map1 map[keytype]valuetype</li></ul></li><li><p>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">myMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">10</span>)</span><br><span class="line">myMap[<span class="string">&quot;a&quot;</span>] = <span class="string">&quot;b&quot;</span></span><br><span class="line">myFuncMap := <span class="keyword">map</span>[<span class="type">string</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span>&#123;</span><br><span class="line"><span class="string">&quot;funcA&quot;</span>: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(myFuncMap)</span><br><span class="line">f := myFuncMap[<span class="string">&quot;funcA&quot;</span>]</span><br><span class="line">fmt.Println(f())</span><br></pre></td></tr></table></figure></li></ul><h5 id="4-9-访问-Map-元素"><a href="#4-9-访问-Map-元素" class="headerlink" title="4.9 访问 Map 元素"></a><font color=DarkOrange>4.9 访问 Map 元素</font></h5><ul><li><p>按 Key 取值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value, exists := myMap[<span class="string">&quot;a&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> exists &#123;</span><br><span class="line"><span class="built_in">println</span>(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>遍历 Map</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> myMap &#123;</span><br><span class="line"><span class="built_in">println</span>(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="4-10-结构体和指针"><a href="#4-10-结构体和指针" class="headerlink" title="4.10 结构体和指针"></a><font color=DarkOrange>4.10 结构体和指针</font></h5><ul><li>通过 type … struct 关键字自定义结构体</li><li>Go 语言支持指针，但不支持指针运算<ul><li>指针变量的值为内存地址</li><li>未赋值的指针为 nil</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyType <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMyType</span><span class="params">(t *MyType)</span></span>&#123;</span><br><span class="line"><span class="built_in">println</span>(t.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  t := MyType&#123;Name: <span class="string">&quot;test&quot;</span>&#125;</span><br><span class="line">  printMyType(&amp;t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-11-结构体标签"><a href="#4-11-结构体标签" class="headerlink" title="4.11 结构体标签"></a><font color=DarkOrange>4.11 结构体标签</font></h5><ul><li>结构体中的字段除了有名字和类型外，还可以有一个可选的标签（tag）</li><li>使用场景：Kubernetes APIServer 对所有资源的定义都用 Json tag 和 protoBuff tag<ul><li>NodeName string <code>json:&quot;nodeName,omitempty&quot; protobuf:&quot;bytes,10,opt,name=nodeName&quot;</code></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyType <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  mt := MyType&#123;Name: <span class="string">&quot;test&quot;</span>&#125;</span><br><span class="line">  myType := reflect.TypeOf(mt)</span><br><span class="line">  name := myType.Field(<span class="number">0</span>)</span><br><span class="line">  tag := name.Tag.Get(<span class="string">&quot;json&quot;</span>)</span><br><span class="line">  <span class="built_in">println</span>(tag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-12-类型别名"><a href="#4-12-类型别名" class="headerlink" title="4.12 类型别名"></a><font color=DarkOrange>4.12 类型别名</font></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Service Type string describes ingress methods for a service</span></span><br><span class="line"><span class="keyword">type</span> ServiceType <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  <span class="comment">// ServiceTypeClusterIP means a service will only be accessible inside the</span></span><br><span class="line">  <span class="comment">// cluster, via the ClusterIP.</span></span><br><span class="line">  ServiceTypeClusterIP ServiceType = <span class="string">&quot;ClusterIP&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ServiceTypeNodePort means a service will be exposed on one port of</span></span><br><span class="line">  <span class="comment">// every node, in addition to &#x27;ClusterIP&#x27; type.</span></span><br><span class="line">  ServiceTypeNodePort ServiceType = <span class="string">&quot;NodePort&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ServiceTypeLoadBalancer means a service will be exposed via an</span></span><br><span class="line">  <span class="comment">// external load balancer (if the cloud provider supports it), in addition</span></span><br><span class="line">  <span class="comment">// to &#x27;NodePort&#x27; type.</span></span><br><span class="line">  ServiceTypeLoadBalancer ServiceType = <span class="string">&quot;LoadBalancer&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ServiceTypeExternalName means a service consists of only a reference to</span></span><br><span class="line">  <span class="comment">// an external name that kubedns or equivalent will return as a CNAME</span></span><br><span class="line">  <span class="comment">// record, with no exposing or proxying of any pods involved.</span></span><br><span class="line">  ServiceTypeExternalName ServiceType = <span class="string">&quot;ExternalName&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="5-Go-语言函数调用"><a href="#5-Go-语言函数调用" class="headerlink" title="5. Go 语言函数调用"></a><font color=DarkOrange>5. Go 语言函数调用</font></h4><h5 id="5-1-main函数"><a href="#5-1-main函数" class="headerlink" title="5.1 main函数"></a><font color=DarkOrange>5.1 main函数</font></h5><ul><li>每个 Go 语言程序都应该有个 main package</li><li>Main package 里的 main 函数是 Go 语言程序入口</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  args := os.Args</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;Do not accept any argument&quot;</span>)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-2-参数解析"><a href="#5-2-参数解析" class="headerlink" title="5.2 参数解析"></a><font color=DarkOrange>5.2 参数解析</font></h5><ul><li>请注意 main 函数与其他语言不同，没有类似 java 的 []string args 参数</li><li>Go 语言如何传入参数呢？<ul><li>方法1：<ul><li>fmt.Println(“os args is:”, os.Args)</li></ul></li><li>方法2：<ul><li>name :&#x3D; flag.String(“name”, “world”, “specify the name you want to say hi”)</li><li>flag.Parse()</li></ul></li></ul></li></ul><h5 id="5-3-init函数"><a href="#5-3-init函数" class="headerlink" title="5.3 init函数"></a><font color=DarkOrange>5.3 init函数</font></h5><ul><li>init 函数：会在包初始化时运行</li><li>谨慎使用 init 函数<ul><li>当多个依赖项目引用统一项目，且被引用项目的初始化在 init 中完成，并且不可重复运行时，会导 致启动错误</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myVariable = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">myVariable = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-4-返回值"><a href="#5-4-返回值" class="headerlink" title="5.4 返回值"></a><font color=DarkOrange>5.4 返回值</font></h5><ul><li>多值返回<ul><li>函数可以返回任意数量的返回值</li></ul></li><li>命名返回值<ul><li>Go 的返回值可被命名，它们会被视作定义在函数顶部的变量</li><li>返回值的名称应当具有一定的意义，它可以作为文档使用</li><li>没有参数的 return 语句返回已命名的返回值。也就是直接返回</li></ul></li><li>调用者忽略部分返回值<ul><li>result, _ &#x3D; strconv.Atoi(origStr)</li></ul></li></ul><h5 id="5-5-传递变长参数"><a href="#5-5-传递变长参数" class="headerlink" title="5.5 传递变长参数"></a><font color=DarkOrange>5.5 传递变长参数</font></h5><p>Go 语言中的可变长参数允许调用方传递任意多个相同类型的参数</p><ul><li><p>函数定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(slice []Type, elems ...Type)</span></span> []Type</span><br></pre></td></tr></table></figure></li><li><p>调用方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myArray := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">myArray = <span class="built_in">append</span>(myArray, <span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h5 id="5-6-内置函数"><a href="#5-6-内置函数" class="headerlink" title="5.6 内置函数"></a><font color=DarkOrange>5.6 内置函数</font></h5><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>close</td><td>管道关闭</td></tr><tr><td>len, cap</td><td>返回数组、切片，Map 的长度或容量</td></tr><tr><td>new, make</td><td>内存分配</td></tr><tr><td>copy, append</td><td>操作切片</td></tr><tr><td>panic, recover</td><td>错误处理</td></tr><tr><td>print, println</td><td>打印</td></tr><tr><td>complex, real, imag</td><td>操作复数</td></tr></tbody></table><h5 id="5-7-回调函数-Callback"><a href="#5-7-回调函数-Callback" class="headerlink" title="5.7 回调函数(Callback)"></a><font color=DarkOrange>5.7 回调函数(Callback)</font></h5><p>函数作为参数传入其它函数，并在其他函数内部调用执行</p><ul><li>strings.IndexFunc(line, unicode.IsSpace)</li><li>Kubernetes controller的leaderelection</li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  DoOperation(<span class="number">1</span>, increase)</span><br><span class="line">  DoOperation(<span class="number">1</span>, decrease)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increase</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(“increase result is:”, a+b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoOperation</span><span class="params">(y <span class="type">int</span>, f <span class="keyword">func</span>(<span class="type">int</span>, <span class="type">int</span>)</span></span>) &#123;</span><br><span class="line">f(y, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decrease</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;decrease result is:&quot;</span>, a-b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-8-闭包"><a href="#5-8-闭包" class="headerlink" title="5.8 闭包"></a><font color=DarkOrange>5.8 闭包</font></h5><p>匿名函数</p><ul><li><p>不能独立存在</p></li><li><p>可以赋值给其他变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x:= <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以直接调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(x,y <span class="type">int</span>)</span></span>&#123;<span class="built_in">println</span>(x+y)&#125;(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li><li><p>可作为函数返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">()</span></span> (<span class="function"><span class="keyword">func</span><span class="params">(b <span class="type">int</span>)</span></span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure></li><li><p>使用场景</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">println</span>(“recovered in FuncX”)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></li></ul><h5 id="5-9-方法"><a href="#5-9-方法" class="headerlink" title="5.9 方法"></a><font color=DarkOrange>5.9 方法</font></h5><ul><li><p>方法：作用在接收者上的函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">• <span class="function"><span class="keyword">func</span> <span class="params">(recv receiver_type)</span></span> methodName(parameter_list) (return_value_list)</span><br></pre></td></tr></table></figure></li><li><p>使用场景</p><ul><li>很多场景下，函数需要的上下文可以保存在receiver属性中，通过定义 receiver 的方法，该方法可以直接 访问 receiver 属性，减少参数传递需求</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StartTLS starts TLS on a server from NewUnstartedServer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> StartTLS() &#123;</span><br><span class="line">  <span class="keyword">if</span> s.URL != “” &#123;</span><br><span class="line">  <span class="built_in">panic</span>(“Server already started”)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.client == <span class="literal">nil</span> &#123;</span><br><span class="line">  s.client = &amp;http.Client&#123;Transport: &amp;http.Transport&#123;&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="5-10-传值还是传指针"><a href="#5-10-传值还是传指针" class="headerlink" title="5.10 传值还是传指针"></a><font color=DarkOrange>5.10 传值还是传指针</font></h5><ul><li>Go 语言只有一种规则-传值</li><li>函数内修改参数的值不会影响函数外原始变量的值</li><li>可以传递指针参数将变量地址传递给调用函数，Go 语言会复制该指针作为函数内的地址，但指向同一地址</li></ul><p><strong>思考：当我们写代码的时候，函数的参数传递应该用struct 还是pointer？</strong></p><h5 id="5-11-接口"><a href="#5-11-接口" class="headerlink" title="5.11 接口"></a><font color=DarkOrange>5.11 接口</font></h5><ul><li><p>接口定义一组方法集合</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IF <span class="keyword">interface</span> &#123;</span><br><span class="line">Method1(param_list) return_type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>适用场景：Kubernetes 中有大量的接口抽象和多种实现</p></li><li><p>Struct 无需显示声明实现 interface，只需直接实现方法</p></li><li><p>Struct 除实现 interface 定义的接口外，还可以有额外的方法</p></li><li><p>一个类型可实现多个接口（Go 语言的多重继承）</p></li><li><p>Go 语言中接口不接受属性定义</p></li><li><p>接口可以嵌套其他接口</p></li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IF <span class="keyword">interface</span> &#123;</span><br><span class="line">getName() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">firstName, lastName <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> getName() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> h.firstName + <span class="string">&quot;,&quot;</span> + h.lastName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">factory, model <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Car)</span></span> getName() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.factory + <span class="string">&quot;-&quot;</span> + c.model</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  interfaces := []IF&#123;&#125;</span><br><span class="line">  h := <span class="built_in">new</span>(Human)</span><br><span class="line">  h.firstName = <span class="string">&quot;first&quot;</span></span><br><span class="line">  h.lastName = <span class="string">&quot;last&quot;</span></span><br><span class="line">  interfaces = <span class="built_in">append</span>(interfaces, h)</span><br><span class="line">  c := <span class="built_in">new</span>(Car)</span><br><span class="line">  c.factory = <span class="string">&quot;benz&quot;</span></span><br><span class="line">  c.model = <span class="string">&quot;s&quot;</span></span><br><span class="line">  interfaces = <span class="built_in">append</span>(interfaces, c)</span><br><span class="line">  <span class="keyword">for</span> _, f := <span class="keyword">range</span> interfaces &#123;</span><br><span class="line">  fmt.Println(f.getName())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>Interface 是可能为 nil 的，所以针对 interface 的使用一定要预 先判空，否则会引起程序 crash(nil panic)</li><li>Struct 初始化意味着空间分配，对 struct 的引用不会出现空指针</li></ul><h5 id="5-12-反射机制"><a href="#5-12-反射机制" class="headerlink" title="5.12 反射机制"></a><font color=DarkOrange>5.12 反射机制</font></h5><ul><li>reflect.TypeOf ()返回被检查对象的类型</li><li>reflect.ValueOf()返回被检查对象的值</li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">10</span>)</span><br><span class="line">myMap[<span class="string">&quot;a&quot;</span>] = <span class="string">&quot;b&quot;</span></span><br><span class="line">t := reflect.TypeOf(myMap)</span><br><span class="line">fmt.Println(<span class="string">&quot;type:&quot;</span>, t)</span><br><span class="line">v := reflect.ValueOf(myMap)</span><br><span class="line">fmt.Println(<span class="string">&quot;value:&quot;</span>, v)</span><br></pre></td></tr></table></figure><h5 id="5-13-基于struct的反射"><a href="#5-13-基于struct的反射" class="headerlink" title="5.13 基于struct的反射"></a><font color=DarkOrange>5.13 基于struct的反射</font></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// struct</span></span><br><span class="line">myStruct := T&#123;A: <span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line">v1 := reflect.ValueOf(myStruct)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v1.NumField(); i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Field %d: %v\n&quot;</span>, i, v1.Field(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v1.NumMethod(); i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Method %d: %v\n&quot;</span>, i, v1.Method(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要注意 receive 是 struct 还是指针</span></span><br><span class="line">result := v1.Method(<span class="number">0</span>).Call(<span class="literal">nil</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;result:&quot;</span>, result)</span><br></pre></td></tr></table></figure><h5 id="5-14-Go语言中的面向对象编程"><a href="#5-14-Go语言中的面向对象编程" class="headerlink" title="5.14 Go语言中的面向对象编程"></a><font color=DarkOrange>5.14 Go语言中的面向对象编程</font></h5><ul><li>可见性控制<ul><li>public - 常量、变量、类型、接口、结构、函数等的名称大写</li><li>private - 非大写就只能在包内使用</li></ul></li><li>继承<ul><li>通过组合实现，内嵌一个或多个 struct</li></ul></li><li>多态<ul><li>通过接口实现，通过接口定义方法集，编写多套实现</li></ul></li></ul><h5 id="5-15-json编解码"><a href="#5-15-json编解码" class="headerlink" title="5.15 json编解码"></a><font color=DarkOrange>5.15 json编解码</font></h5><ul><li><p>Unmarshal: 从 string 转换至 struct</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unmarshal2Struct</span><span class="params">(humanStr <span class="type">string</span>)</span></span>Human &#123;</span><br><span class="line">  h := Human&#123;&#125;</span><br><span class="line">  err := json.Unmarshal([]<span class="type">byte</span>(humanStr), &amp;h)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">println</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Marshal: 从 struct 转换至 string</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">marshal2JsonString</span><span class="params">(h Human)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  h.Age = <span class="number">30</span></span><br><span class="line">  updatedBytes, err := json.Marshal(&amp;h)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">println</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">string</span>(updatedBytes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>json 包使用 map[string]interface{} 和 []interface{} 类型保存任意对象</p></li><li><p>可通过如下逻辑解析任意 json</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">err := json.Unmarshal([]<span class="type">byte</span>(humanStr), &amp;obj)</span><br><span class="line">objMap, ok := obj.(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> objMap &#123;</span><br><span class="line">  <span class="keyword">switch</span> value := v.(<span class="keyword">type</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">  fmt.Printf(<span class="string">&quot;type of %s is string, value is %v\n&quot;</span>, k, value)</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line">  fmt.Printf(<span class="string">&quot;type of %s is interface&#123;&#125;, value is %v\n&quot;</span>, k, value)</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  fmt.Printf(<span class="string">&quot;type of %s is wrong, value is %v\n&quot;</span>, k, value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-常用语法"><a href="#6-常用语法" class="headerlink" title="6. 常用语法"></a><font color=DarkOrange>6. 常用语法</font></h4><h5 id="6-1-错误处理"><a href="#6-1-错误处理" class="headerlink" title="6.1 错误处理"></a><font color=DarkOrange>6.1 错误处理</font></h5><ul><li><p>Go 语言无内置 exceptio 机制，只提供 error 接口供定义错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可通过 errors.New 或 fmt.Errorf 创建新的 error</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> errNotFound <span class="type">error</span> = errors.New(<span class="string">&quot;NotFound&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>通常应用程序对 error 的处理大部分是判断 error 是否为 nil</p></li></ul><p>如需将 error 归类，通常交给应用程序自定义，比如 kubernetes 自定义了与 apiserver 交互的不同类型错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StatusError <span class="keyword">struct</span> &#123;</span><br><span class="line">ErrStatus metav1.Status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ <span class="type">error</span> = &amp;StatusError&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error implements the Error interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *StatusError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> e.ErrStatus.Message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-2-defer"><a href="#6-2-defer" class="headerlink" title="6.2 defer"></a><font color=DarkOrange>6.2 defer</font></h5><ul><li>函数返回之前执行某个语句或函数</li><li>常见的 defer 使用场景：记得关闭你打开的资源<ul><li>defer file.Close()</li><li>defer mu.Unlock()</li><li>defer println(“”)</li></ul></li></ul><h5 id="6-3-panic和recover"><a href="#6-3-panic和recover" class="headerlink" title="6.3 panic和recover"></a><font color=DarkOrange>6.3 panic和recover</font></h5><ul><li>panic: 可在系统出现不可恢复错误时主动调用 panic, panic 会使当前线程直接 crash</li><li>defer: 保证执行并把控制权交还给接收到 panic 的函数调用者</li><li>recover: 函数从 panic 或 错误场景中恢复</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;defer func is called&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  fmt.Println(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;a panic is triggered&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="7-多线程"><a href="#7-多线程" class="headerlink" title="7. 多线程"></a><font color=DarkOrange>7. 多线程</font></h4><h5 id="7-1-并发和并行"><a href="#7-1-并发和并行" class="headerlink" title="7.1 并发和并行"></a><font color=DarkOrange>7.1 并发和并行</font></h5><ul><li><p>并发（concurrency）</p><ul><li>两个或多个事件在同一时间间隔发生</li></ul><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8bzcerzeej30zw02yjsm.jpg" alt="image.png" style="zoom: 50%;" /></li><li><p>并行（parallellism）</p><ul><li>两个或者多个事件在同一时刻发生</li></ul><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8bzd7setzj30zu0aadh9.jpg" alt="image.png" style="zoom: 50%;" /></li></ul><h5 id="7-2-协程"><a href="#7-2-协程" class="headerlink" title="7.2 协程"></a><font color=DarkOrange>7.2 协程</font></h5><ul><li>进程<ul><li>分配系统资源（CPU 时间、内存等）基本单位</li><li>有独立的内存空间，切换开销大</li></ul></li><li>线程<ul><li>进程的一个执行流，是 CPU 调度并能独立运行的的基本单位</li><li>同一进程中的多线程共享内存空间，线程切换代价小</li><li>多线程通信方便</li><li>从内核层面来看线程其实也是一种特殊的进程，它跟父进程共享了打开的文件和文件系统信息，共<br>享了地址空间和信号处理函数</li></ul></li><li>协程<ul><li>Go 语言中的轻量级线程实现</li><li>Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，当遇到长时间执行<br>或者进行系统调用时，会主动把当前 goroutine 的 CPU (P) 转让出去，让其他 goroutine 能被调度<br>并执行，也就是 Golang 从语言层面支持了协程</li></ul></li></ul><h5 id="7-3-CSP"><a href="#7-3-CSP" class="headerlink" title="7.3 CSP"></a><font color=DarkOrange>7.3 CSP</font></h5><ul><li><p>CSP</p><ul><li>描述两个独立的并发实体通过共享的通讯 channel 进行通信的并发模型</li></ul></li><li><p>Go 协程 goroutine</p><ul><li>是一种轻量线程，它不是操作系统的线程，而是将一个操作系统线程分段使用，通过调度器实现协<br>作式调度</li><li>是一种绿色线程，微线程，它与 Coroutine 协程也有区别，能够在发现堵塞后启动新的微线程</li></ul></li><li><p>通道 channel</p><ul><li>类似 Unix 的 Pipe，用于协程之间通讯和同步</li><li>协程之间虽然解耦，但是它们和 Channel 有着耦合</li></ul></li></ul><h5 id="7-4-线程和协程的差异"><a href="#7-4-线程和协程的差异" class="headerlink" title="7.4 线程和协程的差异"></a><font color=DarkOrange>7.4 线程和协程的差异</font></h5><ul><li><p>每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少</p><ul><li>goroutine：2KB</li><li>线程：8MB</li></ul></li><li><p>线程&#x2F;goroutine 切换开销方面，goroutine 远比线程小</p><ul><li>线程：涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP…等寄存器的刷新</li><li>goroutine：只有三个寄存器的值修改 - PC &#x2F; SP &#x2F; DX</li></ul></li><li><p>GOMAXPROCS</p><ul><li>控制并行线程数量</li></ul></li><li><p>启动新协程：go functionName()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">go</span> fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br></pre></td></tr></table></figure></li></ul><h5 id="7-5-channel-多线程通信"><a href="#7-5-channel-多线程通信" class="headerlink" title="7.5 channel-多线程通信"></a><font color=DarkOrange>7.5 channel-多线程通信</font></h5><ul><li>Channel 是多个协程之间通讯的管道<ul><li>一端发送数据，一端接收数据</li><li>同一时间只有一个协程可以访问数据，无共享内存模式可能出现的内存竞争</li><li>协调协程的执行顺序</li></ul></li><li>声明方式<ul><li><code>var identifier chan datatype</code></li><li>操作符&lt;-</li></ul></li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;hello from goroutine&quot;</span>)</span><br><span class="line">  ch &lt;- <span class="number">0</span> <span class="comment">//数据写入Channel</span></span><br><span class="line">&#125;()</span><br><span class="line">i := &lt;-ch<span class="comment">//从Channel中取数据并赋值</span></span><br></pre></td></tr></table></figure><h5 id="7-6-通道缓冲"><a href="#7-6-通道缓冲" class="headerlink" title="7.6 通道缓冲"></a><font color=DarkOrange>7.6 通道缓冲</font></h5><ul><li>基于 Channel 的通信是同步的</li><li>当缓冲区满时，数据的发送是阻塞的</li><li>通过 make 关键字创建通道时可定义缓冲区容量，默认缓冲区容量为 0</li></ul><h5 id="7-7-遍历通道缓冲区"><a href="#7-7-遍历通道缓冲区" class="headerlink" title="7.7 遍历通道缓冲区"></a><font color=DarkOrange>7.7 遍历通道缓冲区</font></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    n := rand.Intn(<span class="number">10</span>) <span class="comment">// n will be between 0 and 10</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;putting: &quot;</span>, n)</span><br><span class="line">    ch &lt;- n</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">close</span>(ch)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;hello from main&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;receiving: &quot;</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-8-单向通道"><a href="#7-8-单向通道" class="headerlink" title="7.8 单向通道"></a><font color=DarkOrange>7.8 单向通道</font></h5><ul><li><p>只发送通道</p><ul><li><code>var sendOnly chan&lt;- int</code></li></ul></li><li><p>只接收通道</p><ul><li><code>var readOnly &lt;-chan int</code></li></ul></li><li><p>Istio webhook controller</p><ul><li><code>func (w *WebhookCertPatcher) runWebhookController(stopChan &lt;-chan struct&#123;&#125;) &#123;&#125;</code></li></ul></li><li><p>如何用: 双向通道转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> prod(c)</span><br><span class="line"><span class="keyword">go</span> consume(c)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prod</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> &#123; ch &lt;- <span class="number">1</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123; &lt;-ch &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="7-9-关闭通道"><a href="#7-9-关闭通道" class="headerlink" title="7.9 关闭通道"></a><font color=DarkOrange>7.9 关闭通道</font></h5><ul><li>通道无需每次关闭</li><li>关闭的作用是告诉接收者该通道再无新数据发送</li><li>只有发送方需要关闭通道</li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(ch)</span><br><span class="line"><span class="keyword">if</span> v, notClosed := &lt;-ch; notClosed &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-10-select"><a href="#7-10-select" class="headerlink" title="7.10 select"></a><font color=DarkOrange>7.10 select</font></h5><ul><li>当多个协程同时运行时，可通过 select 轮询多个通道<ul><li>如果所有通道都阻塞则等待，如定义了 default 则执行 default</li><li>如多个通道就绪则随机选择</li></ul></li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v:= &lt;- ch1:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> v:= &lt;- ch2:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-11-定时器timer"><a href="#7-11-定时器timer" class="headerlink" title="7.11 定时器timer"></a><font color=DarkOrange>7.11 定时器timer</font></h5><ul><li>time.Ticker 以指定的时间间隔重复的向通道 C 发送时间值</li><li>使用场景<ul><li>为协程设定超时时间</li></ul></li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">timer := time.NewTimer(time.Second)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="comment">// check normal channel</span></span><br><span class="line">  <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">  fmt.Println(<span class="string">&quot;received from ch&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">  fmt.Println(<span class="string">&quot;timeout waiting from channel ch&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-12-上下文context"><a href="#7-12-上下文context" class="headerlink" title="7.12 上下文context"></a><font color=DarkOrange>7.12 上下文context</font></h5><ul><li><p>超时、取消操作或者一些异常情况，往往需要进行抢占操作或者中断后续操作</p></li><li><p>Context 是设置截止日期、同步信号，传递请求相关值的结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">Err() <span class="type">error</span></span><br><span class="line">Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用法</p><ul><li>context.Background</li><li>context.TODO</li><li>context.WithDeadline</li><li>context.WithValue</li><li>context.WithCancel</li></ul></li></ul><h5 id="7-13-如何停止一个子协程"><a href="#7-13-如何停止一个子协程" class="headerlink" title="7.13 如何停止一个子协程"></a><font color=DarkOrange>7.13 如何停止一个子协程</font></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-done:</span><br><span class="line">    fmt.Println(<span class="string">&quot;done channel is triggerred, exit child go routine&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">close</span>(done)</span><br></pre></td></tr></table></figure><h5 id="7-14-基于context停止子协程"><a href="#7-14-基于context停止子协程" class="headerlink" title="7.14 基于context停止子协程"></a><font color=DarkOrange>7.14 基于context停止子协程</font></h5><p>Context 是 Go 语言对 go routine 和 timer 的封装</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"><span class="keyword">go</span> process(ctx, <span class="number">100</span>*time.Millisecond)</span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line">fmt.Println(<span class="string">&quot;main:&quot;</span>, ctx.Err())</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Go语言基础知识整理&lt;/p&gt;
&lt;h4 id=&quot;1-为什么需要另Go语言&quot;&gt;&lt;a href=&quot;#1-为什么需要另Go语言&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么需要另Go语言&quot;&gt;&lt;/a&gt;&lt;font color=DarkOrange&gt;1. 为什么需要</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Golang" scheme="https://huajun-chen.github.io/tags/Golang/"/>
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>云原生00-什么是云原生</title>
    <link href="https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F00-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    <id>https://huajun-chen.github.io/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F00-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%91%E5%8E%9F%E7%94%9F/</id>
    <published>2022-11-08T01:00:00.000Z</published>
    <updated>2022-11-19T09:55:32.415Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-什么是云原生"><a href="#1-什么是云原生" class="headerlink" title="1. 什么是云原生"></a><font color=DarkOrange>1. 什么是云原生</font></h4><ul><li><p>在包括公有云、私有云、混合云等动态环境中构建和运行规模化应用的能力</p></li><li><p>云原生是一种思想，是技术、企业管理方法的集合</p><ul><li>技术层面<ul><li>应用程序从设计之初就为在云上运行而做好准备</li><li>云平台基于自动化体系</li></ul></li><li>流程层面<ul><li>基于 DevOps，CI&#x2F;CD</li></ul></li></ul></li><li><p>基于多种手段</p><ul><li>应用容器化封装</li><li>服务网格</li><li>不可变基础架构</li><li>声明式 API</li></ul></li><li><p>云原生的意义</p><ul><li>提升系统的适应性、可管理性、可观察性</li><li>使工程师能以最小成本进行频繁和可预测的系统变更</li><li>提升速度和效率，助力业务成长，缩短 I2M（Idea to Market）</li></ul></li></ul><h4 id="2-云原生核心项目概览"><a href="#2-云原生核心项目概览" class="headerlink" title="2. 云原生核心项目概览"></a><font color=DarkOrange>2. 云原生核心项目概览</font></h4><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8akra0wvmj30yk0qgdvy.jpg" alt="image.png" style="zoom:50%;" /></div><h4 id="3-kube-proxy-是干啥用的"><a href="#3-kube-proxy-是干啥用的" class="headerlink" title="3. kube-proxy 是干啥用的"></a><font color=DarkOrange>3. kube-proxy 是干啥用的</font></h4><h5 id="3-1-官方文档"><a href="#3-1-官方文档" class="headerlink" title="3.1 官方文档"></a><font color=DarkOrange>3.1 官方文档</font></h5><p>官方文档：<a href="https://kubernetes.io/docs/concepts/overview/components/">点击跳转</a></p><p>kube-proxy uses the operating system packet filtering layer if there is one and it’s available. Otherwise, kube-proxy forwards the traffic itself.</p><h5 id="3-2-看看前人是怎么解读的"><a href="#3-2-看看前人是怎么解读的" class="headerlink" title="3.2 看看前人是怎么解读的"></a><font color=DarkOrange>3.2 看看前人是怎么解读的</font></h5><p>搜中文文档，知乎，CSDN，简书都有比较高质量的文章，可以多看一些文档，并理解不同人 的理解差异</p><p>知乎：<a href="https://zhuanlan.zhihu.com/p/337806843">点击跳转</a></p><p>中文世界Kubernetes非常活跃，不少文档质量超过英文。但中文搬运转载问题比较严重，需要自己甄别</p><h5 id="3-3-找关键知识点"><a href="#3-3-找关键知识点" class="headerlink" title="3.3 找关键知识点"></a><font color=DarkOrange>3.3 找关键知识点</font></h5><ul><li>先对大概的框架有认识</li><li>kube-proxy 监听 API server 中 资源对象的变化情况，包括以下三种：<ul><li>service</li><li>endpoint&#x2F;endpointslices</li><li>node</li></ul></li><li>目前 Kube-proxy 支持4中代理模式：<ul><li>userspace</li><li>iptables</li><li>ipvs</li><li>kernelspace（windows）</li></ul></li></ul><h5 id="3-4-由点到面稍稍展开一下"><a href="#3-4-由点到面稍稍展开一下" class="headerlink" title="3.4 由点到面稍稍展开一下"></a><font color=DarkOrange>3.4 由点到面稍稍展开一下</font></h5><p>由浅入深的理解，成为专家</p><ul><li>入门：可以使用，知道怎么用，大概做了什么</li><li>初级：粗略理解配置方法</li><li>高级：理解不同模式的差异，理解为什么要有多种模式，理解配置细节</li><li>专家级：理解完整的内核协议栈处理数据包的流程，能够举一反三</li></ul><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8akygl1nyj31qi0fe46c.jpg" alt="image.png" style="zoom:67%;" /></div><h4 id="4-如何学习云原生技术"><a href="#4-如何学习云原生技术" class="headerlink" title="4. 如何学习云原生技术"></a><font color=DarkOrange>4. 如何学习云原生技术</font></h4><ul><li><p>代码驱动</p><ul><li>掌握 Go 语言编程能力</li></ul></li><li><p>从点到面</p><ul><li>cgroup、namespace</li><li>网络协议栈</li><li>文件系统</li></ul></li><li><p>抓住核心掌控全局</p><ul><li>深入理解 Kubernetes<ul><li>API 定义</li><li>控制器模式</li><li>核心组件</li></ul></li></ul></li><li><p>大规模生产化</p><ul><li>多集群</li><li>服务网格和多网格</li></ul></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-什么是云原生&quot;&gt;&lt;a href=&quot;#1-什么是云原生&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是云原生&quot;&gt;&lt;/a&gt;&lt;font color=DarkOrange&gt;1. 什么是云原生&lt;/font&gt;&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在包括公有</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>云原生训练营课程大纲</title>
    <link href="https://huajun-chen.github.io/2022/11/06/%E4%BA%91%E5%8E%9F%E7%94%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E8%AF%BE%E7%A8%8B%E5%A4%A7%E7%BA%B2/"/>
    <id>https://huajun-chen.github.io/2022/11/06/%E4%BA%91%E5%8E%9F%E7%94%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E8%AF%BE%E7%A8%8B%E5%A4%A7%E7%BA%B2/</id>
    <published>2022-11-06T09:21:29.000Z</published>
    <updated>2022-11-18T10:00:34.166Z</updated>
    
    <content type="html"><![CDATA[<h4 id="第一部分：Go-语言基础"><a href="#第一部分：Go-语言基础" class="headerlink" title="第一部分：Go 语言基础"></a><font color=DarkOrange>第一部分：Go 语言基础</font></h4><h5 id="模块一：Go-语言特性"><a href="#模块一：Go-语言特性" class="headerlink" title="模块一：Go 语言特性"></a><font color=DarkOrange>模块一：Go 语言特性</font></h5><p><strong>教学目标：</strong></p><ol><li><p>理解 Go 语言基本语法</p></li><li><p>理解 Go 语言常用数据类型</p></li><li><p>理解 Go 语言常用小技巧</p></li><li><p>深入理解 Go 语言的多线程编程</p></li></ol><p><strong>针对的用户痛点：</strong></p><ol><li><p>云原生从业者因为未熟练掌握 Go 语言，在阅读 Docker、containerd、Kubernetes 代码时有困难</p></li><li><p>未熟练掌握 Go 语言，在需要编写云原生组件时无法高效率高质量交付</p></li></ol><p><strong>通过学习掌握的核心能力：</strong></p><ol><li><p>阅读 Go 语言代码的能力</p></li><li><p>用 Go 语言编写应用程序的基本能力</p></li><li><p>用 Go 语言编写一个 Kubernetes 中最常见的生产者消费者小程序</p></li></ol><p><strong>详细内容：</strong></p><ol><li><p>Go 语言编译环境设置</p></li><li><p>Go 语言常用数据结构</p></li><li><p>Go 语言函数调用，深入理解 Channel 并基于 Channel 编写一个生产者消费者程序</p></li></ol><hr><h5 id="模块二：使用-Go-语言编写一个小-Demo"><a href="#模块二：使用-Go-语言编写一个小-Demo" class="headerlink" title="模块二：使用 Go 语言编写一个小 Demo "></a><font color=DarkOrange>模块二：使用 Go 语言编写一个小 Demo </font></h5><p><strong>教学目标：</strong></p><ol><li><p>理解 Go 语言的调度原理</p></li><li><p>理解 Go 语言的内存管理</p></li><li><p>Go 语言依赖管理</p></li><li><p>Go 语言调试和问题分析 pprof</p></li></ol><p><strong>针对的用户痛点：</strong></p><ol><li><p>对 Goroutine 无深入理解，无法利用 Go 语言强大的并发能力</p></li><li><p>面对众多的 Go 语言项目包依赖管理工具无所适从，不知道该用哪一个工具</p></li><li><p>针对 Go 语言编写的程序，不知道如何调试</p></li></ol><p><strong>通过学习掌握的核心能力：</strong></p><ol><li><p>了解 Go 语言的高级话题，如线程调度原理，内存管理等，使得学员有能力编写高效程序</p></li><li><p>理解 Go 语言的依赖管理方法，以便能够正确地管理项目依赖</p></li><li><p>学会用 pprof 对应用运行时的调用栈、内存等进行分析</p></li><li><p>学会用 Go 语言编写一个简单的 HTTP 服务器供后续云原生应用使用</p></li></ol><p><strong>详细内容：</strong></p><ol><li><p>Goroutine 的调度</p></li><li><p>内存管理</p></li><li><p>学会用 Go 语言编写一个简单的 HTTP 服务器</p></li></ol><hr><h4 id="第二部分：云原生技术栈"><a href="#第二部分：云原生技术栈" class="headerlink" title="第二部分：云原生技术栈"></a><font color=DarkOrange>第二部分：云原生技术栈</font></h4><h5 id="模块三：Docker-核心技术"><a href="#模块三：Docker-核心技术" class="headerlink" title="模块三：Docker 核心技术"></a><font color=DarkOrange>模块三：Docker 核心技术</font></h5><p><strong>教学目标：</strong></p><ol><li><p>理解容器特性以及相比虚拟化技术所具备的优势</p></li><li><p>了解容器技术的实现细节：Namespace、cgroup、文件系统</p></li></ol><p><strong>针对的用户痛点：</strong></p><ol><li><p>分不清容器技术和虚拟化技术的差异，在做技术决策时没有理论支撑</p></li><li><p>因为不了解技术原理，排查容器问题时毫无头绪</p></li></ol><p><strong>通过学习掌握的核心能力：</strong></p><ol><li><p>了解 Namespace 技术的原理以及基于 Namespace 的问题排查方法</p></li><li><p>理解 cgroup 控制资源限额的方法，查看 cgroup 配置并临时调整 cgroup 配置</p></li><li><p>理解容器文件系统如何高效管理运行时和数据</p></li><li><p>理解容器网络，为进一步理解 Kubernetes 网络插件奠定基础</p></li><li><p>基于 Dockerfile 将应用程序打包成容器镜像</p></li></ol><p><strong>详细内容：</strong></p><ol><li><p>容器技术的本质以及技术优势，Namespace、cgroup、文件系统、网络连通</p></li><li><p>容器镜像与镜像仓库</p></li><li><p>将 Go 语言编写的 HTTP 服务器打包成容器镜像</p></li></ol><hr><h5 id="模块四：Kubernetes-架构原则和对象设计"><a href="#模块四：Kubernetes-架构原则和对象设计" class="headerlink" title="模块四：Kubernetes 架构原则和对象设计"></a><font color=DarkOrange>模块四：Kubernetes 架构原则和对象设计</font></h5><p><strong>教学目标：</strong></p><ol><li><p>理解 Kubenretes 架构原则</p></li><li><p>理解 Kubernetes 的对象设计与 API 定义</p></li><li><p>理解 Kubernetes 控制器模式与多组件联动机制</p></li></ol><p><strong>针对的用户痛点：</strong></p><ol><li><p>对 Kubernetes 有简单认知，但无法编写出高效的、符合云原生规范和最佳实践的组件</p></li><li><p>对组件和基本对象只有浅层次的理解，对 API 的统一性和差异性无深入理解</p></li><li><p>不了解 Kubernetes 的控制器原理，对 Kubernetes 控制面板组件如何运作无深入理解</p></li></ol><p><strong>通过学习掌握的核心能力：</strong></p><ol><li><p>动手搭建 Kubernetes 环境</p></li><li><p>理解 Kubernetes 架构原则</p></li><li><p>理解 Kubernetes API 定义的设计原则，理解 Kubernetes 对象中的重要属性</p></li><li><p>理解 Kubernetes 控制器的联动机制</p></li></ol><p><strong>详细内容：</strong></p><ol><li><p>环境搭建</p></li><li><p>Kubernetes 架构优势及架构原则</p></li><li><p>Kubernetes 核心组件</p></li><li><p>Kubernetes 对象设计与 API 定义</p></li><li><p>Kubernetes 控制器模式</p></li></ol><hr><h5 id="模块五：Kubernetes-控制平面组件：etcd"><a href="#模块五：Kubernetes-控制平面组件：etcd" class="headerlink" title="模块五：Kubernetes 控制平面组件：etcd"></a><font color=DarkOrange>模块五：Kubernetes 控制平面组件：etcd</font></h5><p><strong>教学目标：</strong></p><ol><li><p>深入理解 Kubernetes 的唯一数据存储组件 etcd</p></li><li><p>掌握构建生产系统中 etcd 集群的方法</p></li><li><p>熟悉 etcd 的优化管理，了解灾备方案</p></li></ol><p><strong>针对的用户痛点：</strong></p><ol><li><p>对 etcd 的实现机制不了解，不知道在生产化应用过程中可能遇到的问题</p></li><li><p>不知道应该如何构建生产系统中的 etcd 集群</p></li><li><p>不知道如何进行数据的备份和灾难恢复</p></li></ol><p><strong>通过学习掌握的核心能力：</strong></p><ol><li><p>理解 Raft 协议的工作机制和 etcd 的实现原理，针对 etcd 生产系统的配置优化以及数据灾备</p></li><li><p>深入理解 API Server 的实现机制，包括与企业认证系统整合、鉴权、准入插件的实现等等</p></li><li><p>深入理解 Kubernetes 的对象实现</p></li><li><p>如何构建高可用的 etcd 和 API Server 控制平面</p></li></ol><p><strong>详细内容：</strong></p><ol><li><p>深入理解 Kubernetes 的数据存储 etcd</p></li><li><p>了解 Raft 协议</p></li><li><p>生产系统中 etcd 的配置</p></li><li><p>etcd operator</p></li><li><p>etcd 的灾备方案</p></li><li><p>生产系统中常见问题解析</p></li></ol><hr><h5 id="模块六：Kubernetes-控制平面组件：API-Server"><a href="#模块六：Kubernetes-控制平面组件：API-Server" class="headerlink" title="模块六：Kubernetes 控制平面组件：API Server"></a><font color=DarkOrange>模块六：Kubernetes 控制平面组件：API Server</font></h5><p><strong>教学目标：</strong></p><ol><li><p>深入理解 Kubernetes API Server 的实现机制</p></li><li><p>掌握基于 API Server Webhook 的整合方案</p></li></ol><p><strong>针对的用户痛点：</strong></p><ol><li><p>缺乏对 Kubernetes 对象实现方法的理解</p></li><li><p>对 API Server 缺乏理解，不知道如何与企业认证系统整合，不会基于鉴权准入等机制打造多租户 Kubernetes 平台</p></li></ol><p><strong>通过学习掌握的核心能力：</strong></p><ol><li><p>理解 Kubernetes 对象设计的实现机制</p></li><li><p>理解 API Server 缓存的工作机制</p></li><li><p>掌握生产系统中 API Server 的常用配置</p></li><li><p>掌握 API Server 与企业生态系统的整合方法</p></li></ol><p><strong>详细内容：</strong></p><ol><li><p>深入理解 Kubernetes API Server</p></li><li><p>API Server 代码走读</p></li><li><p>理解 internalVersion、externalVersion 和 storageVersion</p></li><li><p>理解 conversion</p></li><li><p>基于 client-go 生成 Kubernetes 框架代码</p></li><li><p>理解 lister 和 informer 框架</p></li><li><p>理解 API Server 缓存</p></li><li><p>API Server 与企业生态系统的整合：认证接入、鉴权、准入控制</p></li><li><p>API Server 常用配置与常见问题解析</p></li></ol><hr><h5 id="模块七：Kubernetes-控制平面组件：调度器和控制器"><a href="#模块七：Kubernetes-控制平面组件：调度器和控制器" class="headerlink" title="模块七：Kubernetes 控制平面组件：调度器和控制器"></a><font color=DarkOrange>模块七：Kubernetes 控制平面组件：调度器和控制器</font></h5><p><strong>教学目标：</strong></p><ol><li><p>理解 Kubernetes 调度器原理以及常用调度插件</p></li><li><p>理解 Kubernetes 调度的常用技巧，利用亲和性与反亲和性进行调度</p></li><li><p>理解 Kubernetes 的常见控制器</p></li><li><p>深入理解 Kubelet 对 Pod 声明周期的管理</p></li></ol><p><strong>针对的用户痛点：</strong></p><ol><li><p>对 Kubernetes 调度器无深入理解，在 Pod 无法调度时，不知道如何排查问题</p></li><li><p>不会利用 Kubernetes 调度器实现应用的高效、高可用部署</p></li><li><p>对 Kubernetes 控制器缺乏全面认知</p></li><li><p>对 Kubernetes 如何管理 Pod 生命周期缺乏认知</p></li></ol><p><strong>通过学习掌握的核心能力：</strong></p><ol><li><p>排查调度故障，利用调度器实现应用的高可用部署</p></li><li><p>扩展对 Kubernetes 控制器的认知，理解更多的 Kubernetes 控制平面行为</p></li><li><p>深入理解 CRI、CNI 和 CSI</p></li></ol><p><strong>详细内容：</strong></p><ol><li><p>深入理解 Kubernetes 调度器</p></li><li><p>深入理解 Kubenretes 控制器</p></li><li><p>深入理解 Kubelet</p></li><li><p>如何运行你的 Pod（CRI、CNI、CSI）</p></li><li><p>Kubelet Pod 代码走读</p></li><li><p>containerd 代码走读</p></li><li><p>CNI 代码走读</p></li><li><p>全方位的 CSI 一站式解决方案：Rook</p></li></ol><hr><h5 id="模块八：Kubernetes-控制平面组件：生命周期管理和服务发现"><a href="#模块八：Kubernetes-控制平面组件：生命周期管理和服务发现" class="headerlink" title="模块八：Kubernetes 控制平面组件：生命周期管理和服务发现"></a><font color=DarkOrange>模块八：Kubernetes 控制平面组件：生命周期管理和服务发现</font></h5><p><strong>教学目标：</strong></p><ol><li><p>深入理解 Pod 的完整生命周期和就绪状态控制</p></li><li><p>深入理解 Pod 状态控制对应用可用性的影响</p></li><li><p>深入理解 Kubernetes 中的服务发现机制，包括负载均衡配置和域名服务</p></li></ol><p><strong>针对的用户痛点：</strong></p><ol><li><p>解决日常运维的困扰，比如，在 Pod 初始化或故障转移时或者版本发布时，如何不影响业务？</p></li><li><p>我发布的服务经常出现服务中断，是缺了什么配置吗？</p></li></ol><p><strong>通过学习掌握的核心能力：</strong></p><ol><li><p>理解 Pod 的完整生命周期，如何初始化、如何控制就绪状态、如何探活、如何优雅终止</p></li><li><p>如何发布服务，如何剔出异常实例</p></li></ol><p><strong>详细内容：</strong></p><ol><li><p>深入理解 Kubernetes 的服务实例对象 Pod：Pod 生命周期详解、健康探针、ReadinessGate</p></li><li><p>深入理解 Kube-Proxy：如何发布你的服务、代码走读、负载均衡配置</p></li><li><p>域名管理</p></li><li><p>基于 Ingress 以及 Service API 的入站流量管理</p></li></ol><hr><h5 id="模块九：生产化集群的管理"><a href="#模块九：生产化集群的管理" class="headerlink" title="模块九：生产化集群的管理"></a><font color=DarkOrange>模块九：生产化集群的管理</font></h5><p><strong>教学目标：</strong></p><ol><li><p>掌握生产化集群的搭建技术</p></li><li><p>掌握生产化集群持续运维过程中最重要的节点管理能力</p></li><li><p>如何在不影响业务的前提下完成 Kubernetes 升级</p></li></ol><p><strong>针对的用户痛点：</strong></p><ol><li><p>不知道如何快速构建本地集群供研发测试使用</p></li><li><p>未掌握构建生产化集群的方法，缺少对集群节点的管控，节点出现故障以后需要人为介入</p></li><li><p>如何实现生产化集群的管理，比如计算节点的监控与管理</p></li><li><p>不了解完成了集群搭建以后离生产化还有多远</p></li></ol><p><strong>通过学习掌握的核心能力：</strong></p><p>快速构建本地集群的能力</p><p>理解 Kubernetes 集群构建的原理，掌握搭建 Kubernetes 集群的能力</p><p>基于 Cluster API 完成生产化集群的构建和持续运维</p><p><strong>详细内容：</strong></p><ol><li><p>利用 kind 构建本地集群</p></li><li><p>利用 kubeadm 构建基于虚拟机的集群</p></li><li><p>利用 Cluster API 完成生产化集群的搭建</p></li><li><p>持续运维的考量：节点健康检查、Kubernetes 升级、主机操作系统升级</p></li></ol><hr><h5 id="模块十：Kubernetes-的生产化运维"><a href="#模块十：Kubernetes-的生产化运维" class="headerlink" title="模块十：Kubernetes 的生产化运维"></a><font color=DarkOrange>模块十：Kubernetes 的生产化运维</font></h5><p><strong>教学目标：</strong></p><ol><li><p>如何实现基于 Kubernetes 的 CI&#x2F;CD</p></li><li><p>如何实现生产化集群的监控</p></li></ol><p><strong>针对的用户痛点：</strong></p><ol><li><p>缺少企业统一的镜像仓库</p></li><li><p>镜像安全应该如何保证</p></li><li><p>企业缺少持续集成持续部署能力</p></li><li><p>缺少对整个集群的监控，希望实现无人值守</p></li></ol><p><strong>通过学习掌握的核心能力：</strong></p><ol><li><p>打造持续集成平台</p></li><li><p>基于自动化管理生产化集群</p></li><li><p>实现对集群控制面板以及重要应用的监控和告警</p></li></ol><p><strong>详细内容：</strong></p><ol><li><p>镜像仓库和容器镜像缓存</p></li><li><p>镜像扫描和镜像安全保证</p></li><li><p>基于 Kubernetes、Jenkins、Tekton 打造 CI&#x2F;CD Pipeline</p></li><li><p>集群监控：日志收集和分析，事件、指标和告警（Event、Metrics 和 Alert）</p></li></ol><hr><h5 id="模块十一：将应用迁移至-Kubernetes-平台"><a href="#模块十一：将应用迁移至-Kubernetes-平台" class="headerlink" title="模块十一：将应用迁移至 Kubernetes 平台"></a><font color=DarkOrange>模块十一：将应用迁移至 Kubernetes 平台</font></h5><p><strong>教学目标：</strong></p><ol><li><p>如何将无状态应用发布到 Kubernetes 平台</p></li><li><p>如何基于 Kubernetes 原生能力将有状态应用发布到 Kubernetes 平台</p></li><li><p>基于 Kubernetes 对象扩展，将更复杂的应用发布到 Kubernetes 平台</p></li></ol><p><strong>针对的用户痛点：</strong></p><ol><li><p>缺少将应用发布到 Kubernetes 平台上的理论指导</p></li><li><p>对于有状态应用，更不知道如何借助 Kubernetes 平台的优势进行处理</p></li></ol><p><strong>通过学习掌握的核心能力：</strong></p><ol><li><p>掌握 Kubernetes 提供的应用管理框架，包括有状态应用和无状态应用</p></li><li><p>掌握 Operator 模式，具备通过 Kubebuilder 构建自己的 CRD，并且基于 CRD 编写控制器的能力</p></li><li><p>利用 Kubebuilder 完成控制器的测试和发布</p></li><li><p>借助 Helm 完成复杂的应用模板管理</p></li></ol><p><strong>详细内容：</strong></p><ol><li><p>应用容器化</p></li><li><p>无状态应用移植到 Kubernetes 平台的考量</p></li><li><p>有状态应用移植到 Kubernetes 平台的考量</p></li><li><p>理解 Operator</p></li><li><p>借助 Kubebuilder 开发一个 Operator</p></li><li><p>借助 Helm 管理应用发布</p></li></ol><hr><h5 id="模块十二：基于-Istio-的高级流量管理"><a href="#模块十二：基于-Istio-的高级流量管理" class="headerlink" title="模块十二：基于 Istio 的高级流量管理"></a><font color=DarkOrange>模块十二：基于 Istio 的高级流量管理</font></h5><p><strong>教学目标：</strong></p><ol><li><p>理解基于 TCP&#x2F;UDP 协议的 Kubernetes Service 的局限性</p></li><li><p>理解 Kubernetes 入站流量管理的场景和原生方案</p></li><li><p>理解原生方案的局限性和社区的方向</p></li><li><p>深入理解 Envoy 的服务发现机制、线程模型以及扩展机制</p></li><li><p>理解如何基于 Istio 实现入站、出站流量管理以及服务网格管理</p></li></ol><p><strong>针对的用户痛点：</strong></p><ol><li><p>社区的 Ingress 对象无法毕业，为支持生产化应用，应该用什么方案提供入站流量支撑</p></li><li><p>Envoy 为什么变成了 Kubernetes 中七层代理的首选</p></li><li><p>社区爆火的 Istio 背后的技术驱动力是什么，我应该选 Istio 作为入站流量管理平面组件吗</p></li></ol><p><strong>通过学习掌握的核心能力：</strong></p><ol><li><p>深入理解 Envoy 的实现机制</p></li><li><p>深入理解 Istio 的实现机制，了解为什么 Istio 会成为服务网格的标准</p></li></ol><p><strong>详细内容：</strong></p><ol><li><p>入站流量管理 Ingress 和 Service API</p></li><li><p>Istio 和 Envoy</p></li><li><p>深入理解 Envoy：发现机制、线程模型、filter 机制、高级特性</p></li><li><p>深入理解 Isito：入站流量、出站流量、Service Mesh（服务网格）、Istio 服务发现代码走读</p></li><li><p>安全保证</p></li></ol><hr><h5 id="模块十三：Kubernetes-集群联邦和-Istio-多集群管理"><a href="#模块十三：Kubernetes-集群联邦和-Istio-多集群管理" class="headerlink" title="模块十三：Kubernetes 集群联邦和 Istio 多集群管理"></a><font color=DarkOrange>模块十三：Kubernetes 集群联邦和 Istio 多集群管理</font></h5><p><strong>教学目标：</strong></p><ol><li><p>如何通过集群联邦的统一控制平面管理多个集群</p></li><li><p>如何部署跨地域的高可用应用</p></li><li><p>如何通过 Istio 多集群方案管理跨集群的 Service Mesh（服务网格）</p></li></ol><p><strong>针对的用户痛点：</strong></p><ol><li><p>针对真正的生产化应用，跨地域部署是确保应用高可用的一个强需求，那么如何管理多个 Kubernetes 集群</p></li><li><p>针对跨集群部署的应用，如何确保其接入流量高可用，如何借助 Istio 实现这一目的</p></li></ol><p><strong>通过学习掌握的核心能力：</strong></p><ol><li><p>Kubernetes 集群联邦的实现原理和配置方法</p></li><li><p>Istio 多集群实现原理和配置方法</p></li></ol><p><strong>详细内容：</strong></p><ol><li><p>Kubernetes 集群联邦</p></li><li><p>基于集群联邦的跨地域高可用部署</p></li><li><p>基于 Istio 多集群的流量高可用方案</p></li></ol><hr><h5 id="模块十四：基于-Kubernetes-和-Istio-的安全保证"><a href="#模块十四：基于-Kubernetes-和-Istio-的安全保证" class="headerlink" title="模块十四：基于 Kubernetes 和 Istio 的安全保证"></a><font color=DarkOrange>模块十四：基于 Kubernetes 和 Istio 的安全保证</font></h5><p><strong>教学目标：</strong></p><ol><li><p>理解传统安全架构的挑战</p></li><li><p>掌握零信任架构的意义和机遇</p></li><li><p>掌握 Kubernetes 平台本身的安全保证手段</p></li><li><p>学习如何基于 Kubernetes 和 Istio 实现对应用的隔离和安全保证</p></li></ol><p><strong>针对的用户痛点：</strong></p><ol><li><p>如何确保 Kubernetes 平台的安全性</p></li><li><p>如何确保 Kubernetes 中数据保存的安全性</p></li><li><p>如何确保 Kubernetes 上运行应用的安全性</p></li></ol><p><strong>通过学习掌握的核心能力：</strong></p><ol><li><p>如何保证 etcd 中保存的数据安全性</p></li><li><p>如何保证 Kubernetes 控制面板的安全性</p></li><li><p>如何确保 API 网关的安全性</p></li><li><p>对应用进行安全隔离</p></li><li><p>如何基于零信任架构完成应用的认证和授权</p></li></ol><p><strong>详细内容：</strong></p><ol><li><p>理解 etcd 的加密方法</p></li><li><p>掌握 Kubernetes 控制面板的安全配置</p></li><li><p>掌握应用隔离的常规手段以及在 Kubernetes 中配置的方式</p></li><li><p>掌握 API 网关的安全配置</p></li><li><p>了解基于 Istio 的认证鉴权机制</p></li></ol><hr><h4 id="第三部分：云原生项目实战"><a href="#第三部分：云原生项目实战" class="headerlink" title="第三部分：云原生项目实战"></a><font color=DarkOrange>第三部分：云原生项目实战</font></h4><h5 id="模块十五：微服务项目的开发和部署案例"><a href="#模块十五：微服务项目的开发和部署案例" class="headerlink" title="模块十五：微服务项目的开发和部署案例"></a><font color=DarkOrange>模块十五：微服务项目的开发和部署案例</font></h5><p><strong>教学目标：</strong></p><p>完成一个复杂的异构的微服务系统在 Kubernetes 平台上的部署，以 Istio 的 Bookinfo 为例</p><p><strong>针对的用户痛点：</strong></p><ol><li><p>随着业务复杂度的增加，微服务的部署和运维变得越来越有挑战性，如何保证微服务应用部署的高性能是一个复杂问题</p></li><li><p>如何基于熔断、限流等手段保护核心业务</p></li><li><p>如何基于基础架构平台确保应用安全</p></li></ol><p><strong>通过学习掌握的核心能力：</strong></p><ol><li><p>基于微服务架构的复杂应用部署</p></li><li><p>熔断、限流、故障注入</p></li><li><p>应用的安全保证</p></li></ol><p><strong>详细内容：</strong></p><p>本模块是之前所有模块的综合复习模块，希望借助本模块完成基于 Kubernetes 框架下面微服务治理这一重要命题的回顾和总结</p><hr><h4 id="石墨文档"><a href="#石墨文档" class="headerlink" title="石墨文档"></a><font color=DarkOrange>石墨文档</font></h4><p>石墨文档的链接可能会更新，在此附上原地址链接</p><p>云原生训练营课程大纲：<a href="https://shimo.im/docs/6VdchtKxdjrCqDdY/read">点击跳转</a></p><p>云原生训练营实战项目：<a href="https://shimo.im/docs/RKAWV8xgZ7tKWXk8/read">点击跳转</a></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;第一部分：Go-语言基础&quot;&gt;&lt;a href=&quot;#第一部分：Go-语言基础&quot; class=&quot;headerlink&quot; title=&quot;第一部分：Go 语言基础&quot;&gt;&lt;/a&gt;&lt;font color=DarkOrange&gt;第一部分：Go 语言基础&lt;/font&gt;&lt;/h4&gt;&lt;h5</summary>
      
    
    
    
    <category term="后端" scheme="https://huajun-chen.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="https://huajun-chen.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>行为面试</title>
    <link href="https://huajun-chen.github.io/2022/11/03/%E8%A1%8C%E4%B8%BA%E9%9D%A2%E8%AF%95/"/>
    <id>https://huajun-chen.github.io/2022/11/03/%E8%A1%8C%E4%B8%BA%E9%9D%A2%E8%AF%95/</id>
    <published>2022-11-03T01:47:19.000Z</published>
    <updated>2022-11-16T05:42:34.654Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容">  <script id="hbeData" type="hbeData" data-hmacdigest="a8b86b813299ebbebcf5c8e37b632bec34567a10a781d1c0f7886774ff5d758f">a17b4de793b95f7877066d2186f5861555e2d6b9cb5641947e36c8450a906224c08d548d079000bc6f30a7dca4e9b9768784f58ce2cede9cd16046bcdfa4170c5df29963de96439a4700b20fe1c6bd48e1c637e68b3d692bb82396ba2b8e61a27aeb472a4ece7462bedaa47e0166e07402b9e66322e5a59d673008b371ae2c88697b077e75194122c8ab1692f775e4ae384ae8612d66416100cf18ea2db6d2d2135483e3ad66311358f79b5667e6e56acbcc5fe7ac4849038b11388dfb6071bf8229ae26a8b0b8010dcad13e12d001812938475829b8b1a23b483d43387a7167800cb46f7227105f6bba0da71d6b0cb31a499e56cc1c14df53b422830dd27761a7748932898ac08f1338b1439da51e1e5215a76da3d0709325803e88624061ce8026f837f5bc9c30ed200cd83198b4cca9bd2a91976dc999c5b7489acdcd1ec22335e1f742f5fcdea6203fc8fcdf20d595222c05543e032f0fbe62de69bd9c80dc4f305f1d361bf5df88e9c60f02a63513f7b6aef827bf0eaef65e1db50648301b7c0f392c83c8ce92568cdc315711750f9a2c9c5c67d90db7c262d4c9e1839eafd4d3a586b60ffe54f6bb467d2972e5a50bba83101e9e57b88459c8cc51412459739b2e234fa5deef68992d310405a65326e071e9f7e9880d77f9c602c95be3d37c9fcd255565977fad01f2ffe34b7a41ca2a1cefc5560344d0dab6855fd936e4a211be87b5abb1a3a28173a42dde8095c81b18abea007937660ca1df84ee54b5fa2fcbc07b2d17ece9b4df43b58da5c6188b875d4daef4796804840af3324d98df2d6b62ea942cae8f3cb4f9c63bb5b300d39f7078149cc664c8154553e4e5b46e003cd926481f7b841815d4234ed5d7ff2b38dac521f8a62140bbf8143b47ab51af96543a5bff3c44f8988aefccb51418a113588138824c5f8848397b6331cb726f05ea4f19078f40967492fa6576a45c2500092e840936534750cf90307436b771c3941ba32dadaf5aab682763355590969b0f5a2b55b4c35561e8543062c40b5e81c1037901bf029f2e84de2ec3005f86000e509ac133e5a07dd9bcc7cc53167fe6e928161ffc86099b62f19af9d9166c7f5ec62c4be9de0cb238ae53b0200cdb8c268213f7d764e52cd1aa560327f0c9e31ef527f5dd07177946fda880bab35667ca5f1969a26d82f0e5f198e3e9f44248c297d55a9e22f892447022b8ec074c8ff57d6ea6750ee8e9e162d6b0a1dcd0e4c13d16dbf7d66d8a9cc8fa0529e2960a404407bbb91cd2c10f5892c045dc48cdd3a04288f288b512d7d467001cf96db701287e66314c0d6290981edcf057c727da62c29ca322238f88e8149f4f82fea3511b6869dec8c99ce9da1c9f5147e88d0695264905ecb406904305b33d1c6d8e3e3c03d437a15312eed0877d876e949589b26b42b817d703fe5fc5c1b82b659a4f630ac760afcaff6ccce2f69e3d90a18db0e349224be2b35f8fb55758af81150b5f729c42315188e148869fb0f35f1f641f86b61e33597150cb6dfbe54e42e864f1671c701d6f422beba84681bb019cb9c5346f3f1c05b877ad41d8185123d4ac64b741f3b51104f9364932ed20daf19873390ed73266239b43db67e4ae2611fe687c0b7ff9b6f11485c80e6c9495844fee09439fb09978b73b611760477ed8001b0b3f11caa63672c9c8ecc41e4c0ae6f560589a8743bd905efe28ada82daccf0c7fa7287f150c23e236f7c903f7707c7d7d06958bfdfde88091a241acf1ced3f218f399dcb13a22796786f32fbeac4268e69a30e41b002f51d18eb8ad267715b985df5e544820ac9b3d5231170a736920a93ec2ec09fe18bd77c9f585f63f3106222e6a092d8758ede91aef8b81c7e67a3744a464ce7629d265a77cc6429ffa3261f7874eb610678ddb914069f3885344bdf2802804615e624e8d7f7c2cf1c6fc30d4d3393c84ef3fae0af6ff22429cbc3faa47b83d0e5fcfede5cc8303d6f8aabcbb864e0b2a39ef4421389ada13cfaf45fbf8f10f895e1e73889ce6a674751610d8944257abd8417b50a670445d5b37124d0edf304efeed35bcedfa8769de9d21482d0be06190a89682d898307bb532b457ad72a5ad34f2788c7357ade3db37cc39383e2b1151ff555a60ece8db1d8ed5582a90927caaba3ff3d81bf8b5cdf2397c1ba75334b05757ff528d9b8e32583ae8220cdebca43fc98bfbbc86b1eba689a6178d0683f08f31237c555234a9b3f4c0b32984547cad47f55b650c30a6cfc22d64f7772075806356cc6de335433c1039145119f4ef26d1715d871a86ad36268d17f2d3d9235a1848bde2ea2dc0e552610a4624fde41f269d5930a8929ea69da4cdc1cad23b4c3645b3353b52fcaefdf4a6b9821563af46f65f903cc2f28ad38e43549a830cc98970cac816dfaff1d19b2cadc327230a9c5f12f0ea2d2eec4307de7ab664c856dbe4da2eca64dd2cb007b1664f343bc2925d85f4c914e43975c4f2ff4e70995eea43fbc163831a7485a8527995534f3351dd9d589dee9f2e39dba017e42eedd6992e71cfb4a5507cf64a1318610ea807d9b02406e4d980e030c26b9ea2ecdc4b13cc3bf8b442980d5b3f2f50745e7db5e3d46ba6b3378f0d208729c439c3c6cdebe720b20232d066c00020e4a08c34547ce905dc712835cb275545b36f60de3a9fcb2d801f9552f50c238870e4f9d23a52c27b0c8430db61a28f29efcef45edb414a0c15b26ad9838cb5eda33ff08144d6b5469864127a4db70f54c24f8a5d90fadaa2b1432d8cd881110b631f010e524daf462f48e68e16eba4afea663d1cee6fe398d0f7e89d20990bfe6730284936a3a43e4480e9c44a32125f9562b0f70f1bedd46baf0ef178715218818e0f6deed2437d4e118a4fe60502bebf245f8c003ccc869ac1533555feab09f8f7e76eef9be444ed317bef61a69e5412f37d0ce13b91802865fc7e0e57d793c073ce14f1970bb52426a5945e819074cf24ac0f8ed18778ae8b111756358b45f6992b594d3be009666a20bb10316e71b481644167745e93682655759993b763a21cb9bbf85481106373cf925cf106884be280ae29bde1e92e7d45183ef41ae5a4ff2831f648e3b596f3182a4b4898bd30102081174ad6ba4584cf6951534adaca693f820ba8242feeca1386b6c642721942f39b7a275bc07a0be1fb01f2949083e93405c4b57df0543c5737964687a1827f8efecfaebaaf52a0b62cf9baf0936f77fe5a228ab35a77c4e9cc2a9a1fe0945e7767edc9d9a30aa58070294987f52c230267fe3e09314af99261ea653b5caa19cfb4b572b0af759bffe42ab0ee1978acc42e255dd545c2f28f65f6b2a68f823e1b8ce9f52e8da1cb81f1cb242067510816103e98e9f6c7b0a1211872efefb6e2833474d0517de82870db071a746cbaa5378c3040db59c4ae4050656f4d1377813c38a16072c5d1f0f3adc4542df3fad98512c5477a4904b91da22bdc1bf78223e080692c1f46e653d505e394d10ac214e33fd40cbe2481f61f0e7f727ea83e2b4aba848dc5f40b16e66e2e736b1f6aa906e4658c6bad60aeae5c6d3cdac6a600d5133d2bdf790fcf9a59daf519fdb3572a554ed2ff14669d7413e0683475b10e803f16eed5a6019058cf5e915b5288bf52cbcceded7841be0892f4c46f2f2f52f49ab603efe1d55410db7ad75985fa3878f210ec87d90220349bf23e6c6dbdb3a8966566e9adaf11cd929ab6677b54f7cc4dbc6ddaf7902f004043fc6ec20291cf82222550fe518b2e87c19fe1739118fa45df815d5997a95143a6ce3eff19966035d5f0337119b8593d7150ce0bb478a9167fb4ae3b7829eda660d7583416a699b9bb84f6bd501230920c7be16bf7ad189fdc9a12f5874a69150719aed4320b0572d7bf2723a2b6c2fca9fc199920e5e66290bbabd50082eb20f8af40491dc44a5f6eef6b3b7d8e3a8e5d01c6a882936fefb1a37feb6a73eae83021477183f36b9d8f713d7ad3f30fb72f4c27d55308334fc4b296020b3723bec07f171fe8c2d6a0860fd69da4bc6f6c66e273198e048b73644207fd6ffdaf2e3e3143852c9ce6ca5f7ff0d18b113b1c202926a5693260781792a076dd27eb290148e5b4019bc12b4816b7af228b5384af1c7aeef9c3317baef2ee16e428bfc430aa78b4ab7472c80443c6861778ab691edd820f6c92afe288fa1d402c6eb10223afd09583f17fcd7ae1c345b4f106a515614d54fa1d650e1d426ccd3589a369f4b7d5280104bcbe47df0043b000280f98d53a54f525990af8f208cabe67bed8d393d5bf1aa967478d20e112562e2e7744ea8c866a082507fb15c1ea8fbcd4dadbcef83b95f50b8e81b39a0b44ca796002f1d9a14bfb799dde085cd2705a42c4b279b27a975914faefcd2605e7745a3735ba56e6d8059fe058df4005337f3e385cfc0c2f900a1a7496cc770a1e539f1b5e5756adf9ea110dff0d78cbe00375dcb867bc186b94b2d35349627e85c89f4daf639bb247ef8c2f415fec7b10ce89e54f6d09ece698831abbfad108f3e73694fd7c9e0b6a9b0318419087acb0f116e8ed90e2747f4fd345b275e9a53928dac60e41c464f8de78b6af8a0848146dd19513da1da6dec831ca577a0dd562c7947a1464237c96477896ed0d345ef41ddd338a9a10d60e819f7bee9ad901d1210f790b51bdc42b0242d4fff5efa1ee0d4f3aab87c577928a311e207d811692c6950411cd4333d1e937b35ac5100b79730957aab7ed5195aecfd3c21a97c5338420eeacff356f8967b84448a6fa5adc4b16bc172bdeed97cf6f6a27cdf73e129d3824b351b4c61ec804eb3d298047447371f24b7ac0f569c3cc4b605a4c227f36de5abc7ebd76953e24ce403faf0958b3189799600991017133f3b2e3fb067f8966d84914e4c55928efb9aac812a25241fd1a929d98d82e57ce07ff3730b847183f44add4b3c0600386db2610fa00f6c8243362795004ddf3effc7227a3ad0f9b3a13472485c540ddc9fb9d83fe04ddf2309f980fb482a8a56b2837d5a2cd84c5af922ee1e452f725c9d2dc081ba49c20ecd0d84907f3dfd75a51f257851dc6a712e3746ce3c6d65ef2b09ae301102a96e1d87a64e0fb3459384e47688bd9474e5312a06fdd9de201ccbaa7025e379af02600ea781a24247fc8e26dae2e9be1cc902df9e0801ef8af7792548a578bd29457cc97109af5d332e5c91eb9162aa85f59bff7d350324b18f55440675e59268d2962e8a4c9c393883c97750d7d54b50541ab4eba4a2ac780b2d8af059e50894cfad2e00dc592d4c7b70d73f4969e787c6e9beb242fb1e78c6d813650c1cb4659cb21a359d734dd63eef80b2a733f5f180221d8201919b02c298e015ae6fed028993ea24b6f47270ad4b268a5b237dc31f0ca5f81c0d5c357924833e234e57eb358843d45c96417428870f4c180c954c211ff6a943472f25e7dccc3a70ef158fc55b83000c5431c8879b445ce15732fb2b24e766dd7065ec4deb48dc0af90c10a72d8037502c27f94b44ab36659cb1173fa8d1c80cb2d9d68c776d4264ce1858fa5fad8bc7ec52f5253be06ff017f7c7b87b300a8b3eaeca4841eb369b3d173e0f10fe27ffc049f48891bef2dff6062ab639ce5df50ea2ec26a4ed777587591411816cc6abf3a9c0e6554140dd74c4cd05a1da8dd65536034e96ee8c4447d7528ad491ed1a9a809dca07b3e4236bf1d4292d9d38755e5ff8bcf3580196ebaac118dbc38978b72efa004d4f068a86bf5e20d17bce046291e8eb36410bfe796b9a9fdd893bc260e7f3456d781a14b1e3f0da7e7797cc6cd99add2c04685fca647e6c0e948c9a463cc7aa3fbbaf2ecf2e8f8de9f59c5d3fbe509af2b3b2788384eda2ec5c8e4bea6f91654dfdcc7f6bb1d762512665cec9bdc1e131ecabc1c46e6eebf81fcc9145acd5a85cae6b880f65542cba7bc3d8bdd8d99e2f552d2b3ab4f3d0916aa663df9c5cb4521c43622d1254acfba81d59c9f593c5f009de8789e69f54a76d25475f6cd0ff41ce351276b216312cae9e2adebc7fdf95c8521a433697391dc7dfdd0e4a29d969ba00653d5e1deacb0a58144f25254413c14f88f9f27553a0d28a0edaf9c794c56018d0e2c70a8f3eba8354e4b376c1bdac4477f470a57d3a3aa9ee8af12456e566555d53a73f15beed4c24586080bea02648a3d0fe81ade0e3d0b8062dd77c6df8bd9f54eaf200b027076950324736a861ca31bc437912647de4f23e1b957a4fe9a5ce29ab49a8547cce2e81eb8d216daa9d44734fcd0289ad59575b5790c1679a3c2368f50be11b8b533ffeb442a88761922c29f3fa9facbc380344c6b3b22e5ac708a456ab65f55a94224eae5778e7d1488e97c6986da49d512581f7052ab48ce3bceaa8e19935723daee0aa0adf662bf06e543a095a1aeb8275702b3883fa0627e2923b1f8907ed32428822942b2b2b787bee68773c1e82cc9521889bb3f21f4429a214c559d6ecb14b5e2262f133fcced3cb843a96d472c5bc03a377070037dbcfed423d6117100c09d9f17452a39624fb4ccf12a28e4bec23fe035da4b9ffaad994aebf62826e121139b35f460c8d685c6e48b7fa60c801cf07a3ca4ee4416f608572ba354064aad683b9cf4ce7eac6157c7ab2831b3edfc4722848b3ff8d8dcc8a15e1dfab2666ca95c24f156081b0d7e52c9f52b132c7de4faf61db63308990b223eae4e38b2cdbde57a0177cc620524996de437ce0545e2d86b896b0dbd43ec6af88aa4cbcdaebdb66d27e9002091ee77833dc109c1e34c0409a32108c619996e456b50a7bcbf0e86f309d6ce431ca5e2dd6e84a8823d4da469f24c2b8be71dd6c65776bd5e7aba9704e440211f7bc00a36ee437d7af49b454e545bb7291bb811b731740f63f5256de4fd7f268b6b81080dad7e802940072ac39780015c3443ff7a67eae370572281709d377ca8ba0f5bbd46cae86cecd49e32e7ab3d023dc4eda80bd1f0597380e927e476c48cdc86c64db8d6aa1718824925b7580c3a6b2b2e8b71fc7197777bcdc204450ae4d324981942612829cdd5afd7b35dc6506c5e7a9cffc19f17fd783396a0f391884ca521621527b36a12bc703ded3014902ceaa1bc15a28c6011ccfe11ab0ae0b043c85789caa49c709371fed45735c7dd8f09ec46128ea2f4d232ecea726b6de9bc02e67813cf76c5bd811283818f7b39368f09d43d11174930e78ad2c4099446622b3ea1801717e24f9f1c04dcce20f9285c81de6a7cb0dbd4f6563d2582f8821711d16a83a1a192f16289b7acc9236b8b77d4d09ade86f08bbe80afcc94ba9e9bb12bc3b231ba974b8eb4c9e757d67b3a4d7c4e30e51103541b8b19959f47062cf2cfb26051bf680adc724e3ade0fd34d62169822c8a191510cc5636382a070149c96e402d94edf6f11442a9049c134da51fb3c6f13d59839206727530f6133f442f5399d599628ad3cc8a26a1d993a3079547ecaf2d18780a4128e8f4f77e4cdeb5fe393d2bf6c400322995f4a5c3196c18c2dbef247cc50b662238005e6d107775e2efa76b30791daf151768624a4c3e141bd5d945daeed3f8f86fd047ad70793bacb5f317af3fd08941a83e1890a7409e9f2408b82bce0e4043e44891613f16b3bf0868f42efc617d7a174396cf2d69334ae4b3198d496e23d4d474f10f55fa5957d89400362c9d2c537fe75ef5cb08efbec5b2023ce0713cf29a0020d80e2dd6735beda9d82ca376b5dfcf442bd418bafc7ca2dafda75fb8ddcc98ff086eb50701279c4568fa1e014336c552e5672292c62ec3794688a7fcba984f9cc78deb875f9118e23b3e86c6f36f4547066815d79e25f578198fa729f9a79cdb1cbde64f64a6b11c767d3581aa46b5cbf45443ede26481e2789e0b1c3eb9ea86b394f72d7e1f8089bcb8e24e3eaa5471d27247fc88717123e66ef2c1b9551926c3d6955ca7540fe70f9fe8ed132e5190400a1818f09e8d3064de5a4a2bc4e2fd945826dbfed2ba6e93cdd881aa1d03e9dba8403e7971bd89b236d58b71593d81559997ebffa2fc29b5e81bf6fd1dc46abd7cb82e058c304c18699e5b36a50963ae75559453ba665b6c322ec2eda9c3ea295b9b02144513e26135a7e6a362a66cd2f4007b97277e1215fef5a50eca8123af54a4292e121700ea9fd1564bac95abc35dd475c95e5fc63d178e47eed5ed037264c86a05ce227f2f32c784089fa83c367e2ea2a5948c6d5f80808fa0764370343214a6e4bf64d64f48b4380fa77a7bdf6b0cd0ae8b29e9208ef0164dfbca55238657a5b7ad8bc124ccc0b1b2c9bae9a76600b5ca55657565a95d1ffe3d4fe29e1e2f2827e36aeee1a8095b028ce0c35a2317f99482a589c61d4715eb132f2241a9140222ade594d7650756a3441bb082191f8afac0510a278aa8c8d58a5a84c27f85a9c97d446123d2cc1bb53eec61f8e7e098ce3fa17c15d4600c8fd3a6a2d697af2b8b44ac902f62bc89df7326400b4454eb50f6a7433ce98feaa7241faf67b6f6bc08e4f29d8940d2fe5ecc322cc9c01616ca8085074b74226be82b7755a8864b58efd6cb4caac8f12dfd859e49e7af3df965186f2684354293b52b2fba0d9b7b61f0ff4d6f0363778d1f46082974540d26017b60c23623240a2bc4839f9e0596948432ec2ddf9800d2594ef1b541d9e3d90021f04e7dc3146d4a47f225a4b88a1c94ff333bdf079c75171b3938c059cf0c380c28ee9aaf706bbc5b97ada3c652de2fee507b6a800e4731a1e93a4588c39226e78ca6bc477c5ec7d5d5f576e836fa7dc949ce1fe2c15aab8be465948083556e1793270765ae9402806ca5000d025d018130241174030d7e0d8548fbd78db0a4f18c8ef056730ee19e6ba04637722259fe62f2106a7fc4aceb4daf30282ada765fffed6f158dffaf25b30cbd3ec078ff5fc9abdcc6842f18955159b40136d06cbdd05f3f47a2808e0513a8bb8b73aacd00eb608cbb02a18f0fa3dff3a15405fd27eeb74962945d77dd324597a65dd1bc083f7ef3cd1094763a364bb36429eddf6d09acea5e2f0f451a7a5db32803b793d12f70dfbad448593e0ccdf87ecdb23060aefe78084303fbd3e52bc0f4db2c2079bac33fab2ff86ac65d22bb490bfd241b1bc82828b52f5d3f2a02babb624b6d9ab4bab96b72227294baa1ff5e8c9098df92446ce50cfbe9f3d5ecea988e8f8caa5aac72d6b17fb523ad6f873c949ecbffbf9a24f7a0c293d33c0650136d5ddac75ba8553a6505c943d3f8b70ae2b62511a0baad4f8a65d064ad6b48f187e0692fe21a96aaac42de1564f935fd18e1a265f10e38e4839942cea4f5ae3fa43514f45b9a491acb28b1b95aa5bb21a5be8735ed6545c028468433d9a6879268a999fcacf251149bb260646ac0a2cc934b02c5688c0b185f10c45a48ccc97cc7270eee241054e83ebd55dc9c2cb961af5b36629963a2fb5709261113c6e5c66bcc8fc73d4d6c32e0d615ce3832b0298fa94643434dc03e13601bb468f6cbb0475dec3806c69ba0e7ff73975aeac0c0cb493e25cfbbccddfe2fc882da587bb2fad476d6c96fe05e833245e3b8ce26e60a9f3bec17e5d41c4a3c593bccca8adc3142e2800ef2f3628b8f027ad7512ff9ee6a2239e2ee561d9d1ae48afc67144d2906da1707e0b4d23a221d76916356140348667add834a889f02d693da46512e6f7f7909505242700e6484f41bd2887fa4687b235c86549410cce898c10e247dfe63460f6f0bf0ec35a937dd6c285023976ba8ab9911948c5af5466caa30a47b1ae56d7c7fb2ae13b1846c241c7fb0623f84591d773ca794159ada7badcfac41379b69f810500644a4eed5e83a8ff8e70602e0b2bd6d59f3b0e01ff2ca004386fffcf672de5d3dbbed0ae98a84b11859a2295b557ea1763a8b2927bb70699f2a56143ba1c6ad1fd677f2ded266eedcca8538d8a7ea36d176d257490abcf521f896f8dfe0dc958c66a125538a387a84fadce5121bd34fdcd45dbcefc0741833a81ba35a6603f5d3eb7436bc9f75e6ff8292938f363e64fa612f1467d3f3f00a7ed8d73f7d0c9a1b95092679882df5a451d12d538efdcb89aeb0f841bf7c76a36dde45837174326eae0409ad3ae3536484639d5d91aaaf63948ae7b98de196a2e4d82d8bf7098c478ab1b9710aee93289b6362073c61554839f174a4f589c331f78957783561185e00fd0a95ae8c645198076726b654c4d818e66d74b3055cc657b0cdaa5646c6485da29c58e68949bed77e0320a475317e568cd7d496e9256e3d5dbc737f8a03cebbea5bfab6d0b636e0f7e6cfdcd07beeb2b7736c1f16bc43c817d92488846fbcc1c6857c3c71430ec10934ee406402548795bf8ee8c1e369bddd0a382a29a665e66a1856bec91500c354504694669336b229cbfdaedb9a7f40cf7157f417de65b1e76f28c538d6b589d8e545365373ef41181d4133cce12edf2cdb10a3a324dedb9567ef6d9b33fea55609275138f6c9b898d143bacdd83479efa209e3d8fa5e702887ddac52c24ad028efadd57adce6f433a655fd75725e2765c2cff75e6cd29004cfdc5e6b30ad500367e2521858a16c90d475b586ae80725d43fdf5c86339b1296b3800768e731e6361ab23b6cc8d914f8416f140b47cf4635f0017ac4eaa55beb0a4faad29d615f1a9d53196deb7eb7a5f3f37a44e8ee2246c98e44c6ee467af69e4854773911cf15bf581fb2e7cb41f5fed9497d5a15c38dc13a94c91db682813e855d9b9ee4ebb41625e4cbc305caf3284df797dd1990fa106e1461dbfab9df2dac2b81b4f4679aaa2a4f5cdb07087a715ffd7fd42908c26c305b05eec37c0583220e5483bccfa65d02bec374a3b7ab52876e3cefa89f7cd3ac6214135f54f2c0e6a8c51bda88d20dc99d65c192faf1db0ee585e4448bad910cf32d72fac65666076e0814aaea20516f7b150e7a460329255be99cddf68ab4b8b6fcde9383b2a021ac843abcb221436bfabf09230dcd52e034c79a904d3a6945ed04bb20d3f3c7f677e0f7585cc38ce49c7f48fdf43cd84c9ed8c4496b02bebe8fb41b10daed865b63069c7263a772e2f75259df033aeab2348492fdbfe0a268d8538bfe1a1fe6c7269fda644e22b3d07ccbb9ef2f7e24353feef43f2be887fb1751716101e9066552ca0f050eb324128968e232b1727b6f3099ea70496de338a51ef8556620910da6bf643443fd9fa7c2e58b85c488cb907026f0c4f563d9c6ed0f08bf0d3a4bf67ed82918b5fd98f0fa3990ae86ac9f4e93c879227ec2ce5a4a9177b8c94286e43facd83bc941186082c2c1a71df25198c1db488e3c1545069ff39e26a7a359cad4e52886052f00b132f66919e5b8a55bbf69d595658963c86a728929888f8c41d84d09ebbfc2cf47cf56b6f43ff2c5d3bba7a3c752eb03861ca1eed947a05856cdde5b7e73de55a0c45a3fc77205dcfbf9857519350106e667783dd62ce21923d3132c0d8bdc859f13bcea87423b25e682e42acbd87f3623abbedf7e219aacfb3114a0eba68a1d52591e7031bbbb37b3cd7b223fafc0617818772874fe8e99424ac6ec91bd75e61ad35c868b84a5415f5627277ded23bc24e8bfaba9f61e7d0e427ea284f37f67917dbbf706ab7ee8131ac6ff070847f063ab0253daedba30a48b49e481c0b636151432b7270cd70477eb2af8209e362962cbf4af5681fdd711636d568c2dcbdaf6d71037443dc057688bc82a6f50b0a969902b29b5c47cdb36acfd1f97fe8a89c1d9adb818d14deb8b77ec0c0f6c5f9947d78c9fe2226e1b96b0d40c204654ef6018d716b6e76f1b5d4efcaaf947243cf2f0fdac5f491c3b591e4b410e9a56cb66ff234d2b9f1434d919350c0192c71163232b6fb1e96398cbfc069553d94826fd7312f1deaa3ed7da5569a0d40875ec61962bdb94294541e561bc3b3835380a2d6fb37157a71451e428ffceb77856bcd24c0266f6d93f0d0fb9e166fb4f1302de8a25c2c5238f43fc2c81d860d1dac794e60363d08eb9a209c5b7b6ee04938c870a6db1739a1baa87dc7c8ad35f7c9398e3f8b18c473fc0dfaaa0c3d0fbddbaa4ba795f1d6091477071b1297aad63ad7bf10235a61f3973130c25a3650c8ee4ae205981d789177ac4cdb157bd3c501a94b2b464a51d9e52afb7d5cfbc3b202898521097bb731ada6eecea2a1a0b50de4c5be023db51b57f5484f1dbd7c86ac3874bc705efed445cc1f5465aee8b2b578ab7f3b13f8e54949c0961015d33e22166369b9ad5ea2b918040d66dc98f2ae88b7b032a950318d3cf9f846824c73876845bef74396504a896d6f7b28781bbb5b0eb86b4bc64035abf090a021786294c0f5915c01a7b459c041c00c586ad13718412857c221a8cf1079001cbaaf3fd75530df0f34002dcce81618e4b88bb68b1f65802c17eb665f0a6b5e6aa4313cfecf4a9ea67077b3369ec4ec267279c588c1207c850403db82757004ca51012f766fe2bd0ef800ba05fe01eae92f89c033aef1ab4cbb800df900ec16ff00243b2da313413f4bf413e21d59e1c57db19fcb296632bf6f07f4616c8fab77ed2eb2d662cd501760f0d3e422499ab08c14ffc7e4687c65523f3c74211cf2c257a55ae716b9e73327d0067d57472b1f1f8163798c6eda0ac91a8b556cec592b55f94acd12b4f239624bb9fcee1b7bced29c409f49b01480ce2b24d77fb5050fc91259d1dfbef95f0356bd0d337b58672c1b510aa68d0e3c447fd6c7b588be17ad783623b0770bff4d9ad18befbe1933a9f2bc17057f500b85526d5a7012e460bed1109afe5604955b84c5a3a0c9ef3668856b75cdb0d6d8f7487a7febc4955ff9ecddf50617b615763781a1bc11d7b7fbd800bd2281283db9bae7fa8e93d6bc02aaa33ec320789e139da6ea3ccdf6b7dcbe49a8eadd267f9a7f6294c4ab610715bb6d69acaa163cf24c0aac9a0e77d032973335a18929bac8f01c371de2f092e08a0590bad52a52c09a9d01f0b974923f92bf231cd2c6742d4b88b758b49d9fe606fea8f51cfc1164e11d6ebeab725820b883b81b98a1321aee53ffe738aa6ded6da86f73e3c1a86d703ab8820ed06f91aea131160514fb0745e6574bef1ee026b5b0db24d4dc4b156f5cecc412b6ccda97eafd78588d01a04e9d9c60941565f13f17e0b86dbc0926acc0b670a84d5e427597896bf5879d4dd41589cb244acae3fa8b35e90bf38d449531c4c049cc4512adae2b539cba4485910a3526f5ba170ac9a2e73accfc14be27d81b6a2ba23741fb5b2669afcb000c9f9a92204f5fbd87e5b755fa1f0b6ac32ced18c66dfc7c10da454447aec133c5964654ba5ebd693f1c14deb5121e36a1a1c46180b96ab053967677ec6b79d4b4c600e6dd2804299da800be302338b39a69a2ba64f48e2327a87e10a498fad31fe8ee8f14f7ebbeb552868d8875d83e9f6a4751ea00c3244d8fb722464dff0ca40c94a4adca00716445fa78693eb7a481f8259e51a4e168e9d64b74dfd3ba49f3416c8713a0450f4c3e9739c9b7476c2fbc755fa638fbda01ac93f15d22b754e1b6fd933b8f52baa512234205aedf431198468c0d9e4ebaeea1d12bfbc2f6072ccef352c02c6898f7b8b3f018d1b5eae2204376b4e95898aae1536e23519fdadd3d0124a28f904f5c0fe024fed1fa059af7bb60e641f5dbcc305d9def37030f8950ad14bfccd9f52244f1badd6a83fac754fa4e25024d0b97e019ba314a31ec22e5123a8067d44d36553715492e54b78daa71ff3ae47404fc6025bbfab47b0f8adcc221ae420b18fb1cbdb6cfd41a35207ce931785de4022247fb70fb8df989355fc6bde330c64c1b12795e5307be3406a9e7f6e71a2b3027f77b117cdcf91111970e8e58bf062c5e55188f48e7bb7606e5d67b40587eb634a59a1fed071dac1f45913eb9ba3525bd49c3d7e410b4ad8b4eb6b53774f0a49f8937bf57463c6181af1f2a3e45ab1c3f55c747c2331973da2ca346c32f1c62fb3fc58f970903d9765902be9f11652bd7cbe776761d0ba618cc85b68aff8fa7f8c6d86fcda0c74bcc1ed5412e72486ddab02c56ece8618430280ac406f3e0502343de1f15abb12588a8f14242acb1acb2ab254684adaf4e55cbbbc3cac2bab640e82cc1d87b458c33185be304e4c5fb2fc9d934f10660dc1688f886fd1e0862ce16facec252515c2bfa904a2c9070dc2f25c1032afdb5bfddc3fb9d37e9e7b1ac62b284b36b05c1d06d83e44a08129b4edca72dd47e05d81862258a135487d9184dbe2c9b7e4a3a701796046dc977eee6c9f9c18639c007d66b6ddfaf88bc4913d6adb888eb8bc0966f1e902de6a5da555df352922e8f2750dc97eed11a2a3aa377827e6d7cbd22ce34da40ce0d8cb2948aa5aa3557aaf8fddb93895f86862662ef72fdec415319892057c7f7c79b068687fdb552dde6838a8929dce0a80edecdbb7d861525586fcbc006989476a8d55a15c813e08331cfd1dddf58a31ed7254bdf118c19116d14da9dfb617830c3657bb40c66a10bd0ea9ffd35d8d227a28377f068d694ac0464a23dec53ae8a5e857473a8622fa4c6e46daf02e3a8b878ef0fd860aee7f56a2e32fb7ea1e7fa121b565dddb9fa70c450772b80ac12cf5d1437023c47f12af89daff6c1812f7448beb5dbc80952a9963f8389cecf2f2ee541626dee6af11c7cc2327a9c0411eae841080a97139758f95d7d418a47eb2e0d38ed38bba25dcc3a631eb0305fb10ee581f3be0e3e05b56a298e446ab07a6c03970434848e2a4a653fa6cf106fd90aa9d6701cc47b0f2a6dfe44c5e15d380e0efb1e8ce475a2e8764039aa66c39880b5eada10642d7e030794a9c33ab7baf31a37a5f518a8b02aad00a8fd7c2a40abb2a6779fdda6ad23b958b974cb87bce967a2d2171a6c4df95b4eaab94a98319d13b2ce386813be638cef14871097c9a0e2d75c4b822ccf1695c8866da8a49e5ca56c419f40277569ec94c91e6d8d68bcfb6ca4afa30a02c984261fdb7f095d6a280c6cb0f38a0bb43c5968cdf9a1a68be2164b6e4eaaa64fceffe4feae7809c4603f151a860a316b31c43eb5e8369e490f617598ae1ca9b1533f2e31422d62c533dd2cefcc32dba9b64355648f2849484a4d7fd271d48b98d6f98143fa1b6bee4495689c29e21dd0c7efa805c6c013059da78e83de41dd32267f8dd802628957d1b69a94932e8f3fcd79ef18cb848a66d111330472e0582456c608410b82271081651161ebd73e9befd20d0e0df16f557a6f62d5c37709ff133ae0f646b7cff4c0febb1ba45b06971e92e28b9765dc8b308508bf603fb3bf5ff0bdb7490be8d2e1464c49474f178c8d347951adcbc5f7c9b6149fd52d6a1265376bec12ccfeaa7c145815d392f7fa24afda2bcb860279af32e97f385a638d32b2a250a495f6a89a4e01db868982d82e43523f0c64717d77c4e5e411b8594a05259c7d4d15b47680676b4ba1757b74c69283f4e37b1c18e6c5460cf6439bc01053b024c9514a734eaad736925cdd755d78c4a001659786483f06b05c9f9dd3a84b3207754b8dd1f3b4d0d1bc86dcd493cf5de6c2022eed13e616308b9cc14956f9467057b0bb53e670142a5048429aff782de5a5068b71d16306f73c880a33ec6f286dbc58b851ffbcf8a46999e5dc6b1446f5a7db259126d8166552ed553356ef7fd64c17a7e586c362d3d8ceae23972f5b0f1646b0e4829536f3443782084ec5fa3db647db4f529bee9e8d22ffd64e42a4045bf0845b79190065358f191d966886de5293f94973e95d34aa3c326940245e3c07033059068e68ad7398138b3e8c233201c1318fa4e577fb3b46bee39e315927be9bd160932f24c2c8052f6e7d7ba731fc867a36a53b43e098cd727b0966b13827e37a71c863924b9ddc77b3b2d4c8d705a4ab5c63e89e8670a32daa1dd5f7acbe7bf2e8a331c257faf7986808e77105136cfb45559d82c48147bed682f1d15132b85cace399e623a2e438fbd0592c97606df4e72001f08d14567691c27d0de7112680951e2b9effa62642018b2cea68d44008317a73590e639fa6558ff25a461c8700f8951dcdaf0027d951b752c596dfbcca42db2ecfbe872f438d60c765a94a66a81230edc4f92b922e450a5c83fd72b7aa0375d9027ea45925cb720b1b1bb337281317b8cd2cb3d16fe26e5a267bac64699d419ad76470004602b12c104937a756ef3c7cef58294a44c79b12fcac0b4300a5e4d137aaa2a121d795a35b1686df753e569812d0608b55fb9646b382e894aa824d1017b3904e0911bc2e8d0de0b14ac5a989886f32f8df637dde4cf4769365febabb858dca5435e0f4d7fc4efa0f8cfaf14e5df41320d5b769a79a3cf383ad0659525adb45b76ab098a8104288286b5b75787ee32eed242691d4bb0af76382942a25571a3e606f84f3cc96010467ae714888d3c576944fbbd6486997f59ee0d1fbfc01d0694f4b1852d748d9f4bc40f42187e5986209466eac4a76e40a8d9cc24d0a3a8fe9c1ad8bc8abddd84968826f4e6ca02b7e3bfbc64f5982d36c8ac1d81c099d54a188a537438db52fb230e5c3c1e8a2ed63891796f93817c8c19f30707e3c0f0b5f5b4b52c9872bcd6e121edb8908a8511c41d9e3ba0e0ceea3eccfd8d8ec55ba3b93e5034b40ddb0e5cf9242aaf1cd24642354df779596e4f711e5b2115bb3e82dd75e46a8fcb88c493661e5563accf47acad652bd4193b142b1c5f59f78a0bb04201cbc55419d19a4e4be09a8357ff202eaf4af08b01876321f219df05488459058fd797dd48384fec3350870e7ea5cb4f7f1ede61e0ef187d3594dce0756068eec38345810ee68d392c480325055582ee3a1d7c1fee4728415eb3fe46e6d4d4b5ec6b4cca5c65408b94941b2abc51d984053d3657cee0c8e82e6d7bd0a4435df476913b017467ca06de92e29ceace040f0a007ba25cd84d2158cb4d8a25c6e58c7bfb0860d6215e1e1a9fd732962967bfbfc16c7a6a61b6c7385b125c0f32a976f1525e3e5224a07a278809924f2215eeb2e6740da63705439227e7d180a0f2d6c7d56b72e658de7772f01e07ee2342c29dc62ed96518d813a5d78cd3de5cbf904c4800a15612997f1ae2aca282accce43d9817254539b2b799fe6cd03987bb6fa7daa005e6ec76c2f026412046916d86d5e2a7c386a46a980899b5052719b9fab90f888601394909d69ef859e84560b9c6a8a74ae0c74e40cb9583683aff187e2f382aa357a5a2fb837b76948274bb4bd9d620f0d779ca6474c11b0becfa78eddd2127bfc8998aad1c87aacb563d44c871588bed8a63dc4e959490fa5f313ee074e9755f054838d1a23c82d0f4e6963d1e3f3c169cc20e1e906d8342fc80737c84327e8965fd2c5bdde55ee95cd82fa8ef507e8f5371c9418bd0c3d758f993bebd1e5b5e61c3b2bd9287b3f1ba96ebfb5cf5480dc60a9b91cc3d1a5fe3aca37e928995a84cb9b88d202623cd1da70cc2469d3f6396de8443054a528fcde979ba0216077f8a0113618e6a8e9fb69cff1bbb3862449b5e673de0eb326cdc13dcb4be2d7a97af1100f3304a26d2c38dc52bbe26a3148dcde84bd73af118a00585192af3fa4fbfc9debab17144d6768862f134ab7ae6f68df12bc727125924a915c110e6094d9bab53542d98cbc0c700a0d8e540147abc902cd73632887b9fed41139f256fe03146834d4f14c5b8bd66247585511de8dee6141c672d060d8dd6b3dab6210c0270c8241c967972b12e2e73edb74f8f1853da19b63953f67983ae11440032bffe02c78d311e17f0483bbac10e4188b90b52b1ef120d2ccac626de699ca3ce85ea326332bde377ddddd390201be631aa2fd2ce6b128979bb981796f94dd42c684eaaef01f993e8cfcc376ac03e0a9efb0d62e329b062322d0765192dea7f861b01bb6d909fc78c2cd81cf3d38c5588b3ef19bb9226939853e1f626d646a019acb17b7a3ce5cf91f1bc7bb8dfa1917b3099fbf8a9da1a728ac9e658c688d921b77b7f8902ede5be2d839980ae26351538b64b75eb2c0704acc39d8374433b91569f49e80511866ce129f7ed0538b2f70dd96afdc14af5253d1a59ee473428f26343e4daf3c50f6c606fb6893ddd824b5bf475b319e345cd4a7ba79e1d8f0138190203f1e0da1cadac92a3fc641949e7102f970ec7e35833a75234e1faae1d1b13c5a1ed514675fb16f6618a2eee30e1dd7ddf964af44050ff249b5f01dc435c90386c686f87e6f64ab989bd41a2ebb94250d812c43a60764fcfcc520e2960063d737c510e5dd4004ebf77100129a91b24bd9ad89578c6fe8f25a5963efb9cbdb69f4a6f6191441414ce9a001ae3e9b21ce52aebaf9f327498ad3ff7e7d0d6586393c7338644430b4fb3db5f505b195195a101d8b6b3b45e513c48476f734acb45ff62d890b7975e8a2d68e8837326e4f2d60b7fd5001e890bdd38b189cf5477cebc6597c482ea4a891f20c7598f86124c277aad55fde06fd725d27583ac1231bff15e07ef1caeb0d75c5c1d4860ad0c24ca06cafa9a4281f00f25a9f9f6340678f63b6c1bba1809e2c3f024185c87a9ea0c2325a8457f7144570e61a785bb4e6355f7a3320ce8e7c5d564eaaf878e227840c7280a67f2d1ca8441daca7096dfff120076616c1cbc560a82713074495a8929c1f3fc802c17f6e3897829f8072fe18af9377a1d68dc2460ab7fad48c551e6ce739ab2de079b00f5a2b82fd1241f127f88e8968974c28dc3e2dab754b7c6d7c2eaa0619df4baea7676866b2ad00efb13c2ec47f11ecf7aac97de11c7f4a4c9274d747214c4b681380dc8bee1a771ca96b06fe81b96d48e03fb6d39c965a19ad5ac2fa472ae98db4ca98e88cbec1171ce112e977fde8a8050f03340820ef489edc5c315ce6adf555529533fe38edeacb8f71a05381e600270d88f2cb42037786ac5df4c423d6d25e6f92ca264f656cc4369ad8dc50d0d4265139b4d4585b151d89b82490e9b22cdc0881ebabbc535e0158ab706f9ab53c41f20de07816d30e5a2db0a6c2f5c1dfba5c4a67b105aa9202e7444947e71219ca12fa2657ee9856b75bd38aa7c825be0804123e78ab54c6d2f23708a976a9542759166a882ac83253e09398842dadaa66963518a05f602d852418613579198ffe5ebd5d41f03e7bb8fea87e2ce57cf137bd96ce96db8fe2c01c761f6d6c3ae5dc7e5e31d2768df8ca06590742b01c1facb3578d96fa99cbbc5dc32b555196ea1a6f34add38c76694f90f6a47c6c885e5f0242ca35edfa0d0155d792e58ec84b30ec88bb3aacb177826a714aa68d073a8efb513528432eb73e2774f97f09f4626aad39a783f61b53d202735230ced02b65cf12c013511a29034b76864350a563b70639a8807e90c656e94feac66ad24e9885008314ebbb881dbfcb4347afee1c73853019a02d4e7a0ce60ea9c27306fac360bf5d87174c3a8b2da1b2748eee94c9f48ac114fc8a6aeeeda56daff49a0d8f61a506a295ffc6be6eed6067fc3a268197289712b78f63cc83a455c8793fcef96c298b19bbed35ba124f8cf54edaed616938770fcd292680266e3a09db6db0f7740ebf351d06bc60730954120714225b88ff2245ebe69d288f325b6c7d0249c12076d7c3befeed2d698f546aae74f11f53a39e8e0afdfcad84cefcb76592d63be1d67cba8df923e1432dc04c89976e3079e540a7fc25556b33a1207e6abda377e3c29cb1520fd7c1b33f64bed4a7ef9f30071de6e2ef7e2c848ea757ce5ccd395420160c718b1982e9ab87acaf7189e7482d3522a2af96a5d8f0e6c9817ac572e4f8ab195be0b8eb638e13d4fd177bd734047a32791bdba9fe18310611cfa8fc12a8225ddd52dc3581393ec89d96625d1d176fca3cacdea8dea0acbb1f8bec5514cd1d7e0993eb5272b760cd0fc69d1d3d287f80d8d71f7c879f5d4c9de7364516fed22cae8237ae1717109b245533990ecfe556b7c7556781cb9916d287fd520eddd52728e641e1c9d2a3060f3cb42e8b59a7c702a90e7d939ff2e3b653914a3222d9187f0d3b785bcb4680d3f4c23182343168ecc6dd57f4a55ac768b1917e7dcfad90d891552dc5c289158c95367744b84d896f95d59a9de582e256c837d32905b6b68ff8b9cae4d98bf2a4b5665bba20f3c91983a42c0d19b8ed6d55ba3c5bb392f86ca2a28eb3f2774d3796e9c624a3bd44475d194f270a7215fa33f7d704e12c18053a59ab1f5f04d8bc3a9f7e1d00b7393743dff5d68ea8afe00e795419e07ecf9c701974643c760861ac72e2bec3f01529e128e5ec41d4c55ad15f085f751004aed8f18b4ae87879ccecfdcd7b7e4a3dfdcba0d9abba8515fc9e6d0fdf6b83344e2b42cfe5caf9ea4639a3eaeaab6903669252901a784d474cad5ae3edc1325057c3964f62a6fccd88058a89ef80d9890f05235bff9cb6b852c9a715ab8ad9f47eb781b3c30701de30104b7917fcabf99d171a22ab4f8e903392345f074811da2ae38062d29aac22679b6474938a77f06d6b9203acf28ae2eb8903cf145a9589982006d78d83f7ae6a5b25ee546ca5191f789131c9a69daec7396e231232490761d3a3cf67a2ddab648754a5c47370a8de350c6b30970e5683299d6b101a5ee7d90c584bb67024101e86cfed41bd214a01aff9f85c86894de1dd2e71e5afe265bbc91b38e6aebe9f8777b9f7f6eca739f5f44c70ac11d507fb16deaa2edef5652936332776198fd4cd8b9e7da2c006b97bf6df2d0dcb5143fcd2a0d4a36dc2016c0b43657372d0c0de1243cd9c7a354a962414a316500ac9dff09ed4e1341d8de889d5de4c88e4d56b4fdf19602c4930cb8130106160c425f30654c5a9a315a7876b46a921d49c4848fbe731d7c3c8f58f9b8ab9bc3b6f638dc1a66fe77fe61eb0060c868b3a41e42b1a75def9d1c23de821409aba751746ac2502acd567930b8d6397ffda781c721ab198eb613e114ed90b34357685ec4e417dc111e8da1c5a92205daf3f057541ed2801ad54f7a41ddfb7917f0e80b1a02b00f0907c2a6e249809708c5a6b70127b1b0828eaba5185c962b2e79cbf187871b40f909b67c50f13c222253fc4828e6052e3b3703c59ad3495eed8543a9c741fe445d42b0cf9f42ee619a6d9e052478b2522cbf755b0d930133ac743097c7c8c8fcaa6a86038d4059d38b82419b221f62607f80c98d8dd7e3fdf915106c11cfe2de0fa0f9148c5fdacff7040a09b1a8971526650085e3ae69cf95fbf8a908ba4254368f8aad645ff99324d2c766c3952a60a54bd9f4de6982f5d08960600b91f0eb336d0455761d2a6fc46983412186c83a8bbdc3d27a62c7d79a50a64600cd3f90a6205904554ff214c5ce14a8e6eb0692afeabb4036cb4042857071a8700b7eaef3f8489ae3915f6f3e13a273a1642681bff81105693ccbeb85875a4776cdc085a8619ac58a6cf18f6a219ba66bd7d7fc20c3cd56390586abce8df5d89ad7bc2e4e624edd242d4bb48f6f9bc29b99dd63fb6c37b21d4e6a98c8030fce8c21b80909ff397563da4af48c30efc7beb2e3e4c981c7ebdf52de663ce2d8d2cab0404ec152087f75599baa781e1526e5d3415744009fb37d6d091093e55e7329ba0b47787494d46f91eec964f0c22bfe70434f24a41e56b674213bc50965af330fadbc3e88ed7326b4cc27b4b69a288835d61e03c5ce6501c0c4ab17e56317aeedce49206846f13782e1513c883f00c5fd62682c13082beb06a61f70c01db40c155637ffc79030cad7e1732ce57660b2a39e9b6437613cb5766671ed1066aab5c7388c17618ca45149e37e1b6a9c39d279ed55b7cc97446c2137a44600a4414797ae6139ff5d3a1e9a3e130cb251d15597d61cfc1351734f2ec47a5110e8ee3059013d145bee7a4653ffdd275d2b362a2b2feed58aed2a898640382345939c160ebc59e1f3a5123883a012973c58a240c6d4d0312844527158add8d72cdde0611e3e65cab50c8ec1ea7b3ea0c9423ec56a9da6851f40afbb089d2b1db65e36f088da0238edcaa3fc1378dea8eb966bb9a88cacb73a74ede1c71dd98aabe566452d933d8f1da7a58cad4cef07466d5512f74ebc5194af88870d81a7e3330764de3c41a601ae3c8494549d75e5cb6f58ca1d994cbf968fc73626fe96c7ea5a95e9caf9a390bf7e190d7e9a11af4713470dee9cfba0692a4033aaf19777468e231712943add2334ae8d60d06db1bdedc197e0bd5d3b70c649789f6076aa930804f4dbd53b2d327d54d770c45dbc5f48defde759aa9f1c176f3fdc0cd6f269bbb24f859413679753a03eaf9c52d692ccbaf8165c2bceb3c9fdd73232c8eec58afdcee417672bf8e0f23e8a059c8a8789370a53cd1cc84ec364d6700476c1ef5f94ae40f7edae30dbfe8a0d14ad542a18374524723c238861d54d30312f8e50ccd2c669121bbe08e1fd51db514016540b2640107766f0a78183144e4e1a6fff2649f47725de18f911f31e23917601aa24f00ead135fd538d5cbe2c9bce7a0fc8862add14c0903dcf015c68890273d35baa66de0e4eb9133eda60291d8956ec6eca45800e1f3677d1651048ac7a6b62bc0cc56d6a429280e96f94e827a54c254c1fdd8a73a2798673b47b43bfad4e0beec4bf263d4cf2052465171dbbff91b32058297477bc8b83643aa7dec2dbd93f7c1390876a859f45ee0090dd42258266457cf74e7a9fbff5fa7cd7b318ec818ac27459df7b92c5ffe3b29137f1e49f9c9711da9ec0c463143ed7e3b6bc40dc44ed3c3d66d5a7eb707ced5b885959861d6f3963c6b21b7c4f17ae18b3308c42372b84431e82855e88d97487dfcb1fa7a0dff81f1ed570b2d4fd783ee23f77750e5483d3d1453f280b13bb148958f038209efcffb006f8ee26cb5d9beafba05a63fe1d9350c36caff9bfd9b4530d6f4ba745bc5f79686ea57e9a558418eeef2ccf24ea1297220cff68cf36500f2e4ef2132d6504f054aa061324ea0d3f13faac017b09f16295a1c47c015b5c75bf69ba0c9d39b7b5491b21c1c23a81a5d790e29b3743cd7d6b6db499ea42986347c089b374f925e1213468e27ca00c980fd6ccc12f12910b2c8b40392f0d8e3f69b9ca25223e53c8f990fabc291f89e18fbed50a99e7a98e714fbd3e5b9073a2a0f957e5591998e1742f27520e0415d4fc1f860b010f24dfa38f1e65d06cd0bd7a33d92022a73488fd1444d93fc03a3b16b72b753df8cc48e4c8f7e6f27ae4ed859bf1ce5df34c0632b672bc93340ddc49291f794e21c8fc756d07288d37854a6dc3f4088ab9c24cc0d91180993c7dfe34bcec16cb024da2e217002cc4677c752ce2ac10f9b1a45229b1b337945ff5da1d6617d26c324b5383338beb659a6005080e727e47fa37ef9012be5a636c77ef04c8b6e47768a7cc906417f4877e017de587e785e3a7248d3618be173716c7583a2997098dda87175173bf7c8848b2637ab994e5e66618292735f4f820300d1d0bdf7d3b71f2ecb382f5ba4dcfb8d3e28c588ed40691c25dbadfd755e081a5a8d68f89e6e3c24b91e3b7f5a165fb2761a35fb7400f02c643e2a691ee43289a0f911cfdac411fd95897543842f72626185cc4c22cbc348a7863be58f05594c4f0eb80a7db8b6ca7bc0c01d4310bc4b917de0566cd3da4c81fb60e0105386789090f2893e1e3bd5d39a0bdb03d63e9f73337cca97acc6f13054003bdfd08a899f2d23f049d7f5898b8b91eb73a538c9e5f55a617d011ee39f4538677c922d45b7452d5a1fb7bacb450931986de6e00b5bde7e9485f0c79ac12a3a4470bf973f5325c0f8305cce7c6f31c856c8f4d59c48d8ea1dcb00327b69f5d996cd1ce9ac6553bec255d70d27a4399cefc3f6718db3a3b02c5318c949bbc079306d163b5a797f305da6f38485aa1a000f945f7f85e4d3968b2e1b127f82856b3f5909a5535b27287bf44ef38a9a3c3be1cfa99618ea6c00c3d025d2ed16d4d5da552d3aec84b5bf73acc16c5ba9c01b75b027a6c16dc9c1f72975dbe16e2672cfe3274bf3b7250e851409333f715f86a213c9d0af2ad81d0f56a9599ac7ead35fbadb4d6abc65c92bee02265e94eec2f569dbd8e9cba5137bd5f82f3e5ed14f313382c1a67a134e2a1ddc43c155fcd9290e9a5d5307a2a37294ef7050065f46b17b5ebff5db2f9c8cc68bbfba49d5371d7e0b832d55311e11d20328fea5f21f8d128606a5dd44740aadc6aba07df4e5dbba2c7353701c854f4a86ae1d2b1af567192cdf5e5e2cb2aec613eedb0c7aeb7f83965e3b3fe6ef81248f88f47a55c68720430fbc2400ea77a030325ac4b7c003eb805e2bfee6616611eb095d42569dab195ebe6e29b782058b1f233e3736a3702e36693179beb3116341e3d302d4422721654ae6315bfcb2c20d6b1d2d4ca29fe101965119a3d0bc9a62254fa465d3b493b406c44b01d04585f10d33c2e9224e67cffd7c38a1761ff89c97bfec2970d4d2fd896b36bc4963eef234b56feea7842157828aa3029d0cd2c2d6a3c53a975da10a73a11d92f7129b083b72ee50c7ff90c4ee53a35dd15dc5bf8f935df694f8914980c71b7827d84c35de5b13ea644958d12f3d986c84c2d538c38d99173ff21276de21440adf5714de6e547dbd35ad14f6fb53800ef034a95c50bf0402a97470391594d37eaca382eda6896e77275389ca8c0d139df74da8eecf4bd1efd299b38f1ae6be16c8b179fc819f29ba956627e807eb9d477dd734742b690525f02f26f16349ae277fd019f2f49e92914e48c72a3faa7c51911bef7916ce5760831bbc30f2f96714e13407ada8eaef540058b112c570754348654585c34fc3ca918859749d721b17877d0bdc625c9cf4e5e2209bd9e7cd428283bc6348f6efb9191d831cd1859ef6883899216afa0a018cb22e045b2d3ac5f3fb2f2dc0d54efa88c93c3a0e5d4d4d631238780fc6c7ff62c3102733d0b8a63234ea1a65b2964994bc6afe060f664b67fdf39780c0ac392904cd3b482850188fe2542df033d3e8698ccef6051cd9cb4b25d7ee002ce9d8ca18691f70ca00800f62048d58d8c0e9c317cd0ac24b09cb4b7b8948a63c2c68847969e6d35a7a244975646455d200155b72e672a0c50f9d0516bc80fe10b290729bd41c08fc79bd90853181a6dcb57fe4ff2170d2c881c981985d641bb33007f5ba61afc3d7753aa7a630f103dfcb40ee19ce5d0c0fb4c70b890428529b4384fc65f51f0455bb01205b4298acf23a2e3cb3d859f2826206a1bbd6683452e99eab8502ecc007e49db099740fff30f8ce521c456d47753692860eabafcbdae39a28cb5bd6ae1ce2afd73e112d9ee12694bee15e307f9248fd79cdb9d9ff1b4c62866adb113f43780d8e67fb488113be4b770ecc48cb02c4769e34e593cddb27f5e7994ae2b0f742bc5e91da6a92a80cbc9a8c3e034fc23a147ffe65e5e6544783454638c5bf989b522b73f0d215fadd0b70fc881586105129a81f2b8e66f9054bc818f6c88d69934c3b71d83a1c924e6a21c0e8462310553b2276cfb68e3d3c2c0d07d352c69de27431988f309cf76f376eb49969f4c72dd57b29aee25896cb9855692cdc66b97bbd7856aaf257f8ebf617411d9ed48d8238118d3cb5ce6798b567a523743e043169191293f13ebeba0c34c1cbd7715271729d1003dfa109f29f56f1c6814a0021e60268eecd12ed83eda7f1d9c2fb5e46d83a1a718f6ca73454a58d80376b42d38f21f766d94f2c94b777b760ea04bef44cfa2a1b42efddb85c88d09768b1059661f95c7191a4575902f52b0e0f83f74f393cb97e3e4c361ae12a992b352a8430067573ebacb0dfb84bad0bdd3c30314d168fc39d2bc7a13e872f47db7317f7efca0b4e69b8a6f51fd0d2f858cea2ab1636801edba21569b3cb6b612a7112e38a5e0109abb536507c12e45b9a14e87a14d6b2d20236f5a7a9c4e006873045893ddd0d3c479ad4c14e4a3e3f9ab682d1907ac44bd41d351d8aacad5eeee9e65cf0cf38ec2e3f81d7cd0ce81747cf246adb0f084e322d339fd011cc4daaff458995062c7c00399b1ee38e07fe5df2afc76c772377a605d3c02ecd75acf40ec61fc670881a323288fc6ceb627f4722f2746f88311a6d9c83f51ee026957dae11e60ee2266ea311f74a316633529cff327a4c41076a9061986ce79324a357fbc6386220476c9d5c43560a443e3f30163e1c3b65c0526ebb184d12b4fa3754710284c726895bed7d3c3a97cd826ddc05ab3f2290a61c18bcd927a255d672de1a071f26ab5d2e120e688a9ea691149e06fea0f74e5a140ba8bfa84694d4980929bb772da6febf870d54679bd251c0e36b651c2f4ed020b61ea7e26a3080158d7326f54f7144a04ae03c72325981ed64ea04daa9d7e234af65c451252ef55b7f34692b592b47245e97bda79c16237d20acd34072de168d5bb3ece43c1b9010bdfc9658ce5e05c68230e50024f670ba37d78d28dbe0db64cb1bc58bcd7d878bdfd80e7d12f0aacdd28b7f5534c279d28e57e090513afcbd92933a13412e96dd716dc82930d18ab683e6fe03abf2dcaa07df4c0681af8a68ee6e5438ebd53715f63eb4a21d203463425eefad1d5a81809c91dd0298f99973e3a9c5ec92bc7a4d8ca288c8f5deb82e58f9a943a5ac3cd15ba4d9af52ddcd2c33072fb8e2a1ef825cad3a0958a85596897a06f6352598f2e92225db550194cda355f6576709b80be7d5ec96a9d48e1b9a87732a733971fca2b84beaf758fd3859e6bcca1e9dbe0901f3fb61c72fdb954856b0aa809478e3804e25e97c538e8a175c4cc9359946616ef332f5e50691d8b28224a5cde99dccf81b525a0a2e35f3829962b86c3cc971bfbc7e00858d13de22794239337fe95b0c2fb74976e5a58902051c05cb3f7bdced412d9ef9af71613dc8bace479a893e862405f67c3374065743917192fc97ce2cb4c26983a6a711bf169a41138c4ee0a68f23e40c074a6a09059fd90f5fad4e39a78030411680cd0e9b45757c31dd4ccdb34468f29648f129b969013649a825fab2f792ac32968b7349ef7e4877064e3e684827649667dece1b6983bef5359fa8450a5382ddef6133183af3a574688e4ae9c39c24333bc71bf03954a9af75c3a9946c6ea255b498415d9c7777e44206d54851c96add06fadbaa65eefce70f518b8dcf5e8bc25fe102b3f0bb3378f65dd05ef395e67aaf368235c4d5095e858caecd49e9ab419ebc2d32bbc363e28423cc5e1e573368f9a22cee201ad5793f8464c616469e70b00aa7a4d7394a5622844f06b1603fb73c87f7358d7cdc08a3fffa28ede28441a15c1cba42c3e80d11e3782666ffed962063d0851d211305a84da1f2fc0546d20489dea9cc7502a1c1fc4ed5ef7b86b90b97cffc75f99adf409e6fb9719b7b9e9e9abb4d065424b198973a3d3c3a19673f792143c85342a4131dde194f62f20c9e85242a5b310ef68f29fc16d51a6a2fa41d3efdea7a01142eb30b85f6424f9a3411901c4d9263aaad185313f9c3a6099bee85dba4ec7aef85b729a0b4371dbeb1eca21e91e1ef585e0e1a6db11286329c63ba336b410d9d8c90a741eebe9fc851ba142a2a7a5ee1ffcee821c1385e4549b782fcd98c5a945dd8f34d8af1337bbc7d58a7a1e5b2258ed90d8e0faaaee69890a9f134e051e8143aa5ed937853f5201126e7f9455d30b0d52e9babc048564a2ffad8cee64eba75931e1fd4d21d31f5930183b6d8ac5fd063568d36aeea74ef5dde7ec92ceb59a2667518e56aef66cf4a518e66f6a6cc87d33c405e845f91b8945b1e1b87c1c1f5733ca057ce17041acfdcde12446c81c52b6d021d4a9e250956dce1715de8041193af48ce6b491ebbe3b4b4e714fee6e66538a71be7889472496fb0e957d2f20ed0df28cba7516eab0dc342096f7696d09c0ba7bf1296d196989084638c445bb824ce8180df4a6a35f65543b882c33b13e737618db557130d87d36a78875bfe965ec0878b41d331c1a420c12c9f9c196da32f63d02786ec20cb39c5ae499869d0fa672b289816f2a896e508d60b0c33eb28436b32a9224e5078858f33abc9c193c9909090e7ca54c28df603f61cbe0eb3e961d7a6172ad9b7292db95fb24767c031b715a96acdb7</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 请输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">此文章已被加密, 查看文章正文前需要先输入密码</summary>
    
    
    
    <category term="其他" scheme="https://huajun-chen.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>系统设计与架构</title>
    <link href="https://huajun-chen.github.io/2022/11/01/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%9E%B6%E6%9E%84/"/>
    <id>https://huajun-chen.github.io/2022/11/01/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%9E%B6%E6%9E%84/</id>
    <published>2022-11-01T10:14:35.000Z</published>
    <updated>2022-11-20T15:29:59.112Z</updated>
    
    <content type="html"><![CDATA[<p>系统设计与架构常见题整理</p><p>GitHub地址：<a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md">点击跳转</a></p><h4 id="1-如何设计一个短链服务"><a href="#1-如何设计一个短链服务" class="headerlink" title="1. 如何设计一个短链服务"></a><font color=DarkOrange>1. 如何设计一个短链服务</font></h4><p>参考链接：<a href="https://mp.weixin.qq.com/s/33lcKX3bLUAC-Mj0VlXa6A">点击跳转</a></p><h5 id="1-1-短链的价值"><a href="#1-1-短链的价值" class="headerlink" title="1.1 短链的价值"></a><font color=DarkOrange>1.1 短链的价值</font></h5><ul><li><strong>更加简洁：</strong>比起一长串无意义的问题，只有差不多 10 个字符的字符串显然更加简洁</li><li><strong>便于使用：</strong>第一，有些平台对内容长度有限制（微博只能发 140 个字），此时短网址就可以输入更多内容。第二，我们将链接转为二维码时，短链接生成的二维码更容易识别。第三，有些平台无法识别特殊的长链参数，转为短链就没这个问题</li><li><strong>节省成本：</strong>当我们需要发短信的时候，短信是按照长度计费的，短网址可以节省成本</li></ul><h5 id="1-2-短链的原理"><a href="#1-2-短链的原理" class="headerlink" title="1.2 短链的原理"></a><font color=DarkOrange>1.2 短链的原理</font></h5><p>当我们输入短链时，其实访问的是短链服务器的地址。短链服务器获取到对应的长链地址之后，返回一个 302 的 HTTP 响应，在响应中包含了长链接地址。浏览器收到响应后，转而去请求长链接地址。 访问短链的整个流程如下图所示：</p><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7qyiustgcj30e307zq3t.jpg" alt="image.png" style="zoom:90%;" /></div><p>从上面的流程中可以知道，短链涉及到的技术原理主要有两点，分别是：HTTP 重定向和短链服务的设计</p><p>对于 HTTP 重定向来说，301 和 302 都是重定向：</p><ul><li>301 代表永久重定向。它表示第一次拿到长链接之后，下次浏览器如果再去请求短链的话，不会再向短链服务器请求了，而是直接从浏览器的缓存中获取。</li><li>302 代表临时重定向。它表示每次请求短链都会去请求短链服务器，不会从浏览器缓存中获取</li></ul><p>如果我们希望统计短链接的点击次数信息，从而来分析活动的效果的话。那么我们就需要使用 302 重定向码，这样才能获取到每次的请求数据。 一般情况下，我们都是需要获取到请求的数据的，因此对于短链服务都是用 302 临时重定向</p><h5 id="1-3-实现思路"><a href="#1-3-实现思路" class="headerlink" title="1.3 实现思路"></a><font color=DarkOrange>1.3 实现思路</font></h5><p>系统的处理流程：</p><ol><li>用户访问短链生成页面，输入长链字符串，短链服务返回生成的短链</li><li>用户访问短链，短链服务返回 302 响应，用户浏览器跳转到长链地址</li></ol><p>如果我们要实现上面的系统流程，我们大致的处理思路是：</p><ol><li><strong>生成短链。</strong> 生成短链时，短链服务获取到长链，随后生成一个短链，并把短链与长链的映射关系保存下来，最后将短链返回给用户</li><li><strong>找到长链。</strong> 访问短链时，短链服务获取到短链，根据短链去获取到长链，返回返回 302 响应</li></ol><p>根据上面的分析，我们可以知道短链系统设计主要得解决如下两个问题：</p><ol><li>如何根据长链生成唯一短链？</li><li>如何保存短链与长链的映射关系</li></ol><p>对于第 1 点，我们有 2 个思路生成一个唯一短链，分别是：</p><ol><li>使用哈希算法生成唯一值</li><li>使用分布式唯一 ID 生成作为锻炼 ID</li></ol><p>对于第 2 点，保存短链与长链的映射关系，考虑到持久性的问题，我们肯定需要落库，所以使用 MySQL 表保存即可。如果有需要的话，可以在 MySQL 前做一层缓存。因此第 2 点相对来说比较简单</p><hr><h6 id="1-3-1-哈希算法生成短链"><a href="#1-3-1-哈希算法生成短链" class="headerlink" title="1.3.1 哈希算法生成短链"></a><font color=DarkOrange>1.3.1 哈希算法生成短链</font></h6><p>要生成一个短链，我们可以将原有的长链做一次哈希，然后就可以得到一个哈希值，计算哈希值会遇到如下2个问题：</p><p><strong>使用什么哈希算法</strong></p><p>我们都知道哈希算法是一种摘要算法，它的作用是：对任意一组输入数据进行计算，得到一个固定长度的输出摘要。我们常见的哈希算法有：MD5、SHA-1、SHA-256、SHA-512 算法等。但我们最好还是使用另一种叫做 MurmurHash 的哈希算法。为什么呢</p><p>因为 MD5 和 SHA 哈希算法，它们都是加密的哈希算法，也就是说我们无法从哈希值反向推导出原文，从而保证了原文的保密性</p><p>但对于我们这个场景而言，我们并不关心安全性，我们关注的是运算速度以及哈希冲突。而 MurmurHash 算法是一个非加密哈希算法，所以它的速度回更快</p><p><strong>哈希冲突</strong></p><p>学过 HashMap 的同学都知道，哈希冲突是哈希算法不可避免的问题。而解决哈希冲突的方式有两种，分别是：链表法和重哈希法。HashMap 使用了链表法，但我们这里使用的是重哈希法</p><p>所谓的重哈希法，指的是当发生哈希冲突的时候，我们在原有长链后面加上固定的特殊字符，后续拿出长链时再将其去掉，如下所示</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原有长链：https://mp.weixin.qq.com/s1caec8eb1b81d6ee5dd7b</span><br><span class="line">              ↓↓  </span><br><span class="line">           发生哈希冲突</span><br><span class="line">              ↓↓  </span><br><span class="line">补上特殊字符：https://mp.weixin.qq.com/s1caec8eb1b81d6ee5dd7b[SPECIAL-CHARACTER]</span><br><span class="line">              ↓↓  </span><br><span class="line">           再次进行哈希</span><br></pre></td></tr></table></figure><p>通过这种办法，我们就可以解决哈希冲突的问题了。如果再次发生，那么就再进行哈希，一直到不冲突位置。一般来说，哈希冲突的可能性微乎其微</p><p>好了，现在我们通过哈希算法得到了一个哈希值：<code>29541341303115543223957290326355</code>，变成了这样：<code>http://dwz.com/29541341303115543223957290326355</code></p><p>有没有办法让网址变得再短一点呢</p><p>我们知道在网址 URL 中，常用的合法字符有 0～9、a～z、A～Z 这样 62 个字符。如果我们用哈希值与 62 取余，那么余数肯定是在 0-61 之间</p><p>这 62 个数字刚好与 62 个合法网址字符一一对应。接着，我们再用除 62 得到的值，再次与 62 取余，一直到位 0 为止。通过这样的处理，我们就可以得到一个字符为 62 个字符、长度很短的字符串了</p><p>上面讲有点晦涩难懂，我们来举个例子。假设我们得到的哈希值为 181338494，那么上面的处理流程为：</p><ol><li>将 181338494 除以 62，得到结果为 2924814，余数为 26，此时余数 26 对应字符为 q。</li><li>将 2924814 除以 62，得到结果为 47174，余数为 26，此时余数 26 对应字符为 q。</li><li>将 47174 除以 62，得到结果为 760，余数为 54，此时余数 54 对应字符为 S。</li><li>省略剩余步骤</li></ol><p>整个处理流程如下图所示：</p><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7qyyjct7rj30ia0bk405.jpg" alt="image.png" style="zoom:90%;" /></div><p>可以看到，我们把 181338494 这个十进制数，转成了由合法网址字符组成的「62 进制数」—— <code>cgSqq</code></p><p>到这里，我们不仅生成了短链，还将短链的长度极大地缩短了</p><p>这就是使用哈希算法生成唯一锻炼的全部内容了，我们总结一下：<strong>首先，使用 MurmurHash 生成哈希值，并且用重哈希法解决哈希冲突的问题。接着，将 10 进制的哈希值转成 62 进制的合法网址字符，从而缩短网址长度</strong></p><h6 id="1-3-2-分布式-ID-生成短链"><a href="#1-3-2-分布式-ID-生成短链" class="headerlink" title="1.3.2 分布式 ID 生成短链"></a><font color=DarkOrange>1.3.2 分布式 ID 生成短链</font></h6><p>上面使用哈希算法生成唯一短链的方式，相对来说是比较形象的。但其实我们也可以用分布式 ID 的方式，来完成唯一短链的生成</p><p>例如第一次请求的长链，我们为其生成一个唯一 ID，将其长链与唯一 ID 对应起来。第二次请求，我们再为其生成一个唯一 ID，再次将长链与唯一 ID 对应起来，如下所示。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一次请求：https://mp.weixin.qq.com/s1caec8eb1b81d6ee5dd7b</span><br><span class="line">              ↓↓  </span><br><span class="line">生成短链：https://dwz.com/1021000001</span><br><span class="line"></span><br><span class="line">第一次请求：https://mp.weixin.qq.com/s1caec8eb1b81d6ee5ff7b</span><br><span class="line">              ↓↓  </span><br><span class="line">生成短链：https://dwz.com/1021000002</span><br></pre></td></tr></table></figure><p>因为生成的唯一 ID 也可能非常长，因此我们可以采用上面同样的方式，将 10 进制的唯一 ID 转成 62 进制的合法网址字符，从而缩短字符长度</p><p>那么接下来的问题就变成了：如何设计一个全局唯一 ID 发号器了</p><p>对于如何设计一个全局唯一的 ID 发号器，就属于另外一个话题，我们这里就不深入探讨了</p><h5 id="1-4-性能优化"><a href="#1-4-性能优化" class="headerlink" title="1.4 性能优化"></a><font color=DarkOrange>1.4 性能优化</font></h5><p>看到这里，我们基本上有了一个完整的思路：拿到长链地址后，可以用哈希算法或唯一 ID 分号器获取唯一字符串，从而建立长链与短链的映射关系。为了缩短短链长度，我们还可以将其用 62 进制数表示，整个短链生成过程如下图所示</p><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7qz2vgn49j30f10d3gn7.jpg" alt="image.png" style="zoom:80%;" /></div><p>短链生成完，并且已经存到了数据库中，接下里该使用了。通常的做法是会根据请求的短链字符串，从数据库中找到数据，然后返回 HTTP 重定向原始地址。而在不断使用过程中，还有一些可能发现的优化点，这里简单讲讲</p><ul><li><p>索引优化</p><ul><li>如果使用关系型数据库的话，对于短链字段需要创建唯一索引，从而加快查询速度</li></ul></li><li><p>增加缓存</p><ul><li>并发量小的时候，我们都是直接访问数据库。但当并发量再次升高时，需要加上缓存抗住热点数据的访问</li></ul></li><li><p>读写分离</p><ul><li>短链服务肯定是读远大于写的，因此对于短链服务，可以做好读写分离</li></ul></li><li><p>分库分表</p><ul><li>如果是商用的短链服务，那么数据量上亿是很正常的，更不用说常年累月积累下的量了。这时候可以一开始就做好分库分表操作，避免后期再大动干戈</li><li>对于分库分表来说，最关键的便是根据哪个字段去作为分库分表的依据了。对于短链服务来说，当然是用转化后的 62 进制数字做分表依据了，因为它是唯一的嘛</li></ul></li><li><p>防止恶意攻击</p><ul><li><p>开放到公网的服务，什么事情都可能发生，其中一个可能的点就是被恶意攻击，不断循环调用</p></li><li><p>一开始我们可以做一下简单地限流操作，例如：</p><ol><li>没有授权的用户，根据 IP 进行判断，1 分钟最多只能请求 10 次</li><li>没有授权的用户，所有用户 1 分钟最多只能请求 4000 次，防止更换 IP 进行攻击</li></ol></li><li><p>简单地说，就是要不断提高攻击的成本，使得最坏情况下系统依然可以正常提供服务</p></li></ul></li></ul><h5 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a><font color=DarkOrange>1.5 总结</font></h5><p>在短链服务的设计思路上，最重要是解决两个问题：根据长链生成短链、根据短链找到长链。在根据长链生成短链的思路上，有两种实现思路，分别是：哈希算法生成短链、分布式全局 ID 生成短链，其中哈希算法涉及到哈希算法的选择，以及哈希冲突的处理</p><p>最后还列举了一些短链服务后续可能的优化点，包括：如何让网址变得更短、索引优化、增加热点数据、读写分离、分库分表、防止恶意攻击等等</p><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7qz95bl1zj30u00l77d9.jpg" alt="image.png" style="zoom:100%;" /></div><h4 id="2-如何设计一个秒杀系统"><a href="#2-如何设计一个秒杀系统" class="headerlink" title="2. 如何设计一个秒杀系统"></a><font color=DarkOrange>2. 如何设计一个秒杀系统</font></h4><p>参考链接：<a href="https://mp.weixin.qq.com/s/kWqgzMw4qKek7QUfkDSwNg">点击跳转</a></p><p>秒杀系统的设计是高级职位面试中非常高频的一道题目，它可以较好地考察候选人的知识体系情况。对于我们来说，学习秒杀系统的设计，能够让我们学以致用，设计系统的时候考虑得更加全面</p><p>活动一般出现在电商的促销活动中，一般是指定了很少数量的商品，以极低的价格，让大量的用户参与，从而造成大量用户在极短的时间内参与活动，进而造成系统在极短的时间内有极高的流量。系统设计的目的是使系统能够稳定地支撑活动的进行，因此其稳定性、高可用是我们考虑的第一位</p><p>要知道如何进行秒杀系统的优化，那我们需要先对请求的整个流程有个全局的认识。<strong>一般来说，秒杀活动请求以公网为划分点，可以分为：前端部分、后端部分。</strong> 前端部分指的是从用户端到进入后端服务前的部分，包括了移动端的处理、DNS 解析、公网的数据传递等</p><p>后端部分指的是经公网进入了后端的服务器网络里，包括了前置的负载均衡（Nginx 等）、应用服务器、数据库层等。秒杀活动的整个流程可以用下图来表示</p><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7qzrdanrnj30r90bpn04.jpg" alt="image.png" style="zoom:80%;" /></div><p>我们要去设计一个秒杀系统，那自然也是从这两大部分来进行优化。整体思路是尽量将流量挡在前面，让尽量少的流量留到后端部分。因为越往后端，我们的处理逻辑就越重，其处理能力也越弱</p><h5 id="2-1-前端优化"><a href="#2-1-前端优化" class="headerlink" title="2.1 前端优化"></a><font color=DarkOrange>2.1 前端优化</font></h5><p>对于前端部分来说，常见的优化手段有：页面静态化 + CDN、请求频率限制</p><h6 id="2-1-1-页面静态化-CDN"><a href="#2-1-1-页面静态化-CDN" class="headerlink" title="2.1.1 页面静态化 + CDN"></a><font color=DarkOrange>2.1.1 页面静态化 + CDN</font></h6><p>一般来说，活动页面是流量最大的地方。活动页面上绝大部分内容都是固定的，比如：商品描述、图片等。这时候没有必要每次都去请求服务端，而是将这些静态的内容放到 CDN 上</p><p>每次打开页面的时候，直接去请求 CDN 服务器，能极大地减少后端的请求流量。加入了 CDN 之后，其请求过程如下：</p><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7qzu0en0vj30k105ldh2.jpg" alt="image.png" style="zoom:100%;" /></div><p>所谓的 CDN 就是内容分发网络，它由非常多台分布在世界各地的缓存服务器组成。每次用户请求特定域名的时候，会转发到对应 CDN 的 DNS 解析服务器，随后会返回一台离用户地理位置最近的一台 CDN 服务器</p><p>随后，用户直接请求这台 CDN 服务器获取数据，从而极大地减少了长途网络传输的时间，并且也减少了后端服务器的压力</p><p><strong>因此，对于秒杀活动设计来说，我们可以将所有可以静态化的内容全部静态化，然后将其配置在 CDN 服务器上。这样既提高了用户打开页面的时间，又减少了后端服务器的压力</strong></p><h6 id="2-1-2-请求频率限制"><a href="#2-1-2-请求频率限制" class="headerlink" title="2.1.2 请求频率限制"></a><font color=DarkOrange>2.1.2 请求频率限制</font></h6><p>请求频率限制，指的是根据业务的特点，在前端做一些流量拦截，减少后端服务器的压力。常见的拦截方式有：</p><ol><li>设定一个请求概率，只允许 30% 的概率向后端发送接口请求。</li><li>设定一个请求频率，例如 10 秒钟只能请求 1 次，随后按钮置灰</li></ol><p>通过这种方式，我们可以减少很大一部分流量。但在具体实现的时候，可能需要考虑安全问题，预防某些用户直接调用后台接口，绕过前端的频率检查</p><p>常见的方法是在频率检查时生成一个参数，随后请求后端服务时携带上该参数。没有该参数的请求，都视为非法请求，直接拒绝该请求</p><h5 id="2-2-后端优化"><a href="#2-2-后端优化" class="headerlink" title="2.2 后端优化"></a><font color=DarkOrange>2.2 后端优化</font></h5><p>无论我们做多大的努力，始终还是会有不少流量会来到后端服务器这里。一般来说，后端的优化有如下几种方式：</p><ol><li>增加缓存层 + 预热数据</li><li>MQ 异步处理</li><li>限流、熔断、兜底</li><li>业务侧优化</li></ol><h6 id="2-2-1-增加缓存层-预热数据"><a href="#2-2-1-增加缓存层-预热数据" class="headerlink" title="2.2.1 增加缓存层 + 预热数据"></a><font color=DarkOrange>2.2.1 增加缓存层 + 预热数据</font></h6><p>如果我们所有数据都去读取数据库，数据库可能无法承受较大的流量，此时一个常见的优化就是增加缓存层</p><p>当我们需要查询数据库之前，我们先去查询缓存，这样可以减少绝大部分的数据库请求，减轻数据库压力。如果在缓存中找不到数据，我们再去请求数据库，随后再将数据缓存到缓存中</p><p>在引入缓存层的时候，我们需要考虑缓存击穿、缓存穿透的可能性，在写相关代码的时候就要做好这些优化。另外，我们在秒杀活动开始之前，可以手动将热点数据加载到缓存中，从而避免秒杀时去请求数据库</p><h6 id="2-2-2-MQ-异步处理"><a href="#2-2-2-MQ-异步处理" class="headerlink" title="2.2.2 MQ 异步处理"></a><font color=DarkOrange>2.2.2 MQ 异步处理</font></h6><p>我们知道秒杀活动一般涉及抢购、下单、支付、发货等阶段，而抢购与后续的几个阶段是可以异步执行的。为了避免对下单、支付、发货等阶段产生影响，我们可以将抢购阶段与后续阶段用 MQ 进行解耦处理。当用户抢购成功后，往消息队列中丢入一台消息，随后再由订单系统消费进行下单处理</p><p>通过各系统之间的解耦处理，我们可以将原本同步的处理方式变为异步处理，从而大大的减少了请求的处理时间，提高了系统的并发处理能力。其次，也能避免系统之间相互影响，提高了整体系统的稳定性</p><h6 id="2-2-3-限流、熔断、兜底"><a href="#2-2-3-限流、熔断、兜底" class="headerlink" title="2.2.3 限流、熔断、兜底"></a><font color=DarkOrange>2.2.3 限流、熔断、兜底</font></h6><p>我们可以在每个业务系统做限流操作，从而避免因为请求太多，导致整个系统都无法工作。当并发请求在正常范围内时，我们正常处理请求。当超过设置的限流阈值时，我们则直接拒绝该请求，提示用户抢购失败</p><p>如果没有限流操作，那么系统直接崩溃了，一个请求都处理不了。而通过限流这种方式，系统至少还可以保持正常工作，而不至于一个请求都处理不了。而超量的需求，本来就处理不了，因此提示失败也是情理之中</p><p>除了限流之外，不同的系统还可以采用熔断、降级的服务治理措施</p><p>熔断指的是请求的错误次数超过阈值时，不再到用后端服务，直接返回失败。同时每隔一定时间放几个请求去重试后端服务，看看是否正常。如果正常则关闭熔断状态，如果失败则继续快速失败。<strong>熔断的目的是避免因下游短暂的异常，导致上游不断重试，最终造成下游有太多请求，最终压垮下游系统</strong></p><p>降级指的是当服务失败或异常后，返回指定的默认信息。<strong>降级的目的是保证有基本的信息，当下游异常时，与其返回空信息，不如返回一个有业务含义的默认信息，可以提高用户体验</strong></p><h6 id="2-2-4-业务侧优化"><a href="#2-2-4-业务侧优化" class="headerlink" title="2.2.4 业务侧优化"></a><font color=DarkOrange>2.2.4 业务侧优化</font></h6><p>一般来说，经过上述的整体优化之后，系统已经能够比较稳当地应对秒杀活动了。如果此时还是流量比较大，那么或许应该从业务侧去进行优化了</p><p>例如 12306 刚开始的时候，购买时间都在同一时刻，这导致同一时刻并发量太大，系统经常支撑不住。后来 12306 将购票周期放长，可以提前 20 天购买火车票。通过业务侧的优化，我们将本来在 1 个小时的抢购分摊到了 20 天，服务器压力一下子降低了 480 倍</p><p><strong>因此从业务侧进行优化，是一个四两拨千斤的办法，可以极大地降低技术侧实现的难度</strong></p><h5 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a><font color=DarkOrange>2.3 总结</font></h5><p>设计一个秒杀系统，整体而言可以从前端与后端进行优化。</p><p><strong>对于前端优化而言，可以从「页面静态化 + CDN」、请求频率限制进行优化</strong></p><p>其中「页面静态化 + CDN」指的是将不变的静态数据固定下来，然后放入 CDN 服务器，从而降低用户请求的响应速度，降低服务器的并发压力。请求频率限制，则是通过抢购概率与抢购频率限制，降低后端服务器的服务压力。</p><p><strong>对于后端优化而言，一般有「增加缓存层 + 预热数据」、「MQ 异步处理」、「限流、熔断、降级」、业务侧优化这 4 种优化方式</strong></p><p>其中「增加缓存层 + 预热数据」指的是将热点数据存入缓存，并在活动开始前提前加载到缓存中，降低数据库层的读取压力。「MQ 异步处理」指的是对于非必要的业务逻辑，通过 MQ 进行异步处理，降低请求处理延时，同时提高业务系统整体稳定性</p><p>「限流、熔断、降级」是对于整体微服务的保护，其中限流指的是对请求进行限制，当超过限流阈值时，直接拒绝请求，保护系统本身；熔断指的是保护下游系统，当请求下游系统连续错误超过阈值时，自动不去请求下游系统，避免因重试流量过大击垮下游系统。</p><p>降级指的是当请求失败时，自动返回默认数据，提高用户体验。业务侧优化，则是指从业务层面去进行逻辑优化，从而降低技术复杂度，使得业务与技术复杂度达到一个平衡的状态，有利于更好地实现秒杀系统的高可用与高并发。</p><p>上面说到的 6 个优化思路，是设计秒杀系统常见的优化思路。<strong>但在实际业务场景中，除了要保障正常的功能设计之外，还还考虑防刷、安全、黑产等问题</strong>，此时可能需要多考虑一些其他优化，例如：黄牛利用抢购工具抢购，导致正常用户无法抢到商品等</p><p>这时候可能需要考虑增加验证码，用 App 设备指纹等风控措施。<strong>此外，对于秒杀系统而言，做好业务指标和系统指标的埋点监控也是非常重要的</strong></p><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7r06ob49vj30u00e145t.jpg" alt="image.png" style="zoom:100%;" /></div><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;系统设计与架构常见题整理&lt;/p&gt;
&lt;p&gt;GitHub地址：&lt;a href=&quot;https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md&quot;&gt;点击跳转&lt;/a&gt;&lt;/p&gt;
&lt;h4</summary>
      
    
    
    
    <category term="面试" scheme="https://huajun-chen.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="系统设计与架构" scheme="https://huajun-chen.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
</feed>
