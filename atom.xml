<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>可可西里-博客</title>
  
  <subtitle>好好吃饭 好好睡觉 好好上班</subtitle>
  <link href="https://huajun-chen.github.io/atom.xml" rel="self"/>
  
  <link href="https://huajun-chen.github.io/"/>
  <updated>2022-10-28T13:20:12.901Z</updated>
  <id>https://huajun-chen.github.io/</id>
  
  <author>
    <name>可可西里</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>项目经验面试题</title>
    <link href="https://huajun-chen.github.io/2022/10/28/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://huajun-chen.github.io/2022/10/28/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-10-28T13:20:12.000Z</published>
    <updated>2022-10-28T13:20:12.901Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法面试题</title>
    <link href="https://huajun-chen.github.io/2022/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://huajun-chen.github.io/2022/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-10-28T13:18:42.000Z</published>
    <updated>2022-10-28T13:18:42.447Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux操作系统面试题</title>
    <link href="https://huajun-chen.github.io/2022/10/28/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://huajun-chen.github.io/2022/10/28/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-10-28T13:17:35.000Z</published>
    <updated>2022-10-28T13:17:35.552Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机网络面试题</title>
    <link href="https://huajun-chen.github.io/2022/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://huajun-chen.github.io/2022/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-10-28T13:16:59.000Z</published>
    <updated>2022-10-28T13:16:59.443Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis面试题</title>
    <link href="https://huajun-chen.github.io/2022/10/28/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://huajun-chen.github.io/2022/10/28/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-10-28T08:50:10.000Z</published>
    <updated>2022-10-28T17:49:09.777Z</updated>
    
    <content type="html"><![CDATA[<p>Redis面试常见问题汇总</p><h4 id="1-Redis的数据结构及使用场景"><a href="#1-Redis的数据结构及使用场景" class="headerlink" title="1. Redis的数据结构及使用场景"></a>1. Redis的数据结构及使用场景</h4><ul><li><p>String字符串</p><p>字符串类型是 Redis 最基础的数据结构，首先键都是字符串类型，而且 其他几种数据结构都是在字符串类型基础上构建的，我们常使用的 set key value 命令就是字符串。常用在缓存、计数、共享Session、限速等</p></li></ul><hr><ul><li><p>Hash哈希</p><p>在Redis中，哈希类型是指键值本身又是一个键值对结构，哈希可以用来存放用户信息，比如实现购物车</p></li></ul><hr><ul><li><p>List列表（双向链表）</p><p>列表（list）类型是用来存储多个有序的字符串。可以做简单的消息队列的功能</p></li></ul><hr><ul><li><p>Set集合</p><p>集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一 样的是，集合中不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素。利用 Set 的交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能</p></li></ul><hr><ul><li><p>Sorted Set有序集合（跳表实现）</p><p>Sorted Set 多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。可以做排行榜应用，取 TOP N 操作</p></li></ul><h4 id="2-Redis持久化的几种方式"><a href="#2-Redis持久化的几种方式" class="headerlink" title="2. Redis持久化的几种方式"></a>2. Redis持久化的几种方式</h4><p>Redis为了保证效率，数据缓存在了内存中，但是会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中，以保证数据的持久化。Redis的持久化策略有两种：</p><ul><li><strong>RDB：</strong> 快照形式是直接把内存中的数据保存到一个dump的文件中，定时保存，保存策略<ul><li>当Redis需要做持久化时，Redis会fork一个子进程，子进程将数据写到磁盘上一个临时RDB文件中。当子进程完成写临时文件后，将原来的RDB替换掉</li></ul></li></ul><hr><ul><li><strong>AOF：</strong> 把所有的对Redis的服务器进行修改的命令都存到一个文件里，命令的集合<ul><li>使用AOF做持久化，每一个写命令都通过write函数追加到<code>appendonly.aof</code>中</li><li>aof的默认策略是每秒钟fsync一次，在这种配置下，就算发生故障停机，也最多丢失一秒钟的数据</li><li>缺点是对于相同的数据集来说，AOF的文件体积通常要大于RDB文件的体积。根据所使用的fsync策略，AOF的速度可能会慢于RDB</li></ul></li></ul><p>Redis默认是快照RDB的持久化方式。对于主从同步来说，主从刚刚连接的时候，进行全量同步（RDB），全同步结束后，进行增量同步(AOF)</p><h4 id="3-Redis的LRU具体实现"><a href="#3-Redis的LRU具体实现" class="headerlink" title="3. Redis的LRU具体实现"></a>3. Redis的LRU具体实现</h4><ul><li>传统的LRU是使用栈的形式，每次都将最新使用的移入栈顶，但是用栈的形式会导致执行<code>select *</code>的时候大量非热点数据占领头部数据，所以需要改进</li><li>Redis每次按key获取一个值的时候，都会更新value中的lru字段为当前秒级别的时间戳。Redis初始的实现算法很简单，随机从dict中取出五个key，淘汰一个lru字段值最小的</li><li>在3.0的时候，又改进了一版算法，首先第一次随机选取的key都会放入一个pool中(pool的大小为16)，pool中的key是按lru大小顺序排列的</li><li>接下来每次随机选取的keylru值必须小于pool中最小的lru才会继续放入，直到将pool放满。放满之后，每次如果有新的key需要放入，需要将pool中lru最大的一个key取出。淘汰的时候，直接从pool中选取一个lru最小的值然后将其淘汰</li></ul><h4 id="4-单线程的Redis为什么快"><a href="#4-单线程的Redis为什么快" class="headerlink" title="4. 单线程的Redis为什么快"></a>4. 单线程的Redis为什么快</h4><ul><li>纯内存操作</li><li>单线程操作，避免了频繁的上下文切换</li><li>合理高效的数据结构</li><li>采用了非阻塞I&#x2F;O多路复用机制</li></ul><h4 id="5-Redis的数据过期策略"><a href="#5-Redis的数据过期策略" class="headerlink" title="5. Redis的数据过期策略"></a>5. Redis的数据过期策略</h4><p>Redis 中数据过期策略采用<strong>定期删除</strong>和<strong>惰性删除</strong>策略：</p><ul><li>定期删除策略<ul><li>Redis 启用一个定时器定时监视所有的 key，判断key是否过期，过期的话就删除</li><li>这种策略可以保证过期的 key 最终都会被删除，但是也存在严重的缺点：每次都遍历内存中所有的数据，非常消耗 CPU资源，并且当 key 已过期，但是定时器还处于未唤起状态，这段时间内 key 仍然可以用</li></ul></li></ul><hr><ul><li>惰性删除策略<ul><li>在获取 key 时，先判断 key 是否过期，如果过期则删除</li><li>这种方式存在一个缺点：如果这个 key一直未被使用，那么它一直在内存中，其实它已经过期了，会浪费大量的空间</li></ul></li></ul><p>这两种策略天然的互补，结合起来之后，定时删除策略就发生了一些改变，不在是每次扫描全部的 key 了，而是随机抽取一部分 key 进行检查，这样就降低了对 CPU 资源的损耗，惰性删除策略互补了为检查到的key，基本上满足了所有要求</p><p>但是有时候就是那么的巧，既没有被定时器抽取到，又没有被使用，这些数据又如何从内存中消失？这个时候就需要用到了，内存淘汰机制</p><h5 id="5-1-内存淘汰机制"><a href="#5-1-内存淘汰机制" class="headerlink" title="5.1 内存淘汰机制"></a>5.1 内存淘汰机制</h5><ul><li>当内存不足以容纳新写入数据时，新写入操作会报错。（Redis 默认策略）</li><li>当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。（LRU推荐使用）</li><li>当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key</li><li>当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用</li><li>当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key</li><li>当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除</li></ul><h4 id="6-如何解决Redis缓存雪崩问题"><a href="#6-如何解决Redis缓存雪崩问题" class="headerlink" title="6. 如何解决Redis缓存雪崩问题"></a>6. 如何解决Redis缓存雪崩问题</h4><ul><li>使用 Redis 高可用架构：使用 Redis 集群来保证 Redis 服务不会挂掉</li><li>缓存时间不一致，给缓存的失效时间，加上一个随机值，避免集体失效</li><li>限流降级策略：有一定的备案，比如个性推荐服务不可用了，换成热点数据推荐服务</li></ul><h4 id="7-如何解决Redis缓存穿透问题"><a href="#7-如何解决Redis缓存穿透问题" class="headerlink" title="7. 如何解决Redis缓存穿透问题"></a>7. 如何解决Redis缓存穿透问题</h4><ul><li>在接口层做校验</li><li>存null值（缓存击穿加锁）</li><li>布隆过滤器拦截：将所有可能的查询key 先映射到布隆过滤器中，查询时先判断key是否存在布隆过滤器中，存在才继续向下执行，如果不存在，则直接返回<br>布隆过滤器将值进行多次哈希bit存储，布隆过滤器说某个元素在，可能会被误判。布隆过滤器说某个元素不在，那么一定不在</li></ul><h4 id="8-Redis并发竞争key如何解决"><a href="#8-Redis并发竞争key如何解决" class="headerlink" title="8. Redis并发竞争key如何解决"></a>8. Redis并发竞争key如何解决</h4><ul><li>可以利用分布式锁和时间戳来解决</li><li>利用消息队列解决</li></ul><h4 id="9-Redis的主从模式和哨兵模式和集群模式区别"><a href="#9-Redis的主从模式和哨兵模式和集群模式区别" class="headerlink" title="9. Redis的主从模式和哨兵模式和集群模式区别"></a>9. Redis的主从模式和哨兵模式和集群模式区别</h4><p>Redis集群方式共有三种：<strong>主从模式</strong>，<strong>哨兵模式</strong>，<strong>集群(cluster)模式</strong></p><ul><li><p>主从模式</p><p>主从模式是三种集群方式里最简单的。它主要是基于Redis的主从复制特性架构的。通常我们会设置一个主节点，N个从节点;默认情况下，主节点负责处理使用者的IO操作，而从节点则会对主节点的数据进行备份，并且也会对外提供读操作的处理。主要的特点如下：</p><ul><li>主从模式下，当某一节点损坏时，因为其会将数据备份到其它Redis实例上，这样做在很大程度上可以恢复丢失的数据</li><li>主从模式下，可以保证负载均衡.</li><li>主从模式下，主节点和从节点是读写分离的。使用者不仅可以从主节点上读取数据，还可以很方便的从从节点上读取到数据，这在一定程度上缓解了主机的压力</li></ul><p>从节点也是能够支持写入数据的，只不过从从节点写入的数据不会同步到主节点以及其它的从节点下。从以上，我们不难看出Redis在主从模式下，必须保证主节点不会宕机——一旦主节点宕机，其它节点不会竞争称为主节点，此时，Redis将丧失写的能力。这点在生产环境中，是致命的</p></li></ul><hr><ul><li><p>哨兵模式</p><p>哨兵模式是基于主从模式做的一定变化，它能够为Redis提供了高可用性</p><p>在实际生产中，服务器难免不会遇到一些突发状况：服务器宕机，停电，硬件损坏等。这些情况一旦发生，其后果往往是不可估量的</p><p>而哨兵模式在一定程度上能够帮我们规避掉这些意外导致的灾难性后果。其实，哨兵模式的核心还是主从复制</p><p>只不过相对于主从模式在主节点宕机导致不可写的情况下，多了一个竞选机制——从所有的从节点竞选出新的主节点。竞选机制的实现，是依赖于在系统中启动一个sentinel进程。sentinel特点：</p><ul><li>监控：它会监听主服务器和从服务器之间是否在正常工作</li><li>通知：它能够通过API告诉系统管理员或者程序，集群中某个实例出了问题。</li><li>故障转移：它在主节点出了问题的情况下，会在所有的从节点中竞选出一个节点，并将其作为新的主节点。</li><li>提供主服务器地址：它还能够向使用者提供当前主节点的地址。这在故障转移后，使用者不用做任何修改就可以知道当前主节点地址</li></ul><p>sentinel，也可以集群，部署多个哨兵，sentinel可以通过发布与订阅来自动发现Redis集群上的其它sentinel。sentinel在发现其它sentinel进程后，会将其放入一个列表中，这个列表存储了所有已被发现的sentinel</p><p>集群中的所有sentinel不会并发着去对同一个主节点进行故障转移。故障转移只会从第一个sentinel开始，当第一个故障转移失败后，才会尝试下一个</p><p>当选择一个从节点作为新的主节点后，故障转移即成功了(而不会等到所有的从节点配置了新的主节点后)。这过程中，如果重启了旧的主节点，那么就会出现无主节点的情况，这种情况下，只能重启集群</p><p>当竞选出新的主节点后，被选为新的主节点的从节点的配置信息会被sentinel改写为旧的主节点的配置信息。完成改写后，再将新主节点的配置广播给所有的从节点</p></li></ul><hr><ul><li><p>集群模式</p><p>Redis 集群是一个提供在多个Redis间节点间共享数据的程序集， 其中Redis集群分为主节点和从节点。主节点用于处理槽，而从节点用于复制某个主节点，并在被复制的主节点下线时，代替下线的主节点继续处理命令请求</p><p>Redis集群并不支持处理多个keys的命令，因为这需要在不同的节点间移动数据，从而达不到像Redis那样的性能，在高负载的情况下可能会导致不可预料的错误</p><p>Redis 集群通过分区来提供一定程度的可用性，在实际环境中当某个节点宕机或者不可达的情况下继续处理命令. Redis 集群的优势：自动分割数据到不同的节点上</p><p>整个集群的部分节点失败或者不可达的情况下能够继续处理命令</p><p>Redis集群的数据分片 Redis 集群没有使用一致性hash， 而是引入了哈希槽的概念</p><p>Redis 集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽</p></li></ul><h4 id="10-Redis事物的了解CheckAndSet操作实现乐观锁"><a href="#10-Redis事物的了解CheckAndSet操作实现乐观锁" class="headerlink" title="10. Redis事物的了解CheckAndSet操作实现乐观锁"></a>10. Redis事物的了解CheckAndSet操作实现乐观锁</h4><p>和众多其它数据库一样，Redis作为NoSQL数据库也同样提供了事务机制。在Redis中，<code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code>，<code>WATCH</code>这四个命令是我们实现事务的基石。相信对有关系型数据库开发经验的开发者而言这一概念并不陌生，即便如此，我们还是会简要的列出 Redis中事务的实现特征 ：</p><ul><li>在事务中的所有命令都将会被串行化的顺序执行，事务执行期间，Redis不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行</li><li>和关系型数据库中的事务相比，在Redis事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行</li><li>我们可以通过MULTI命令开启一个事务，有关系型数据库开发经验的人可以将其理解为”BEGIN TRANSACTION”语句。在该语句之后执行的命令都将被视为事务之内的操作，最后我们可以通过执行<code>EXEC</code>，<code>DISCARD</code>命令来提交，回滚该事务内的所有操作。这两个Redis命令可被视为等同于关系型数据库中的COMMIT&#x2F;ROLLBACK语句</li><li>在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行</li><li>当使用<code>Append-Only</code>模式时，Redis会通过调用系统函数write将该事务内的所有写操作在本次调用中全部写入磁盘。然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。Redis服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用Redis工具包中提供的<code>redis-check-aof</code>工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了</li></ul><h4 id="11-Redis有序集合zset底层怎么实现的"><a href="#11-Redis有序集合zset底层怎么实现的" class="headerlink" title="11. Redis有序集合zset底层怎么实现的"></a>11. Redis有序集合zset底层怎么实现的</h4><ul><li>跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表</li><li>跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找</li><li>跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能</li></ul><hr><ul><li>跳表是可以实现二分查找的有序链表</li><li>每个元素插入时随机生成它的level</li><li>最低层包含所有的元素</li><li>如果一个元素出现在level(x)，那么它肯定出现在x以下的level中</li><li>每个索引节点包含两个指针，一个向下，一个向右</li><li>跳表查询、插入、删除的时间复杂度为O(log n)，与平衡二叉树接近</li></ul><hr><h5 id="11-1-为什么Redis选择使用跳表而不是红黑树来实现有序集合？-O-logN"><a href="#11-1-为什么Redis选择使用跳表而不是红黑树来实现有序集合？-O-logN" class="headerlink" title="11.1 为什么Redis选择使用跳表而不是红黑树来实现有序集合？(O(logN))"></a>11.1 为什么Redis选择使用跳表而不是红黑树来实现有序集合？(O(logN))</h5><p>首先，我们来分析下Redis的有序集合支持的操作：</p><ul><li>插入元素</li><li>删除元素</li><li>查找元素</li><li>有序输出所有元素</li><li>查找区间内所有元素</li></ul><p>其中，前4项红黑树都可以完成，且时间复杂度与跳表一致。但是，最后一项，红黑树的效率就没有跳表高了。在跳表中，要查找区间的元素，我们只要定位到两个区间端点在最低层级的位置，然后按顺序遍历元素就可以了，非常高效</p><p>而红黑树只能定位到端点后，再从首位置开始每次都要查找后继节点，相对来说是比较耗时的。此外，跳表实现起来很容易且易读，红黑树实现起来相对困难，所以Redis选择使用跳表来实现有序集合</p><h4 id="12-跳表的查询过程是怎么样的，查询和插入的时间复杂度"><a href="#12-跳表的查询过程是怎么样的，查询和插入的时间复杂度" class="headerlink" title="12. 跳表的查询过程是怎么样的，查询和插入的时间复杂度"></a>12. 跳表的查询过程是怎么样的，查询和插入的时间复杂度</h4><p>先从第一层查找，不满足就下沉到第二层找，因为每一层都是有序的，写入和插入的时间复杂度都是O(logN)</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis面试常见问题汇总&lt;/p&gt;
&lt;h4 id=&quot;1-Redis的数据结构及使用场景&quot;&gt;&lt;a href=&quot;#1-Redis的数据结构及使用场景&quot; class=&quot;headerlink&quot; title=&quot;1. Redis的数据结构及使用场景&quot;&gt;&lt;/a&gt;1. Redis的数据结构</summary>
      
    
    
    
    <category term="面试" scheme="https://huajun-chen.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="八股文" scheme="https://huajun-chen.github.io/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    <category term="Redis" scheme="https://huajun-chen.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL面试题</title>
    <link href="https://huajun-chen.github.io/2022/10/28/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://huajun-chen.github.io/2022/10/28/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-10-28T06:09:46.000Z</published>
    <updated>2022-10-28T17:13:49.891Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL常见面试题、八股文</p><h4 id="1-Mysql索引用的是什么算法"><a href="#1-Mysql索引用的是什么算法" class="headerlink" title="1. Mysql索引用的是什么算法"></a>1. Mysql索引用的是什么算法</h4><ul><li>Mysql索引选用的是B+树，平衡二叉树的高度太高，查找可能需要较多的磁盘IO。B树索引占用内存较高(非叶子节点存储数据)</li><li>B+树，主要是查询效率高，O(logN)，可以充分利用磁盘预读的特性，多叉树，深度小，叶子结点有序且存储数据</li></ul><h4 id="2-Mysql事务的基本要素"><a href="#2-Mysql事务的基本要素" class="headerlink" title="2. Mysql事务的基本要素"></a>2. Mysql事务的基本要素</h4><ul><li>原子性：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行</li><li>一致性：事务开始前和结束后，数据库的完整性约束没有被破坏</li><li>隔离性：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰</li><li>持久性：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚</li></ul><h4 id="3-Mysql的存储引擎"><a href="#3-Mysql的存储引擎" class="headerlink" title="3. Mysql的存储引擎"></a>3. Mysql的存储引擎</h4><ul><li>InnoDB存储引擎<ul><li>InnoDB存储引擎支持事务，其设计目标主要面向在线事务处理（OLTP）的应用</li><li>其特点是行锁设计，支持外键，并支持非锁定锁，即默认读取操作不会产生锁。从Mysql5.5.8版本开始，InnoDB存储引擎是默认的存储引擎</li></ul></li><li>MyISAM存储引擎<ul><li>MyISAM存储引擎不支持事务、表锁设计，支持全文索引，主要面向一些OLAP数据库应用</li><li>InnoDB的数据文件本身就是主索引文件，而MyISAM的主索引和数据是分开的</li></ul></li><li>NDB存储引擎<ul><li>NDB存储引擎是一个集群存储引擎，其结构是share nothing的集群架构，能提供更高的可用性</li><li>NDB的特点是数据全部放在内存中（从MySQL 5.1版本开始，可以将非索引数据放在磁盘上），因此主键查找的速度极快，并且通过添加NDB数据存储节点可以线性地提高数据库性能，是高可用、高性能的集群系统</li><li>NDB存储引擎的连接操作是在MySQL数据库层完成的，而不是在存储引擎层完成的。这意味着，复杂的连接操作需要巨大的网络开销，因此查询速度很慢。如果解决了这个问题，NDB存储引擎的市场应该是非常巨大的</li></ul></li><li>Memory存储引擎<ul><li>Memory存储引擎（之前称HEAP存储引擎）将表中的数据存放在内存中，如果数据库重启或发生崩溃，表中的数据都将消失</li><li>它非常适合用于存储临时数据的临时表，以及数据仓库中的纬度表。Memory存储引擎默认使用哈希索引，而不是我们熟悉的B+树索引</li><li>虽然Memory存储引擎速度非常快，但在使用上还是有一定的限制。比如，只支持表锁，并发性能较差，并且不支持TEXT和BLOB列类型。最重要的是，存储变长字段时是按照定常字段的方式进行的，因此会浪费内存</li></ul></li><li>Archive存储引擎<ul><li>Archive存储引擎只支持INSERT和SELECT操作，从MySQL 5.1开始支持索引</li><li>Archive存储引擎使用zlib算法将数据行（row）进行压缩后存储，压缩比一般可达1∶10。正如其名字所示，Archive存储引擎非常适合存储归档数据，如日志信息</li><li>Archive存储引擎使用行锁来实现高并发的插入操作，但是其本身并不是事务安全的存储引擎，其设计目标主要是提供高速的插入和压缩功能</li></ul></li><li>Maria存储引擎<ul><li>Maria存储引擎是新开发的引擎，设计目标主要是用来取代原有的MyISAM存储引擎，从而成为MySQL的默认存储引擎。它可以看做是MyISAM的后续版本</li><li>Maria存储引擎的特点是：支持缓存数据和索引文件，应用了行锁设计，提供了MVCC功能，支持事务和非事务安全的选项，以及更好的BLOB字符类型的处理性能</li></ul></li></ul><h4 id="4-Mysql事务隔离级别"><a href="#4-Mysql事务隔离级别" class="headerlink" title="4. Mysql事务隔离级别"></a>4. Mysql事务隔离级别</h4><p>Mysql有四种事务隔离级别，默认的是可重复读</p><table><thead><tr><th align="left">事务隔离级别</th><th align="left">脏读</th><th align="left">不可重复读</th><th align="left">幻读</th></tr></thead><tbody><tr><td align="left">读未提交</td><td align="left">是</td><td align="left">是</td><td align="left">是</td></tr><tr><td align="left">读已提交</td><td align="left">否</td><td align="left">是</td><td align="left">是</td></tr><tr><td align="left">可重复读</td><td align="left">否</td><td align="left">否</td><td align="left">是</td></tr><tr><td align="left">串行</td><td align="left">否</td><td align="left">否</td><td align="left">否</td></tr></tbody></table><ul><li><p>读未提交(Read uncommitted)</p><p>一个事务可以读取另一个未提交事务的数据，最低级别，任何情况都无法保证</p><ul><li>所有事务都可以看到其他未提交事务的执行结果</li><li>本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少</li><li>该级别引发的问题是——脏读(Dirty Read)：读取到了未提交的数据</li></ul></li><li><p>读已提交(Read committed)</p><p>一个事务要等另一个事务提交后才能读取数据，可避免脏读的发生</p><ul><li>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）</li><li>它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变</li><li>这种隔离级别出现的问题是——不可重复读(Nonrepeatable Read)，不可重复读意味着我们在同一个事务中执行完全相同的select语句时可能看到不一样的结果</li></ul><p>导致这种情况的原因可能有：</p><ul><li>有一个交叉的事务有新的commit，导致了数据的改变</li><li>一个数据库被多个实例操作时，同一事务的其他实例在该实例处理其间可能会有新的commit</li></ul></li><li><p>可重复读(Repeatable read)</p><p>就是在开始读取数据（事务开启）时，不再允许修改操作，可避免脏读、不可重复读的发生</p><ul><li>这是MySQL的默认事务隔离级别</li><li>它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行</li><li>此级别可能出现的问题——幻读(Phantom Read)：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行</li><li>InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了该问题.InnoDB采用MVCC来支持高并发，实现了四个标准隔离级别。默认基本是可重复读，并且提供间隙锁（next-key locks）策略防止幻读出现</li></ul></li><li><p>串行(Serializable)</p><p>串行(Serializable)，是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。Mysql的默认隔离级别是Repeatable read</p><ul><li>这是最高的隔离级别</li><li>它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁</li><li>在这个级别，可能导致大量的超时现象和锁竞争</li></ul></li></ul><h4 id="5-Mysql高可用方案有哪些"><a href="#5-Mysql高可用方案有哪些" class="headerlink" title="5. Mysql高可用方案有哪些"></a>5. Mysql高可用方案有哪些</h4><ul><li>主从复制方案<ul><li>这是MySQL自身提供的一种高可用解决方案，数据同步方法采用的是<code>MySQL replication</code>技术。<code>MySQL replication</code>就是从服务器到主服务器拉取二进制日志文件，然后再将日志文件解析成相应的SQL在从服务器上重新执行一遍主服务器的操作，通过这种方式保证数据的一致性</li><li>为了达到更高的可用性，在实际的应用环境中，一般都是采用<code>MySQL replication</code>技术配合高可用集群软件<code>keepalived</code>来实现自动<code>failover</code>，这种方式可以实现95.000%的SLA</li></ul></li><li>MMM&#x2F;MHA高可用方案<ul><li>MMM提供了MySQL主主复制配置的监控、故障转移和管理的一套可伸缩的脚本套件。在MMM高可用方案中，典型的应用是双主多从架构，通过MySQL replication技术可以实现两个服务器互为主从，且在任何时候只有一个节点可以被写入，避免了多点写入的数据冲突</li><li>同时，当可写的主节点故障时，MMM套件可以立刻监控到，然后将服务自动切换到另一个主节点，继续提供服务，从而实现MySQL的高可用</li></ul></li><li>Heartbeat&#x2F;SAN高可用方案<ul><li>在这个方案中，处理failover的方式是高可用集群软件Heartbeat，它监控和管理各个节点间连接的网络，并监控集群服务，当节点出现故障或者服务不可用时，自动在其他节点启动集群服务</li><li>在数据共享方面，通过SAN（Storage Area Network）存储来共享数据，这种方案可以实现99.990%的SLA</li></ul></li><li>Heartbeat&#x2F;DRBD高可用方案<ul><li>这个方案处理failover的方式上依旧采用Heartbeat，不同的是，在数据共享方面，采用了基于块级别的数据同步软件DRBD来实现</li><li>DRBD是一个用软件实现的、无共享的、服务器之间镜像块设备内容的存储复制解决方案。和SAN网络不同，它并不共享存储，而是通过服务器之间的网络复制数据</li></ul></li><li>NDB CLUSTER高可用方案<ul><li>国内用NDB集群的公司非常少，貌似有些银行有用。NDB集群不需要依赖第三方组件，全部都使用官方组件，能保证数据的一致性，某个数据节点挂掉，其他数据节点依然可以提供服务，管理节点需要做冗余以防挂掉</li><li>缺点是：管理和配置都很复杂，而且某些SQL语句例如join语句需要避免</li></ul></li></ul><h4 id="6-Mysql中utf8和utf8mb4区别"><a href="#6-Mysql中utf8和utf8mb4区别" class="headerlink" title="6. Mysql中utf8和utf8mb4区别"></a>6. Mysql中utf8和utf8mb4区别</h4><ul><li>MySQL在5.5.3之后增加了这个utf8mb4的编码，mb4就是most bytes 4的意思，专门用来兼容四字节的unicode。好在utf8mb4是utf8的超集，除了将编码改为utf8mb4外不需要做其他转换。当然，为了节省空间，一般情况下使用utf8也就可以了</li><li>Mysql支持的utf8编码最大字符长度为3字节，如果遇到4字节的宽字符就会插入异常了。三个字节的UTF-8最大能编码的Unicode字符是0xffff，也就是Unicode中的基本多文种平面(BMP)。任何不在基本多文本平面的Unicode字符，都无法使用Mysql的utf8字符集存储</li><li>包括 Emoji 表情(Emoji是一种特殊的Unicode编码，常见于ios和android手机上)，和很多不常用的汉字，以及任何新增的Unicode字符等等</li><li>Mysql中保存4字节长度的UTF-8字符，需要使用utf8mb4字符集，但只有5.5.3版本以后的才支持(查看版本： select version();)。因此呢，为了获取更好的兼容性，应该总是使用utf8mb4而非utf8</li><li>对于CHAR类型数据，utf8mb4会多消耗一些空间，根据Mysql官方建议，使用VARCHAR替代CHAR</li></ul><h4 id="7-Mysql中乐观锁和悲观锁区别"><a href="#7-Mysql中乐观锁和悲观锁区别" class="headerlink" title="7. Mysql中乐观锁和悲观锁区别"></a>7. Mysql中乐观锁和悲观锁区别</h4><ul><li><p>悲观锁(Pessimistic Lock)</p><ul><li>悲观锁顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁</li><li>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁</li></ul></li><li><p>乐观锁(Optimistic Lock)</p><ul><li>乐观锁顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制</li><li>乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于<code>write_condition</code>机制的其实都是提供的乐观锁</li><li>乐观锁的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好</li></ul></li><li><p>两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适</p></li></ul><h4 id="8-Mysql索引主要是哪些"><a href="#8-Mysql索引主要是哪些" class="headerlink" title="8. Mysql索引主要是哪些"></a>8. Mysql索引主要是哪些</h4><p>索引的目的在于提高查询效率</p><ul><li>UNIQUE(唯一索引)：不可以出现相同的值，可以有NULL值</li><li>INDEX(普通索引)：允许出现相同的索引内容</li><li>PROMARY KEY(主键索引)：不允许出现相同的值</li><li>fulltext index(全文索引)：可以针对值中的某个单词，但效率确实不敢恭维</li><li>组合索引：实质上是将多个字段建到一个索引里，列值的组合必须唯一</li></ul><hr><h5 id="8-1-索引的缺点"><a href="#8-1-索引的缺点" class="headerlink" title="8.1 索引的缺点"></a>8.1 索引的缺点</h5><ul><li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT，UPDATE和DELETE。因为更新表时，mysql不仅要保存数据，还要保存一下索引文件</li><li>建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在要给大表上建了多种组合索引，索引文件会膨胀很宽， 索引只是提高效率的一个方式，如果mysql有大数据量的表，就要花时间研究建立最优的索引，或优化查询语句</li></ul><hr><h5 id="8-2-索引使用技巧"><a href="#8-2-索引使用技巧" class="headerlink" title="8.2 索引使用技巧"></a>8.2 索引使用技巧</h5><ul><li><strong>索引不会包含有NULL的列：</strong> 只要列中包含有NULL值，都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此符合索引就是无效的</li><li><strong>使用短索引：</strong> 对串列进行索引，如果可以就应该指定一个前缀长度。例如，如果有一个char（255）的列，如果在前10个或20个字符内，多数值是唯一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I&#x2F;O操作</li><li><strong>索引列排序：</strong>mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作，尽量不要包含多个列的排序，如果需要最好给这些列建复合索引</li><li><strong>like语句操作：</strong>一般情况下不鼓励使用like操作，如果非使用不可，注意正确的使用方式。<code>like ‘%aaa%’</code>不会使用索引，而<code>like ‘aaa%’</code>可以使用索引</li><li>不要在列上进行运算</li><li>不使用<code>NOT IN</code> 、<code>&lt;&gt;</code>、<code>！=</code>操作，但<code>&lt;</code>，<code>&lt;=</code>，<code>=</code>，<code>&gt;</code>，<code>&gt;=</code>，BETWEEN，IN是可以用到索引的</li><li>索引要建立在经常进行select操作的字段上。这是因为，如果这些列很少用到，那么有无索引并不能明显改变查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求</li><li>索引要建立在值比较唯一的字段上。</li><li>对于那些定义为text、image和bit数据类型的列不应该增加索引。因为这些列的数据量要么相当大，要么取值很少</li><li>在where和join中出现的列需要建立索引。</li><li>where的查询条件里有不等号(where column !&#x3D; …)，mysql将无法使用索引。</li><li>如果where字句的查询条件里使用了函数(如：where DAY(column)&#x3D;…)，mysql将无法使用索引</li><li>在join操作中(需要从多个数据表提取数据时)，mysql只有在主键和外键的数据类型相同时才能使用索引，否则及时建立了索引也不会使用</li></ul><hr><h5 id="8-3-组合索引的作用"><a href="#8-3-组合索引的作用" class="headerlink" title="8.3 组合索引的作用"></a>8.3 组合索引的作用</h5><ul><li>减少开销<ul><li>建一个组合索引(col1，col2，col3)，实际相当于建了(col1)，(col1，col2)，(col1，col2，col3)三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用组合索引会大大的减少开销</li></ul></li><li>覆盖索引<ul><li>通常指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖</li><li>对组合索引(col1，col2，col3)，如果有如下的<code>sql: select col1，col2，col3 from test where col1=1 and col2=2</code></li><li>那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一</li></ul></li><li>效率高<ul><li>索引列越多，通过索引筛选出的数据越快</li></ul></li></ul><h4 id="9-Mysql联合索引最左匹配原则"><a href="#9-Mysql联合索引最左匹配原则" class="headerlink" title="9. Mysql联合索引最左匹配原则"></a>9. Mysql联合索引最左匹配原则</h4><ul><li>在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先<ul><li>在检索数据时从联合索引的最左边开始匹配，Mysql会一直向右匹配直到遇到范围查询（<code>&gt;、&lt;、between、like</code>）就停止匹配了</li><li>就比如 <code>a=3 and b=4 and c&gt;5 and d=6</code>如果建立(abcd)顺序的索引，d就用不到索引了，如果建立(abdc)的索引则都可以用到索引，其中abd的顺序可以任意调整，因为查询优化器会重新编排（即使是c&gt;5 and b&#x3D;4 and d&#x3D;6 and a&#x3D;3也会全部用到 abdc索引 ）</li></ul></li><li><code>=</code>和<code>in</code>可以乱序，比如<code>a=1 and b=2 and c=3</code> 建立(abc)索引可以任意顺序，mysql查询优化器会优化顺序<ul><li>这里需要注意下，比如abc索引 那么只要查询条件有a即可用到abc索引（如abc ab ac a），没有a就用不到</li><li>最左前缀匹配成因：Mysql是创建复合索引的规则是根据索引最左边的字段进行排序，在第一个字段排序的基础上再进行第二个字段排序，类似于order by col1，col2… 所以第一个字段是绝对有序的 第二个字段就是无序的了，所以Mysql强调最左前缀匹配</li></ul></li></ul><h4 id="10-聚簇索引和非聚簇索引区别"><a href="#10-聚簇索引和非聚簇索引区别" class="headerlink" title="10. 聚簇索引和非聚簇索引区别"></a>10. 聚簇索引和非聚簇索引区别</h4><ul><li>聚簇索引与非聚簇索引的区别是：叶子节点是否存放一整行记录</li><li>InnoDB 主键使用的是聚簇索引，MyISAM 不管是主键索引，还是二级索引使用的都是非聚簇索引</li><li>对于聚簇索引表来说（左图），表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值。使用的是B+树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)</li><li>对于非聚簇索引表来说（右图），表数据和索引是分成两部分存储的，主键索引和二级索引存储上没有任何区别。使用的是B+树作为索引的存储结构，所有的节点都是索引，叶子节点存储的是索引+索引对应的记录的数据</li><li>因此，聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针</li></ul><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7lczbhkshj318611ik0y.jpg" alt="image.png" style="zoom: 20%;" /></div><h4 id="11-如何查询一个字段是否命中了索引"><a href="#11-如何查询一个字段是否命中了索引" class="headerlink" title="11. 如何查询一个字段是否命中了索引"></a>11. 如何查询一个字段是否命中了索引</h4><ul><li>通过explain sql可看下SQL是否走了索引，很快对比出来 </li><li>当一个sql中索引字段为int类型时，例如搜索条件<code>where num=&quot;111&quot;</code>与<code>where num=111</code>都可以使用该字段的索引。当一个中索引字段为varchar类型时，例如搜索条件<code>where num=&quot;111&quot;</code>可以使用索引，<code>where num=111</code>不可以使用索引</li></ul><h4 id="12-Mysql中查询数据什么情况下不会命中索引"><a href="#12-Mysql中查询数据什么情况下不会命中索引" class="headerlink" title="12. Mysql中查询数据什么情况下不会命中索引"></a>12. Mysql中查询数据什么情况下不会命中索引</h4><ul><li>索引规范不合理，sql解析器不命中索引</li><li>表中索引是以表中数据量字段最多的建立的索引，sql解析器不命中索引(实际就是索引没用，最后全局查找了)</li><li>bool的字段做索引，sql选择器不命中索引</li><li>模糊查询 %like</li><li>索引列参与计算，使用了函数</li><li>非最左前缀顺序</li><li>where对null判断</li><li>where不等于</li><li>or操作有至少一个字段没有索引</li><li>需要回表的查询结果集过大（超过配置的范围）</li></ul><h4 id="13-Mysql中的MVCC是什么"><a href="#13-Mysql中的MVCC是什么" class="headerlink" title="13. Mysql中的MVCC是什么"></a>13. Mysql中的MVCC是什么</h4><p>数据库并发控制——锁:Multiversion (version) concurrency control (MCC or MVCC) 多版本并发控制 ，它是数据库管理系统一种常见的并发控制</p><p>并发控制常用的是锁，当线程要对一个共享资源进行操作的时候，加锁是一种非常简单粗暴的方法(事务开始时给 DQL 加读锁，给 DML 加写锁)，这种锁是一种 悲观 的实现方式，也就是说这会给其他事务造成堵塞，从而影响数据库性能</p><p>其中在数据库中最常见的就是悲观锁和乐观锁：</p><ul><li>悲观锁：当一个线程需要对共享资源进行操作的时候，首先对共享资源进行加锁，当该线程持有该资源的锁的时候，其他线程对该资源进行操作的时候会被阻塞.</li><li>乐观锁：当一个线程需要对一个共享资源进行操作的时候，不对它进行加锁，而是在操作完成之后进行判断。比如乐观锁会通过一个版本号控制，如果操作完成后通过版本号进行判断在该线程操作过程中是否有其他线程已经对该共享资源进行操作了，如果有则通知操作失败，如果没有则操作成功，当然除了版本号还有CAS，如果不了解的可以去学习一下，这里不做过多涉及</li></ul><p>MVCC的两种读形式：</p><ul><li>快照读：读取的只是当前事务的可见版本，不用加锁。而你只要记住 简单的 <code>select</code>操作就是快照读(select * from table where id &#x3D; xxx)</li><li>当前读：读取的是当前版本，比如 特殊的读操作，更新&#x2F;插入&#x2F;删除操作</li></ul><p>MVCC的实现原理：</p><p>MVCC 使用了“三个隐藏字段”来实现版本并发控制，MySQL在创建建表的时候 innoDB 创建的真正的三个隐藏列吧</p><table><thead><tr><th align="left">RowID</th><th align="left">DB_TRX_ID</th><th align="left">DB_ROLL_PTR</th><th align="left">id</th><th align="left">name</th><th align="left">password</th></tr></thead><tbody><tr><td align="left">自动创建的id</td><td align="left">事务id</td><td align="left">回滚指针</td><td align="left">id</td><td align="left">name</td><td align="left">password</td></tr></tbody></table><ul><li>RowID：隐藏的自增ID，当建表没有指定主键，InnoDB会使用该RowID创建一个聚簇索引</li><li>DB_TRX_ID：最近修改（更新&#x2F;删除&#x2F;插入）该记录的事务ID</li><li>DB_ROLL_PTR：回滚指针，指向这条记录的上一个版本</li></ul><p>其实还有一个删除的flag字段，用来判断该行记录是否已经被删除。而 MVCC 使用的是其中的 事务字段，回滚指针字段，是否删除字段</p><h4 id="14-Mvcc和Redolog和Undolog以及Binlog有什么不同"><a href="#14-Mvcc和Redolog和Undolog以及Binlog有什么不同" class="headerlink" title="14. Mvcc和Redolog和Undolog以及Binlog有什么不同"></a>14. Mvcc和Redolog和Undolog以及Binlog有什么不同</h4><ul><li>Mvcc<ul><li>MVCC多版本并发控制是MySQL中基于乐观锁理论实现隔离级别的方式，用于读已提交和可重复读取隔离级别的实现</li><li>在MySQL中，会在表中每一条数据后面添加两个字段，最近修改该行数据的事务ID，指向该行（undolog表中）回滚段的指针</li><li>Read View判断行的可见性，创建一个新事务时，copy一份当前系统中的活跃事务列表。意思是，当前不应该被本事务看到的其他事务id列表</li></ul></li><li>UndoLog<ul><li>UndoLog也就是我们常说的回滚日志文件 主要用于事务中执行失败，进行回滚，以及MVCC中对于数据历史版本的查看</li><li>由引擎层的InnoDB引擎实现，是逻辑日志，记录数据修改被修改前的值，比如”把id&#x3D;’B’ 修改为id &#x3D; ‘B2’ ，那么undo日志就会用来存放id &#x3D;’B’的记录”</li><li>当一条数据需要更新前，会先把修改前的记录存储在undolog中，如果这个修改出现异常，则会使用undo日志来实现回滚操作，保证事务的一致性</li><li>当事务提交之后，undo log并不能立马被删除，而是会被放到待清理链表中，待判断没有事物用到该版本的信息时才可以清理相应undolog。它保存了事务发生之前的数据的一个版本，用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读</li></ul></li><li>Redolog<ul><li>Redolog是重做日志文件是记录数据修改之后的值，用于持久化到磁盘中</li><li>Redolog包括两部分：一：是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二：是磁盘上的重做日志文件(redo log file)，该部分日志是持久的</li><li>由引擎层的InnoDB引擎实现，是物理日志，记录的是物理数据页修改的信息，比如“某个数据页上内容发生了哪些改动”。当一条数据需要更新时，InnoDB会先将数据更新，然后记录redoLog 在内存中，然后找个时间将redoLog的操作执行到磁盘上的文件上</li><li>不管是否提交成功我都记录，你要是回滚了，那我连回滚的修改也记录。它确保了事务的持久性</li></ul></li><li>Binlog<ul><li>Binlog由Mysql的Server层实现，是逻辑日志，记录的是sql语句的原始逻辑，比如”把id&#x3D;’B’ 修改为id &#x3D; ‘B2’</li><li>Binlog会写入指定大小的物理文件中，是追加写入的，当前文件写满则会创建新的文件写入</li><li>产生:事务提交的时候，一次性将事务中的sql语句，按照一定的格式记录到binlog中</li><li>用于复制和恢复在主从复制中，从库利用主库上的binlog进行重播(执行日志中记录的修改逻辑)，实现主从同步。业务数据不一致或者错了，用binlog恢复</li></ul></li></ul><h4 id="15-Mysql读写分离以及主从同步"><a href="#15-Mysql读写分离以及主从同步" class="headerlink" title="15. Mysql读写分离以及主从同步"></a>15. Mysql读写分离以及主从同步</h4><ul><li>原理：主库将变更写binlog日志，然后从库连接到主库后，从库有一个IO线程，将主库的binlog日志拷贝到自己本地，写入一个中继日志中，接着从库中有一个sql线程会从中继日志读取binlog，然后执行binlog日志中的内容，也就是在自己本地再执行一遍sql，这样就可以保证自己跟主库的数据一致</li><li>问题：这里有很重要一点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行操作，在从库上会串行化执行，由于从库从主库拷贝日志以及串行化执行sql特点，在高并发情况下，从库数据一定比主库慢一点，是有延时的，所以经常出现，刚写入主库的数据可能读不到了，要过几十毫秒，甚至几百毫秒才能读取到。还有一个问题，如果突然主库宕机了，然后恰巧数据还没有同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。所以mysql实际上有两个机制，一个是半同步复制，用来解决主库数据丢失问题，一个是并行复制，用来解决主从同步延时问题</li><li>半同步复制：semi-sync复制，指的就是主库写入binlog日志后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的relay log之后，接着会返回一个ack给主库，主库接收到至少一个从库ack之后才会认为写完成</li><li>并发复制：指的是从库开启多个线程，并行读取relay log中不同库的日志，然后并行重放不同库的日志，这样库级别的并行。（将主库分库也可缓解延迟问题）</li></ul><h4 id="16-InnoDB的关键特性"><a href="#16-InnoDB的关键特性" class="headerlink" title="16. InnoDB的关键特性"></a>16. InnoDB的关键特性</h4><ul><li>插入缓冲：对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个Insert Buffer对象中。然后再以一定的频率和情况进行Insert Buffer和辅助索引页子节点的merge（合并）操作，这时通常能将多个插入合并到一个操作中（因为在一个索引页中），这就大大提高了对于非聚集索引插入的性能</li><li>两次写：两次写带给InnoDB存储引擎的是数据页的可靠性，有经验的DBA也许会想，如果发生写失效，可以通过重做日志进行恢复。这是一个办法。但是必须清楚地认识到，如果这个页本身已经发生了损坏（物理到page页的物理日志成功页内逻辑日志失败），再对其进行重做是没有意义的。这就是说，在应用（apply）重做日志前，用户需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做。在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是会通过memcpy函数将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，这就是doublewrite</li><li>自适应哈希索引：InnoDB存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引</li><li>异步IO：为了提高磁盘操作性能，当前的数据库系统都采用异步IO（AIO）的方式来处理磁盘操作。AIO的另一个优势是可以进行IO Merge操作，也就是将多个IO合并为1个IO，这样可以提高IOPS的性能</li><li>刷新邻接页：当刷新一个脏页时，InnoDB存储引擎会检测该页所在区（extent）的所有页，如果是脏页，那么一起进行刷新。这样做的好处显而易见，通过AIO可以将多个IO写入操作合并为一个IO操作，故该工作机制在传统机械磁盘下有着显著的优势</li></ul><h4 id="17-Mysql如何保证一致性和持久性"><a href="#17-Mysql如何保证一致性和持久性" class="headerlink" title="17. Mysql如何保证一致性和持久性"></a>17. Mysql如何保证一致性和持久性</h4><ul><li>Mysql为了保证<code>ACID</code>中的一致性和持久性，使用了WAL(<code>Write-Ahead Logging</code>，先写日志再写磁盘)。<code>Redo log</code>就是一种WAL的应用</li><li>当数据库忽然掉电，再重新启动时，Mysql可以通过<code>Redo log</code>还原数据。也就是说，每次事务提交时，不用同步刷新磁盘数据文件，只需要同步刷新<code>Redo log</code>就足够了</li></ul><h4 id="18-为什么选择B-树作为索引结构"><a href="#18-为什么选择B-树作为索引结构" class="headerlink" title="18. 为什么选择B+树作为索引结构"></a>18. 为什么选择B+树作为索引结构</h4><ul><li>Hash索引：Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描</li><li>二叉查找树：解决了排序的基本问题，但是由于无法保证平衡，可能退化为链表</li><li>平衡二叉树：通过旋转解决了平衡的问题，但是旋转操作效率太低</li><li>红黑树：通过舍弃严格的平衡和引入红黑节点，解决了AVL旋转效率过低的问题，但是在磁盘等场景下，树仍然太高，IO次数太多</li><li>B+树：在B树的基础上，将非叶节点改造为不存储数据纯索引节点，进一步降低了树的高度；此外将叶节点使用指针连接成链表，范围查询更加高效。此外，B+树，主要是查询效率高，O(logN)，可以充分利用磁盘预读的特性，多叉树，深度小，叶子结点有序且存储数据</li></ul><h4 id="19-InnoDB的行锁模式"><a href="#19-InnoDB的行锁模式" class="headerlink" title="19. InnoDB的行锁模式"></a>19. InnoDB的行锁模式</h4><ul><li>共享锁(S)：用法lock in share mode，又称读锁，允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁<ul><li>若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改</li></ul></li><li>排他锁(X)：用法for update，又称写锁，允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁<ul><li>若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。在没有索引的情况下，InnoDB只能使用表锁</li></ul></li></ul><h4 id="20-哈希-hash-比树-tree-更快，索引结构为什么要设计成树型"><a href="#20-哈希-hash-比树-tree-更快，索引结构为什么要设计成树型" class="headerlink" title="20. 哈希(hash)比树(tree)更快，索引结构为什么要设计成树型"></a>20. 哈希(hash)比树(tree)更快，索引结构为什么要设计成树型</h4><p>加速查找速度的数据结构，常见的有两类：</p><ul><li>哈希，例如HashMap，查询&#x2F;插入&#x2F;修改&#x2F;删除的平均时间复杂度都是O(1)</li><li>树，例如平衡二叉搜索树，查询&#x2F;插入&#x2F;修改&#x2F;删除的平均时间复杂度都是O(lg(n))</li></ul><p>哈希只能满足等值查询，不满足范围和大小查询，其次哈希不可以排序。Mysql是用等值查询，用树的话，等值查询只需要顺序遍历即可。但是对于排序查询的sql需求：分组：<code>group by</code> ，排序：<code>order by</code> ，比较：<code>&lt;、&gt;</code>等，哈希型的索引，时间复杂度会退化为O(n)，而树型的“有序”特性，依然能够保持O(log(n)) 的高效率</p><h4 id="21-为什么索引的key长度不能太长"><a href="#21-为什么索引的key长度不能太长" class="headerlink" title="21. 为什么索引的key长度不能太长"></a>21. 为什么索引的key长度不能太长</h4><p>key 太长会导致一个页当中能够存放的 key 的数目变少，间接导致索引树的页数目变多，索引层次增加，从而影响整体查询变更的效率</p><h4 id="22-Mysql的数据如何恢复到任意时间点"><a href="#22-Mysql的数据如何恢复到任意时间点" class="headerlink" title="22. Mysql的数据如何恢复到任意时间点"></a>22. Mysql的数据如何恢复到任意时间点</h4><p>恢复到任意时间点以定时的做全量备份，以及备份增量的 binlog 日志为前提。恢复到任意时间点首先将全量备份恢复之后，再此基础上回放增加的 binlog 直至指定的时间点</p><h4 id="23-Mysql为什么加了索引可以加快查询"><a href="#23-Mysql为什么加了索引可以加快查询" class="headerlink" title="23. Mysql为什么加了索引可以加快查询"></a>23. Mysql为什么加了索引可以加快查询</h4><p>在数据十分庞大的时候，索引可以大大加快查询的速度，这是因为使用索引后可以不用扫描全表来定位某行的数据，而是先通过索引表找到该行数据对应的物理地址然后访问相应的数据</p><ul><li>优势：可以快速检索，减少I&#x2F;O次数，加快检索速度；根据索引分组和排序，可以加快分组和排序</li><li>劣势：索引本身也是表，因此会占用存储空间，一般来说，索引表占用的空间的数据表的1.5倍；索引表的维护和创建需要时间成本，这个成本随着数据量增大而增大；构建索引会降低数据表的修改操作（删除，添加，修改）的效率，因为在修改数据表的同时还需要修改索引表</li></ul><h4 id="24-Explain命令有什么用"><a href="#24-Explain命令有什么用" class="headerlink" title="24. Explain命令有什么用"></a>24. Explain命令有什么用</h4><p>在开发的过程中，我们有时会用<strong>慢查询</strong>去记录一些执行时间比较久的Sql语句，找出这些Sql语句并不意味着完事了，这个时候我们就需要用到explain这个命令来查看一个这些Sql语句的执行计划，查看该Sql语句有没有使用上了索引，有没有做全表扫描，这些都可以通过explain命令来查看</p><p>expain出来的信息有10列，分别是<code>id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- <span class="built_in">id</span>：select选择标识符</span><br><span class="line">- select_type：表示查询的类型</span><br><span class="line">- table：输出结果集的表</span><br><span class="line">- partitions：匹配的分区</span><br><span class="line">- <span class="built_in">type</span>：表示表的连接类型</span><br><span class="line">- possible_keys：表示查询时，可能使用的索引</span><br><span class="line">- key：表示实际使用的索引</span><br><span class="line">- key_len：索引字段的长度</span><br><span class="line">- ref：列与索引的比较</span><br><span class="line">- rows：扫描出的行数(估算的行数)</span><br><span class="line">- filtered：按表条件过滤的行百分比</span><br><span class="line">- Extra：执行情况的描述和说明</span><br></pre></td></tr></table></figure><ul><li><p>id：select选择标识符</p><p>id是Sql执行的顺序的标识，Sql从大到小的执行</p><ul><li>id相同时，执行顺序由上至下</li><li>如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li><li>id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行</li></ul></li><li><p>select_type：表示查询的类型</p><p>查询中每个select子句的类型</p><ul><li>SIMPLE(简单SELECT，不使用UNION或子查询等)</li><li>PRIMARY(查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)</li><li>UNION(UNION中的第二个或后面的SELECT语句)</li><li>DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)</li><li>UNION RESULT(UNION的结果)</li><li>SUBQUERY(子查询中的第一个SELECT)</li><li>DEPENDENT SUBQUERY(子查询中的第一个SELECT，取决于外面的查询)</li><li>DERIVED(派生表的SELECT，FROM子句的子查询)</li><li>UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)</li></ul></li><li><p>table：输出结果集的表</p><ul><li>table显示这一行的数据是关于哪张表的，有时不是真实的表名字，看到的是derivedx</li></ul></li><li><p>partitions：匹配的分区</p></li><li><p>type：表示表的连接类型</p><p>type表示Mysql在表中找到所需行的方式，又称“访问类型”。常用的类型有： ALL， index， range， ref， eq_ref， const， system， NULL（从左到右，性能从差到好）</p><ul><li>ALL：Full Table Scan， Mysql将遍历全表以找到匹配的行</li><li>index：Full Index Scan，index与ALL区别为index类型只遍历索引树</li><li>range：只检索给定范围的行，使用一个索引来选择行</li><li>ref：表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</li><li>eq_ref：类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件</li><li>const、system：当Mysql对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，Mysql就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system</li><li>NULL：Mysql在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成</li></ul></li><li><p>possible_keys：表示查询时，可能使用的索引</p><ul><li>possible_keys指出Mysql能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用</li><li>该列完全独立于<code>EXPLAIN</code>输出所示的表的次序。这意味着在<code>possible_keys</code>中的某些键实际上不能按生成的表次序使用</li><li>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询</li></ul></li><li><p>key：表示实际使用的索引</p><ul><li>key列显示MySql实际决定使用的键（索引）</li><li>如果没有选择索引，键是NULL。要想强制Mysql使用或忽视<code>possible_keys</code>列中的索引，在查询中使用<code>FORCE INDEX、USE INDEX</code>或者<code>IGNORE INDEX</code></li></ul></li><li><p>key_len：索引字段的长度</p><ul><li>key_len表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）不损失精确性的情况下，长度越短越好</li></ul></li><li><p>ref：列与索引的比较</p><ul><li>ref表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</li></ul></li><li><p>rows：扫描出的行数(估算的行数)</p><ul><li>rows表示Mysql根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</li></ul></li><li><p>filtered：按表条件过滤的行百分比</p></li><li><p>Extra：执行情况的描述和说明</p><p>该列包含Mysql解决查询的详细信息，有以下几种情况：</p><ul><li>Using where：列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤</li><li>Using temporary：表示Mysql需要使用临时表来存储结果集，常见于排序和分组查询</li><li>Using filesort：Mysql中无法利用索引完成的排序操作称为“文件排序”</li><li>Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能</li><li>Impossible where：这个值强调了where语句会导致没有符合条件的行</li><li>Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行</li></ul></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MySQL常见面试题、八股文&lt;/p&gt;
&lt;h4 id=&quot;1-Mysql索引用的是什么算法&quot;&gt;&lt;a href=&quot;#1-Mysql索引用的是什么算法&quot; class=&quot;headerlink&quot; title=&quot;1. Mysql索引用的是什么算法&quot;&gt;&lt;/a&gt;1. Mysql索引用的是什么</summary>
      
    
    
    
    <category term="面试" scheme="https://huajun-chen.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="八股文" scheme="https://huajun-chen.github.io/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    <category term="MySQL" scheme="https://huajun-chen.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Golang面试题</title>
    <link href="https://huajun-chen.github.io/2022/10/28/Golang%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://huajun-chen.github.io/2022/10/28/Golang%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-10-28T00:24:34.000Z</published>
    <updated>2022-10-28T13:30:40.629Z</updated>
    
    <content type="html"><![CDATA[<p>Golang常见面试题分享，涵盖了常见的Golang面试八股文</p><h4 id="1-无缓冲Chan的发送和接收是否同步"><a href="#1-无缓冲Chan的发送和接收是否同步" class="headerlink" title="1. 无缓冲Chan的发送和接收是否同步"></a>1. 无缓冲Chan的发送和接收是否同步</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch := make(chan int)    无缓冲的channel由于没有缓冲发送和接收需要同步</span><br><span class="line">ch := make(chan int, 2) 有缓冲channel不要求发送和接收操作同步</span><br></pre></td></tr></table></figure><ul><li>channel无缓冲时，发送阻塞直到数据被接收，接收阻塞直到读到数据</li><li>channel有缓冲时，当缓冲满时发送阻塞，当缓冲空时接收阻塞</li></ul><h4 id="2-什么是channel，为什么它可以做到线程安全"><a href="#2-什么是channel，为什么它可以做到线程安全" class="headerlink" title="2. 什么是channel，为什么它可以做到线程安全"></a>2. 什么是channel，为什么它可以做到线程安全</h4><ul><li>Channel是Go中的一个核心类型，可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication)，Channel也可以理解是一个先进先出的队列，通过管道进行通信</li><li>Golang的Channel，发送一个数据到Channel和从Channel接收一个数据都是原子性的</li><li>Go的设计思想就是，不要通过共享内存来通信，而是通过通信来共享内存，前者就是传统的加锁，后者就是Channel</li><li>设计Channel的主要目的就是在多任务间传递数据的，本身就是安全的</li></ul><h4 id="3-Goroutine和Channel的作用分别是什么"><a href="#3-Goroutine和Channel的作用分别是什么" class="headerlink" title="3. Goroutine和Channel的作用分别是什么"></a>3. Goroutine和Channel的作用分别是什么</h4><h4 id="4-Channel是同步的还是异步的"><a href="#4-Channel是同步的还是异步的" class="headerlink" title="4. Channel是同步的还是异步的"></a>4. Channel是同步的还是异步的</h4><p>Channel是异步进行的，channel存在3种状态：</p><ul><li>nil，未初始化的状态，只进行了声明，或者手动赋值为nil</li><li>active，正常的channel，可读或者可写</li><li>closed，已关闭，千万不要误认为关闭channel后，channel的值是nil</li></ul><table><thead><tr><th align="left">操作</th><th align="left">一个零值nil通道</th><th align="left">一个非零值但已关闭的通道</th><th align="left">一个非零值且尚未关闭的通道</th></tr></thead><tbody><tr><td align="left">关闭</td><td align="left">产生恐慌</td><td align="left">产生恐慌</td><td align="left">成功关闭</td></tr><tr><td align="left">发送数据</td><td align="left">永久阻塞</td><td align="left">产生恐慌</td><td align="left">阻塞或者成功发送</td></tr><tr><td align="left">接收数据</td><td align="left">永久阻塞</td><td align="left">永不阻塞</td><td align="left">阻塞或者成功接收</td></tr></tbody></table><h4 id="5-Go中的channel的实现"><a href="#5-Go中的channel的实现" class="headerlink" title="5. Go中的channel的实现"></a>5. Go中的channel的实现</h4><h4 id="6-Golang并发机制以及它所使用的CSP并发模型"><a href="#6-Golang并发机制以及它所使用的CSP并发模型" class="headerlink" title="6. Golang并发机制以及它所使用的CSP并发模型"></a>6. Golang并发机制以及它所使用的CSP并发模型</h4><h4 id="7-Go的GPM如何调度"><a href="#7-Go的GPM如何调度" class="headerlink" title="7. Go的GPM如何调度"></a>7. Go的GPM如何调度</h4><h4 id="8-Golang中常用的并发模型"><a href="#8-Golang中常用的并发模型" class="headerlink" title="8. Golang中常用的并发模型"></a>8. Golang中常用的并发模型</h4><p>Golang中常用的并发模型有三种:</p><ul><li>通过channel通知实现并发控制</li><li>通过sync包中的WaitGroup实现并发控制</li><li>在Go1.7以后引进的强大的Context上下文，实现并发控制</li></ul><ol><li><p>通过channel通知实现并发控制</p><p>无缓冲的通道指的是通道的大小为0，也就是说，这种类型的通道在接收前没有能力保存任何值，它要求发送 goroutine 和接收 goroutine 同时准备好，才可以完成发送和接收操作</p><p>发送 goroutine 和接收 gouroutine 必须是同步的，同时准备后，如果没有同时准备好的话，先执行的操作就会阻塞等待，直到另一个相对应的操作准备好为止</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;start working&quot;</span>)</span><br><span class="line">        time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">        ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;-ch</span><br><span class="line">    fmt.Println(<span class="string">&quot;finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当主 goroutine 运行到 <code>&lt;-ch</code> 接受 channel 的值的时候，如果该 channel 中没有数据，就会一直阻塞等待，直到有值。 这样就可以简单实现并发控制</p><hr></li><li><p>通过sync包中的WaitGroup实现并发控制</p><p>Goroutine是异步执行的，有的时候为了防止在结束main函数的时候结束掉Goroutine，所以需要同步等待，这个时候就需要用 WaitGroup了，在sync包中，提供了WaitGroup，它会等待它收集的所有Goroutine任务全部完成。在WaitGroup里主要有三个方法:</p><ul><li>Add，可以添加或减少Goroutine的数量</li><li>Done，相当于Add(-1)</li><li>Wait，执行后会堵塞主线程，直到WaitGroup里的值减至0</li></ul><p>在主 goroutine 中 Add(delta int) 索要等待goroutine 的数量。在每一个 goroutine 完成后 Done() 表示这一个goroutine 已经完成，当所有的 goroutine 都完成后，在主 goroutine 中 WaitGroup 返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">var</span> urls = []<span class="type">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;http://www.golang.org/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://www.google.com/&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            http.Get(url)</span><br><span class="line">        &#125;(url)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Golang官网中对于WaitGroup介绍是<code>A WaitGroup must not be copied after first use</code>,在 WaitGroup第一次使用后，不能被拷贝</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(wg sync.WaitGroup, i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;i:%d&quot;</span>, i)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(wg, i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;exit&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后会报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i:1i:3i:2i:0i:4fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine 1 [semacquire]:</span><br><span class="line">sync.runtime_Semacquire(0xc000094018)</span><br><span class="line">        /home/keke/soft/go/src/runtime/sema.go:56 +0x39</span><br><span class="line"><span class="built_in">sync</span>.(*WaitGroup).Wait(0xc000094010)</span><br><span class="line">        /home/keke/soft/go/src/sync/waitgroup.go:130 +0x64</span><br><span class="line">main.main()</span><br><span class="line">        /home/keke/go/Test/wait.go:17 +0xab</span><br><span class="line"><span class="built_in">exit</span> status 2</span><br></pre></td></tr></table></figure><p>它提示所有的 <code>goroutine</code> 都已经睡眠了，出现了死锁。这是因为wg给拷贝传递到了goroutine中，导致只有Add操作，其实Done操作是在wg的副本执行的，因此 Wait 就会死锁</p><ul><li><p>这个第一个修改方式：将匿名函数中wg的传入类型改为 <code>*sync.WaitGroup，</code>这样就能引用到正确的<code>WaitGroup</code>了</p></li><li><p>这个第二个修改方式：将匿名函数中的wg的传入参数去掉，因为Go支持闭包类型，在匿名函数中可以直接使用外面的wg变量</p></li></ul><hr></li><li><p>Context上下文实现并发控制</p><p>通常，在一些简单场景下使用channel和WaitGroup已经足够了，但是当面临一些复杂多变的网络并发场景下channel和WaitGroup显得有些力不从心了，比如一个网络请求Request，每个Request都需要开启一个goroutine做一些事情，这些goroutine又可能会开启其他的goroutine，比如数据库和RPC服务</p><p>所以我们需要一种可以跟踪goroutine的方案，才可以达到控制他们的目的，这就是Go语言为我们提供的Context，称之为上下文非常贴切，它就是goroutine的上下文，它是包括一个程序的运行环境、现场和快照等。每个程序要运行时，都需要知道当前程序的运行状态，通常Go将这些封装在一个 Context里，再将它传给要执行的goroutine ，context包主要是用来处理多个goroutine之间共享数据，及多个goroutine的管理</p><p>context包的核心是struct Context，接口声明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Context carries a deadline, cancelation signal, and request-scoped values</span></span><br><span class="line"><span class="comment">// across API boundaries. Its methods are safe for simultaneous use by multiple</span></span><br><span class="line"><span class="comment">// goroutines.</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Done returns a channel that is closed when this `Context` is canceled</span></span><br><span class="line">    <span class="comment">// or times out.</span></span><br><span class="line">    <span class="comment">// Done() 返回一个只能接受数据的channel类型，当该context关闭或者超时时间到了的时候，该channel就会有一个取消信号</span></span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Err indicates why this Context was canceled, after the Done channel</span></span><br><span class="line">    <span class="comment">// is closed.</span></span><br><span class="line">    <span class="comment">// Err() 在Done() 之后，返回context 取消的原因。</span></span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deadline returns the time when this Context will be canceled, if any.</span></span><br><span class="line">    <span class="comment">// Deadline() 设置该context cancel的时间点</span></span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Value returns the value associated with key or nil if none.</span></span><br><span class="line">    <span class="comment">// Value() 方法允许 Context 对象携带request作用域的数据，该数据必须是线程安全的。</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Context对象是线程安全的，你可以把一个Context对象传递给任意个数的gorotuine，对它执行 取消 操作时，所有goroutine都会接收到取消信号。一个Context不能拥有Cancel方法，同时我们也只能Done channel接收数据。其中的原因是一致的：接收取消信号的函数和发送信号的函数通常不是一个。典型的场景是：父操作为子操作操作启动goroutine，子操作也就不能取消父操作</p></li></ol><h4 id="9-并发编程概念是什么"><a href="#9-并发编程概念是什么" class="headerlink" title="9. 并发编程概念是什么"></a>9. 并发编程概念是什么</h4><ul><li>并行是指两个或者多个事件在同一时刻发生；并发是指两个或多个事件在同一时间间隔发生</li><li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群</li><li>并发偏重于多个任务交替执行，而多个任务之间有可能还是串行的。而并行是真正意义上的“同时执行”</li><li>并发编程是指在一台处理器上“同时”处理多个任务。并发是在同一实体上的多个事件。多个事件在同一时间间隔发生。并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能</li></ul><h4 id="10-怎么查看Goroutine的数量"><a href="#10-怎么查看Goroutine的数量" class="headerlink" title="10. 怎么查看Goroutine的数量"></a>10. 怎么查看Goroutine的数量</h4><p>在Golang中，<code>GOMAXPROCS</code>中控制的是未被阻塞的所有Goroutine，可以被 <code>Multiplex</code> 到多少个线程上运行，通过<code>GOMAXPROCS</code>可以查看Goroutine的数量</p><h4 id="11-怎么限制Goroutine的数量"><a href="#11-怎么限制Goroutine的数量" class="headerlink" title="11. 怎么限制Goroutine的数量"></a>11. 怎么限制Goroutine的数量</h4><p>在Golang中，Goroutine虽然很好，但是数量太多了，往往会带来很多麻烦，比如耗尽系统资源导致程序崩溃，或者CPU使用率过高导致系统忙不过来。所以我们可以限制下Goroutine的数量，这样就需要在每一次执行go之前判断goroutine的数量，如果数量超了，就要阻塞go的执行</p><ul><li>使用通道，每次执行的go之前向通道写入值，直到通道满的时候就阻塞了</li><li>但是新的问题于是就出现了，因为并不是所有的goroutine都执行完了，在main函数退出之后，还有一些goroutine没有执行完就被强制结束了。这个时候我们就需要用到sync.WaitGroup。使用WaitGroup等待所有的goroutine退出</li><li>Go的GOMAXPROCS默认值已经设置为CPU的核数， 这里允许我们的Go程序充分使用机器的每一个CPU，最大程度的提高我们程序的并发性能。<code>runtime.NumGoroutine</code>函数在被调用后，会返回系统中的处于特定状态的Goroutine的数量。这里的特指是指<code>Grunnable\Gruning\Gsyscall\Gwaition</code>。处于这些状态的Groutine即被看做是活跃的或者说正在被调度</li><li><strong>注意：</strong> 垃圾回收所在Groutine的状态也处于这个范围内的话，也会被纳入该计数器</li></ul><h4 id="12-Goroutine和线程的区别"><a href="#12-Goroutine和线程的区别" class="headerlink" title="12. Goroutine和线程的区别"></a>12. Goroutine和线程的区别</h4><h4 id="13-在Go函数中为什么会发生内存泄露，Goroutine发生了泄漏如何检测"><a href="#13-在Go函数中为什么会发生内存泄露，Goroutine发生了泄漏如何检测" class="headerlink" title="13. 在Go函数中为什么会发生内存泄露，Goroutine发生了泄漏如何检测"></a>13. 在Go函数中为什么会发生内存泄露，Goroutine发生了泄漏如何检测</h4><p>内存泄漏，指的是能够预期的能很快被释放的内存由于附着在了长期存活的内存上、或生命期意外地被延长，导致预计能够立即回收的内存而长时间得不到回收</p><ul><li>预期能被快速释放的内存因被根对象引用而没有得到迅速释放；当有一个全局对象时，可能不经意间将某个变量附着在其上，且忽略的将其进行释放，则该内存永远不会得到释放</li><li>Goroutine泄漏；Goroutine作为一种逻辑上理解的轻量级线程，需要维护执行用户代码的上下文信息。在运行过程中也需要消耗一定的内存来保存这类信息，而这些内存在目前版本的 Go 中是不会被释放的。因此，如果一个程序持续不断地产生新的 goroutine、且不结束已经创建的goroutine并复用这部分内存，就会造成内存泄漏的现象</li><li>检测方法：通过Go自带的工具pprof或者使用Gops去检测诊断当前在系统上运行的Go进程的占用的资源</li></ul><h4 id="14-Goroutine和KernelThread之间是什么关系"><a href="#14-Goroutine和KernelThread之间是什么关系" class="headerlink" title="14. Goroutine和KernelThread之间是什么关系"></a>14. Goroutine和KernelThread之间是什么关系</h4><h4 id="15-协程和线程和进程的区别"><a href="#15-协程和线程和进程的区别" class="headerlink" title="15. 协程和线程和进程的区别"></a>15. 协程和线程和进程的区别</h4><ul><li>进程：是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。<br>每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全</li><li>线程：是进程的一个实体，线程是内核态，而且是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据</li><li>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</li></ul><h4 id="16-G0的作用"><a href="#16-G0的作用" class="headerlink" title="16. G0的作用"></a>16. G0的作用</h4><ul><li>在Go中g0作为一个特殊的goroutine，为scheduler执行调度循环提供了场地（栈）。对于一个线程来说，g0总是它第一个创建的 goroutine。之后，它会不断地寻找其他普通的goroutine来执行，直到进程退出</li><li>当需要执行一些任务，且不想扩栈时，就可以用到 g0了，因为g0的栈比较大</li><li>g0 其他的一些“职责”有：创建 <code>goroutine</code>、<code>deferproc</code> 函数里新建 <code>_defer</code>、垃圾回收相关的工作（例如stw、扫描goroutine的执行栈、一些标识清扫的工作、栈增长）等等</li></ul><h4 id="17-Golang的内存模型中为什么小对象多了会造成GC压力"><a href="#17-Golang的内存模型中为什么小对象多了会造成GC压力" class="headerlink" title="17. Golang的内存模型中为什么小对象多了会造成GC压力"></a>17. Golang的内存模型中为什么小对象多了会造成GC压力</h4><p>通常小对象过多会导致GC三色法消耗过多的CPU。优化思路：减少对象分配</p><h4 id="18-Go的对象在内存中是怎样分配的"><a href="#18-Go的对象在内存中是怎样分配的" class="headerlink" title="18. Go的对象在内存中是怎样分配的"></a>18. Go的对象在内存中是怎样分配的</h4><h4 id="19-栈的内存是怎么分配的"><a href="#19-栈的内存是怎么分配的" class="headerlink" title="19. 栈的内存是怎么分配的"></a>19. 栈的内存是怎么分配的</h4><h4 id="20-堆内存管理怎么分配的"><a href="#20-堆内存管理怎么分配的" class="headerlink" title="20. 堆内存管理怎么分配的"></a>20. 堆内存管理怎么分配的</h4><h4 id="21-在Go函数中为什么会发生内存泄露"><a href="#21-在Go函数中为什么会发生内存泄露" class="headerlink" title="21. 在Go函数中为什么会发生内存泄露"></a>21. 在Go函数中为什么会发生内存泄露</h4><p>同上13</p><h4 id="22-Go语言的栈空间管理是怎么样的"><a href="#22-Go语言的栈空间管理是怎么样的" class="headerlink" title="22. Go语言的栈空间管理是怎么样的"></a>22. Go语言的栈空间管理是怎么样的</h4><h4 id="23-Go中的逃逸分析是什么"><a href="#23-Go中的逃逸分析是什么" class="headerlink" title="23. Go中的逃逸分析是什么"></a>23. Go中的逃逸分析是什么</h4><h4 id="24-Go函数返回局部变量的指针是否安全"><a href="#24-Go函数返回局部变量的指针是否安全" class="headerlink" title="24. Go函数返回局部变量的指针是否安全"></a>24. Go函数返回局部变量的指针是否安全</h4><p>在Go中是安全的，Go编译器将会对每个局部变量进行逃逸分析。如果发现局部变量的作用域超出该函数，则不会将内存分配在栈上，而是分配在堆上</p><h4 id="25-Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量"><a href="#25-Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量" class="headerlink" title="25. Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量"></a>25. Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量</h4><p>Golang中Goroutine可以通过Channel进行安全读写共享变量，还可以通过原子性操作进行</p><h4 id="26-Go中的锁有哪些"><a href="#26-Go中的锁有哪些" class="headerlink" title="26. Go中的锁有哪些"></a>26. Go中的锁有哪些</h4><p>Go中的三种锁包括：</p><ul><li>互斥锁</li><li>读写锁</li><li>sync.Map安全锁</li></ul><ol><li><p>互斥锁</p><p>Go并发程序对共享资源进行访问控制的主要手段，由标准库代码包中sync中的Mutex结构体表示，sync.Mutex包中的类型只有两个公开的指针方法Lock和Unlock</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Locker表示可以锁定和解锁的对象。</span></span><br><span class="line"> <span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 锁定当前的互斥量</span></span><br><span class="line"> <span class="comment">// 如果锁已被使用，则调用goroutine</span></span><br><span class="line"> <span class="comment">// 阻塞直到互斥锁可用。</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() </span><br><span class="line"></span><br><span class="line"> <span class="comment">// 对当前互斥量进行解锁</span></span><br><span class="line"> <span class="comment">// 如果在进入解锁时未锁定m，则为运行时错误。</span></span><br><span class="line"> <span class="comment">// 锁定的互斥锁与特定的goroutine无关。</span></span><br><span class="line"> <span class="comment">// 允许一个goroutine锁定Mutex然后安排另一个goroutine来解锁它。</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock()</span><br></pre></td></tr></table></figure><p>如果对一个已经上锁的对象再次上锁，那么就会导致该锁定操作被阻塞，直到该互斥锁回到被解锁状态。互斥锁锁定操作的逆操作并不会导致协程阻塞，但是有可能导致引发一个无法恢复的运行时的panic，比如对一个未锁定的互斥锁进行解锁时就会发生panic。避免这种情况的最有效方式就是使用defer</p><hr></li><li><p>读写锁</p><p>读写锁是针对读写操作的互斥锁，可以分别针对读操作与写操作进行锁定和解锁操作 。读写锁的访问控制规则如下：</p><ul><li>多个写操作之间是互斥的</li><li>写操作与读操作之间也是互斥的</li><li>多个读操作之间不是互斥的</li></ul><p>在这样的控制规则下，读写锁可以大大降低性能损耗。sync中的RWMutex有以下几种方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对读操作的锁定</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//对读操作的解锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//对写操作的锁定</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//对写操作的解锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个实现了sync.Locker接口类型的值，实际上是回调rw.RLock and rw.RUnlock.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLocker() Locker</span><br></pre></td></tr></table></figure><ul><li>若对一个未被写锁定的读写锁进行写解锁，就会引发一个不可恢复的panic，同理对一个未被读锁定的读写锁进行读写锁也会如此。</li><li>由于读写锁控制下的多个读操作之间不是互斥的，因此对于读解锁更容易被忽视。对于同一个读写锁，添加多少个读锁定，就必要有等量的读解锁，这样才能其他协程有机会进行操作</li><li>因此Go中读写锁，在多个读线程可以同时访问共享数据,写线程必须等待所有读线程都释放锁以后，才能取得锁</li><li>同样的，读线程必须等待写线程释放锁后，才能取得锁，也就是说读写锁要确保的是如下互斥关系，可以同时读，但是读-写，写-写都是互斥的</li></ul><hr></li><li><p>sync.Map安全锁</p><p>golang中的sync.Map是并发安全的，其实也就是sync包中golang自定义的一个名叫Map的结构体</p><ul><li>Delete 方法</li><li>Store 方法</li><li>Load方法</li></ul><p>sync.Map是通过冗余的两个数据结构(read、dirty)，实现性能的提升。为了提升性能，load、delete、store等操作尽量使用只读的read；为了提高read的key击中概率，采用动态调整，将dirty数据提升为read；对于数据的删除，采用延迟标记删除法，只有在提升dirty的时候才删除</p></li></ol><h4 id="27-Go中的锁如何实现"><a href="#27-Go中的锁如何实现" class="headerlink" title="27. Go中的锁如何实现"></a>27. Go中的锁如何实现</h4><h4 id="28-Go中数据竞争问题怎么解决"><a href="#28-Go中数据竞争问题怎么解决" class="headerlink" title="28. Go中数据竞争问题怎么解决"></a>28. Go中数据竞争问题怎么解决</h4><ul><li>数据竞争问题可以使用互斥锁sync.Mutex，或者也可以通过CAS无锁并发解决</li><li>其中使用同步访问共享数据或者CAS无锁并发是处理数据竞争的一种有效的方法</li><li>golang在1.1之后引入了竞争检测机制，可以使用 <code>go run -race</code> 或者 <code>go build -race</code>来进行静态检测。其在内部的实现是，开启多个协程执行同一个命令， 并且记录下每个变量的状态</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> test -race mypkg    <span class="comment">// 测试包</span></span><br><span class="line"><span class="keyword">go</span> run -race mysrc.<span class="keyword">go</span>  <span class="comment">// 编译和运行程序</span></span><br><span class="line"><span class="keyword">go</span> build -race mycmd   <span class="comment">// 构建程序</span></span><br><span class="line"><span class="keyword">go</span> install -race mypkg <span class="comment">// 安装程序</span></span><br></pre></td></tr></table></figure><h4 id="29-Go中CAS是怎么回事"><a href="#29-Go中CAS是怎么回事" class="headerlink" title="29. Go中CAS是怎么回事"></a>29. Go中CAS是怎么回事</h4><h4 id="30-Go主协程如何等其余协程完再操作"><a href="#30-Go主协程如何等其余协程完再操作" class="headerlink" title="30. Go主协程如何等其余协程完再操作"></a>30. Go主协程如何等其余协程完再操作</h4><ul><li>Go提供了更简单的方法——使用<code>sync.WaitGroup</code>。<code>WaitGroup</code>，就是用来等待一组操作完成的。<code>WaitGroup</code>内部实现了一个计数器，用来记录未完成的操作个数</li><li>它提供了三个方法，<code>Add()</code>用来添加计数。<code>Done()</code>用来在操作结束时调用，使计数减一。<code>Wait()</code>用来等待所有的操作结束，即计数变为0，该函数会在计数不为0时等待，在计数为0时立即返回</li></ul><h4 id="31-Context包的用途是什么"><a href="#31-Context包的用途是什么" class="headerlink" title="31. Context包的用途是什么"></a>31. Context包的用途是什么</h4><h4 id="32-Go中对nil的Slice和空Slice的处理是一致的吗"><a href="#32-Go中对nil的Slice和空Slice的处理是一致的吗" class="headerlink" title="32. Go中对nil的Slice和空Slice的处理是一致的吗"></a>32. Go中对nil的Slice和空Slice的处理是一致的吗</h4><p>首先Go的JSON 标准库对 <code>nil slice</code> 和 空 <code>slice</code> 的处理是不一致</p><p>通常错误的用法，会报数组越界的错误，因为只是声明了slice，却没有给实例化的对象。nil的slice定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="type">int</span></span><br></pre></td></tr></table></figure><p>此时slice的值是nil，这种情况可以用于需要返回slice的函数，当函数出现异常的时候，保证函数依然会有nil的返回值</p><hr><p>空的slice是指slice不为nil，但是slice没有值，slice的底层的空间是空的，空的slice定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>）</span><br><span class="line">slice := []<span class="type">int</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>当我们查询或者处理一个空的列表的时候，这非常有用，它会告诉我们返回的是一个列表，但是列表内没有任何值</p><p><strong>总结：</strong> nil的slice和空的slice是不同的东西，需要我们加以区分</p><h4 id="33-Go的Slice如何扩容"><a href="#33-Go的Slice如何扩容" class="headerlink" title="33. Go的Slice如何扩容"></a>33. Go的Slice如何扩容</h4><ul><li>slice是Go中的一种基本的数据结构，使用这种结构可以用来管理数据集合。但是slice本身并不是动态数据或者数组指针。slice常见的操作有 reslice、append、copy</li><li>slice自身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。slice本身是一个只读对象，其工作机制类似数组指针的一种封装</li><li>slice是对数组一个连续片段的引用，所以切片是一个引用类型。这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集</li><li>slice的结构体由3部分构成，Pointer 是指向一个数组的指针，len 代表当前切片的长度，cap 是当前切片的容量。cap 总是大于等于 len 的</li></ul><p>通常我们在对slice进行append等操作时，可能会造成slice的自动扩容</p><ul><li><strong>1.18版本之前：</strong> 当原slice容量小于1024的时候，新slice容量变成原来的2倍；原slice容量超过1024，新slice容量变成原来的1.25倍</li><li><strong>1.18版本之后：</strong> 当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的2倍；原slice容量超过256，新slice容量newcap &#x3D; oldcap+(oldcap+3*256)&#x2F;4</li><li><strong>最后：</strong> 扩容后的容量并不一定就是按照以上公式计算的结果，容量可能会存在小的差异，主要原因是扩容后会有内存对齐，导致容量不是百分百按照公式计算的结果。如果扩容之后，还没有触及原数组的容量，那么，切片中的指针指向的位置，就还是原数组，如果扩容之后，超过了原数组的容量，那么，Go就会开辟一块新的内存，把原来的值拷贝过来，这种情况丝毫不会影响到原数组</li></ul><h4 id="34-Go的Struct能不能比较"><a href="#34-Go的Struct能不能比较" class="headerlink" title="34. Go的Struct能不能比较"></a>34. Go的Struct能不能比较</h4><ul><li>相同struct类型的可以比较</li><li>不同struct类型的不可以比较，编译都不过，类型不匹配</li></ul><h4 id="35-Go中的map的实现"><a href="#35-Go中的map的实现" class="headerlink" title="35. Go中的map的实现"></a>35. Go中的map的实现</h4><h4 id="36-Go中的map如何实现顺序读取"><a href="#36-Go中的map如何实现顺序读取" class="headerlink" title="36. Go中的map如何实现顺序读取"></a>36. Go中的map如何实现顺序读取</h4><p>Go中map如果要实现顺序读取的话，先把map中的key添加到数组（array）或切片（slice）中，然后通过sort包对数组或切片进行排序，最后在遍历数组或切片的时候将map中key所对应的value取出来</p><h4 id="37-Go中new和make的区别"><a href="#37-Go中new和make的区别" class="headerlink" title="37. Go中new和make的区别"></a>37. Go中new和make的区别</h4><ul><li>值类型：int，float，bool，string，struct和array。变量直接存储值，分配栈区的内存空间，这些变量所占据的空间在函数被调用完后会自动释放</li><li>引用类型：slice，map，chan和值类型对应的指针。变量存储的是一个地址（或者理解为指针），指针指向内存中真正存储数据的首地址。内存通常在堆上分配，通过GC回收</li><li><strong>注意：</strong> 对于引用类型的变量，我们不仅要声明变量，更重要的是，我们得手动为它分配空间</li></ul><ol><li>new该方法的参数要求传入一个类型，而不是一个值，它会申请一个该类型大小的内存空间，并会初始化为对应的零值，返回指向该内存空间的一个指针</li><li>make也是用于内存分配，但是和new不同，只用来引用对象slice、map和channel的内存创建，它返回的类型就是类型本身，而不是它们的指针类型</li></ol><h4 id="38-Go的defer原理是什么"><a href="#38-Go的defer原理是什么" class="headerlink" title="38. Go的defer原理是什么"></a>38. Go的defer原理是什么</h4><h4 id="39-Go的select可以用于什么"><a href="#39-Go的select可以用于什么" class="headerlink" title="39. Go的select可以用于什么"></a>39. Go的select可以用于什么</h4><h4 id="40-Go值接收者和指针接收者的区别"><a href="#40-Go值接收者和指针接收者的区别" class="headerlink" title="40. Go值接收者和指针接收者的区别"></a>40. Go值接收者和指针接收者的区别</h4><h4 id="41-Go中两个Nil可能不相等吗"><a href="#41-Go中两个Nil可能不相等吗" class="headerlink" title="41. Go中两个Nil可能不相等吗"></a>41. Go中两个Nil可能不相等吗</h4><h4 id="42-Golang垃圾回收算法"><a href="#42-Golang垃圾回收算法" class="headerlink" title="42. Golang垃圾回收算法"></a>42. Golang垃圾回收算法</h4><p>Golang1.5版本后，采取的是“非分代的、非移动的、并发的、三色的”标记清除垃圾回收算法</p><p>垃圾回收算法分类：</p><ul><li>引用计数</li><li>标记-清除</li><li>分代回收</li></ul><p>golang的垃圾回收是基于标记清扫算法，这种算法需要进行 STW（stop the world)，这个过程就会导致程序是卡顿的，频繁的 GC 会严重影响程序性能，golang在此基础上进行了改进，通过三色标记清扫法与写屏障来减少STW的时间</p><p>gc的过程一共分为四个阶段：</p><ol><li>栈扫描（开始时STW） 所有对象最开始都是白色</li><li>从 root 开始找到所有可达对象，标记为灰色，放入待处理队列</li><li>遍历灰色对象队列，将其引用对象标记为灰色放入待处理队列，自身标记为黑色</li><li>清除（并发） 循环步骤3直到灰色队列为空为止，此时所有引用对象都被标记为黑色，所有不可达的对象依然为白色，白色的就是需要进行回收的对象</li></ol><p>三色标记法相对于普通标记清扫，减少了STW时间. 这主要得益于标记过程是 “on-the-fly” 的，在标记过程中是不需要STW的，它与程序是并发执行的，这就大大缩短了STW的时间</p><p>写屏障：</p><ul><li>当标记和程序是并发执行的，这就会造成一个问题. 在标记过程中，有新的引用产生，可能会导致误清扫</li><li>清扫开始前，标记为黑色的对象引用了一个新申请的对象，它肯定是白色的，而黑色对象不会被再次扫描，那么这个白色对象无法被扫描变成灰色、黑色，它就会最终被清扫，而实际它不应该被清扫</li><li>golang采用了写屏障，其作用就是为了避免这类误清扫问题. 写屏障即在内存写操作前，维护一个约束，从而确保清扫开始前，黑色的对象不能引用白色对象</li></ul><h4 id="43-GC的触发条件"><a href="#43-GC的触发条件" class="headerlink" title="43. GC的触发条件"></a>43. GC的触发条件</h4><ul><li>主动触发(手动触发)，通过调用<code>runtime.GC</code> 来触发<code>GC</code>，此调用阻塞式地等待当前<code>GC</code>运行完毕.</li><li>被动触发，分为两种方式：<ul><li>使用系统监控，当超过两分钟没有产生任何<code>GC</code>时，强制触发 <code>GC</code></li><li>使用步调（Pacing）算法，其核心思想是控制内存增长的比例,当前内存分配达到一定比例则触发</li></ul></li></ul><h4 id="44-Go中的http包的实现原理"><a href="#44-Go中的http包的实现原理" class="headerlink" title="44. Go中的http包的实现原理"></a>44. Go中的http包的实现原理</h4><h4 id="45-Go中的defer函数使用下面的两种情况下结果是什么"><a href="#45-Go中的defer函数使用下面的两种情况下结果是什么" class="headerlink" title="45. Go中的defer函数使用下面的两种情况下结果是什么"></a>45. Go中的defer函数使用下面的两种情况下结果是什么</h4><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Golang常见面试题分享，涵盖了常见的Golang面试八股文&lt;/p&gt;
&lt;h4 id=&quot;1-无缓冲Chan的发送和接收是否同步&quot;&gt;&lt;a href=&quot;#1-无缓冲Chan的发送和接收是否同步&quot; class=&quot;headerlink&quot; title=&quot;1. 无缓冲Chan的发送和接</summary>
      
    
    
    
    <category term="面试" scheme="https://huajun-chen.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="Golang" scheme="https://huajun-chen.github.io/tags/Golang/"/>
    
    <category term="八股文" scheme="https://huajun-chen.github.io/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>关于博客</title>
    <link href="https://huajun-chen.github.io/2022/10/27/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/"/>
    <id>https://huajun-chen.github.io/2022/10/27/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/</id>
    <published>2022-10-27T10:34:00.000Z</published>
    <updated>2022-10-28T13:27:55.635Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容">  <script id="hbeData" type="hbeData" data-hmacdigest="eb58b17fbd8bd4587408abcb6d1633c2cec529c7e637ac9635e6cabf3104fdd2">a17b4de793b95f7877066d2186f5861555e2d6b9cb5641947e36c8450a9062244141303af7f6ac122ca280e580e95da40c8ee95d99d2439c2f200eaab162cbb1875108085071c26de1a7a2252b96fcbe0f08370a21f14470abd2a2d2b018211a390d4a79c82cf2a64ae884fb7caded6082fa0005ef84e7ea431151015e2060bda837f3b622c77b40ee17a251d882f100278d00b9963489c074d217f528b9e8e054d830314c2ebd97fa3c76a53976dbdc3aa54c7b15ce70a5882de8489603f7173418c015d0ef7e8aa5ae4a33046644b0e563b4499cb8d0d6173282b0a21575c27f9144f5086203cb49e7bd9f84fa510fa7ca67502f97fdebb306ef8a69773c81e40bf148ee8b9d8ad2d1bdf194c6075caa40305d045fbb2a1c2119103f08f156ceaebc719357118924dd869dcd27372f3549487bee4f166e5c77adcb1ac7794dbe0a673ebfa66aa2595818250b9851cbcad400d4687e30b48667a8013245d51dce6aae77d5905b91f53b574fc443b1684c92af0bac92b0aacfa2311b89865521de7bc0054eeb9670d5568a2e98652854cf0ed9fc027967d196f3a30f8b2b14066b2b52b741727573fadde89b47e0d9fa69fed76a226477fc8a2f55fb32f9e4a53348a2747f494b15c8d7565c27afbb068f7ce813b4e1ddedada52692a9c6d917f278d17b970668263eeaaefcc44df89bcde5edc1ad4988985ab067b75e6cd1d6f6083dd6b1ce8e775db02a7d9533537b178a63ec573a5043bc15bbd2fc963c4f3aa122ec4f0b3fc30cca5257817db4bd4ffccc7a43fd006bc392e64e161e7b59542881b1b7db7805b0003d89224d2ef64a29bbcbd982ea90041c78c6f87bee6da444542e072c9c6786ea8101f8bf295aee03c0d6033a3e19116bae338e4be2520f564c69e09cabcbd5249b3c4c50d66ab39b30dd90f909ea126d2b48f8245d175a365531c939ef6e9a42c17a33a69c8b52de48e4757f5f25a4fef9493350305d558c5c0c806c0698893aaa568476e50e6079fe997df4194d8fb35a21ea8958bff697c158b049a30bd3bcd0e162772f352d83b202daafb229c098c33cda25c04e715a81f80f6673a1a70c6f17a033b3ddcd772068cce43302f1602f71d2b7a5e121056818a837126e27c0990955f13ad5ed1fe26d0e0aee808c0717a47a38999c20411f7ce53f8b1bc86018e5b9287eeaa3caf58b4244ae291f351667c000a7830273ef3d8a17f8c1254d819d16bcb2a2d9683972c91763ebbda2a379442d0b07437cfe123ac3be67f7318fb7803470146435bd3d593263e5e37c32705f6ad8b8d0decb68839c28c9a838f97b8613f4c483eee116afbea3097e72e0077f5a4ed396ad4c4be49ee36f3726809e0efa9aa8a9e0e3181b1126675c191b7b9a7fcf1ff115b2e87efd6ec64274d47cbdbd09c899a776819132d9566fea583fa1897209395d8dfb78cf6cdc2819d6c0e75da888e88ad236667388f965855fd7fc36d1249a1a1d24eab917be709ea423f9491f59038c726eac3ffed3707f0d3bdb8c90e1951f96ef89d1abfd2d4679259ea0d69c9a1f152594c71981fcc4dece41fa6dbc07cd2a1a3a0949396cebc5a8a3f13d0033e3ed78f7473fa5c9d6d5802e15232fa8b6bdd1feee2a12f22c2449c68bb1e7d8052c8ae42bfcc1f65444565986cbc63a4381f9bb0b27d0f5387f2f04a80432645dcd2a57c171892bdd3ffce03a5852a2768dfd5d53ac1fa5e321da9dba979819096a00897281370689f9e75e450560f86f506e598fff748d42ec26aab61b453561f9facad5af053d0c77652e200b75d59620b32899f0977b4d7f947cf1fd9beb68e8280f53cbfcdf2ef9ab67cdbb3bba405d77af100b02287ea616c931799fd7eb8c65b4843c926b2651e5d68b33e0e8cde998c763b06347c459de9fc8b6d5b10460a3388c750b194669523e2e6628d25d736b401ce307f71cc25241f4c82561bc6fa56eb3924f23148fbf518a80344233e7f71a3fe7150d9566a5b2d78802878628dcbe3aae5d400d10be685cf3015c07fa9981fe3645873b7089878cf1743cb0f6eb1796b83b00fe30bb78a6d55e94b4d4f0a2ededbfc36e8de15a8c68506befc43dc69e9abaaa7cd55a6b0f6e6792c45997a7acc30f602b783f1c2d9e0a430ab0a3fe4708ccebd7296c44cfbbed6e7cdf13078753bfd0f6d1866bcb3909c3a07cbdb5faa777ce9e8229c9f734f9bd4b8345ac641766ecb4180dff676c9eb4ac91e0330e530705671b54027ce8d3d33fc6fc9a01753866b28e5bcb8d028adb423edbaf834b45079379af6dbf75c379ec6cbe97f5acab496506713300ee2fa1d677ec006f8460d04a3a797a316a88ba832955f99e291cda035b1663c676618e95cc59dcd3414befa5426a4c35a12f9f95d1bf2fb1b12fe350b0b1b3bc504578eb3ab16aaff15505b218ec2b0fbc933d9034bea8be11ca2ace22f04b861883fd863a5ec6c16ab8ff90a72fbc89fe91f9c2b84601a8dd28de98bfe0d12ebbfbb14b201090325fbfdd352e276c6fbbdc989d94ee96b47b57a5aeff3af3e8bf9f7a0cafd74b8a28cf11b86ae485563e16bc071035388116b04012ae9d36e259252145eaf552be23a474c5c6069c29b15df7194f40734f61e4f0f9e7da86c08944a68a2b6e7768e608d01145a35e4973f948119045948996df2410aa5c019c24fbb7c8615d0409ea313ebeb78d6ee8c9ea6fabd9c504713c21c54b21e773fee2c29468af30e00839978e769b07780286f5ba0b35971772053de944880873743e8073f3ca90778c45d558733835666daba6285c05162bbf1873a03e9a29994cc53678aca15cddcc1d2d8ca360828c2dc48f9a536ab4d309b01814f0a7627862f3b718b4b95fad03b8299e80e08b96e73105d9198cefc55bf0a26c8e13906b900bebc96b87960b5763d31f03f411ef027006cdae44aef11472578447a913034088d6d861c71de18fb99a9ce6932e0072cfd030bb49c34cb8286c90aed1408f146dbc39e78b0ffe602096c078d6c92ca59e264608df236ad9ee41f99c24f97b379a8d06636842e2d54008152997c8beb6cb86971dbd8b476596e0fec9229e959c1ad4a20259b1d1580e789a16c5b860e447a97f6c6daa850e83715e9236f6fa882a6adf7daee4e66d54b0ddf0966b181098e9998014905ba6b79e76f0c7cb3a6ffc3bf6640b20551704fe94216a732df2642e8d1fa25aebe51b04b3eb634a9e00f307e266f3cf9271e3faab8a828182a0e514f37888a805a4d3cc60c3ce428e9db37be132155b55740d4f93b7addd70d38ba8ac286921ab9ca32690350d35098782c618a7a6aef460e67652366c7b919d0a0aac2646daf741e55bfc9c650539dd6d755574cad07af9359895132f201d2eda1229b7540487750ba60e705158636e473b1a7ecb944b98587de86c6eebfc6a7e64291374129bcd142da570765bdb65cbc046c0a07cee6a59d7153a389ff2c27e0ce590808f50429d5877bcf24e2f1e2a72d63b464ad6bb91eac128ee19d1ed8bd6143604eae097c485dbeb04c56de34f94d28846fd5621c08a6609e7d408b1fd03e36defa8d59dc0cb9400a4a7e614d4aace51ebd7252c40a67ce237573a934fdeb1b9e0e127f5718fe4315a5026a455e2dacd45ae5e352aac9a03e56e8aba77b182194d330a5e68dda7b4202a9ccaf2864a34814a2cb060cfec55b655b899e7f66f11348acf51964d5603025054b1be35317c7de9a4941b5ed3fc3c3038be497bd3762134b9e892b01fe7791b0037cd8a6d15476c3b22aed3e7276c5ff1f8fdb1a7ae77715a81f0dd955e18fc54c6d1d28e4a6779546eb93449b288da309947a747dfed8c497520513b1bc7d271cbae4bf199355f37b5964535f0be92998aea448384e17cf990b8b339c8301edf9ac37219ebf580e1c60a7d2b7719d0856e8dc8c1e56141c0abd47916b1cf6a9f735b60278b3bd02567a54d01ccc1926134111fe7184a54d872ce230aca60f6625700d5bfc925d2d178b3251a1a5dfa97d824b585dbdfdd24303f1af300c79882c82ac677764761dbf2497fc2692ef13eabf8f75914376ae2d870c272f8d50828f1ad29d5f39d2d17a5f40b62d01cc10f9067e72fbf8a64abf11db7a154fcfdc2a246a074cf4fad6058df30d63893581dd4e643a4067a26cf9ad99dc00a2428d4fc1ea6269371358a98ac96075883b5afb47da32a16d1e710ca17171b9d9a672106c8ffd65a3d736314ef7f7565d9b5a5167b09b964647bb16d64acca1f5fb4e4d7c77d7231b2ffd44f49b26114450ff399482595e7e4944fcd2aa8b51db1817d1c85672ffdd06128a6cea9979d6f5d21e0c776773bf98664fe200a1385f15fc747a5109614c79d8e5ddaea38beeae3df3dc66a9609ca51b4b77421c29e270f13b470fb9064eb2c7337f8b8cadd7f8f46db0e885d8a6c2fdadb226ccbcc963d128198eea37b72c738b0617ec7b706bf2e1319ced1c4bed6b9f89d4f9f8fce6253b8c0718eefa341caf689c11a3b7e9e2468c390141a75123a22a9778686b5fb9153a16ae9aaebcf1efe2e65097a27e392be7c40eef4f89a21ef027a2b02848cceabd148899cc00feef565c7ca4763ccf8df0cc725e504442b7762b816a28abf87cc691b04aff02609c24a3096f6cda6f10934092d210c80253b7ab0aa094f07b2bde74027c08628d4be8c0d1d694f4281a80942a0513c4bf7d69a5710da1bff7162f55481ebc01412afb661d4f15e9b852485209297a86917ae77f93da5dfb61f3c28caf621d2bb6b774e504b25e1cca8bc4fba4779b37fd53beb9e32702f607a3da09ff0e6a7087ec634cdd032caae734e7716dd649a1357c881fe4201be2e571f0c58f438a5010a9b589af169b6fe742c62571010fd5e52410060c9df1b96e48c549de6ef71208dade0fcab28a5f361b7fce007f3c8582b6b0762b86bb4f2ce6534d243e1b74d9bbe1db822cc65e89c3413499aeffcb41daa11ec6cf7f6c629161b4a2f5b220728f2ef926958a12ae7c5afe783debf02b87a131f84bb9c9f1e8ca4be885197f8553c0161dc78614dcf0d59f9c508e1c29fc544879c298a40357211cf3fb939ce2209f2530ac9b6dd2c9ffe993bcaff95166587c97fca773327cd34b6ae1f9295f6d46802ff7abe5564433c5d79ecdb1b901c61ef66e7e3b9c112e8ababce533980de9b4fb0d89c70f37c591b4a333456f3539315b6e0dd0d88a3b1cf30654a245d45402bf6cc0b31c6e59468a9138d92cdd497aaf79fe5cbdeb5a212cdee179e733efc0f73d6c53d864f4a4e06eb99679993933457dafcadcf28b4560f2219058dcc787bf8f7c1e81722eeb06c6dc1531c89cc1d4b061682a2b7e83d8e5dade8fd22f5e8a69756d248cff100051202d4c8a42166a7160e7d4cafe9ab436a6249b79526789c5e668106d77ea10775293e31f1d069ac547f070b374d1499d19f4737b098dd286d7a4d1701a310a0075b2f738489e4fe8cf6e316e2f0d4560fce3b91998c2435e4e0bb3a29188d555bed21fc9c283fcfc1cc711ac1d470a9f123ce065c9a03b58f8ffc1faa2d30635d4386ba259e10c8e9a2aa00684c459669c6fe126f7a1ed046e731d233d24a6b2398cedc65021d96a79100826e08ff4a0e0e0f3844bdffadee28b67f75fb7ddbd1e9b6cc11c673e030381a3071315c030f576e6b857bfd346b8ccee3d1b124ff7d3f945b8a70b75279f3ded3d41299972fa894a513fbe068fd15357ca5b388897f3c95198d8566f478dc4ae0c9ed47dd4d6fb25a76dbfb3d0426bede7b8e43f509197652b52cdb094ea3c497e2fe87b8663b7cef4346243a22dd50e0d8d11cd4d7ce5af60a5d4e0355f29f0c9f527dc97f5c5021d6594f58089d9f9ae09bc0f9dede35395c26c1863950066c7007dd605ee69cb05b8795872447630fde8b49f8d34223a27bd7525461bc6642f672e80f929624419b18a70346553b026955ae72a9fc2aa39df88a2cf39ac6880f16b67d6f2dbd9a37e3f42894062ff465fc76b266048835eaeb3429a983411f623d0e5192480467fe4c1e80855297189a16a88dc565e0b1331e3135ef6741bb979ab30582a53d2c8ecda49eb3dc373f92ced74ce77304adecbf90dd86e4a8e85580c7ecb1236cfabd31f5967f7ea744d9a3cdea9687fbb6d2a3fac1c62f5c78538f475d7dcee528fe1605ab146ad88a72d7b731472da6f7f5404504f2db6478fa39bcbf96d66558147142f367da08212832de3b4cf517c67bbddb56d903bc18c005c7c42243e93ce478f0ce3408f4bd8b1ed5233e0a793612780432992f7dc89ffdae984d8f83400d4bdcdb2fcd33619491f6224365a0ce4971f140510f81848091874e342c5adc68587a7c3146cda2c02d42af80a96392eef81684e04cfb2105e34fcf1b4701a9354dd602eee04a89e76afe332c2e027b115503be350b22ce4049f44a6d35ed9c8e46cc423e6edddfa46a04667c50d8abac59984f120636823000f5a9ec3c27f597f4ec2fb4a3f8f4c56e42e0a394de309ab173e546638e3eb7527d7a8c42207b20e5ac7b1dd5d87b27b368390582ac1ebc1ac74e44291c8ca0860521437c81500f32528e53443104c0c0a9d9c10ee482b249d95570dceab9d62c08ea1d8bfedadc8411214a22618ea409d5c1c4314c9441226584a6945afe05610ce54379461cc57b70229cb0eaf7bc3a99739c1a682b34ab09c7c51fef9970a8b7c884cc267b2b917d185cac81b6077b66b379ad9ee32cebd0d71fa5ce457981861d64d2bbfc0c5b44b4cda0c63c4479f104299d552ba6c1047adcfe9f405d5518978d1123fb952cbd3d0c9fc061618fe8e39c1ede4ade5915fea228b494d6538a95b2e57a529bbdea39cbf060b1f782bf52a0c651ffdda5dbd166c83dff43bdc96efbbeb87fc861fcc58cc16953ccceb0b05cb9f8505499551a6a8f52b6af7c9b1086b6a22ddc3f1b6aa5ce0572a0c88c675491e4e2e39ebec54308d70d49915fe2e01c14766fbc6e0e2d24fb34a4b8f72a27daf3b95f2056cbf2ba2ef6c3e742099bb663bfa0f33b5de4cb57c6a10563dd4e08263c571354b0c4b596b0bad09ae1708c00fdd6f2232a60905c9a6d9d0e89e1b2cfe8d3ced85d14ca3a2cd55baa9dfc43f0c3f15ad137689b017d80fa5641f1b9a81b3cc824b65accc1c4b4ada2117e18d493d24781d026ff33fd8a3bbe318dc026cdce4b0b06b9153210d1e56ed21d1776d21b873083fa86c5331f17f2a10c388a1a76aa08fd830906a927d1ee9ff818f6e9622742e2168006449021f9e6bc1fdd48c5afe28cf580e4c395b97ecde098746d56eac9d2c5cc3a931c11b4af5da4c94f6f0965923bf405b0f9af134ac2b333009a347c81adb028c419baf3dc41fcf4c813c2775f465f23ea799dc25f79769aa70aafffa06a53000e4560b98f60f272128bcec75cc7d6aab15c65f9ab6f57c86c1168c5610aca352c0a39ab915eea4e0cf45e4088a7fce3b3564a6d01d5eb7db83a54a0571a3542bb2f0edfc5116fd62e3114958c861f3ac0e598bf8125a4ddc4b20ab9c389491026ae18c54a800749fdf99f8d1d98ad3ab875bd0a2c526bcb946ec61cd6dde542f9eaf3087091c0e9fc9dd36a0272b0854fe19d0dbf4c1b48409a65fc44eb2d36cad999cd463969706a8cd0ff3e192d4d2467569894194ea3f6824e3023839036bd11e74a513f5f34cb4d731bd8061f50b43353950debb696f4b379f527c291df3bcfe1b310318e52b1d6756bd830d0120088d95ef536c19b0b66b9154ce4b629a68f8790b1e3d673bc09cdeca52382fe2d737b119b8114f79cbf92bdc8be40d6bcaa9ac02e942d348d25ff5b1a8364fbc580fba583158b7847ad3dcddbddc9ff78e36cdd0051f48baa33a0b6cf338cf68bc2682274b000a7e23e155bb1492975f6b7a32d136d32050b84ba9b36ec5c44073bd24a092db38ae45b2a227782086f1dcfcf1b6dbd3eadb3b27829e366a716e60ad354f1979a3c41503a0beb2fd18527bb793160bb0020c9705aedfb9d661dd29fe045f5f081c8c394484596ad8ff6e6302c81b01cc89c4d79ff7086964a22ed0b7de5f2bdc56154fcdeed41671fbfe5378cbe7d51d7062a7631c5139389c5a0bba2daedf8886aa2773eeaa388d92f7a233e87058f25f68297146675b41276f12ebe2a91093e7f217bdf833d27fbe05121590790f437b63ee290c46933ba2dc898759a26308f65252fba5ad1f6246e862fe0f297d1ab39cf848687cb95d7fcae1770f9bdb04ea96efa41b15192dc164c2d0318828751479492307cf3e3ad1609e258b722a240c54ef9e388cc11fcc6fc107e5063e32006fff902274cc2189cce462257e99c487e31ab5f5437de9d80ac01aad8ae8adc68d8c0dd66bcfd4a9b287455f39cbf1aa024924d20f0c800e0b6d8dc3ac7b4d6ec9dc9fb9e7512def8b9516441b5edd2df7918bb5913a24980a2d094d90bed2c6235ea76f1f1f8acf6d32adffb814f8580c3456bbe6e77fa7d24d1af0ee5ab5a57315f0c51282ada588c44ba9f57715e1527d636d0edc5be17b47e2bd93fee89a3af61c5a6a1a7a012e070d90d7987f729beb54367e87231830b202e845e8d4e9576aa5245f0771f4e0e2dc26780f3d7747fbf412de0744094de0d2bafb810f6869e39084b76975cf1382204b051b621bc9fb579bd11fbffff09366d9dcf79c010784cc092ee28d7552b4abe0c66a446d9e6eb9f8ba071489a8d0d2697f1bd6f796c307c09c97346633424698dc2d0b37b97caa92633aaa930a447122c5990855a3cba87b4bcdca8475a0f53912f436a9445583ea2bb176cc6c65d499358d3a7fbb7c7d53033998b583cbc74d70cec475eaad0b6246e40e3a4ba81aa668a88117a718ee4d9ae3b69efe4a2b27781d367d900196dc575175611abb84f518d607354e4d4da7fea1db1429b85a613eee2c51407e5cc2be509902cd8ce984e3c442b6ec62db1a8cfea68471e20434e2896c1a8ac399cd2809653c3dbd0f43bab61dd1a997d8de21e05c3c90e96b4c37e2227ec0583ebf4e94349b163ef21ea9b830b42aa27e3ea3c1e1ffa7362368b3a2afd772263487dbccb7bbce315cbc5c9650a5fc38fad4c0f754221d55a8d1279fc09c057371b1dc283cb4a2e9db83ce8731c6e35d780e718a4bf5c9f857744f3442b75e1dc27de3d2eb572f77be7fce3c94ebe838cd4711550bb3543a6cf13137eb368a7074ddf570bf72b7104b94e445e7b3046b43a72469bce912250f190e20e8107582c73c0c2a10507cf8398ca2492f16c1cae451b20e356f60a3f2e270887a149475442e0b6a89e13cbc71044178448cde0a4586f66d6b6181de6ee4a265ebbfb8bfc70add3a4f0a1003448edeb5c7723c013272c0461205c1de1f68177ef0dd9e9d04c942c7228e35e4fb4be5488ffaf7241bfdc0d85ee282bef73cf</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 请输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">此文章已被加密, 查看文章正文前需要先输入密码</summary>
    
    
    
    
    <category term="关于博客" scheme="https://huajun-chen.github.io/tags/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://huajun-chen.github.io/2022/10/27/hello-world/"/>
    <id>https://huajun-chen.github.io/2022/10/27/hello-world/</id>
    <published>2022-10-27T08:34:59.095Z</published>
    <updated>2022-10-28T13:10:33.978Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
