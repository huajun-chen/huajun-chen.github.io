<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux操作系统面试题</title>
    <url>/2022/10/28/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>MySQL面试题</title>
    <url>/2022/10/28/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>MySQL常见面试题、八股文</p>
<h4 id="1-Mysql索引用的是什么算法"><a href="#1-Mysql索引用的是什么算法" class="headerlink" title="1. Mysql索引用的是什么算法"></a>1. Mysql索引用的是什么算法</h4><ul>
<li>Mysql索引选用的是B+树，平衡二叉树的高度太高，查找可能需要较多的磁盘IO。B树索引占用内存较高(非叶子节点存储数据)</li>
<li>B+树，主要是查询效率高，O(logN)，可以充分利用磁盘预读的特性，多叉树，深度小，叶子结点有序且存储数据</li>
</ul>
<h4 id="2-Mysql事务的基本要素"><a href="#2-Mysql事务的基本要素" class="headerlink" title="2. Mysql事务的基本要素"></a>2. Mysql事务的基本要素</h4><ul>
<li>原子性：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行</li>
<li>一致性：事务开始前和结束后，数据库的完整性约束没有被破坏</li>
<li>隔离性：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰</li>
<li>持久性：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚</li>
</ul>
<h4 id="3-Mysql的存储引擎"><a href="#3-Mysql的存储引擎" class="headerlink" title="3. Mysql的存储引擎"></a>3. Mysql的存储引擎</h4><ul>
<li>InnoDB存储引擎<ul>
<li>InnoDB存储引擎支持事务，其设计目标主要面向在线事务处理（OLTP）的应用</li>
<li>其特点是行锁设计，支持外键，并支持非锁定锁，即默认读取操作不会产生锁。从Mysql5.5.8版本开始，InnoDB存储引擎是默认的存储引擎</li>
</ul>
</li>
<li>MyISAM存储引擎<ul>
<li>MyISAM存储引擎不支持事务、表锁设计，支持全文索引，主要面向一些OLAP数据库应用</li>
<li>InnoDB的数据文件本身就是主索引文件，而MyISAM的主索引和数据是分开的</li>
</ul>
</li>
<li>NDB存储引擎<ul>
<li>NDB存储引擎是一个集群存储引擎，其结构是share nothing的集群架构，能提供更高的可用性</li>
<li>NDB的特点是数据全部放在内存中（从MySQL 5.1版本开始，可以将非索引数据放在磁盘上），因此主键查找的速度极快，并且通过添加NDB数据存储节点可以线性地提高数据库性能，是高可用、高性能的集群系统</li>
<li>NDB存储引擎的连接操作是在MySQL数据库层完成的，而不是在存储引擎层完成的。这意味着，复杂的连接操作需要巨大的网络开销，因此查询速度很慢。如果解决了这个问题，NDB存储引擎的市场应该是非常巨大的</li>
</ul>
</li>
<li>Memory存储引擎<ul>
<li>Memory存储引擎（之前称HEAP存储引擎）将表中的数据存放在内存中，如果数据库重启或发生崩溃，表中的数据都将消失</li>
<li>它非常适合用于存储临时数据的临时表，以及数据仓库中的纬度表。Memory存储引擎默认使用哈希索引，而不是我们熟悉的B+树索引</li>
<li>虽然Memory存储引擎速度非常快，但在使用上还是有一定的限制。比如，只支持表锁，并发性能较差，并且不支持TEXT和BLOB列类型。最重要的是，存储变长字段时是按照定常字段的方式进行的，因此会浪费内存</li>
</ul>
</li>
<li>Archive存储引擎<ul>
<li>Archive存储引擎只支持INSERT和SELECT操作，从MySQL 5.1开始支持索引</li>
<li>Archive存储引擎使用zlib算法将数据行（row）进行压缩后存储，压缩比一般可达1∶10。正如其名字所示，Archive存储引擎非常适合存储归档数据，如日志信息</li>
<li>Archive存储引擎使用行锁来实现高并发的插入操作，但是其本身并不是事务安全的存储引擎，其设计目标主要是提供高速的插入和压缩功能</li>
</ul>
</li>
<li>Maria存储引擎<ul>
<li>Maria存储引擎是新开发的引擎，设计目标主要是用来取代原有的MyISAM存储引擎，从而成为MySQL的默认存储引擎。它可以看做是MyISAM的后续版本</li>
<li>Maria存储引擎的特点是：支持缓存数据和索引文件，应用了行锁设计，提供了MVCC功能，支持事务和非事务安全的选项，以及更好的BLOB字符类型的处理性能</li>
</ul>
</li>
</ul>
<h4 id="4-Mysql事务隔离级别"><a href="#4-Mysql事务隔离级别" class="headerlink" title="4. Mysql事务隔离级别"></a>4. Mysql事务隔离级别</h4><p>Mysql有四种事务隔离级别，默认的是可重复读</p>
<table>
<thead>
<tr>
<th align="left">事务隔离级别</th>
<th align="left">脏读</th>
<th align="left">不可重复读</th>
<th align="left">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="left">读未提交</td>
<td align="left">是</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">读已提交</td>
<td align="left">否</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">可重复读</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">串行</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">否</td>
</tr>
</tbody></table>
<ul>
<li><p>读未提交(Read uncommitted)</p>
<p>一个事务可以读取另一个未提交事务的数据，最低级别，任何情况都无法保证</p>
<ul>
<li>所有事务都可以看到其他未提交事务的执行结果</li>
<li>本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少</li>
<li>该级别引发的问题是——脏读(Dirty Read)：读取到了未提交的数据</li>
</ul>
</li>
<li><p>读已提交(Read committed)</p>
<p>一个事务要等另一个事务提交后才能读取数据，可避免脏读的发生</p>
<ul>
<li>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）</li>
<li>它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变</li>
<li>这种隔离级别出现的问题是——不可重复读(Nonrepeatable Read)，不可重复读意味着我们在同一个事务中执行完全相同的select语句时可能看到不一样的结果</li>
</ul>
<p>导致这种情况的原因可能有：</p>
<ul>
<li>有一个交叉的事务有新的commit，导致了数据的改变</li>
<li>一个数据库被多个实例操作时，同一事务的其他实例在该实例处理其间可能会有新的commit</li>
</ul>
</li>
<li><p>可重复读(Repeatable read)</p>
<p>就是在开始读取数据（事务开启）时，不再允许修改操作，可避免脏读、不可重复读的发生</p>
<ul>
<li>这是MySQL的默认事务隔离级别</li>
<li>它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行</li>
<li>此级别可能出现的问题——幻读(Phantom Read)：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行</li>
<li>InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了该问题.InnoDB采用MVCC来支持高并发，实现了四个标准隔离级别。默认基本是可重复读，并且提供间隙锁（next-key locks）策略防止幻读出现</li>
</ul>
</li>
<li><p>串行(Serializable)</p>
<p>串行(Serializable)，是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。Mysql的默认隔离级别是Repeatable read</p>
<ul>
<li>这是最高的隔离级别</li>
<li>它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁</li>
<li>在这个级别，可能导致大量的超时现象和锁竞争</li>
</ul>
</li>
</ul>
<h4 id="5-Mysql高可用方案有哪些"><a href="#5-Mysql高可用方案有哪些" class="headerlink" title="5. Mysql高可用方案有哪些"></a>5. Mysql高可用方案有哪些</h4><ul>
<li>主从复制方案<ul>
<li>这是MySQL自身提供的一种高可用解决方案，数据同步方法采用的是<code>MySQL replication</code>技术。<code>MySQL replication</code>就是从服务器到主服务器拉取二进制日志文件，然后再将日志文件解析成相应的SQL在从服务器上重新执行一遍主服务器的操作，通过这种方式保证数据的一致性</li>
<li>为了达到更高的可用性，在实际的应用环境中，一般都是采用<code>MySQL replication</code>技术配合高可用集群软件<code>keepalived</code>来实现自动<code>failover</code>，这种方式可以实现95.000%的SLA</li>
</ul>
</li>
<li>MMM&#x2F;MHA高可用方案<ul>
<li>MMM提供了MySQL主主复制配置的监控、故障转移和管理的一套可伸缩的脚本套件。在MMM高可用方案中，典型的应用是双主多从架构，通过MySQL replication技术可以实现两个服务器互为主从，且在任何时候只有一个节点可以被写入，避免了多点写入的数据冲突</li>
<li>同时，当可写的主节点故障时，MMM套件可以立刻监控到，然后将服务自动切换到另一个主节点，继续提供服务，从而实现MySQL的高可用</li>
</ul>
</li>
<li>Heartbeat&#x2F;SAN高可用方案<ul>
<li>在这个方案中，处理failover的方式是高可用集群软件Heartbeat，它监控和管理各个节点间连接的网络，并监控集群服务，当节点出现故障或者服务不可用时，自动在其他节点启动集群服务</li>
<li>在数据共享方面，通过SAN（Storage Area Network）存储来共享数据，这种方案可以实现99.990%的SLA</li>
</ul>
</li>
<li>Heartbeat&#x2F;DRBD高可用方案<ul>
<li>这个方案处理failover的方式上依旧采用Heartbeat，不同的是，在数据共享方面，采用了基于块级别的数据同步软件DRBD来实现</li>
<li>DRBD是一个用软件实现的、无共享的、服务器之间镜像块设备内容的存储复制解决方案。和SAN网络不同，它并不共享存储，而是通过服务器之间的网络复制数据</li>
</ul>
</li>
<li>NDB CLUSTER高可用方案<ul>
<li>国内用NDB集群的公司非常少，貌似有些银行有用。NDB集群不需要依赖第三方组件，全部都使用官方组件，能保证数据的一致性，某个数据节点挂掉，其他数据节点依然可以提供服务，管理节点需要做冗余以防挂掉</li>
<li>缺点是：管理和配置都很复杂，而且某些SQL语句例如join语句需要避免</li>
</ul>
</li>
</ul>
<h4 id="6-Mysql中utf8和utf8mb4区别"><a href="#6-Mysql中utf8和utf8mb4区别" class="headerlink" title="6. Mysql中utf8和utf8mb4区别"></a>6. Mysql中utf8和utf8mb4区别</h4><ul>
<li>MySQL在5.5.3之后增加了这个utf8mb4的编码，mb4就是most bytes 4的意思，专门用来兼容四字节的unicode。好在utf8mb4是utf8的超集，除了将编码改为utf8mb4外不需要做其他转换。当然，为了节省空间，一般情况下使用utf8也就可以了</li>
<li>Mysql支持的utf8编码最大字符长度为3字节，如果遇到4字节的宽字符就会插入异常了。三个字节的UTF-8最大能编码的Unicode字符是0xffff，也就是Unicode中的基本多文种平面(BMP)。任何不在基本多文本平面的Unicode字符，都无法使用Mysql的utf8字符集存储</li>
<li>包括 Emoji 表情(Emoji是一种特殊的Unicode编码，常见于ios和android手机上)，和很多不常用的汉字，以及任何新增的Unicode字符等等</li>
<li>Mysql中保存4字节长度的UTF-8字符，需要使用utf8mb4字符集，但只有5.5.3版本以后的才支持(查看版本： select version();)。因此呢，为了获取更好的兼容性，应该总是使用utf8mb4而非utf8</li>
<li>对于CHAR类型数据，utf8mb4会多消耗一些空间，根据Mysql官方建议，使用VARCHAR替代CHAR</li>
</ul>
<h4 id="7-Mysql中乐观锁和悲观锁区别"><a href="#7-Mysql中乐观锁和悲观锁区别" class="headerlink" title="7. Mysql中乐观锁和悲观锁区别"></a>7. Mysql中乐观锁和悲观锁区别</h4><ul>
<li><p>悲观锁(Pessimistic Lock)</p>
<ul>
<li>悲观锁顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁</li>
<li>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁</li>
</ul>
</li>
<li><p>乐观锁(Optimistic Lock)</p>
<ul>
<li>乐观锁顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制</li>
<li>乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于<code>write_condition</code>机制的其实都是提供的乐观锁</li>
<li>乐观锁的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好</li>
</ul>
</li>
<li><p>两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适</p>
</li>
</ul>
<h4 id="8-Mysql索引主要是哪些"><a href="#8-Mysql索引主要是哪些" class="headerlink" title="8. Mysql索引主要是哪些"></a>8. Mysql索引主要是哪些</h4><p>索引的目的在于提高查询效率</p>
<ul>
<li>UNIQUE(唯一索引)：不可以出现相同的值，可以有NULL值</li>
<li>INDEX(普通索引)：允许出现相同的索引内容</li>
<li>PROMARY KEY(主键索引)：不允许出现相同的值</li>
<li>fulltext index(全文索引)：可以针对值中的某个单词，但效率确实不敢恭维</li>
<li>组合索引：实质上是将多个字段建到一个索引里，列值的组合必须唯一</li>
</ul>
<hr>
<h5 id="8-1-索引的缺点"><a href="#8-1-索引的缺点" class="headerlink" title="8.1 索引的缺点"></a>8.1 索引的缺点</h5><ul>
<li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT，UPDATE和DELETE。因为更新表时，mysql不仅要保存数据，还要保存一下索引文件</li>
<li>建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在要给大表上建了多种组合索引，索引文件会膨胀很宽， 索引只是提高效率的一个方式，如果mysql有大数据量的表，就要花时间研究建立最优的索引，或优化查询语句</li>
</ul>
<hr>
<h5 id="8-2-索引使用技巧"><a href="#8-2-索引使用技巧" class="headerlink" title="8.2 索引使用技巧"></a>8.2 索引使用技巧</h5><ul>
<li><strong>索引不会包含有NULL的列：</strong> 只要列中包含有NULL值，都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此符合索引就是无效的</li>
<li><strong>使用短索引：</strong> 对串列进行索引，如果可以就应该指定一个前缀长度。例如，如果有一个char（255）的列，如果在前10个或20个字符内，多数值是唯一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I&#x2F;O操作</li>
<li><strong>索引列排序：</strong>mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作，尽量不要包含多个列的排序，如果需要最好给这些列建复合索引</li>
<li><strong>like语句操作：</strong>一般情况下不鼓励使用like操作，如果非使用不可，注意正确的使用方式。<code>like ‘%aaa%’</code>不会使用索引，而<code>like ‘aaa%’</code>可以使用索引</li>
<li>不要在列上进行运算</li>
<li>不使用<code>NOT IN</code> 、<code>&lt;&gt;</code>、<code>！=</code>操作，但<code>&lt;</code>，<code>&lt;=</code>，<code>=</code>，<code>&gt;</code>，<code>&gt;=</code>，BETWEEN，IN是可以用到索引的</li>
<li>索引要建立在经常进行select操作的字段上。这是因为，如果这些列很少用到，那么有无索引并不能明显改变查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求</li>
<li>索引要建立在值比较唯一的字段上。</li>
<li>对于那些定义为text、image和bit数据类型的列不应该增加索引。因为这些列的数据量要么相当大，要么取值很少</li>
<li>在where和join中出现的列需要建立索引。</li>
<li>where的查询条件里有不等号(where column !&#x3D; …)，mysql将无法使用索引。</li>
<li>如果where字句的查询条件里使用了函数(如：where DAY(column)&#x3D;…)，mysql将无法使用索引</li>
<li>在join操作中(需要从多个数据表提取数据时)，mysql只有在主键和外键的数据类型相同时才能使用索引，否则及时建立了索引也不会使用</li>
</ul>
<hr>
<h5 id="8-3-组合索引的作用"><a href="#8-3-组合索引的作用" class="headerlink" title="8.3 组合索引的作用"></a>8.3 组合索引的作用</h5><ul>
<li>减少开销<ul>
<li>建一个组合索引(col1，col2，col3)，实际相当于建了(col1)，(col1，col2)，(col1，col2，col3)三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用组合索引会大大的减少开销</li>
</ul>
</li>
<li>覆盖索引<ul>
<li>通常指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖</li>
<li>对组合索引(col1，col2，col3)，如果有如下的<code>sql: select col1，col2，col3 from test where col1=1 and col2=2</code></li>
<li>那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一</li>
</ul>
</li>
<li>效率高<ul>
<li>索引列越多，通过索引筛选出的数据越快</li>
</ul>
</li>
</ul>
<h4 id="9-Mysql联合索引最左匹配原则"><a href="#9-Mysql联合索引最左匹配原则" class="headerlink" title="9. Mysql联合索引最左匹配原则"></a>9. Mysql联合索引最左匹配原则</h4><ul>
<li>在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先<ul>
<li>在检索数据时从联合索引的最左边开始匹配，Mysql会一直向右匹配直到遇到范围查询（<code>&gt;、&lt;、between、like</code>）就停止匹配了</li>
<li>就比如 <code>a=3 and b=4 and c&gt;5 and d=6</code>如果建立(abcd)顺序的索引，d就用不到索引了，如果建立(abdc)的索引则都可以用到索引，其中abd的顺序可以任意调整，因为查询优化器会重新编排（即使是c&gt;5 and b&#x3D;4 and d&#x3D;6 and a&#x3D;3也会全部用到 abdc索引 ）</li>
</ul>
</li>
<li><code>=</code>和<code>in</code>可以乱序，比如<code>a=1 and b=2 and c=3</code> 建立(abc)索引可以任意顺序，mysql查询优化器会优化顺序<ul>
<li>这里需要注意下，比如abc索引 那么只要查询条件有a即可用到abc索引（如abc ab ac a），没有a就用不到</li>
<li>最左前缀匹配成因：Mysql是创建复合索引的规则是根据索引最左边的字段进行排序，在第一个字段排序的基础上再进行第二个字段排序，类似于order by col1，col2… 所以第一个字段是绝对有序的 第二个字段就是无序的了，所以Mysql强调最左前缀匹配</li>
</ul>
</li>
</ul>
<h4 id="10-聚簇索引和非聚簇索引区别"><a href="#10-聚簇索引和非聚簇索引区别" class="headerlink" title="10. 聚簇索引和非聚簇索引区别"></a>10. 聚簇索引和非聚簇索引区别</h4><ul>
<li>聚簇索引与非聚簇索引的区别是：叶子节点是否存放一整行记录</li>
<li>InnoDB 主键使用的是聚簇索引，MyISAM 不管是主键索引，还是二级索引使用的都是非聚簇索引</li>
<li>对于聚簇索引表来说（左图），表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值。使用的是B+树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)</li>
<li>对于非聚簇索引表来说（右图），表数据和索引是分成两部分存储的，主键索引和二级索引存储上没有任何区别。使用的是B+树作为索引的存储结构，所有的节点都是索引，叶子节点存储的是索引+索引对应的记录的数据</li>
<li>因此，聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针</li>
</ul>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7lczbhkshj318611ik0y.jpg" alt="image.png" style="zoom: 20%;" /></div>

<h4 id="11-如何查询一个字段是否命中了索引"><a href="#11-如何查询一个字段是否命中了索引" class="headerlink" title="11. 如何查询一个字段是否命中了索引"></a>11. 如何查询一个字段是否命中了索引</h4><ul>
<li>通过explain sql可看下SQL是否走了索引，很快对比出来 </li>
<li>当一个sql中索引字段为int类型时，例如搜索条件<code>where num=&quot;111&quot;</code>与<code>where num=111</code>都可以使用该字段的索引。当一个中索引字段为varchar类型时，例如搜索条件<code>where num=&quot;111&quot;</code>可以使用索引，<code>where num=111</code>不可以使用索引</li>
</ul>
<h4 id="12-Mysql中查询数据什么情况下不会命中索引"><a href="#12-Mysql中查询数据什么情况下不会命中索引" class="headerlink" title="12. Mysql中查询数据什么情况下不会命中索引"></a>12. Mysql中查询数据什么情况下不会命中索引</h4><ul>
<li>索引规范不合理，sql解析器不命中索引</li>
<li>表中索引是以表中数据量字段最多的建立的索引，sql解析器不命中索引(实际就是索引没用，最后全局查找了)</li>
<li>bool的字段做索引，sql选择器不命中索引</li>
<li>模糊查询 %like</li>
<li>索引列参与计算，使用了函数</li>
<li>非最左前缀顺序</li>
<li>where对null判断</li>
<li>where不等于</li>
<li>or操作有至少一个字段没有索引</li>
<li>需要回表的查询结果集过大（超过配置的范围）</li>
</ul>
<h4 id="13-Mysql中的MVCC是什么"><a href="#13-Mysql中的MVCC是什么" class="headerlink" title="13. Mysql中的MVCC是什么"></a>13. Mysql中的MVCC是什么</h4><p>数据库并发控制——锁:Multiversion (version) concurrency control (MCC or MVCC) 多版本并发控制 ，它是数据库管理系统一种常见的并发控制</p>
<p>并发控制常用的是锁，当线程要对一个共享资源进行操作的时候，加锁是一种非常简单粗暴的方法(事务开始时给 DQL 加读锁，给 DML 加写锁)，这种锁是一种 悲观 的实现方式，也就是说这会给其他事务造成堵塞，从而影响数据库性能</p>
<p>其中在数据库中最常见的就是悲观锁和乐观锁：</p>
<ul>
<li>悲观锁：当一个线程需要对共享资源进行操作的时候，首先对共享资源进行加锁，当该线程持有该资源的锁的时候，其他线程对该资源进行操作的时候会被阻塞.</li>
<li>乐观锁：当一个线程需要对一个共享资源进行操作的时候，不对它进行加锁，而是在操作完成之后进行判断。比如乐观锁会通过一个版本号控制，如果操作完成后通过版本号进行判断在该线程操作过程中是否有其他线程已经对该共享资源进行操作了，如果有则通知操作失败，如果没有则操作成功，当然除了版本号还有CAS，如果不了解的可以去学习一下，这里不做过多涉及</li>
</ul>
<p>MVCC的两种读形式：</p>
<ul>
<li>快照读：读取的只是当前事务的可见版本，不用加锁。而你只要记住 简单的 <code>select</code>操作就是快照读(select * from table where id &#x3D; xxx)</li>
<li>当前读：读取的是当前版本，比如 特殊的读操作，更新&#x2F;插入&#x2F;删除操作</li>
</ul>
<p>MVCC的实现原理：</p>
<p>MVCC 使用了“三个隐藏字段”来实现版本并发控制，MySQL在创建建表的时候 innoDB 创建的真正的三个隐藏列吧</p>
<table>
<thead>
<tr>
<th align="left">RowID</th>
<th align="left">DB_TRX_ID</th>
<th align="left">DB_ROLL_PTR</th>
<th align="left">id</th>
<th align="left">name</th>
<th align="left">password</th>
</tr>
</thead>
<tbody><tr>
<td align="left">自动创建的id</td>
<td align="left">事务id</td>
<td align="left">回滚指针</td>
<td align="left">id</td>
<td align="left">name</td>
<td align="left">password</td>
</tr>
</tbody></table>
<ul>
<li>RowID：隐藏的自增ID，当建表没有指定主键，InnoDB会使用该RowID创建一个聚簇索引</li>
<li>DB_TRX_ID：最近修改（更新&#x2F;删除&#x2F;插入）该记录的事务ID</li>
<li>DB_ROLL_PTR：回滚指针，指向这条记录的上一个版本</li>
</ul>
<p>其实还有一个删除的flag字段，用来判断该行记录是否已经被删除。而 MVCC 使用的是其中的 事务字段，回滚指针字段，是否删除字段</p>
<h4 id="14-Mvcc和Redolog和Undolog以及Binlog有什么不同"><a href="#14-Mvcc和Redolog和Undolog以及Binlog有什么不同" class="headerlink" title="14. Mvcc和Redolog和Undolog以及Binlog有什么不同"></a>14. Mvcc和Redolog和Undolog以及Binlog有什么不同</h4><ul>
<li>Mvcc<ul>
<li>MVCC多版本并发控制是MySQL中基于乐观锁理论实现隔离级别的方式，用于读已提交和可重复读取隔离级别的实现</li>
<li>在MySQL中，会在表中每一条数据后面添加两个字段，最近修改该行数据的事务ID，指向该行（undolog表中）回滚段的指针</li>
<li>Read View判断行的可见性，创建一个新事务时，copy一份当前系统中的活跃事务列表。意思是，当前不应该被本事务看到的其他事务id列表</li>
</ul>
</li>
<li>UndoLog<ul>
<li>UndoLog也就是我们常说的回滚日志文件 主要用于事务中执行失败，进行回滚，以及MVCC中对于数据历史版本的查看</li>
<li>由引擎层的InnoDB引擎实现，是逻辑日志，记录数据修改被修改前的值，比如”把id&#x3D;’B’ 修改为id &#x3D; ‘B2’ ，那么undo日志就会用来存放id &#x3D;’B’的记录”</li>
<li>当一条数据需要更新前，会先把修改前的记录存储在undolog中，如果这个修改出现异常，则会使用undo日志来实现回滚操作，保证事务的一致性</li>
<li>当事务提交之后，undo log并不能立马被删除，而是会被放到待清理链表中，待判断没有事物用到该版本的信息时才可以清理相应undolog。它保存了事务发生之前的数据的一个版本，用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读</li>
</ul>
</li>
<li>Redolog<ul>
<li>Redolog是重做日志文件是记录数据修改之后的值，用于持久化到磁盘中</li>
<li>Redolog包括两部分：一：是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二：是磁盘上的重做日志文件(redo log file)，该部分日志是持久的</li>
<li>由引擎层的InnoDB引擎实现，是物理日志，记录的是物理数据页修改的信息，比如“某个数据页上内容发生了哪些改动”。当一条数据需要更新时，InnoDB会先将数据更新，然后记录redoLog 在内存中，然后找个时间将redoLog的操作执行到磁盘上的文件上</li>
<li>不管是否提交成功我都记录，你要是回滚了，那我连回滚的修改也记录。它确保了事务的持久性</li>
</ul>
</li>
<li>Binlog<ul>
<li>Binlog由Mysql的Server层实现，是逻辑日志，记录的是sql语句的原始逻辑，比如”把id&#x3D;’B’ 修改为id &#x3D; ‘B2’</li>
<li>Binlog会写入指定大小的物理文件中，是追加写入的，当前文件写满则会创建新的文件写入</li>
<li>产生:事务提交的时候，一次性将事务中的sql语句，按照一定的格式记录到binlog中</li>
<li>用于复制和恢复在主从复制中，从库利用主库上的binlog进行重播(执行日志中记录的修改逻辑)，实现主从同步。业务数据不一致或者错了，用binlog恢复</li>
</ul>
</li>
</ul>
<h4 id="15-Mysql读写分离以及主从同步"><a href="#15-Mysql读写分离以及主从同步" class="headerlink" title="15. Mysql读写分离以及主从同步"></a>15. Mysql读写分离以及主从同步</h4><ul>
<li>原理：主库将变更写binlog日志，然后从库连接到主库后，从库有一个IO线程，将主库的binlog日志拷贝到自己本地，写入一个中继日志中，接着从库中有一个sql线程会从中继日志读取binlog，然后执行binlog日志中的内容，也就是在自己本地再执行一遍sql，这样就可以保证自己跟主库的数据一致</li>
<li>问题：这里有很重要一点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行操作，在从库上会串行化执行，由于从库从主库拷贝日志以及串行化执行sql特点，在高并发情况下，从库数据一定比主库慢一点，是有延时的，所以经常出现，刚写入主库的数据可能读不到了，要过几十毫秒，甚至几百毫秒才能读取到。还有一个问题，如果突然主库宕机了，然后恰巧数据还没有同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。所以mysql实际上有两个机制，一个是半同步复制，用来解决主库数据丢失问题，一个是并行复制，用来解决主从同步延时问题</li>
<li>半同步复制：semi-sync复制，指的就是主库写入binlog日志后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的relay log之后，接着会返回一个ack给主库，主库接收到至少一个从库ack之后才会认为写完成</li>
<li>并发复制：指的是从库开启多个线程，并行读取relay log中不同库的日志，然后并行重放不同库的日志，这样库级别的并行。（将主库分库也可缓解延迟问题）</li>
</ul>
<h4 id="16-InnoDB的关键特性"><a href="#16-InnoDB的关键特性" class="headerlink" title="16. InnoDB的关键特性"></a>16. InnoDB的关键特性</h4><ul>
<li>插入缓冲：对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个Insert Buffer对象中。然后再以一定的频率和情况进行Insert Buffer和辅助索引页子节点的merge（合并）操作，这时通常能将多个插入合并到一个操作中（因为在一个索引页中），这就大大提高了对于非聚集索引插入的性能</li>
<li>两次写：两次写带给InnoDB存储引擎的是数据页的可靠性，有经验的DBA也许会想，如果发生写失效，可以通过重做日志进行恢复。这是一个办法。但是必须清楚地认识到，如果这个页本身已经发生了损坏（物理到page页的物理日志成功页内逻辑日志失败），再对其进行重做是没有意义的。这就是说，在应用（apply）重做日志前，用户需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做。在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是会通过memcpy函数将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，这就是doublewrite</li>
<li>自适应哈希索引：InnoDB存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引</li>
<li>异步IO：为了提高磁盘操作性能，当前的数据库系统都采用异步IO（AIO）的方式来处理磁盘操作。AIO的另一个优势是可以进行IO Merge操作，也就是将多个IO合并为1个IO，这样可以提高IOPS的性能</li>
<li>刷新邻接页：当刷新一个脏页时，InnoDB存储引擎会检测该页所在区（extent）的所有页，如果是脏页，那么一起进行刷新。这样做的好处显而易见，通过AIO可以将多个IO写入操作合并为一个IO操作，故该工作机制在传统机械磁盘下有着显著的优势</li>
</ul>
<h4 id="17-Mysql如何保证一致性和持久性"><a href="#17-Mysql如何保证一致性和持久性" class="headerlink" title="17. Mysql如何保证一致性和持久性"></a>17. Mysql如何保证一致性和持久性</h4><ul>
<li>Mysql为了保证<code>ACID</code>中的一致性和持久性，使用了WAL(<code>Write-Ahead Logging</code>，先写日志再写磁盘)。<code>Redo log</code>就是一种WAL的应用</li>
<li>当数据库忽然掉电，再重新启动时，Mysql可以通过<code>Redo log</code>还原数据。也就是说，每次事务提交时，不用同步刷新磁盘数据文件，只需要同步刷新<code>Redo log</code>就足够了</li>
</ul>
<h4 id="18-为什么选择B-树作为索引结构"><a href="#18-为什么选择B-树作为索引结构" class="headerlink" title="18. 为什么选择B+树作为索引结构"></a>18. 为什么选择B+树作为索引结构</h4><ul>
<li>Hash索引：Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描</li>
<li>二叉查找树：解决了排序的基本问题，但是由于无法保证平衡，可能退化为链表</li>
<li>平衡二叉树：通过旋转解决了平衡的问题，但是旋转操作效率太低</li>
<li>红黑树：通过舍弃严格的平衡和引入红黑节点，解决了AVL旋转效率过低的问题，但是在磁盘等场景下，树仍然太高，IO次数太多</li>
<li>B+树：在B树的基础上，将非叶节点改造为不存储数据纯索引节点，进一步降低了树的高度；此外将叶节点使用指针连接成链表，范围查询更加高效。此外，B+树，主要是查询效率高，O(logN)，可以充分利用磁盘预读的特性，多叉树，深度小，叶子结点有序且存储数据</li>
</ul>
<h4 id="19-InnoDB的行锁模式"><a href="#19-InnoDB的行锁模式" class="headerlink" title="19. InnoDB的行锁模式"></a>19. InnoDB的行锁模式</h4><ul>
<li>共享锁(S)：用法lock in share mode，又称读锁，允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁<ul>
<li>若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改</li>
</ul>
</li>
<li>排他锁(X)：用法for update，又称写锁，允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁<ul>
<li>若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。在没有索引的情况下，InnoDB只能使用表锁</li>
</ul>
</li>
</ul>
<h4 id="20-哈希-hash-比树-tree-更快，索引结构为什么要设计成树型"><a href="#20-哈希-hash-比树-tree-更快，索引结构为什么要设计成树型" class="headerlink" title="20. 哈希(hash)比树(tree)更快，索引结构为什么要设计成树型"></a>20. 哈希(hash)比树(tree)更快，索引结构为什么要设计成树型</h4><p>加速查找速度的数据结构，常见的有两类：</p>
<ul>
<li>哈希，例如HashMap，查询&#x2F;插入&#x2F;修改&#x2F;删除的平均时间复杂度都是O(1)</li>
<li>树，例如平衡二叉搜索树，查询&#x2F;插入&#x2F;修改&#x2F;删除的平均时间复杂度都是O(lg(n))</li>
</ul>
<p>哈希只能满足等值查询，不满足范围和大小查询，其次哈希不可以排序。Mysql是用等值查询，用树的话，等值查询只需要顺序遍历即可。但是对于排序查询的sql需求：分组：<code>group by</code> ，排序：<code>order by</code> ，比较：<code>&lt;、&gt;</code>等，哈希型的索引，时间复杂度会退化为O(n)，而树型的“有序”特性，依然能够保持O(log(n)) 的高效率</p>
<h4 id="21-为什么索引的key长度不能太长"><a href="#21-为什么索引的key长度不能太长" class="headerlink" title="21. 为什么索引的key长度不能太长"></a>21. 为什么索引的key长度不能太长</h4><p>key 太长会导致一个页当中能够存放的 key 的数目变少，间接导致索引树的页数目变多，索引层次增加，从而影响整体查询变更的效率</p>
<h4 id="22-Mysql的数据如何恢复到任意时间点"><a href="#22-Mysql的数据如何恢复到任意时间点" class="headerlink" title="22. Mysql的数据如何恢复到任意时间点"></a>22. Mysql的数据如何恢复到任意时间点</h4><p>恢复到任意时间点以定时的做全量备份，以及备份增量的 binlog 日志为前提。恢复到任意时间点首先将全量备份恢复之后，再此基础上回放增加的 binlog 直至指定的时间点</p>
<h4 id="23-Mysql为什么加了索引可以加快查询"><a href="#23-Mysql为什么加了索引可以加快查询" class="headerlink" title="23. Mysql为什么加了索引可以加快查询"></a>23. Mysql为什么加了索引可以加快查询</h4><p>在数据十分庞大的时候，索引可以大大加快查询的速度，这是因为使用索引后可以不用扫描全表来定位某行的数据，而是先通过索引表找到该行数据对应的物理地址然后访问相应的数据</p>
<ul>
<li>优势：可以快速检索，减少I&#x2F;O次数，加快检索速度；根据索引分组和排序，可以加快分组和排序</li>
<li>劣势：索引本身也是表，因此会占用存储空间，一般来说，索引表占用的空间的数据表的1.5倍；索引表的维护和创建需要时间成本，这个成本随着数据量增大而增大；构建索引会降低数据表的修改操作（删除，添加，修改）的效率，因为在修改数据表的同时还需要修改索引表</li>
</ul>
<h4 id="24-Explain命令有什么用"><a href="#24-Explain命令有什么用" class="headerlink" title="24. Explain命令有什么用"></a>24. Explain命令有什么用</h4><p>在开发的过程中，我们有时会用<strong>慢查询</strong>去记录一些执行时间比较久的Sql语句，找出这些Sql语句并不意味着完事了，这个时候我们就需要用到explain这个命令来查看一个这些Sql语句的执行计划，查看该Sql语句有没有使用上了索引，有没有做全表扫描，这些都可以通过explain命令来查看</p>
<p>expain出来的信息有10列，分别是<code>id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">- <span class="built_in">id</span>：select选择标识符</span><br><span class="line">- select_type：表示查询的类型</span><br><span class="line">- table：输出结果集的表</span><br><span class="line">- partitions：匹配的分区</span><br><span class="line">- <span class="built_in">type</span>：表示表的连接类型</span><br><span class="line">- possible_keys：表示查询时，可能使用的索引</span><br><span class="line">- key：表示实际使用的索引</span><br><span class="line">- key_len：索引字段的长度</span><br><span class="line">- ref：列与索引的比较</span><br><span class="line">- rows：扫描出的行数(估算的行数)</span><br><span class="line">- filtered：按表条件过滤的行百分比</span><br><span class="line">- Extra：执行情况的描述和说明</span><br></pre></td></tr></table></figure>

<ul>
<li><p>id：select选择标识符</p>
<p>id是Sql执行的顺序的标识，Sql从大到小的执行</p>
<ul>
<li>id相同时，执行顺序由上至下</li>
<li>如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li>
<li>id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行</li>
</ul>
</li>
<li><p>select_type：表示查询的类型</p>
<p>查询中每个select子句的类型</p>
<ul>
<li>SIMPLE(简单SELECT，不使用UNION或子查询等)</li>
<li>PRIMARY(查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)</li>
<li>UNION(UNION中的第二个或后面的SELECT语句)</li>
<li>DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)</li>
<li>UNION RESULT(UNION的结果)</li>
<li>SUBQUERY(子查询中的第一个SELECT)</li>
<li>DEPENDENT SUBQUERY(子查询中的第一个SELECT，取决于外面的查询)</li>
<li>DERIVED(派生表的SELECT，FROM子句的子查询)</li>
<li>UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)</li>
</ul>
</li>
<li><p>table：输出结果集的表</p>
<ul>
<li>table显示这一行的数据是关于哪张表的，有时不是真实的表名字，看到的是derivedx</li>
</ul>
</li>
<li><p>partitions：匹配的分区</p>
</li>
<li><p>type：表示表的连接类型</p>
<p>type表示Mysql在表中找到所需行的方式，又称“访问类型”。常用的类型有： ALL， index， range， ref， eq_ref， const， system， NULL（从左到右，性能从差到好）</p>
<ul>
<li>ALL：Full Table Scan， Mysql将遍历全表以找到匹配的行</li>
<li>index：Full Index Scan，index与ALL区别为index类型只遍历索引树</li>
<li>range：只检索给定范围的行，使用一个索引来选择行</li>
<li>ref：表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</li>
<li>eq_ref：类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件</li>
<li>const、system：当Mysql对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，Mysql就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system</li>
<li>NULL：Mysql在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成</li>
</ul>
</li>
<li><p>possible_keys：表示查询时，可能使用的索引</p>
<ul>
<li>possible_keys指出Mysql能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用</li>
<li>该列完全独立于<code>EXPLAIN</code>输出所示的表的次序。这意味着在<code>possible_keys</code>中的某些键实际上不能按生成的表次序使用</li>
<li>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询</li>
</ul>
</li>
<li><p>key：表示实际使用的索引</p>
<ul>
<li>key列显示MySql实际决定使用的键（索引）</li>
<li>如果没有选择索引，键是NULL。要想强制Mysql使用或忽视<code>possible_keys</code>列中的索引，在查询中使用<code>FORCE INDEX、USE INDEX</code>或者<code>IGNORE INDEX</code></li>
</ul>
</li>
<li><p>key_len：索引字段的长度</p>
<ul>
<li>key_len表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）不损失精确性的情况下，长度越短越好</li>
</ul>
</li>
<li><p>ref：列与索引的比较</p>
<ul>
<li>ref表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</li>
</ul>
</li>
<li><p>rows：扫描出的行数(估算的行数)</p>
<ul>
<li>rows表示Mysql根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</li>
</ul>
</li>
<li><p>filtered：按表条件过滤的行百分比</p>
</li>
<li><p>Extra：执行情况的描述和说明</p>
<p>该列包含Mysql解决查询的详细信息，有以下几种情况：</p>
<ul>
<li>Using where：列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤</li>
<li>Using temporary：表示Mysql需要使用临时表来存储结果集，常见于排序和分组查询</li>
<li>Using filesort：Mysql中无法利用索引完成的排序操作称为“文件排序”</li>
<li>Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能</li>
<li>Impossible where：这个值强调了where语句会导致没有符合条件的行</li>
<li>Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>关于博客</title>
    <url>/2022/10/27/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容">
  <script id="hbeData" type="hbeData" data-hmacdigest="4fd5a5bd8707a0a1cd39307dad6cd98e03fded9ba27a54a5b61e9696d84ea268">a17b4de793b95f7877066d2186f5861555e2d6b9cb5641947e36c8450a9062244141303af7f6ac122ca280e580e95da40c8ee95d99d2439c2f200eaab162cbb1875108085071c26de1a7a2252b96fcbe0f08370a21f14470abd2a2d2b018211a390d4a79c82cf2a64ae884fb7caded6082fa0005ef84e7ea431151015e2060bda837f3b622c77b40ee17a251d882f100278d00b9963489c074d217f528b9e8e054d830314c2ebd97fa3c76a53976dbdc3aa54c7b15ce70a5882de8489603f7173418c015d0ef7e8aa5ae4a33046644b0e563b4499cb8d0d6173282b0a21575c27f9144f5086203cb49e7bd9f84fa510fa7ca67502f97fdebb306ef8a69773c81e40bf148ee8b9d8ad2d1bdf194c6075caa40305d045fbb2a1c2119103f08f156ceaebc719357118924dd869dcd27372f3549487bee4f166e5c77adcb1ac7794dbe0a673ebfa66aa2595818250b9851cbcad400d4687e30b48667a8013245d51dce6aae77d5905b91f53b574fc443b1684c92af0bac92b0aacfa2311b89865521de7bc0054eeb9670d5568a2e98652854cf0ed9fc027967d196f3a30f8b2b14066b2b52b741727573fadde89b47e0d9fa69fed76a226477fc8a2f55fb32f9e4a53348a2747f494b15c8d7565c27afbb068f7ce813b4e1ddedada52692a9c6d917f278d17b970668263eeaaefcc44df89bcde5edc1ad4988985ab067b75e6cd1d6f6083dd6b1ce8e775db02a7d9533537b178a63ec573a5043bc15bbd2fc963c4f3aa122ec4f0b3fc30cca5257817db4bd4ffccc7a43fd006bc392e64e161e7b59542881b1b7db7805b0003d89224d2ef64a29bbcbd982ea90041c78c6f87bee6da444542e072c9c6786ea8101f8bf295aee03c0d6033a3e19116bae338e4be2520f564c69e09cabcbd5249b3c4c50d66ab39b30dd90f909ea126d2b48f8245d175a365531c939ef6e9a42c17a33a69c8b52de48e4757f5f25a4fef9493350305d558c5c0c806c0698893aaa568476e50e6079fe997df4194d8fb35a21ea8958bff697c158b049a30bd3bcd0e162772f352d83b202daafb229c098c33cda25c04e715a81f80f6673a1a70c6f17a033b3ddcd772068cce43302f1602f71d2b7a5e121056818a837126e27c0990955f13ad5ed1fe26d0e0aee808c0717a47a38999c20411f7ce53f8b1bc86018e5b9287eeaa3caf58b4244ae291f351667c000a7830273ef3d8a17f8c1254d819d16bcb2a2d9683972c91763ebbda2a379442d0b07437cfe123ac3be67f7318fb7803470146435bd3d593263e5e37c32705f6ad8b8d0decb68839c28c9a838f97b8613f4c483eee116afbea3097e72e0077f5a4ed396ad4c4be49ee36f3726809e0efa9aa8a9e0e3181b1126675c191b7b9a7fcf1ff115b2e87efd6ec64274d47cbdbd09c899a776819132d9566fea583fa1897209395d8dfb78cf6cdc2819d6c0e75da888e88ad236667388f965855fd7fc36d1249a1a1d24eab917be709ea423f9491f59038c726eac3ffed3707f0d3bdb8c90e1951f96ef89d1abfd2d4679259ea0d69c9a1f152594c71981fcc4dece41fa6dbc07cd2a1a3a0949396cebc5a8a3f13d0033e3ed78f7473fa5c9d6d5802e15232fa8b6bdd1feee2a12f22c2449c68bb1e7d8052c8ae42bfcc1f65444565986cbc63a4381f9bb0b27d0f5387f2f04a80432645dcd2a57c171892bdd3ffce03a5852a2768dfd5d53ac1fa5e321da9dba979819096a00897281370689f9e75e450560f86f506e598fff748d42ec26aab61b453561f9facad5af053d0c77652e200b75d59620b32899f0977b4d7f947cf1fd9beb68e8280f53cbfcdf2ef9ab67cdbb3bba405d77af100b02287ea616c931799fd7eb8c65b4843c926b2651e5d68b33e0e8cde998c763b06347c459de9fc8b6d5b10460a3388c750b194669523e2e6628d25d736b401ce307f71cc25241f4c82561bc6fa56eb3924f23148fbf518a80344233e7f71a3fe7150d9566a5b2d78802878628dcbe3aae5d400d10be685cf3015c07fa9981fe3645873b7089878cf1743cb0f6eb1796b83b00fe30bb78a6d55e94b4d4f0a2ededbfc36e8de15a8c68506befc43dc69e9abaaa7cd55a6b0f6e6792c45997a7acc30f602b783f1c2d9e0a430ab0a3fe4708ccebd7296c44cfbbed6e7cdf13078753bfd0f6d1866bcb3909c3a07cbdb5faa777ce9e8229c9f734f9bd4b8345ac641766ecb4180dff676c9eb4ac91e0330e530705671b54027ce8d3d33fc6fc9a01753866b28e5bcb8d028adb423edbaf834b45079379af6dbf75c379ec6cbe97f5acab496506713300ee2fa1d677ec006f8460d04a3a797a316a88ba832955f99e291cda035b1663c676618e95cc59dcd3414befa5426a4c35a12f9f95d1bf2fb1b12fe350b0b1b3bc504578eb3ab16aaff15505b218ec2b0fbc933d9034bea8be11ca2ace22f04b861883fd863a5ec6c16ab8ff90a72fbc89fe91f9c2b84601a8dd28de98bfe0d12ebbfbb14b201090325fbfdd352e276c6fbbdc989d94ee96b47b57a5aeff3af3e8bf9f7a0cafd74b8a28cf11b86ae485563e16bc071035388116b04012ae9d36e259252145eaf552be23a474c5c6069c29b15df7194f40734f61e4f0f9e7da86c08944a68a2b6e7768e608d01145a35e4973f948119045948996df2410aa5c019c24fbb7c8615d0409ea313ebeb78d6ee8c9ea6fabd9c504713c21c54b21e773fee2c29468af30e00839978e769b07780286f5ba0b35971772053de944880873743e8073f3ca90778c45d558733835666daba6285c05162bbf1873a03e9a29994cc53678aca15cddcc1d2d8ca360828c2dc48f9a536ab4d309b01814f0a7627862f3b718b4b95fad03b8299e80e08b96e73105d9198cefc55bf0a26c8e13906b900bebc96b87960b5763d31f03f411ef027006cdae44aef11472578447a913034088d6d861c71de18fb99a9ce6932e0072cfd030bb49c34cb8286c90aed1408f146dbc39e78b0ffe602096c078d6c92ca59e264608df236ad9ee41f99c24f97b379a8d06636842e2d54008152997c8beb6cb86971dbd8b476596e0fec9229e959c1ad4a20259b1d1580e789a16c5b860e447a97f6c6daa850e83715e9236f6fa882a6adf7daee4e66d54b0ddf0966b181098e9998014905ba6b79e76f0c7cb3a6ffc3bf6640b20551704fe94216a732df2642e8d1fa25aebe51b04b3eb634a9e00f307e266f3cf9271e3faab8a828182a0e514f37888a805a4d3cc60c3ce428e9db37be132155b55740d4f93b7addd70d38ba8ac286921ab9ca32690350d35098782c618a7a6aef460e67652366c7b919d0a0aac2646daf741e55bfc9c650539dd6d755574cad07af9359895132f201d2eda1229b7540487750ba60e705158636e473b1a7ecb944b98587de86c6eebfc6a7e64291374129bcd142da570765bdb65cbc046c0a07cee6a59d7153a389ff2c27e0ce590808f50429d5877bcf24e2f1e2a72d63b464ad6bb91eac128ee19d1ed8bd6143604eae097c485dbeb04c56de34f94d28846fd5621c08a6609e7d408b1fd03e36defa8d59dc0cb9400a4a7e614d4aace51ebd7252c40a67ce237573a934fdeb1b9e0e127f5718fe4315a5026a455e2dacd45ae5e352aac9a03e56e8aba77b182194d330a5e68dda7b4202a9ccaf2864a34814a2cb060cfec55b655b899e7f66f11348acf51964d5603025054b1be35317c7de9a4941b5ed3fc3c3038be497bd3762134b9e892b01fe7791b0037cd8a6d15476c3b22aed3e7276c5ff1f8fdb1a7ae77715a81f0dd955e18fc54c6d1d28e4a6779546eb93449b288da309947a747dfed8c497520513b1bc7d271cbae4bf199355f37b5964535f0be92998aea448384e17cf990b8b339c8301edf9ac37219ebf580e1c60a7d2b7719d0856e8dc8c1e56141c0abd47916b1cf6a9f735b60278b3bd02567a54d01ccc1926134111fe7184a54d872ce230aca60f6625700d5bfc925d2d178b3251a1a5dfa97d824b585dbdfdd24303f1af300c79882c82ac677764761dbf2497fc2692ef13eabf8f75914376ae2d870c272f8d50828f1ad29d5f39d2d17a5f40b62d01cc10f9067e72fbf8a64abf11db7a154fcfdc2a246a074cf4fad6058df30d63893581dd4e643a4067a26cf9ad99dc00a2428d4fc1ea6269371358a98ac96075883b5afb47da32a16d1e710ca17171b9d9a672106c8ffd65a3d736314ef7f7565d9b5a5167b09b964647bb16d64acca1f5fb4e4d7c77d7231b2ffd44f49b26114450ff399482595e7e4944fcd2aa8b51db1817d1c85672ffdd06128a6cea9979d6f5d21e0c776773bf98664fe200a1385f15fc747a5109614c79d8e5ddaea38beeae3df3dc66a9609ca51b4b77421c29e270f13b470fb9064eb2c7337f8b8cadd7f8f46db0e885d8a6c2fdadb226ccbcc963d128198eea37b72c738b0617ec7b706bf2e1319ced1c4bed6b9f89d4f9f8fce6253b8c0718eefa341caf689c11a3b7e9e2468c390141a75123a22a9778686b5fb9153a16ae9aaebcf1efe2e65097a27e392be7c40eef4f89a21ef027a2b02848cceabd148899cc00feef565c7ca4763ccf8df0cc725e504442b7762b816a28abf87cc691b04aff02609c24a3096f6cda6f10934092d210c80253b7ab0aa094f07b2bde74027c08628d4be8c0d1d694f4281a80942a0513c4bf7d69a5710da1bff7162f55481ebc01412afb661d4f15e9b852485209297a86917ae77f93da5dfb61f3c28caf621d2bb6b774e504b25e1cca8bc4fba4779b37fd53beb9e32702f607a3da09f36e4627a85c705326704f75fde436e9e0027506bff83a24ba9b9435d9996a20bc04f57af90ce584828fedd43668ce9edf082e80c9c0a5304f197cc2dc850438269c0ba4f59fce714ff2ad759aa04e0d269af9349539dd6637523a7cd0346623af4f10b3c9eee6b52243ec6645277a27a0b9b530c24c3edc9ba1329e8ec7af7760c9194d276264915df27ad0e40e0b2d4ba0ece0c256cacbe276f3194e7baa25fd5c3b24488f71a4351a3cda0d12f137f22dcb53b0505b4dc2480242ca0153b5e1a681cfe8650460984367b1d6d57adefd262fe260091dd41a4aa954d33742a76ea453feaf354be02c6ef52cb72a5a8d95bf83c57ae34722a45a9058138303aa098b2ee8cca5739b3f79d9529b047f3606a52cc396a159181aea8d341d332aa993ef449926b0608c5356ce90a9867cbcc409ad57c13d97687377876c95a82720dd6bcc77804a65e45a11f5628b8299ca1f4ea9fafc7991e7be9b4d85c9772604e6dcbee78cc0fe3ef7b7ce5d65a4d616c548b6dcf260e2c45e90122cad56a82cb877214e943a45da00a6d6ce6ff7bc36b41075f493ccd5ddc1ed24e1b29fa197e502ee6c10a2adfbff8e87aa0368e6b4ffce4473e4b06c534a48e6005b862a7b1c4904cc354a15b81328e8784e0d88fea417f3bbae96950897714d1b18b566ad8969919082522a2154502441c3c8934903296d249e57bc2d0fe910b429072fbfd644037ccd8f20a462b4d78aafd35b00288279cd49012099279759ddde53c64f36348b03f3eb9ca3ffa5d57c069d20d9c02014b3a5e070672d4084f71494c0e4017aeb6c80fa9f1504e50e566994efd59468621d27a50159a5be9f8273c1af878f8b3d27316ff01c0916259138c84bf87db48d65922edb92f3e5ff3e796dad9ad7acc1a8553f88166817330681804213f94285cd1b9a4a19880ffc0f5409d8051e09b4c38d484256d15b410f4bd85f398c9e5ea6fa06fe6f7c442015b12af608c083a9389fcc978c3b0b72be782ea75e558f9492ca03f42645cf4c84c30fe9b3e0d31ea7c96065a733ae5e71fccb1b41c78799f0953b7a97694c577c41f99666ab1b13606c59df11835b8ab5d60206cc9a029bf5030e59b851893dd77a9f3bef6f26ee1a0686501dcf07985e61b13c359f74f87729376c1566f335c4a8860eeb77b86a9fc33ccf349bd63e1d2a50cb0e3674a9e51dab971d24c4ba0d01f93a121c3b03875a27d00bafa27bcc77eee7891924e9d0dabbc7b6948dc6d45cc37a0628a3d445bde5b07a8667abb8c4187a289326086f171ea977491e2b7b9119f37979e02bc6926f92f820662abf7bd04ee3fe815eecce462b2acd8f5eb4ccc1e5b793fa6499a2d55a614748af7ec575bccfc8054b2badb60dad287f6e32ba592887ca5e0b9ece58168aa5f2b77e334653610b5342b8dd94f06d3eeef00bd56f2f711de41e78ce734603eb0269b65a00c672bce48de2bfb5e83a0cac5300c47b5d544a2d62fcf328e0f40a4cb18bf4292e3623be68ac6bb2b581f05e2c65dae7ce2edb404e914412fadddc9476cb1b6b5c023177fe0e7248a4bcd8a222115517848f2d6fdfb81b3d20d925ff88a9799ae38c590aada4cfe5adaf3b8f45ce6c957c9bab1737868b147fa36403773dc4bb6f6f170380562d18533ec749f2f03faa0b8d924bd93bb44f5aea2c36c513d61413be17f86cb3021fcb23d97bc5d58932f4da260637cb39af923ded689b56b416ee9e26c96b119387795e0be305649a6269f69adbca4b68ce1eb71333f72f3bfcfa9ffdd2ab1cb518c915673aebca636de222320a9f5614b03f70ded338730fedcbed02e001fce23ad923a7a4f75fa2d77315ac28f367d7cfde727e093b718f705dce54a2182f78832fe9ef5d10fcb31b3a1c82287bdf4c2daa0309e9895ad84d3080868731988e86fddafc4f9a349c5f129e79fa33af93fa39c5133e204769041e176bdf9288ddd693565661cc6b7be831248b6896c603b4e194b8e660eb6bdb7c3d906f390984fabdd6f81e8d6e9a5ff50846c06fea899c54e83a4649f769f0651e8891ad4f1dac53bff77d82e5d475ec69ac300b1e05ac272c15da0dcd41ce58d875849be6b9a979ddffd828fcd7fb3e74ce3f2ce616fca13395c763c4ce01472f0696d1cfaff030451c29c04da6b619c012926cc60bb0e8a7984183f8a2a55e1ee754634de1c29917809ff8a3033d7af4bbc4e0a458e5d58ea6f2b7ba6f4abc9726729d17873dc265c20653e7b15b79eb011bf1b0611311b731a779328368426bc7fb81f067a370db788e75a6daffef469d8e5f9a5f4d26405b75b0c040fa79ef5bf098bd2157137b5b99f77b860f4a11603e8341efe2a8c8d7468408cf592a9256c6a443ca92195fa0f6df7c70cfaba30916e460849763ce3f4e384cfc88c36413144bf8770772fb334004290fa323b6ac11e74305f186d1dbe3b1fff8b84fe6368b74cd86cc128458b56730f2049b8ac0d3ebbd96f3dfc14edf2add9e8d37db12461bb916703b3ebfa709d8b0cf8b06fba97e906c2b109449f068e2207fac229b18b54ffbeef14d85776ffb6ceeb34394ef61a9941efe0161506f0c6b886d99b590e747316a8cc86e55f5504c18370d4997d06a369bf3a8b1285ae3b65bdb4f2c4038efd9483a536f2646479730cf5d1354af87b433a9aaafaf821b20fdca525f6a8080cfcf3046cd0bb0c7cd97b2f63df488489b4e6f20dfc454bc3c33efd1427fb13ffc6b267b8642a958b22797509250487d5bc9af3ded8cefbfb699e65c524bcff4b3f20877dc483b4fb38708a96ee8ff514b23ed9a125c6019c8a7f478b9700232de75127f8197d7510808d422fb1ff54d2b60402b45d50c7b9d0c298d768dfb0fa22b766896e33c6ded40d81c3294e0abf6ea504370acabf80d1c60e0e7715b2e75c9f9d70682dd65b10f4cbd99af36fd255a74f295ccbef3994f5223f34a6342a4acd2c882dc85885e86adf795fc48d6a1d97991eb078cc0e5e6b199f79269c141f906082a8bf33bf2aa23071fc955cde1d3dea8d3254dbb7595ec6483e3562d5c6ce7dd0fcd7d296b34e6838eecb760962ac701aa7523d2ff580801c728efd293cdf1ef59b18a86b141d1bbc1df64f9769708ea7cd29462a91dac8a82d9861fba6bc5eba08a0d13132cf9a8e2eef1c2cfae6aff5e9e7864cb40f8e8a6eb3d14509bd3351c24bed9a8bbd0128731b5fdd6eb46910919c5a33fd359233ea0aae5986a1ac602514e52afbe2804cf44fe02b1cbc2fa16910c7f92e97de3fd25ffc7a1f7b54b7a665b9d7697b868d25f67c41b54c383eb058faf3001286af328deec84df499058f0bb102c89db333e787b97efb4d580ebc0ae9ad7bd61668db7c4d64ef698830dadaabd2eff5a28ae57521ba5b67d21f13f8b6452ca5ca349a25fbf4794b31bb4735c3862605c783c90a6106697e04c7e720c9fb200d4f793b58e9f29f9654c37123dc617dd7888217d9d06252bd1bd5d2bb51341b63f276bd8f8f961916166cbd95c36e0f22a8335b1e2aa0cd8b01e6661abb341335da444c845f7f1b08a0f25784d8de5a6c040e4a555946c4630f3e48a73f99d0ba8cf1b89c68c5d75ec1de68a68b4fc7d16f6532c9a2730d136c5de5e05bf5678515709a92ec064dd24b9d09c8eb9fb92ae91651af967d757a0c197ec529a1a9fb4c2b7f59cdab7565bf1490235eb1544b9b57725075db54711678ccf8175229720ae451fbffa80cf3415a520d305ab5abe9002e6adb2b02c740dc2790fd63b0c58d78dd38550f76e783ea61d2623f23853e3341905b08ac9315adcd36e63ed988e1038e8f890ac479a60dc6711c6d3436bffb4098799aaa352093437d6c01c1d954b2338262a51ead3d59699d57622f1030f8a743ec181975fd555b06a9db300b2e75342f5de28f963779bffba61220516e2a408c0785ea4525f5db81c2f6838a05838a8686a82d6eef7ab9219b016df863ac38a83e7e6813ed1d82e5d2ebb98bf684666dd95a4812e7c2ecb6bdccf88ced478379fd05690d3566c0f49a7bc5255288ba01818f1278016807f0da8630a1a65ed948e0c9b2f03698c50681f66c59df879d579fce22f69e134cd83aaa32ece279b29db338eacc2479f08bb59b8fb1cb76dd3e7145ca4163c00452cfdd63117047f7f26544aee248e85261c67bc5e60ef56482f02dc39082f80de245ab7b6fb5af1002666e330e6330af51b5f9a66d5515db849f457414b7a46dfeb656b81f483b12eba2e661e32003b4c85b6c652b48a1a25db319fc47613dc70fbccbe046c3fb257ce3b797ef87723f833ac66d09130395e6319011a160b4a1d5ca181e757663aa406ec3d000dc7882b56804c22841ee166f391b90dcce1dd7e84dc1f9a81ea059285333139da28baf02d1edd7338473abc659df8b0eb94c55bb1bb3f35c48eb77f209db33caf0a7a4a4d1f2a77b16e1eba464712136d5de927e5e722a6b152b63ff116db3f8e223b191651fe89c3e8d16c90ddc1f16736867ab63f3041a70118b6dbae31d76acdd9593824612dc2d17f7cc47b765615ef94c7dcb9ce4518200c6db166ab4f47114d42a2e07016ed8f2ea113e241b3fc7229fa1367a1130b3cbca18a863daba67663fac30a3e77e03a20f453c357e88947dc7f7ed9888e23aa2e1c2d79a16de6d1a3d1fc838416925c26f5721da53c73e2a6ea061972799559fcb8d6f6ac297becf76da9447a2155eb4152f64245ec2ff77ffccaa12c64f1d35cc189b37412b6f69d128d4fea170549ba0a9efb05bb403144991c099cfe95776f8b97da8e46581f40791597e717423bf9a3ebc50079392762f9617efacfe7c4540dec20313f02692132d0e72f56ac0324b5cbfb982fd7acc9fa34556b5a351f8dbabd6f3eb4db4cb51fbe3a9a6ff6bc36e0d9049d0b67a5c7a1b5b80692617d3f38a981ed41db4ef6cfcb28c844cce61c0caf3214f7e37929ab7104ca4830984a879a3532b583e3e29d7921483d656cd7cb346d06657e61919e10b70230697f1b2cec444f901543ee766d912f39e725de506a5b1eb8bec4c6132fdb74b1554229c98b110489502f836e46d1db766e08c773162f92b3abb821220f3a056dceae32f0bf50727b0fd83aa315379ca6dcac30e0df93bfab49bdc1a70be126cf1301b49d5394dc65ae825f1e64738e15afb29c14a9563fe78c2b2024486188a298729d9a04a091d3a1810e36a90d84e36c21fde351c68549ee72ab413f009bc7a6ad699ea8bd641704d14d1e53d592a268dc09848c18e17fb0e190a2c1de5579ca182e42ef3f8cb5bbed17196fa699344aed7c7520dfec39db96182c558b6aebd771c1bced8ad493b25ba6dee9a46e97541144a0874085ca349792400375c1a4d3c0684e0a9f3aa9ca56dda8c005b89fd0da32689859928ddde493711700d7cfc2e27d1aa7d0aa7142d1800986fb59ae9e1c93b98100689a76f1055a00f4a8cdbb2df1d31f5ed08f6cd4f7a417d1bd3c2d5df39e59d0f6c765f6f5612e8c91e8fd20fb0d533e5309893ad792aaa7f3b1a0bb7c0429ba6fc3542e324aea8d565622c700795f717c8ae9bc308317b3c4660cf9338671b959c441a7220e1c5ec88aa056d74fefd626d7b507fa7204e95f0bd198bbcffadd8f6ace30b9c8764edc17f1578d439dc6546388106817b138de9aa5e70450f1cd36adca672eff94e8cc28227b8afea563d456f14ec3e6042a3ad8f0dcb0ed90cd51f4c6587e4919f444f03f73dfc51f64a52261fdb4e4751cb511d071663c2f884e6ccc350f60d2df0e5fadc28b44c9acdaf9d917d97f28b8b9e7f10d16aa4cd041694fe6c8a34090b5b26db4bef222ba8d541a5d09d32799a619dafd24834b345ce924cea15a2a4e064edcdf35f6fac6d5c749a6a99ad139f5577abe58652e9721c65163c700cb1efa24c820d33d9f23ff4b7196c5f3260b88f06604247868e71f9269d845072c4ecb8dcd1385b4abf90b36b97f8e7d99fbea4fbc415</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 请输入密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>关于博客</tag>
      </tags>
  </entry>
  <entry>
    <title>项目经验面试题</title>
    <url>/2022/10/28/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Redis面试题</title>
    <url>/2022/10/28/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>Redis面试常见问题汇总</p>
<h4 id="1-Redis的数据结构及使用场景"><a href="#1-Redis的数据结构及使用场景" class="headerlink" title="1. Redis的数据结构及使用场景"></a>1. Redis的数据结构及使用场景</h4><ul>
<li><p>String字符串</p>
<p>字符串类型是 Redis 最基础的数据结构，首先键都是字符串类型，而且 其他几种数据结构都是在字符串类型基础上构建的，我们常使用的 set key value 命令就是字符串。常用在缓存、计数、共享Session、限速等</p>
</li>
</ul>
<hr>
<ul>
<li><p>Hash哈希</p>
<p>在Redis中，哈希类型是指键值本身又是一个键值对结构，哈希可以用来存放用户信息，比如实现购物车</p>
</li>
</ul>
<hr>
<ul>
<li><p>List列表（双向链表）</p>
<p>列表（list）类型是用来存储多个有序的字符串。可以做简单的消息队列的功能</p>
</li>
</ul>
<hr>
<ul>
<li><p>Set集合</p>
<p>集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一 样的是，集合中不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素。利用 Set 的交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能</p>
</li>
</ul>
<hr>
<ul>
<li><p>Sorted Set有序集合（跳表实现）</p>
<p>Sorted Set 多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。可以做排行榜应用，取 TOP N 操作</p>
</li>
</ul>
<h4 id="2-Redis持久化的几种方式"><a href="#2-Redis持久化的几种方式" class="headerlink" title="2. Redis持久化的几种方式"></a>2. Redis持久化的几种方式</h4><p>Redis为了保证效率，数据缓存在了内存中，但是会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中，以保证数据的持久化。Redis的持久化策略有两种：</p>
<ul>
<li><strong>RDB：</strong> 快照形式是直接把内存中的数据保存到一个dump的文件中，定时保存，保存策略<ul>
<li>当Redis需要做持久化时，Redis会fork一个子进程，子进程将数据写到磁盘上一个临时RDB文件中。当子进程完成写临时文件后，将原来的RDB替换掉</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>AOF：</strong> 把所有的对Redis的服务器进行修改的命令都存到一个文件里，命令的集合<ul>
<li>使用AOF做持久化，每一个写命令都通过write函数追加到<code>appendonly.aof</code>中</li>
<li>aof的默认策略是每秒钟fsync一次，在这种配置下，就算发生故障停机，也最多丢失一秒钟的数据</li>
<li>缺点是对于相同的数据集来说，AOF的文件体积通常要大于RDB文件的体积。根据所使用的fsync策略，AOF的速度可能会慢于RDB</li>
</ul>
</li>
</ul>
<p>Redis默认是快照RDB的持久化方式。对于主从同步来说，主从刚刚连接的时候，进行全量同步（RDB），全同步结束后，进行增量同步(AOF)</p>
<h4 id="3-Redis的LRU具体实现"><a href="#3-Redis的LRU具体实现" class="headerlink" title="3. Redis的LRU具体实现"></a>3. Redis的LRU具体实现</h4><ul>
<li>传统的LRU是使用栈的形式，每次都将最新使用的移入栈顶，但是用栈的形式会导致执行<code>select *</code>的时候大量非热点数据占领头部数据，所以需要改进</li>
<li>Redis每次按key获取一个值的时候，都会更新value中的lru字段为当前秒级别的时间戳。Redis初始的实现算法很简单，随机从dict中取出五个key，淘汰一个lru字段值最小的</li>
<li>在3.0的时候，又改进了一版算法，首先第一次随机选取的key都会放入一个pool中(pool的大小为16)，pool中的key是按lru大小顺序排列的</li>
<li>接下来每次随机选取的keylru值必须小于pool中最小的lru才会继续放入，直到将pool放满。放满之后，每次如果有新的key需要放入，需要将pool中lru最大的一个key取出。淘汰的时候，直接从pool中选取一个lru最小的值然后将其淘汰</li>
</ul>
<h4 id="4-单线程的Redis为什么快"><a href="#4-单线程的Redis为什么快" class="headerlink" title="4. 单线程的Redis为什么快"></a>4. 单线程的Redis为什么快</h4><ul>
<li>纯内存操作</li>
<li>单线程操作，避免了频繁的上下文切换</li>
<li>合理高效的数据结构</li>
<li>采用了非阻塞I&#x2F;O多路复用机制</li>
</ul>
<h4 id="5-Redis的数据过期策略"><a href="#5-Redis的数据过期策略" class="headerlink" title="5. Redis的数据过期策略"></a>5. Redis的数据过期策略</h4><p>Redis 中数据过期策略采用<strong>定期删除</strong>和<strong>惰性删除</strong>策略：</p>
<ul>
<li>定期删除策略<ul>
<li>Redis 启用一个定时器定时监视所有的 key，判断key是否过期，过期的话就删除</li>
<li>这种策略可以保证过期的 key 最终都会被删除，但是也存在严重的缺点：每次都遍历内存中所有的数据，非常消耗 CPU资源，并且当 key 已过期，但是定时器还处于未唤起状态，这段时间内 key 仍然可以用</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>惰性删除策略<ul>
<li>在获取 key 时，先判断 key 是否过期，如果过期则删除</li>
<li>这种方式存在一个缺点：如果这个 key一直未被使用，那么它一直在内存中，其实它已经过期了，会浪费大量的空间</li>
</ul>
</li>
</ul>
<p>这两种策略天然的互补，结合起来之后，定时删除策略就发生了一些改变，不在是每次扫描全部的 key 了，而是随机抽取一部分 key 进行检查，这样就降低了对 CPU 资源的损耗，惰性删除策略互补了为检查到的key，基本上满足了所有要求</p>
<p>但是有时候就是那么的巧，既没有被定时器抽取到，又没有被使用，这些数据又如何从内存中消失？这个时候就需要用到了，内存淘汰机制</p>
<h5 id="5-1-内存淘汰机制"><a href="#5-1-内存淘汰机制" class="headerlink" title="5.1 内存淘汰机制"></a>5.1 内存淘汰机制</h5><ul>
<li>当内存不足以容纳新写入数据时，新写入操作会报错。（Redis 默认策略）</li>
<li>当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。（LRU推荐使用）</li>
<li>当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key</li>
<li>当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用</li>
<li>当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key</li>
<li>当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除</li>
</ul>
<h4 id="6-如何解决Redis缓存雪崩问题"><a href="#6-如何解决Redis缓存雪崩问题" class="headerlink" title="6. 如何解决Redis缓存雪崩问题"></a>6. 如何解决Redis缓存雪崩问题</h4><ul>
<li>使用 Redis 高可用架构：使用 Redis 集群来保证 Redis 服务不会挂掉</li>
<li>缓存时间不一致，给缓存的失效时间，加上一个随机值，避免集体失效</li>
<li>限流降级策略：有一定的备案，比如个性推荐服务不可用了，换成热点数据推荐服务</li>
</ul>
<h4 id="7-如何解决Redis缓存穿透问题"><a href="#7-如何解决Redis缓存穿透问题" class="headerlink" title="7. 如何解决Redis缓存穿透问题"></a>7. 如何解决Redis缓存穿透问题</h4><ul>
<li>在接口层做校验</li>
<li>存null值（缓存击穿加锁）</li>
<li>布隆过滤器拦截：将所有可能的查询key 先映射到布隆过滤器中，查询时先判断key是否存在布隆过滤器中，存在才继续向下执行，如果不存在，则直接返回<br>布隆过滤器将值进行多次哈希bit存储，布隆过滤器说某个元素在，可能会被误判。布隆过滤器说某个元素不在，那么一定不在</li>
</ul>
<h4 id="8-Redis并发竞争key如何解决"><a href="#8-Redis并发竞争key如何解决" class="headerlink" title="8. Redis并发竞争key如何解决"></a>8. Redis并发竞争key如何解决</h4><ul>
<li>可以利用分布式锁和时间戳来解决</li>
<li>利用消息队列解决</li>
</ul>
<h4 id="9-Redis的主从模式和哨兵模式和集群模式区别"><a href="#9-Redis的主从模式和哨兵模式和集群模式区别" class="headerlink" title="9. Redis的主从模式和哨兵模式和集群模式区别"></a>9. Redis的主从模式和哨兵模式和集群模式区别</h4><p>Redis集群方式共有三种：<strong>主从模式</strong>，<strong>哨兵模式</strong>，<strong>集群(cluster)模式</strong></p>
<ul>
<li><p>主从模式</p>
<p>主从模式是三种集群方式里最简单的。它主要是基于Redis的主从复制特性架构的。通常我们会设置一个主节点，N个从节点;默认情况下，主节点负责处理使用者的IO操作，而从节点则会对主节点的数据进行备份，并且也会对外提供读操作的处理。主要的特点如下：</p>
<ul>
<li>主从模式下，当某一节点损坏时，因为其会将数据备份到其它Redis实例上，这样做在很大程度上可以恢复丢失的数据</li>
<li>主从模式下，可以保证负载均衡.</li>
<li>主从模式下，主节点和从节点是读写分离的。使用者不仅可以从主节点上读取数据，还可以很方便的从从节点上读取到数据，这在一定程度上缓解了主机的压力</li>
</ul>
<p>从节点也是能够支持写入数据的，只不过从从节点写入的数据不会同步到主节点以及其它的从节点下。从以上，我们不难看出Redis在主从模式下，必须保证主节点不会宕机——一旦主节点宕机，其它节点不会竞争称为主节点，此时，Redis将丧失写的能力。这点在生产环境中，是致命的</p>
</li>
</ul>
<hr>
<ul>
<li><p>哨兵模式</p>
<p>哨兵模式是基于主从模式做的一定变化，它能够为Redis提供了高可用性</p>
<p>在实际生产中，服务器难免不会遇到一些突发状况：服务器宕机，停电，硬件损坏等。这些情况一旦发生，其后果往往是不可估量的</p>
<p>而哨兵模式在一定程度上能够帮我们规避掉这些意外导致的灾难性后果。其实，哨兵模式的核心还是主从复制</p>
<p>只不过相对于主从模式在主节点宕机导致不可写的情况下，多了一个竞选机制——从所有的从节点竞选出新的主节点。竞选机制的实现，是依赖于在系统中启动一个sentinel进程。sentinel特点：</p>
<ul>
<li>监控：它会监听主服务器和从服务器之间是否在正常工作</li>
<li>通知：它能够通过API告诉系统管理员或者程序，集群中某个实例出了问题。</li>
<li>故障转移：它在主节点出了问题的情况下，会在所有的从节点中竞选出一个节点，并将其作为新的主节点。</li>
<li>提供主服务器地址：它还能够向使用者提供当前主节点的地址。这在故障转移后，使用者不用做任何修改就可以知道当前主节点地址</li>
</ul>
<p>sentinel，也可以集群，部署多个哨兵，sentinel可以通过发布与订阅来自动发现Redis集群上的其它sentinel。sentinel在发现其它sentinel进程后，会将其放入一个列表中，这个列表存储了所有已被发现的sentinel</p>
<p>集群中的所有sentinel不会并发着去对同一个主节点进行故障转移。故障转移只会从第一个sentinel开始，当第一个故障转移失败后，才会尝试下一个</p>
<p>当选择一个从节点作为新的主节点后，故障转移即成功了(而不会等到所有的从节点配置了新的主节点后)。这过程中，如果重启了旧的主节点，那么就会出现无主节点的情况，这种情况下，只能重启集群</p>
<p>当竞选出新的主节点后，被选为新的主节点的从节点的配置信息会被sentinel改写为旧的主节点的配置信息。完成改写后，再将新主节点的配置广播给所有的从节点</p>
</li>
</ul>
<hr>
<ul>
<li><p>集群模式</p>
<p>Redis 集群是一个提供在多个Redis间节点间共享数据的程序集， 其中Redis集群分为主节点和从节点。主节点用于处理槽，而从节点用于复制某个主节点，并在被复制的主节点下线时，代替下线的主节点继续处理命令请求</p>
<p>Redis集群并不支持处理多个keys的命令，因为这需要在不同的节点间移动数据，从而达不到像Redis那样的性能，在高负载的情况下可能会导致不可预料的错误</p>
<p>Redis 集群通过分区来提供一定程度的可用性，在实际环境中当某个节点宕机或者不可达的情况下继续处理命令. Redis 集群的优势：自动分割数据到不同的节点上</p>
<p>整个集群的部分节点失败或者不可达的情况下能够继续处理命令</p>
<p>Redis集群的数据分片 Redis 集群没有使用一致性hash， 而是引入了哈希槽的概念</p>
<p>Redis 集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽</p>
</li>
</ul>
<h4 id="10-Redis事物的了解CheckAndSet操作实现乐观锁"><a href="#10-Redis事物的了解CheckAndSet操作实现乐观锁" class="headerlink" title="10. Redis事物的了解CheckAndSet操作实现乐观锁"></a>10. Redis事物的了解CheckAndSet操作实现乐观锁</h4><p>和众多其它数据库一样，Redis作为NoSQL数据库也同样提供了事务机制。在Redis中，<code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code>，<code>WATCH</code>这四个命令是我们实现事务的基石。相信对有关系型数据库开发经验的开发者而言这一概念并不陌生，即便如此，我们还是会简要的列出 Redis中事务的实现特征 ：</p>
<ul>
<li>在事务中的所有命令都将会被串行化的顺序执行，事务执行期间，Redis不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行</li>
<li>和关系型数据库中的事务相比，在Redis事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行</li>
<li>我们可以通过MULTI命令开启一个事务，有关系型数据库开发经验的人可以将其理解为”BEGIN TRANSACTION”语句。在该语句之后执行的命令都将被视为事务之内的操作，最后我们可以通过执行<code>EXEC</code>，<code>DISCARD</code>命令来提交，回滚该事务内的所有操作。这两个Redis命令可被视为等同于关系型数据库中的COMMIT&#x2F;ROLLBACK语句</li>
<li>在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行</li>
<li>当使用<code>Append-Only</code>模式时，Redis会通过调用系统函数write将该事务内的所有写操作在本次调用中全部写入磁盘。然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。Redis服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用Redis工具包中提供的<code>redis-check-aof</code>工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了</li>
</ul>
<h4 id="11-Redis有序集合zset底层怎么实现的"><a href="#11-Redis有序集合zset底层怎么实现的" class="headerlink" title="11. Redis有序集合zset底层怎么实现的"></a>11. Redis有序集合zset底层怎么实现的</h4><ul>
<li>跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表</li>
<li>跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找</li>
<li>跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能</li>
</ul>
<hr>
<ul>
<li>跳表是可以实现二分查找的有序链表</li>
<li>每个元素插入时随机生成它的level</li>
<li>最低层包含所有的元素</li>
<li>如果一个元素出现在level(x)，那么它肯定出现在x以下的level中</li>
<li>每个索引节点包含两个指针，一个向下，一个向右</li>
<li>跳表查询、插入、删除的时间复杂度为O(log n)，与平衡二叉树接近</li>
</ul>
<hr>
<h5 id="11-1-为什么Redis选择使用跳表而不是红黑树来实现有序集合？-O-logN"><a href="#11-1-为什么Redis选择使用跳表而不是红黑树来实现有序集合？-O-logN" class="headerlink" title="11.1 为什么Redis选择使用跳表而不是红黑树来实现有序集合？(O(logN))"></a>11.1 为什么Redis选择使用跳表而不是红黑树来实现有序集合？(O(logN))</h5><p>首先，我们来分析下Redis的有序集合支持的操作：</p>
<ul>
<li>插入元素</li>
<li>删除元素</li>
<li>查找元素</li>
<li>有序输出所有元素</li>
<li>查找区间内所有元素</li>
</ul>
<p>其中，前4项红黑树都可以完成，且时间复杂度与跳表一致。但是，最后一项，红黑树的效率就没有跳表高了。在跳表中，要查找区间的元素，我们只要定位到两个区间端点在最低层级的位置，然后按顺序遍历元素就可以了，非常高效</p>
<p>而红黑树只能定位到端点后，再从首位置开始每次都要查找后继节点，相对来说是比较耗时的。此外，跳表实现起来很容易且易读，红黑树实现起来相对困难，所以Redis选择使用跳表来实现有序集合</p>
<h4 id="12-跳表的查询过程是怎么样的，查询和插入的时间复杂度"><a href="#12-跳表的查询过程是怎么样的，查询和插入的时间复杂度" class="headerlink" title="12. 跳表的查询过程是怎么样的，查询和插入的时间复杂度"></a>12. 跳表的查询过程是怎么样的，查询和插入的时间复杂度</h4><p>先从第一层查找，不满足就下沉到第二层找，因为每一层都是有序的，写入和插入的时间复杂度都是O(logN)</p>
<hr>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang面试题</title>
    <url>/2022/10/28/Golang%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>Golang常见面试题分享，涵盖了常见的Golang面试八股文</p>
<h4 id="1-无缓冲Chan的发送和接收是否同步"><a href="#1-无缓冲Chan的发送和接收是否同步" class="headerlink" title="1. 无缓冲Chan的发送和接收是否同步"></a>1. 无缓冲Chan的发送和接收是否同步</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ch := make(chan int)    无缓冲的channel由于没有缓冲发送和接收需要同步</span><br><span class="line">ch := make(chan int, 2) 有缓冲channel不要求发送和接收操作同步</span><br></pre></td></tr></table></figure>

<ul>
<li>channel无缓冲时，发送阻塞直到数据被接收，接收阻塞直到读到数据</li>
<li>channel有缓冲时，当缓冲满时发送阻塞，当缓冲空时接收阻塞</li>
</ul>
<h4 id="2-什么是channel，为什么它可以做到线程安全"><a href="#2-什么是channel，为什么它可以做到线程安全" class="headerlink" title="2. 什么是channel，为什么它可以做到线程安全"></a>2. 什么是channel，为什么它可以做到线程安全</h4><ul>
<li>Channel是Go中的一个核心类型，可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication)，Channel也可以理解是一个先进先出的队列，通过管道进行通信</li>
<li>Golang的Channel，发送一个数据到Channel和从Channel接收一个数据都是原子性的</li>
<li>Go的设计思想就是，不要通过共享内存来通信，而是通过通信来共享内存，前者就是传统的加锁，后者就是Channel</li>
<li>设计Channel的主要目的就是在多任务间传递数据的，本身就是安全的</li>
</ul>
<h4 id="3-Goroutine和Channel的作用分别是什么"><a href="#3-Goroutine和Channel的作用分别是什么" class="headerlink" title="3. Goroutine和Channel的作用分别是什么"></a>3. Goroutine和Channel的作用分别是什么</h4><h4 id="4-Channel是同步的还是异步的"><a href="#4-Channel是同步的还是异步的" class="headerlink" title="4. Channel是同步的还是异步的"></a>4. Channel是同步的还是异步的</h4><p>Channel是异步进行的，channel存在3种状态：</p>
<ul>
<li>nil，未初始化的状态，只进行了声明，或者手动赋值为nil</li>
<li>active，正常的channel，可读或者可写</li>
<li>closed，已关闭，千万不要误认为关闭channel后，channel的值是nil</li>
</ul>
<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">一个零值nil通道</th>
<th align="left">一个非零值但已关闭的通道</th>
<th align="left">一个非零值且尚未关闭的通道</th>
</tr>
</thead>
<tbody><tr>
<td align="left">关闭</td>
<td align="left">产生恐慌</td>
<td align="left">产生恐慌</td>
<td align="left">成功关闭</td>
</tr>
<tr>
<td align="left">发送数据</td>
<td align="left">永久阻塞</td>
<td align="left">产生恐慌</td>
<td align="left">阻塞或者成功发送</td>
</tr>
<tr>
<td align="left">接收数据</td>
<td align="left">永久阻塞</td>
<td align="left">永不阻塞</td>
<td align="left">阻塞或者成功接收</td>
</tr>
</tbody></table>
<h4 id="5-Go中的channel的实现"><a href="#5-Go中的channel的实现" class="headerlink" title="5. Go中的channel的实现"></a>5. Go中的channel的实现</h4><h4 id="6-Golang并发机制以及它所使用的CSP并发模型"><a href="#6-Golang并发机制以及它所使用的CSP并发模型" class="headerlink" title="6. Golang并发机制以及它所使用的CSP并发模型"></a>6. Golang并发机制以及它所使用的CSP并发模型</h4><h4 id="7-Go的GPM如何调度"><a href="#7-Go的GPM如何调度" class="headerlink" title="7. Go的GPM如何调度"></a>7. Go的GPM如何调度</h4><h4 id="8-Golang中常用的并发模型"><a href="#8-Golang中常用的并发模型" class="headerlink" title="8. Golang中常用的并发模型"></a>8. Golang中常用的并发模型</h4><p>Golang中常用的并发模型有三种:</p>
<ul>
<li>通过channel通知实现并发控制</li>
<li>通过sync包中的WaitGroup实现并发控制</li>
<li>在Go1.7以后引进的强大的Context上下文，实现并发控制</li>
</ul>
<ol>
<li><p>通过channel通知实现并发控制</p>
<p>无缓冲的通道指的是通道的大小为0，也就是说，这种类型的通道在接收前没有能力保存任何值，它要求发送 goroutine 和接收 goroutine 同时准备好，才可以完成发送和接收操作</p>
<p>发送 goroutine 和接收 gouroutine 必须是同步的，同时准备后，如果没有同时准备好的话，先执行的操作就会阻塞等待，直到另一个相对应的操作准备好为止</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;start working&quot;</span>)</span><br><span class="line">        time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">        ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;-ch</span><br><span class="line">    fmt.Println(<span class="string">&quot;finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当主 goroutine 运行到 <code>&lt;-ch</code> 接受 channel 的值的时候，如果该 channel 中没有数据，就会一直阻塞等待，直到有值。 这样就可以简单实现并发控制</p>
<hr>
</li>
<li><p>通过sync包中的WaitGroup实现并发控制</p>
<p>Goroutine是异步执行的，有的时候为了防止在结束main函数的时候结束掉Goroutine，所以需要同步等待，这个时候就需要用 WaitGroup了，在sync包中，提供了WaitGroup，它会等待它收集的所有Goroutine任务全部完成。在WaitGroup里主要有三个方法:</p>
<ul>
<li>Add，可以添加或减少Goroutine的数量</li>
<li>Done，相当于Add(-1)</li>
<li>Wait，执行后会堵塞主线程，直到WaitGroup里的值减至0</li>
</ul>
<p>在主 goroutine 中 Add(delta int) 索要等待goroutine 的数量。在每一个 goroutine 完成后 Done() 表示这一个goroutine 已经完成，当所有的 goroutine 都完成后，在主 goroutine 中 WaitGroup 返回</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">var</span> urls = []<span class="type">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;http://www.golang.org/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://www.google.com/&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            http.Get(url)</span><br><span class="line">        &#125;(url)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Golang官网中对于WaitGroup介绍是<code>A WaitGroup must not be copied after first use</code>,在 WaitGroup第一次使用后，不能被拷贝</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(wg sync.WaitGroup, i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;i:%d&quot;</span>, i)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(wg, i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;exit&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之后会报错：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">i:1i:3i:2i:0i:4fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine 1 [semacquire]:</span><br><span class="line">sync.runtime_Semacquire(0xc000094018)</span><br><span class="line">        /home/keke/soft/go/src/runtime/sema.go:56 +0x39</span><br><span class="line"><span class="built_in">sync</span>.(*WaitGroup).Wait(0xc000094010)</span><br><span class="line">        /home/keke/soft/go/src/sync/waitgroup.go:130 +0x64</span><br><span class="line">main.main()</span><br><span class="line">        /home/keke/go/Test/wait.go:17 +0xab</span><br><span class="line"><span class="built_in">exit</span> status 2</span><br></pre></td></tr></table></figure>

<p>它提示所有的 <code>goroutine</code> 都已经睡眠了，出现了死锁。这是因为wg给拷贝传递到了goroutine中，导致只有Add操作，其实Done操作是在wg的副本执行的，因此 Wait 就会死锁</p>
<ul>
<li><p>这个第一个修改方式：将匿名函数中wg的传入类型改为 <code>*sync.WaitGroup，</code>这样就能引用到正确的<code>WaitGroup</code>了</p>
</li>
<li><p>这个第二个修改方式：将匿名函数中的wg的传入参数去掉，因为Go支持闭包类型，在匿名函数中可以直接使用外面的wg变量</p>
</li>
</ul>
<hr>
</li>
<li><p>Context上下文实现并发控制</p>
<p>通常，在一些简单场景下使用channel和WaitGroup已经足够了，但是当面临一些复杂多变的网络并发场景下channel和WaitGroup显得有些力不从心了，比如一个网络请求Request，每个Request都需要开启一个goroutine做一些事情，这些goroutine又可能会开启其他的goroutine，比如数据库和RPC服务</p>
<p>所以我们需要一种可以跟踪goroutine的方案，才可以达到控制他们的目的，这就是Go语言为我们提供的Context，称之为上下文非常贴切，它就是goroutine的上下文，它是包括一个程序的运行环境、现场和快照等。每个程序要运行时，都需要知道当前程序的运行状态，通常Go将这些封装在一个 Context里，再将它传给要执行的goroutine ，context包主要是用来处理多个goroutine之间共享数据，及多个goroutine的管理</p>
<p>context包的核心是struct Context，接口声明如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Context carries a deadline, cancelation signal, and request-scoped values</span></span><br><span class="line"><span class="comment">// across API boundaries. Its methods are safe for simultaneous use by multiple</span></span><br><span class="line"><span class="comment">// goroutines.</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Done returns a channel that is closed when this `Context` is canceled</span></span><br><span class="line">    <span class="comment">// or times out.</span></span><br><span class="line">    <span class="comment">// Done() 返回一个只能接受数据的channel类型，当该context关闭或者超时时间到了的时候，该channel就会有一个取消信号</span></span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Err indicates why this Context was canceled, after the Done channel</span></span><br><span class="line">    <span class="comment">// is closed.</span></span><br><span class="line">    <span class="comment">// Err() 在Done() 之后，返回context 取消的原因。</span></span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deadline returns the time when this Context will be canceled, if any.</span></span><br><span class="line">    <span class="comment">// Deadline() 设置该context cancel的时间点</span></span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Value returns the value associated with key or nil if none.</span></span><br><span class="line">    <span class="comment">// Value() 方法允许 Context 对象携带request作用域的数据，该数据必须是线程安全的。</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Context对象是线程安全的，你可以把一个Context对象传递给任意个数的gorotuine，对它执行 取消 操作时，所有goroutine都会接收到取消信号。一个Context不能拥有Cancel方法，同时我们也只能Done channel接收数据。其中的原因是一致的：接收取消信号的函数和发送信号的函数通常不是一个。典型的场景是：父操作为子操作操作启动goroutine，子操作也就不能取消父操作</p>
</li>
</ol>
<h4 id="9-并发编程概念是什么"><a href="#9-并发编程概念是什么" class="headerlink" title="9. 并发编程概念是什么"></a>9. 并发编程概念是什么</h4><ul>
<li>并行是指两个或者多个事件在同一时刻发生；并发是指两个或多个事件在同一时间间隔发生</li>
<li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群</li>
<li>并发偏重于多个任务交替执行，而多个任务之间有可能还是串行的。而并行是真正意义上的“同时执行”</li>
<li>并发编程是指在一台处理器上“同时”处理多个任务。并发是在同一实体上的多个事件。多个事件在同一时间间隔发生。并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能</li>
</ul>
<h4 id="10-怎么查看Goroutine的数量"><a href="#10-怎么查看Goroutine的数量" class="headerlink" title="10. 怎么查看Goroutine的数量"></a>10. 怎么查看Goroutine的数量</h4><p>在Golang中，<code>GOMAXPROCS</code>中控制的是未被阻塞的所有Goroutine，可以被 <code>Multiplex</code> 到多少个线程上运行，通过<code>GOMAXPROCS</code>可以查看Goroutine的数量</p>
<h4 id="11-怎么限制Goroutine的数量"><a href="#11-怎么限制Goroutine的数量" class="headerlink" title="11. 怎么限制Goroutine的数量"></a>11. 怎么限制Goroutine的数量</h4><p>在Golang中，Goroutine虽然很好，但是数量太多了，往往会带来很多麻烦，比如耗尽系统资源导致程序崩溃，或者CPU使用率过高导致系统忙不过来。所以我们可以限制下Goroutine的数量，这样就需要在每一次执行go之前判断goroutine的数量，如果数量超了，就要阻塞go的执行</p>
<ul>
<li>使用通道，每次执行的go之前向通道写入值，直到通道满的时候就阻塞了</li>
<li>但是新的问题于是就出现了，因为并不是所有的goroutine都执行完了，在main函数退出之后，还有一些goroutine没有执行完就被强制结束了。这个时候我们就需要用到sync.WaitGroup。使用WaitGroup等待所有的goroutine退出</li>
<li>Go的GOMAXPROCS默认值已经设置为CPU的核数， 这里允许我们的Go程序充分使用机器的每一个CPU，最大程度的提高我们程序的并发性能。<code>runtime.NumGoroutine</code>函数在被调用后，会返回系统中的处于特定状态的Goroutine的数量。这里的特指是指<code>Grunnable\Gruning\Gsyscall\Gwaition</code>。处于这些状态的Groutine即被看做是活跃的或者说正在被调度</li>
<li><strong>注意：</strong> 垃圾回收所在Groutine的状态也处于这个范围内的话，也会被纳入该计数器</li>
</ul>
<h4 id="12-Goroutine和线程的区别"><a href="#12-Goroutine和线程的区别" class="headerlink" title="12. Goroutine和线程的区别"></a>12. Goroutine和线程的区别</h4><h4 id="13-在Go函数中为什么会发生内存泄露，Goroutine发生了泄漏如何检测"><a href="#13-在Go函数中为什么会发生内存泄露，Goroutine发生了泄漏如何检测" class="headerlink" title="13. 在Go函数中为什么会发生内存泄露，Goroutine发生了泄漏如何检测"></a>13. 在Go函数中为什么会发生内存泄露，Goroutine发生了泄漏如何检测</h4><p>内存泄漏，指的是能够预期的能很快被释放的内存由于附着在了长期存活的内存上、或生命期意外地被延长，导致预计能够立即回收的内存而长时间得不到回收</p>
<ul>
<li>预期能被快速释放的内存因被根对象引用而没有得到迅速释放；当有一个全局对象时，可能不经意间将某个变量附着在其上，且忽略的将其进行释放，则该内存永远不会得到释放</li>
<li>Goroutine泄漏；Goroutine作为一种逻辑上理解的轻量级线程，需要维护执行用户代码的上下文信息。在运行过程中也需要消耗一定的内存来保存这类信息，而这些内存在目前版本的 Go 中是不会被释放的。因此，如果一个程序持续不断地产生新的 goroutine、且不结束已经创建的goroutine并复用这部分内存，就会造成内存泄漏的现象</li>
<li>检测方法：通过Go自带的工具pprof或者使用Gops去检测诊断当前在系统上运行的Go进程的占用的资源</li>
</ul>
<h4 id="14-Goroutine和KernelThread之间是什么关系"><a href="#14-Goroutine和KernelThread之间是什么关系" class="headerlink" title="14. Goroutine和KernelThread之间是什么关系"></a>14. Goroutine和KernelThread之间是什么关系</h4><h4 id="15-协程和线程和进程的区别"><a href="#15-协程和线程和进程的区别" class="headerlink" title="15. 协程和线程和进程的区别"></a>15. 协程和线程和进程的区别</h4><ul>
<li>进程：是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。<br>每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全</li>
<li>线程：是进程的一个实体，线程是内核态，而且是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据</li>
<li>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</li>
</ul>
<h4 id="16-G0的作用"><a href="#16-G0的作用" class="headerlink" title="16. G0的作用"></a>16. G0的作用</h4><ul>
<li>在Go中g0作为一个特殊的goroutine，为scheduler执行调度循环提供了场地（栈）。对于一个线程来说，g0总是它第一个创建的 goroutine。之后，它会不断地寻找其他普通的goroutine来执行，直到进程退出</li>
<li>当需要执行一些任务，且不想扩栈时，就可以用到 g0了，因为g0的栈比较大</li>
<li>g0 其他的一些“职责”有：创建 <code>goroutine</code>、<code>deferproc</code> 函数里新建 <code>_defer</code>、垃圾回收相关的工作（例如stw、扫描goroutine的执行栈、一些标识清扫的工作、栈增长）等等</li>
</ul>
<h4 id="17-Golang的内存模型中为什么小对象多了会造成GC压力"><a href="#17-Golang的内存模型中为什么小对象多了会造成GC压力" class="headerlink" title="17. Golang的内存模型中为什么小对象多了会造成GC压力"></a>17. Golang的内存模型中为什么小对象多了会造成GC压力</h4><p>通常小对象过多会导致GC三色法消耗过多的CPU。优化思路：减少对象分配</p>
<h4 id="18-Go的对象在内存中是怎样分配的"><a href="#18-Go的对象在内存中是怎样分配的" class="headerlink" title="18. Go的对象在内存中是怎样分配的"></a>18. Go的对象在内存中是怎样分配的</h4><h4 id="19-栈的内存是怎么分配的"><a href="#19-栈的内存是怎么分配的" class="headerlink" title="19. 栈的内存是怎么分配的"></a>19. 栈的内存是怎么分配的</h4><h4 id="20-堆内存管理怎么分配的"><a href="#20-堆内存管理怎么分配的" class="headerlink" title="20. 堆内存管理怎么分配的"></a>20. 堆内存管理怎么分配的</h4><h4 id="21-在Go函数中为什么会发生内存泄露"><a href="#21-在Go函数中为什么会发生内存泄露" class="headerlink" title="21. 在Go函数中为什么会发生内存泄露"></a>21. 在Go函数中为什么会发生内存泄露</h4><p>同上13</p>
<h4 id="22-Go语言的栈空间管理是怎么样的"><a href="#22-Go语言的栈空间管理是怎么样的" class="headerlink" title="22. Go语言的栈空间管理是怎么样的"></a>22. Go语言的栈空间管理是怎么样的</h4><h4 id="23-Go中的逃逸分析是什么"><a href="#23-Go中的逃逸分析是什么" class="headerlink" title="23. Go中的逃逸分析是什么"></a>23. Go中的逃逸分析是什么</h4><h4 id="24-Go函数返回局部变量的指针是否安全"><a href="#24-Go函数返回局部变量的指针是否安全" class="headerlink" title="24. Go函数返回局部变量的指针是否安全"></a>24. Go函数返回局部变量的指针是否安全</h4><p>在Go中是安全的，Go编译器将会对每个局部变量进行逃逸分析。如果发现局部变量的作用域超出该函数，则不会将内存分配在栈上，而是分配在堆上</p>
<h4 id="25-Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量"><a href="#25-Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量" class="headerlink" title="25. Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量"></a>25. Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量</h4><p>Golang中Goroutine可以通过Channel进行安全读写共享变量，还可以通过原子性操作进行</p>
<h4 id="26-Go中的锁有哪些"><a href="#26-Go中的锁有哪些" class="headerlink" title="26. Go中的锁有哪些"></a>26. Go中的锁有哪些</h4><p>Go中的三种锁包括：</p>
<ul>
<li>互斥锁</li>
<li>读写锁</li>
<li>sync.Map安全锁</li>
</ul>
<ol>
<li><p>互斥锁</p>
<p>Go并发程序对共享资源进行访问控制的主要手段，由标准库代码包中sync中的Mutex结构体表示，sync.Mutex包中的类型只有两个公开的指针方法Lock和Unlock</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Locker表示可以锁定和解锁的对象。</span></span><br><span class="line"> <span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 锁定当前的互斥量</span></span><br><span class="line"> <span class="comment">// 如果锁已被使用，则调用goroutine</span></span><br><span class="line"> <span class="comment">// 阻塞直到互斥锁可用。</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() </span><br><span class="line"></span><br><span class="line"> <span class="comment">// 对当前互斥量进行解锁</span></span><br><span class="line"> <span class="comment">// 如果在进入解锁时未锁定m，则为运行时错误。</span></span><br><span class="line"> <span class="comment">// 锁定的互斥锁与特定的goroutine无关。</span></span><br><span class="line"> <span class="comment">// 允许一个goroutine锁定Mutex然后安排另一个goroutine来解锁它。</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock()</span><br></pre></td></tr></table></figure>

<p>如果对一个已经上锁的对象再次上锁，那么就会导致该锁定操作被阻塞，直到该互斥锁回到被解锁状态。互斥锁锁定操作的逆操作并不会导致协程阻塞，但是有可能导致引发一个无法恢复的运行时的panic，比如对一个未锁定的互斥锁进行解锁时就会发生panic。避免这种情况的最有效方式就是使用defer</p>
<hr>
</li>
<li><p>读写锁</p>
<p>读写锁是针对读写操作的互斥锁，可以分别针对读操作与写操作进行锁定和解锁操作 。读写锁的访问控制规则如下：</p>
<ul>
<li>多个写操作之间是互斥的</li>
<li>写操作与读操作之间也是互斥的</li>
<li>多个读操作之间不是互斥的</li>
</ul>
<p>在这样的控制规则下，读写锁可以大大降低性能损耗。sync中的RWMutex有以下几种方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对读操作的锁定</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//对读操作的解锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//对写操作的锁定</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//对写操作的解锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个实现了sync.Locker接口类型的值，实际上是回调rw.RLock and rw.RUnlock.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLocker() Locker</span><br></pre></td></tr></table></figure>

<ul>
<li>若对一个未被写锁定的读写锁进行写解锁，就会引发一个不可恢复的panic，同理对一个未被读锁定的读写锁进行读写锁也会如此。</li>
<li>由于读写锁控制下的多个读操作之间不是互斥的，因此对于读解锁更容易被忽视。对于同一个读写锁，添加多少个读锁定，就必要有等量的读解锁，这样才能其他协程有机会进行操作</li>
<li>因此Go中读写锁，在多个读线程可以同时访问共享数据,写线程必须等待所有读线程都释放锁以后，才能取得锁</li>
<li>同样的，读线程必须等待写线程释放锁后，才能取得锁，也就是说读写锁要确保的是如下互斥关系，可以同时读，但是读-写，写-写都是互斥的</li>
</ul>
<hr>
</li>
<li><p>sync.Map安全锁</p>
<p>golang中的sync.Map是并发安全的，其实也就是sync包中golang自定义的一个名叫Map的结构体</p>
<ul>
<li>Delete 方法</li>
<li>Store 方法</li>
<li>Load方法</li>
</ul>
<p>sync.Map是通过冗余的两个数据结构(read、dirty)，实现性能的提升。为了提升性能，load、delete、store等操作尽量使用只读的read；为了提高read的key击中概率，采用动态调整，将dirty数据提升为read；对于数据的删除，采用延迟标记删除法，只有在提升dirty的时候才删除</p>
</li>
</ol>
<h4 id="27-Go中的锁如何实现"><a href="#27-Go中的锁如何实现" class="headerlink" title="27. Go中的锁如何实现"></a>27. Go中的锁如何实现</h4><h4 id="28-Go中数据竞争问题怎么解决"><a href="#28-Go中数据竞争问题怎么解决" class="headerlink" title="28. Go中数据竞争问题怎么解决"></a>28. Go中数据竞争问题怎么解决</h4><ul>
<li>数据竞争问题可以使用互斥锁sync.Mutex，或者也可以通过CAS无锁并发解决</li>
<li>其中使用同步访问共享数据或者CAS无锁并发是处理数据竞争的一种有效的方法</li>
<li>golang在1.1之后引入了竞争检测机制，可以使用 <code>go run -race</code> 或者 <code>go build -race</code>来进行静态检测。其在内部的实现是，开启多个协程执行同一个命令， 并且记录下每个变量的状态</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> test -race mypkg    <span class="comment">// 测试包</span></span><br><span class="line"><span class="keyword">go</span> run -race mysrc.<span class="keyword">go</span>  <span class="comment">// 编译和运行程序</span></span><br><span class="line"><span class="keyword">go</span> build -race mycmd   <span class="comment">// 构建程序</span></span><br><span class="line"><span class="keyword">go</span> install -race mypkg <span class="comment">// 安装程序</span></span><br></pre></td></tr></table></figure>

<h4 id="29-Go中CAS是怎么回事"><a href="#29-Go中CAS是怎么回事" class="headerlink" title="29. Go中CAS是怎么回事"></a>29. Go中CAS是怎么回事</h4><h4 id="30-Go主协程如何等其余协程完再操作"><a href="#30-Go主协程如何等其余协程完再操作" class="headerlink" title="30. Go主协程如何等其余协程完再操作"></a>30. Go主协程如何等其余协程完再操作</h4><ul>
<li>Go提供了更简单的方法——使用<code>sync.WaitGroup</code>。<code>WaitGroup</code>，就是用来等待一组操作完成的。<code>WaitGroup</code>内部实现了一个计数器，用来记录未完成的操作个数</li>
<li>它提供了三个方法，<code>Add()</code>用来添加计数。<code>Done()</code>用来在操作结束时调用，使计数减一。<code>Wait()</code>用来等待所有的操作结束，即计数变为0，该函数会在计数不为0时等待，在计数为0时立即返回</li>
</ul>
<h4 id="31-Context包的用途是什么"><a href="#31-Context包的用途是什么" class="headerlink" title="31. Context包的用途是什么"></a>31. Context包的用途是什么</h4><h4 id="32-Go中对nil的Slice和空Slice的处理是一致的吗"><a href="#32-Go中对nil的Slice和空Slice的处理是一致的吗" class="headerlink" title="32. Go中对nil的Slice和空Slice的处理是一致的吗"></a>32. Go中对nil的Slice和空Slice的处理是一致的吗</h4><p>首先Go的JSON 标准库对 <code>nil slice</code> 和 空 <code>slice</code> 的处理是不一致</p>
<p>通常错误的用法，会报数组越界的错误，因为只是声明了slice，却没有给实例化的对象。nil的slice定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>此时slice的值是nil，这种情况可以用于需要返回slice的函数，当函数出现异常的时候，保证函数依然会有nil的返回值</p>
<hr>
<p>空的slice是指slice不为nil，但是slice没有值，slice的底层的空间是空的，空的slice定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>）</span><br><span class="line">slice := []<span class="type">int</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>当我们查询或者处理一个空的列表的时候，这非常有用，它会告诉我们返回的是一个列表，但是列表内没有任何值</p>
<p><strong>总结：</strong> nil的slice和空的slice是不同的东西，需要我们加以区分</p>
<h4 id="33-Go的Slice如何扩容"><a href="#33-Go的Slice如何扩容" class="headerlink" title="33. Go的Slice如何扩容"></a>33. Go的Slice如何扩容</h4><ul>
<li>slice是Go中的一种基本的数据结构，使用这种结构可以用来管理数据集合。但是slice本身并不是动态数据或者数组指针。slice常见的操作有 reslice、append、copy</li>
<li>slice自身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。slice本身是一个只读对象，其工作机制类似数组指针的一种封装</li>
<li>slice是对数组一个连续片段的引用，所以切片是一个引用类型。这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集</li>
<li>slice的结构体由3部分构成，Pointer 是指向一个数组的指针，len 代表当前切片的长度，cap 是当前切片的容量。cap 总是大于等于 len 的</li>
</ul>
<p>通常我们在对slice进行append等操作时，可能会造成slice的自动扩容</p>
<ul>
<li><strong>1.18版本之前：</strong> 当原slice容量小于1024的时候，新slice容量变成原来的2倍；原slice容量超过1024，新slice容量变成原来的1.25倍</li>
<li><strong>1.18版本之后：</strong> 当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的2倍；原slice容量超过256，新slice容量newcap &#x3D; oldcap+(oldcap+3*256)&#x2F;4</li>
<li><strong>最后：</strong> 扩容后的容量并不一定就是按照以上公式计算的结果，容量可能会存在小的差异，主要原因是扩容后会有内存对齐，导致容量不是百分百按照公式计算的结果。如果扩容之后，还没有触及原数组的容量，那么，切片中的指针指向的位置，就还是原数组，如果扩容之后，超过了原数组的容量，那么，Go就会开辟一块新的内存，把原来的值拷贝过来，这种情况丝毫不会影响到原数组</li>
</ul>
<h4 id="34-Go的Struct能不能比较"><a href="#34-Go的Struct能不能比较" class="headerlink" title="34. Go的Struct能不能比较"></a>34. Go的Struct能不能比较</h4><ul>
<li>相同struct类型的可以比较</li>
<li>不同struct类型的不可以比较，编译都不过，类型不匹配</li>
</ul>
<h4 id="35-Go中的map的实现"><a href="#35-Go中的map的实现" class="headerlink" title="35. Go中的map的实现"></a>35. Go中的map的实现</h4><h4 id="36-Go中的map如何实现顺序读取"><a href="#36-Go中的map如何实现顺序读取" class="headerlink" title="36. Go中的map如何实现顺序读取"></a>36. Go中的map如何实现顺序读取</h4><p>Go中map如果要实现顺序读取的话，先把map中的key添加到数组（array）或切片（slice）中，然后通过sort包对数组或切片进行排序，最后在遍历数组或切片的时候将map中key所对应的value取出来</p>
<h4 id="37-Go中new和make的区别"><a href="#37-Go中new和make的区别" class="headerlink" title="37. Go中new和make的区别"></a>37. Go中new和make的区别</h4><ul>
<li>值类型：int，float，bool，string，struct和array。变量直接存储值，分配栈区的内存空间，这些变量所占据的空间在函数被调用完后会自动释放</li>
<li>引用类型：slice，map，chan和值类型对应的指针。变量存储的是一个地址（或者理解为指针），指针指向内存中真正存储数据的首地址。内存通常在堆上分配，通过GC回收</li>
<li><strong>注意：</strong> 对于引用类型的变量，我们不仅要声明变量，更重要的是，我们得手动为它分配空间</li>
</ul>
<ol>
<li>new该方法的参数要求传入一个类型，而不是一个值，它会申请一个该类型大小的内存空间，并会初始化为对应的零值，返回指向该内存空间的一个指针</li>
<li>make也是用于内存分配，但是和new不同，只用来引用对象slice、map和channel的内存创建，它返回的类型就是类型本身，而不是它们的指针类型</li>
</ol>
<h4 id="38-Go的defer原理是什么"><a href="#38-Go的defer原理是什么" class="headerlink" title="38. Go的defer原理是什么"></a>38. Go的defer原理是什么</h4><h4 id="39-Go的select可以用于什么"><a href="#39-Go的select可以用于什么" class="headerlink" title="39. Go的select可以用于什么"></a>39. Go的select可以用于什么</h4><h4 id="40-Go值接收者和指针接收者的区别"><a href="#40-Go值接收者和指针接收者的区别" class="headerlink" title="40. Go值接收者和指针接收者的区别"></a>40. Go值接收者和指针接收者的区别</h4><h4 id="41-Go中两个Nil可能不相等吗"><a href="#41-Go中两个Nil可能不相等吗" class="headerlink" title="41. Go中两个Nil可能不相等吗"></a>41. Go中两个Nil可能不相等吗</h4><h4 id="42-Golang垃圾回收算法"><a href="#42-Golang垃圾回收算法" class="headerlink" title="42. Golang垃圾回收算法"></a>42. Golang垃圾回收算法</h4><p>Golang1.5版本后，采取的是“非分代的、非移动的、并发的、三色的”标记清除垃圾回收算法</p>
<p>垃圾回收算法分类：</p>
<ul>
<li>引用计数</li>
<li>标记-清除</li>
<li>分代回收</li>
</ul>
<p>golang的垃圾回收是基于标记清扫算法，这种算法需要进行 STW（stop the world)，这个过程就会导致程序是卡顿的，频繁的 GC 会严重影响程序性能，golang在此基础上进行了改进，通过三色标记清扫法与写屏障来减少STW的时间</p>
<p>gc的过程一共分为四个阶段：</p>
<ol>
<li>栈扫描（开始时STW） 所有对象最开始都是白色</li>
<li>从 root 开始找到所有可达对象，标记为灰色，放入待处理队列</li>
<li>遍历灰色对象队列，将其引用对象标记为灰色放入待处理队列，自身标记为黑色</li>
<li>清除（并发） 循环步骤3直到灰色队列为空为止，此时所有引用对象都被标记为黑色，所有不可达的对象依然为白色，白色的就是需要进行回收的对象</li>
</ol>
<p>三色标记法相对于普通标记清扫，减少了STW时间. 这主要得益于标记过程是 “on-the-fly” 的，在标记过程中是不需要STW的，它与程序是并发执行的，这就大大缩短了STW的时间</p>
<p>写屏障：</p>
<ul>
<li>当标记和程序是并发执行的，这就会造成一个问题. 在标记过程中，有新的引用产生，可能会导致误清扫</li>
<li>清扫开始前，标记为黑色的对象引用了一个新申请的对象，它肯定是白色的，而黑色对象不会被再次扫描，那么这个白色对象无法被扫描变成灰色、黑色，它就会最终被清扫，而实际它不应该被清扫</li>
<li>golang采用了写屏障，其作用就是为了避免这类误清扫问题. 写屏障即在内存写操作前，维护一个约束，从而确保清扫开始前，黑色的对象不能引用白色对象</li>
</ul>
<h4 id="43-GC的触发条件"><a href="#43-GC的触发条件" class="headerlink" title="43. GC的触发条件"></a>43. GC的触发条件</h4><ul>
<li>主动触发(手动触发)，通过调用<code>runtime.GC</code> 来触发<code>GC</code>，此调用阻塞式地等待当前<code>GC</code>运行完毕.</li>
<li>被动触发，分为两种方式：<ul>
<li>使用系统监控，当超过两分钟没有产生任何<code>GC</code>时，强制触发 <code>GC</code></li>
<li>使用步调（Pacing）算法，其核心思想是控制内存增长的比例,当前内存分配达到一定比例则触发</li>
</ul>
</li>
</ul>
<h4 id="44-Go中的http包的实现原理"><a href="#44-Go中的http包的实现原理" class="headerlink" title="44. Go中的http包的实现原理"></a>44. Go中的http包的实现原理</h4><h4 id="45-Go中的defer函数使用下面的两种情况下结果是什么"><a href="#45-Go中的defer函数使用下面的两种情况下结果是什么" class="headerlink" title="45. Go中的defer函数使用下面的两种情况下结果是什么"></a>45. Go中的defer函数使用下面的两种情况下结果是什么</h4><hr>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法面试题</title>
    <url>/2022/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>计算机网络面试题</title>
    <url>/2022/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>计算机网络常见面试题</p>
<h4 id="1-OSI七层模型，TCP-x2F-IP四层模型，五层协议"><a href="#1-OSI七层模型，TCP-x2F-IP四层模型，五层协议" class="headerlink" title="1. OSI七层模型，TCP&#x2F;IP四层模型，五层协议"></a>1. OSI七层模型，TCP&#x2F;IP四层模型，五层协议</h4><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7m5w06lbkj313n0iawpi.jpg" alt="69.jpg" style="zoom:55%;" /></div>

<h5 id="1-1-OSI七层模型"><a href="#1-1-OSI七层模型" class="headerlink" title="1.1 OSI七层模型"></a>1.1 OSI七层模型</h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7m5mu30e3j30v41834qp.jpg" alt="1.jpeg" style="zoom:80%;" /></div>

<h5 id="1-2-TCP-x2F-IP四层模型"><a href="#1-2-TCP-x2F-IP四层模型" class="headerlink" title="1.2 TCP&#x2F;IP四层模型"></a>1.2 TCP&#x2F;IP四层模型</h5><ul>
<li>它只有四层，相当于五层协议中<strong>数据链路层和物理层合并为网络接口层</strong></li>
<li>现在的 TCP&#x2F;IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层</li>
<li>TCP&#x2F;IP 协议族是一种沙漏形状，中间小两边大，IP 协议在其中占用举足轻重的地位</li>
</ul>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7m62vqibaj324q0v8amp.jpg" alt="image.png" style="zoom:20%;" /></div>

<h5 id="1-3-五层协议"><a href="#1-3-五层协议" class="headerlink" title="1.3 五层协议"></a>1.3 五层协议</h5><ul>
<li><strong>应用层：</strong> 提供用户接口，特指能够发起网络流量的程序，比如客户端程序：QQ，MSN，浏览器等；服务器程序：web服务器，邮件服务器，流媒体服务器等等。数据单位为报文</li>
<li><strong>传输层：</strong> 提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议</li>
<li><strong>网络层：</strong> 为主机间提供数据传输服务，而运输层协议是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组</li>
<li><strong>数据链路层：</strong> 不同的网络类型，发送数据的机制不同，数据链路层就是将数据包封装成能够在不同的网络传输的帧。能够进行差错检验，但不纠错，监测处错误丢掉该帧</li>
<li><strong>物理层：</strong> 物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的主要任务描述为：确定与传输媒体的接口的一些特性</li>
</ul>
<h4 id="2-TCP和UDP有什么区别"><a href="#2-TCP和UDP有什么区别" class="headerlink" title="2. TCP和UDP有什么区别"></a>2. TCP和UDP有什么区别</h4><ul>
<li>TCP面向连接（如打电话要先拨号建立连接）；UDP是无连接的，即发送数据之前不需要建立连接</li>
<li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付.</li>
<li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文的</li>
<li>每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信</li>
<li>TCP首部开销20字节；UDP的首部开销小，只有8个字节</li>
<li>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</li>
</ul>
<p>TCP使用场景：</p>
<ul>
<li>相对于 UDP，TCP 实现了数据传输过程中的各种控制，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。在对可靠性要求较高的情况下，可以使用 TCP，即不考虑 UDP 的时候，都可以选择 TCP</li>
</ul>
<hr>
<p>UDP使用场景：</p>
<ul>
<li>包总量较小的通信（DNS、SNMP）</li>
<li>视频、音频等多媒体通信（即时通信）</li>
<li>广播通信</li>
</ul>
<h4 id="3-TCP中三次握手和四次挥手"><a href="#3-TCP中三次握手和四次挥手" class="headerlink" title="3. TCP中三次握手和四次挥手"></a>3. TCP中三次握手和四次挥手</h4><h5 id="3-1-三次握手"><a href="#3-1-三次握手" class="headerlink" title="3.1 三次握手"></a>3.1 三次握手</h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7m6hb6w0oj318a0o6qau.jpg" alt="75.jpg" style="zoom:30%;" /></div>

<p>假设 A 为客户端，B 为服务器端：</p>
<ul>
<li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求</li>
<li>A 向 B 发送连接请求报文段，<code>SYN=1</code>，<code>ACK=0</code>，选择一个初始的序号 <code>seq = x</code></li>
<li>B 收到连接请求报文段，如果同意建立连接，则向 A 发送连接确认报文段，<code>SYN=1</code>，<code>ACK=1</code>，确认号为 <code>x+1</code>，同时也选择一个初始的序号 <code>seq = y</code></li>
<li>A 收到 B 的连接确认报文段后，还要向 B 发出确认，确认号为 <code>ack = y+1</code>，序号为 <code>seq = x+1</code></li>
<li>A 的 TCP 通知上层应用进程，连接已经建立。</li>
<li>B 收到 A 的确认后，连接建立。</li>
<li>B 的 TCP 收到主机 A 的确认后，也通知其上层应用进程：TCP 连接已经建立</li>
</ul>
<p><strong>为什么TCP连接需要三次握手，两次不可以吗?</strong></p>
<ul>
<li>TCP是一个双向通信协议，通信双方都有能力发送信息，并接收响应。如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认</li>
<li>为了防止已失效的连接请求报文段突然又传送到了服务端，占用服务器资源<ul>
<li>现假定出现一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络节点长时间滞留了，以致延误到连接释放以后的某个时间才到B。本来这是一个已失效的报文段。但是B收到此失效的连接请求报文段后，就误认为是A有发出一次新的连接请求。于是就向A发出确认报文段，同意建立连接。假定不采用三次握手，那么只要B发出确认，新的连接就建立了</li>
<li>由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据。但B却以为新的运输连接已经建立了，并一直等待A发来数据。B的许多资源就这样白白浪费了</li>
<li>采用三次握手的办法可以防止上述现象的发生。例如在刚才的情况下，A不会向B的确认发出确认。B由于收不到确认，就知道A并没有要求建立连接</li>
</ul>
</li>
</ul>
<h5 id="3-2-四次挥手"><a href="#3-2-四次挥手" class="headerlink" title="3.2 四次挥手"></a>3.2 四次挥手</h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7m6m8l61xj31hc0u0h05.jpg" alt="76.jpg" style="zoom:30%;" /></div>

<p>数据传输结束后，通信的双方都可释放连接。现在 A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP连接</p>
<ul>
<li>A 把连接释放报文段首部的 <code>FIN = 1</code>，其序号 <code>seq = u</code>，等待 B 的确认。</li>
<li>B 发出确认，确认号 <code>ack = u+1</code>，而这个报文段自己的序号 <code>seq = v</code>。（TCP 服务器进程通知高层应用进程）</li>
<li>从 A 到 B 这个方向的连接就释放了，TCP 连接处于半关闭状态。A 不能向 B 发送数据；B 若发送数据，A 仍要接收</li>
<li>当 B 不再需要连接时，发送连接释放请求报文段，FIN&#x3D;1。</li>
<li>A 收到后发出确认，进入<code>TIME-WAIT</code>状态，等待 <code>2 MSL（2*2 = 4 mins）</code>时间后释放连接。</li>
<li>B 收到 A 的确认后释放连接</li>
</ul>
<p><strong>为什么需要四次挥手</strong></p>
<ul>
<li>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 <code>CLOSE-WAIT</code>状态</li>
<li>这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文</li>
</ul>
<h4 id="4-常见的HTTP状态码有哪些"><a href="#4-常见的HTTP状态码有哪些" class="headerlink" title="4. 常见的HTTP状态码有哪些"></a>4. 常见的HTTP状态码有哪些</h4><table>
<thead>
<tr>
<th align="left">状态码</th>
<th align="left">类别</th>
<th align="left">原因短语</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1XX</td>
<td align="left">Informational（信息性状态码）</td>
<td align="left">接收的请求正在处理</td>
</tr>
<tr>
<td align="left">2XX</td>
<td align="left">Success（成功状态码）</td>
<td align="left">请求正常处理完毕</td>
</tr>
<tr>
<td align="left">3XX</td>
<td align="left">Redirection（重定向状态码）</td>
<td align="left">需要进行附加操作以完成请求</td>
</tr>
<tr>
<td align="left">4XX</td>
<td align="left">Client Error（客户端错误状态码）</td>
<td align="left">服务器无法处理请求</td>
</tr>
<tr>
<td align="left">5XX</td>
<td align="left">Server Error（服务器错误状态码）</td>
<td align="left">服务器处理请求出错</td>
</tr>
</tbody></table>
<ul>
<li>1XX：<ul>
<li><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应</li>
</ul>
</li>
<li>2XX：<ul>
<li><strong>200 OK</strong></li>
<li><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用</li>
<li><strong>206 Partial Content</strong> ：表示客户端进行了范围请求。响应报文包含由 Content-Range 指定范围的实体内容</li>
</ul>
</li>
<li>3XX：<ul>
<li><strong>301 Moved Permanently</strong> ：永久性重定向</li>
<li><strong>302 Found</strong> ：临时性重定向</li>
<li>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法</li>
<li><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源</li>
<li><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码</li>
<li><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法</li>
</ul>
</li>
<li>4XX：<ul>
<li><strong>400 Bad Request</strong> ：请求报文中存在语法错误</li>
<li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败</li>
<li><strong>403 Forbidden</strong> ：请求被拒绝，服务器端没有必要给出拒绝的详细理由</li>
<li><strong>404 Not Found</strong></li>
</ul>
</li>
<li>5XX：<ul>
<li><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误</li>
<li><strong>502 Bad Gateway</strong> : 是用来表示代理或网关在处理请求时发生了错误，并不一定是原始服务器出现了问题</li>
<li><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</li>
<li><strong>504 Gateway Timeout</strong>：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应</li>
</ul>
</li>
</ul>
<p><strong>注意：某些代理服务器在DNS查询超时时会返回400或者500错误</strong></p>
<h4 id="5-HTTPS和HTTP有什么区别"><a href="#5-HTTPS和HTTP有什么区别" class="headerlink" title="5. HTTPS和HTTP有什么区别"></a>5. HTTPS和HTTP有什么区别</h4><p>http协议和https协议的区别：<strong>传输信息安全性不同</strong>、<strong>连接方式不同</strong>、<strong>端口不同</strong>、<strong>证书专申请方式不同</strong></p>
<ul>
<li>传输信息安全性不同<ul>
<li>http协议：是超文本传输协议，信息是明文传输。如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息</li>
<li>https协议：是具有安全性的SSL&#x2F;TLS加密传输协议，为浏览器和服务器之间的通信加密，确保数据传输的安全性</li>
</ul>
</li>
<li>连接方式不同<ul>
<li>http协议：http的连接很简单，是无状态的，客户端和服务器端都无法验证对方的身份</li>
<li>https协议：是由SSL&#x2F;TLS＋HTTP协议构建的可进行加密传输、身份认证的网络协议。客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份</li>
</ul>
</li>
<li>端口不同<ul>
<li>http协议：使用的端口是80</li>
<li>https协议：使用的端口是443</li>
</ul>
</li>
<li>证书申请方式不同<ul>
<li>http协议：无需申请证书</li>
<li>https协议：需要到ca申请证书，一般免费证书很少，需要交费</li>
</ul>
</li>
</ul>
<h4 id="6-HTTP-x2F-HTPS安全性"><a href="#6-HTTP-x2F-HTPS安全性" class="headerlink" title="6. HTTP&#x2F;HTPS安全性"></a>6. HTTP&#x2F;HTPS安全性</h4><h5 id="6-1-HTTP的安全性问题"><a href="#6-1-HTTP的安全性问题" class="headerlink" title="6.1 HTTP的安全性问题"></a>6.1 HTTP的安全性问题</h5><ul>
<li>使用明文进行通信，内容可能会被窃听</li>
<li>不验证通信方的身份，通信方的身份有可能遭遇伪装</li>
<li>无法证明报文的完整性，报文有可能遭篡改</li>
</ul>
<hr>
<p>HTTPs（Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲HTTPs是HTTP的安全版。HTTPs 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信。也就是说 HTTPs 使用了隧道进行通信。通过使用 SSL，HTTPs 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）</p>
<h5 id="6-2-对称密钥加密"><a href="#6-2-对称密钥加密" class="headerlink" title="6.2 对称密钥加密"></a>6.2 对称密钥加密</h5><p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥</p>
<ul>
<li>优点：运算速度快；</li>
<li>缺点：无法安全地将密钥传输给通信方</li>
</ul>
<h5 id="6-3-非对称密钥加密"><a href="#6-3-非对称密钥加密" class="headerlink" title="6.3 非对称密钥加密"></a>6.3 非对称密钥加密</h5><p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密</p>
<p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确</p>
<ul>
<li>优点：可以更安全地将公开密钥传输给通信发送方</li>
<li>缺点：运算速度慢</li>
</ul>
<h5 id="6-4-HTTPs-采用的加密方式"><a href="#6-4-HTTPs-采用的加密方式" class="headerlink" title="6.4 HTTPs 采用的加密方式"></a>6.4 HTTPs 采用的加密方式</h5><p>HTTPs 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证安全性，之后使用对称密钥加密进行通信来保证效率</p>
<h4 id="7-SSL-x2F-TLS协议的握手过程"><a href="#7-SSL-x2F-TLS协议的握手过程" class="headerlink" title="7. SSL&#x2F;TLS协议的握手过程"></a>7. SSL&#x2F;TLS协议的握手过程</h4><p>我们知道，HTTP 协议都是明文传输内容，在早期只展示静态内容时没有问题。伴随着互联网的快速发展，人们对于网络传输安全性的要求也越来越高，HTTPS 协议因此出现。如上图所示，在 HTTPS 加密中真正起作用的其实是 SSL&#x2F;TLS 协议。SSL&#x2F;TLS 协议作用在 HTTP 协议之下，对于上层应用来说，原来的发送接收数据流程不变，这就很好地兼容了老的 HTTP 协议，这也是软件开发中分层实现的体现</p>
<h5 id="7-1-SSL-Secure-Socket-Layer，安全套接字层"><a href="#7-1-SSL-Secure-Socket-Layer，安全套接字层" class="headerlink" title="7.1 SSL (Secure Socket Layer，安全套接字层)"></a>7.1 SSL (Secure Socket Layer，安全套接字层)</h5><p>SSL为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取，当前为3.0版本</p>
<p>SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等</p>
<h5 id="7-2-TLS-Transport-Layer-Security，传输层安全协议"><a href="#7-2-TLS-Transport-Layer-Security，传输层安全协议" class="headerlink" title="7.2 TLS (Transport Layer Security，传输层安全协议)"></a>7.2 TLS (Transport Layer Security，传输层安全协议)</h5><p>用于两个应用程序之间提供保密性和数据完整性</p>
<p>TLS 1.0是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本，可以理解为SSL 3.1，它是写入了 RFC 的。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面</p>
<h5 id="7-3-握手过程"><a href="#7-3-握手过程" class="headerlink" title="7.3 握手过程"></a>7.3 握手过程</h5><ul>
<li><p><strong>1-client hello：</strong> 握手第一步是客户端向服务端发送 Client Hello 消息，这个消息里包含了一个客户端生成的随机数 <strong>Random1</strong>、客户端支持的<strong>加密套件</strong>（Support Ciphers）和 SSL Version 等信息</p>
</li>
<li><p><strong>2-server hello：</strong> 第二步是服务端向客户端发送 Server Hello 消息，这个消息会从 Client Hello 传过来的 Support Ciphers 里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法，另外还会生成一份随机数 <strong>Random2</strong>。注意，至此客户端和服务端都拥有了两个随机数（Random1+ Random2），这两个随机数会在后续生成对称秘钥时用到</p>
</li>
<li><p><strong>3-server certificate：</strong> 这一步是服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥</p>
</li>
<li><p><strong>4-Server Hello Done：</strong> Server Hello Done 通知客户端 Server Hello 过程结束</p>
</li>
<li><p><strong>5-Client Key Exchange：</strong> 上面客户端根据服务器传来的公钥生成了 <strong>PreMaster Key</strong>，Client Key Exchange 就是将这个 key 传给服务端，服务端再用自己的私钥解出这个 <strong>PreMaster Key</strong> 得到客户端生成的 <strong>Random3</strong>。至此，客户端和服务端都拥有 <strong>Random1</strong> + <strong>Random2</strong> + <strong>Random3</strong>，两边再根据同样的算法就可以生成一份秘钥，握手结束后的应用层数据都是使用这个秘钥进行对称加密。为什么要使用三个随机数呢？这是因为 SSL&#x2F;TLS 握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解出来</p>
</li>
<li><p><strong>6-Change Cipher Spec(Client)：</strong> 这一步是客户端通知服务端后面再发送的消息都会使用前面协商出来的秘钥加密了，是一条事件消息</p>
</li>
<li><p><strong>7-Finished(Client)：</strong> 客户端发送Finished报文。该报文包含连接至今全部报文的整理校验值。这次握手协议是否能成功，要以服务器是否能够正确解密该报文作为判定标准</p>
</li>
<li><p><strong>8-Change Cipher Spec(Server)：</strong> 服务器同样发送Change Cipher Spec报文给客户端</p>
</li>
<li><p><strong>9-Finished(Server)：</strong> 服务器同样发送Finished报文给客户端</p>
</li>
<li><p><strong>10-11Application Data：</strong> 到这里，双方已安全地协商出了同一份秘钥，所有的应用层数据都会用这个秘钥加密后再通过 TCP 进行可靠传输</p>
</li>
<li><p><strong>12-Alert：warning, close notify：</strong> 最后由客户端断开连接。断开连接时，发送close_notify报文。上图做了一些省略，在这步之后再发送一种叫做MAC（Message Authentication Code）的报文摘要。MAC能够查知报文是否遭到篡改，从而保护报文的完整性</p>
</li>
</ul>
<h4 id="8-Get和Post区别"><a href="#8-Get和Post区别" class="headerlink" title="8. Get和Post区别"></a>8. Get和Post区别</h4><ul>
<li><p>一般约束为：GET是从服务器上获取数据，POST是向服务器传送数据</p>
</li>
<li><p>Get是不安全的，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的</p>
</li>
<li><p>Get传送的数据量较小，这主要是因为受URL长度限制；Post传送的数据量较大，一般被默认为不受限制</p>
</li>
<li><p>Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集</p>
</li>
<li><p>Get执行效率却比Post方法好。Get是form提交的默认方法</p>
</li>
<li><p>GET产生一个TCP数据包；POST产生两个TCP数据包（非必然，客户端可灵活决定）</p>
</li>
</ul>
<h4 id="9-从输入网址到获得页面的网络请求过程"><a href="#9-从输入网址到获得页面的网络请求过程" class="headerlink" title="9. 从输入网址到获得页面的网络请求过程"></a>9. 从输入网址到获得页面的网络请求过程</h4><ol>
<li>输入地址</li>
<li>浏览器查找域名的 IP 地址</li>
<li>浏览器向 web 服务器发送一个 HTTP 请求</li>
<li>服务器的永久重定向响应</li>
<li>服务器处理请求</li>
<li>服务器返回一个 HTTP 响应</li>
<li>浏览器显示 HTML</li>
<li>浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）</li>
</ol>
<p><strong>详细解读：</strong> <a href="https://zhuanlan.zhihu.com/p/133906695">点击跳转至网页</a></p>
<h4 id="10-TCP报头格式和UDP报头格式"><a href="#10-TCP报头格式和UDP报头格式" class="headerlink" title="10. TCP报头格式和UDP报头格式"></a>10. TCP报头格式和UDP报头格式</h4><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。运输层提供了进程间的逻辑通信，运输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个运输层实体之间有一条端到端的逻辑通信信道</p>
<ul>
<li><p>TCP和UDP的特点</p>
<ul>
<li><strong>传输控制协议 TCP</strong>（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）</li>
<li><strong>用户数据报协议 UDP</strong>（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。例如：视频传输、实时通信</li>
</ul>
</li>
<li><p>TCP首部格式</p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7m8ophl1uj317p0r3n7l.jpg" alt="74.jpg" style="zoom:30%;" /></div>

<ul>
<li><strong>序号 seq</strong> ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。[301,400]为序号301的数据长度，下一个则为401。</li>
<li><strong>确认号 ack</strong> ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</li>
<li><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度</li>
<li><strong>确认 ACK</strong> ：当 ACK&#x3D;1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1</li>
<li><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当 SYN&#x3D;1，ACK&#x3D;0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN&#x3D;1，ACK&#x3D;1。</li>
<li><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN&#x3D;1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</li>
<li><strong>窗口</strong> ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的</li>
</ul>
</li>
<li><p>UDP首部格式</p>
<p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的</p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7m8rstr7dj31580k211a.jpg" alt="73.jpg" style="zoom:33%;" /></div></li>
</ul>
<h4 id="11-TCP连接中如果断电怎么办"><a href="#11-TCP连接中如果断电怎么办" class="headerlink" title="11. TCP连接中如果断电怎么办"></a>11. TCP连接中如果断电怎么办</h4><p>都已经断电了，还能怎么办，等电来</p>
<h4 id="12-TCP滑动窗口"><a href="#12-TCP滑动窗口" class="headerlink" title="12. TCP滑动窗口"></a>12. TCP滑动窗口</h4><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7mctzf6qaj31hm0setua.jpg" alt="78.jpg" style="zoom:30%;" /></div>

<p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，<strong>接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小</strong></p>
<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口</p>
<p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {32, 33} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收</p>
<h4 id="13-TCP流量控制"><a href="#13-TCP流量控制" class="headerlink" title="13. TCP流量控制"></a>13. TCP流量控制</h4><ul>
<li>流量控制是为了控制发送方发送速率，保证接收方来得及接收</li>
<li>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据</li>
</ul>
<h4 id="14-TCP拥塞处理（Congestion-Handling）"><a href="#14-TCP拥塞处理（Congestion-Handling）" class="headerlink" title="14. TCP拥塞处理（Congestion Handling）"></a>14. TCP拥塞处理（Congestion Handling）</h4><p><strong>拥塞控制的一般原理：</strong></p>
<ul>
<li>在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏——产生拥塞(congestion)。</li>
<li>出现资源拥塞的条件：对资源需求的总和 &gt; 可用资源</li>
<li>若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降</li>
</ul>
<p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度</p>
<p>TCP 主要通过四种算法来进行拥塞控制：<strong>慢开始</strong>、<strong>拥塞避免</strong>、<strong>快重传</strong>、<strong>快恢复</strong></p>
<h4 id="15-TCP的LISTEN状态是什么"><a href="#15-TCP的LISTEN状态是什么" class="headerlink" title="15. TCP的LISTEN状态是什么"></a>15. TCP的LISTEN状态是什么</h4><p>TCP的LISTEN是服务器处于监听状态：</p>
<ul>
<li><strong>CLOSED：</strong> 初始状态</li>
<li><strong>LISTEN：</strong> 服务器处于监听状态</li>
<li><strong>TIME_WAIT：</strong> 客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态</li>
</ul>
<h4 id="16-Tcp中的拆包和粘包是怎么回事"><a href="#16-Tcp中的拆包和粘包是怎么回事" class="headerlink" title="16. Tcp中的拆包和粘包是怎么回事"></a>16. Tcp中的拆包和粘包是怎么回事</h4><ul>
<li><strong>拆包：</strong> 在socket通讯过程中，如果通讯的一端一次性连续发送多条数据包，tcp协议会将多个数据包打包成一个tcp报文发送出去，这就是所谓的粘包</li>
<li><strong>粘包：</strong> 而如果通讯的一端发送的数据包超过一次tcp报文所能传输的最大值时，就会将一个数据包拆成多个最大tcp长度的tcp报文分开传输，这就叫做拆包</li>
</ul>
<h4 id="17-HTTP的请求和响应报文"><a href="#17-HTTP的请求和响应报文" class="headerlink" title="17. HTTP的请求和响应报文"></a>17. HTTP的请求和响应报文</h4><ul>
<li><p>请求报文</p>
<ul>
<li>请求行：由三部分组成（请求方法、请求URL-不包括域名、HTTP版本协议）</li>
<li>请求头：由关键字-值对组成，每行一对</li>
<li>空行：通知服务器以下不再有请求头</li>
<li>请求体</li>
</ul>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7m91nfjb1j30i8065djn.jpg" alt="84.jpg" style="zoom:80%;" /></div>
</li>
<li><p>响应报文</p>
<ul>
<li>响应行：由三部分组成：服务器HTTP协议版本，响应状态码，状态码的文本描述</li>
<li>响应头：由关键字-值对组成，每行一对</li>
<li>空行：通知服务器以下不再有响应头</li>
<li>响应体</li>
</ul>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7m93g347vj30jk07faec.jpg" alt="96.jpg" style="zoom:80%;" /></div></li>
</ul>
<h4 id="18-HTTP方法"><a href="#18-HTTP方法" class="headerlink" title="18. HTTP方法"></a>18. HTTP方法</h4><ul>
<li>GET：获取资源<ul>
<li>当前网络请求中，绝大部分使用的是GET方法</li>
</ul>
</li>
<li>HEAD：获取报文首部<ul>
<li>和GET方法一样，但是不返回报文实体主体部分</li>
<li>主要用于确认 URL 的有效性以及资源更新的日期时间等</li>
</ul>
</li>
<li>POST：传输实体主体<ul>
<li>POST 主要用来传输数据，而 GET 主要用来获取资源</li>
</ul>
</li>
<li>PUT：上传文件<ul>
<li>由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法</li>
</ul>
</li>
<li>PATCH：对资源进行部分修改<ul>
<li>PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改</li>
</ul>
</li>
<li>DELETE：删除文件<ul>
<li>与 PUT 功能相反，并且同样不带验证机制</li>
</ul>
</li>
<li>OPTIONS：查询支持的方法<ul>
<li>查询指定的 URL 能够支持的方法</li>
<li>会返回 Allow：GET，POST，HEAD，OPTIONS 这样的内容</li>
</ul>
</li>
<li>CONNECT：要求在与代理服务器通信时建立隧道<ul>
<li>使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输</li>
</ul>
</li>
<li>TRACE：追踪路径<ul>
<li>服务器会将通信路径返回给客户端</li>
<li>发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输</li>
<li>通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）</li>
</ul>
</li>
</ul>
<h4 id="19-如何理解HTTP协议是无状态的"><a href="#19-如何理解HTTP协议是无状态的" class="headerlink" title="19. 如何理解HTTP协议是无状态的"></a>19. 如何理解HTTP协议是无状态的</h4><ul>
<li>HTTP协议是无状态的（stateless），指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系</li>
<li>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）</li>
<li>缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快</li>
</ul>
<h4 id="20-HTTP2-0特性"><a href="#20-HTTP2-0特性" class="headerlink" title="20. HTTP2.0特性"></a>20. HTTP2.0特性</h4><p>HTTP&#x2F;2的通过支持请求与响应的多路复用来减少延迟，通过压缩HTTP首部字段将协议开销降至最低，同时增加对请求优先级和服务器端推送的支持</p>
<h4 id="21-什么是短连接和长连接"><a href="#21-什么是短连接和长连接" class="headerlink" title="21. 什么是短连接和长连接"></a>21. 什么是短连接和长连接</h4><p>在HTTP&#x2F;1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话</p>
<p>而从HTTP&#x2F;1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure>

<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接</p>
<p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接</p>
<h4 id="22-Client如何实现长连接"><a href="#22-Client如何实现长连接" class="headerlink" title="22. Client如何实现长连接"></a>22. Client如何实现长连接</h4><p>使用TCP协议的<strong>KeepAlive</strong>机制与<strong>HeartBeat</strong>心跳包</p>
<ul>
<li><code>HeartBeat</code>心跳包</li>
<li>TCP协议的<code>KeepAlive</code>机制</li>
</ul>
<h4 id="23-Quic有什么优点相比Http2"><a href="#23-Quic有什么优点相比Http2" class="headerlink" title="23. Quic有什么优点相比Http2"></a>23. Quic有什么优点相比Http2</h4><ul>
<li><strong>HTTP1：</strong> 有连接无法复用、队头阻塞、协议开销大和安全因素等多个缺陷</li>
<li><strong>HTTP2：</strong> 通过多路复用、二进制流、Header 压缩等等技术，极大地提高了性能，但是还是存在着问题的</li>
<li><strong>Quic：</strong> 基于 UDP 实现，是 HTTP3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议.quic中加密认证的报文(TCP 协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改，注入和窃听。比如修改序列号、滑动窗口。这些行为有可能是出于性能优化，也有可能是主动攻击)。这样只要对 QUIC 报文任何修改，接收端都能够及时发现，有效地降低了安全风险</li>
</ul>
<p>此外quic还有向前纠错的能力，QUIC 协议有一个非常独特的特性，称为向前纠错 (Forward Error Correction，FEC)，每个数据包除了它本身的内容之外，还包括了部分其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传。向前纠错牺牲了每个数据包可以发送数据的上限，但是减少了因为丢包导致的数据重传，因为数据重传将会消耗更多的时间(包括确认数据包丢失、请求重传、等待新数据包等步骤的时间消耗)</p>
<h4 id="24-Grpc的优缺点"><a href="#24-Grpc的优缺点" class="headerlink" title="24. Grpc的优缺点"></a>24. Grpc的优缺点</h4><p>gRPC是Google公司基于Protobuf开发的跨语言的开源RPC框架。gRPC基于HTTP&#x2F;2协议设计，可以基于一个HTTP&#x2F;2链接提供多个服务，对于移动设备更加友好</p>
<p>最底层为TCP或Unix Socket协议，在此之上是HTTP&#x2F;2协议的实现，然后在HTTP&#x2F;2协议之上又构建了针对Go语言的gRPC核心库。应用程序通过gRPC插件生产的Stub代码和gRPC核心库通信，也可以直接和gRPC核心库通信</p>
<p><strong>优点：</strong></p>
<ul>
<li>protobuf二进制消息，性能好&#x2F;效率高（空间和时间效率都很不错）</li>
<li>proto文件生成目标代码，简单易用</li>
<li>序列化反序列化直接对应程序中的数据类，不需要解析后在进行映射(XML,JSON都是这种方式)</li>
<li>支持向前兼容（新加字段采用默认值）和向后兼容（忽略新加字段），简化升级</li>
<li>支持多种语言（可以把proto文件看做IDL文件）</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>GRPC尚未提供连接池，需要自行实现</li>
<li>尚未提供“服务发现”、“负载均衡”机制</li>
<li>因为基于HTTP2，绝大部多数<code>HTTP Server、Nginx</code>都尚不支持，即Nginx不能将GRPC请求作为HTTP请求来负载均衡，而是作为普通的TCP请求（nginx1.9版本已支持）</li>
<li>Protobuf二进制可读性差（貌似提供了Text_Fromat功能）默认不具备动态特性（可以通过动态定义生成消息类型或者动态编译支持）</li>
</ul>
<h4 id="25-Http1和Http2和Grpc之间的区别是什么"><a href="#25-Http1和Http2和Grpc之间的区别是什么" class="headerlink" title="25. Http1和Http2和Grpc之间的区别是什么"></a>25. Http1和Http2和Grpc之间的区别是什么</h4><p>在互联网流量传输只使用了几个网络协议。使用 <code>IPv4</code> 进行路由，使用 <code>TCP</code> 进行连接层面的流量控制，使用 <code>SSL/TLS</code> 协议实现传输安全，使用 <code>DNS</code> 进行域名解析，使用 <code>HTTP</code> 进行应用数据的传输</p>
<p><strong>HTTP2和HTTP1相比的新特性包括：</strong></p>
<ul>
<li><p>新的二进制格式（Binary Format）</p>
<ul>
<li>HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮</li>
</ul>
</li>
<li><p>多路复用（MultiPlexing）</p>
<ul>
<li>连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面</li>
</ul>
</li>
<li><p>Header压缩</p>
<p>Header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小</p>
</li>
<li><p>服务端推送（server push）</p>
<ul>
<li>服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能</li>
</ul>
</li>
</ul>
<hr>
<p>Grpc的设计目标是在任何环境下运行，支持可插拔的负载均衡，跟踪，运行状况检查和身份验证。它不仅支持数据中心内部和跨数据中心的服务调用，它也适用于分布式计算的最后一公里，将设备，移动应用程序和浏览器连接到后端服务，同时，它也是高性能的，而 HTTP2 恰好支持这些</p>
<p><strong>Grpc是基于http2的</strong></p>
<ul>
<li>HTTP2天然的通用性满足各种设备，场景</li>
<li>HTTP2的性能相对来说也是很好的，除非你需要极致的性能</li>
<li>HTTP2的安全性非常好，天然支持 SSL</li>
<li>HTTP2的鉴权也非常成熟</li>
<li>Grpc基于 HTTP2 多语言实现也更容易</li>
</ul>
<h4 id="26-数字签名、数字证书、SSL、https是什么关系"><a href="#26-数字签名、数字证书、SSL、https是什么关系" class="headerlink" title="26. 数字签名、数字证书、SSL、https是什么关系"></a>26. 数字签名、数字证书、SSL、https是什么关系</h4><p>HTTPS 是建立在密码学基础之上的一种安全通信协议，严格来说是基于 HTTP 协议和 SSL&#x2F;TLS 的组合</p>
<h4 id="27-Cookie"><a href="#27-Cookie" class="headerlink" title="27. Cookie"></a>27. Cookie</h4><p>HTTP协议是无状态的，主要是为了让HTTP协议尽可能简单，使得它能够处理大量事务。HTTP&#x2F;1.1引入Cookie来保存状态信息</p>
<p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。它用于告知服务端两个请求是否来自同一浏览器，并保持用户的登录状态</p>
<ul>
<li><p>用途</p>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
</li>
<li><p>创建过程</p>
<ul>
<li>服务器发送的响应报文包含Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中</li>
<li>客户端之后对同一个服务器发送请求时，会从浏览器中读出 Cookie 信息通过 Cookie 请求首部字段发送给服务器</li>
</ul>
</li>
<li><p>分类</p>
<ul>
<li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效</li>
<li>持久性 Cookie：指定一个特定的过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie</li>
</ul>
</li>
<li><p>JavaScript 获取 Cookie</p>
<ul>
<li>通过 <code>Document.cookie</code> 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie</li>
</ul>
</li>
<li><p>Secure 和 HttpOnly</p>
<ul>
<li>标记为 Secure 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障</li>
<li>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。因为跨域脚本 (XSS) 攻击常常使用 JavaScript 的 <code>Document.cookie</code>API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击</li>
</ul>
</li>
<li><p>作用域</p>
<ul>
<li>Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain&#x3D;mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）</li>
<li>Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (“&#x2F;“) 作为路径分隔符，子路径也会被匹配</li>
</ul>
</li>
</ul>
<h4 id="28-Session"><a href="#28-Session" class="headerlink" title="28. Session"></a>28. Session</h4><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全</p>
<p>Session 可以存储在服务器上的文件、数据库或者内存中，现在最常见的是将 Session 存储在内存型数据库中，比如 Redis</p>
<p>使用 Session 维护用户登录的过程如下：</p>
<ul>
<li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li>
<li>服务器验证该用户名和密码</li>
<li>如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 ID 称为 Session ID</li>
<li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中</li>
<li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之后的业务操作</li>
</ul>
<p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式</p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7mdikcs2aj31d80jr11b.jpg" alt="86.jpg" style="zoom:100%;" /></div>

<h4 id="29-Cookie与Session异同"><a href="#29-Cookie与Session异同" class="headerlink" title="29. Cookie与Session异同"></a>29. Cookie与Session异同</h4><p>Cookie 和 Session 都为了用来保存状态信息，都是保存客户端状态的机制，它们都是为了解决HTTP无状态的问题而所做的努力</p>
<ul>
<li>作用范围不同：Cookie 保存在客户端(浏览器)，Session 保存在服务器端</li>
<li>存取方式的不同：Cookie只能保存 ASCII，Session可以存任意数据类型，比如UserId等</li>
<li>有效期不同：Cookie可设置为长时间保持，比如默认登录功能功能，Session一般有效时间较短，客户端关闭或者Session超时都会失效</li>
<li>隐私策略不同：Cookie存储在客户端，信息容易被窃取;Session存储在服务端，相对安全一些</li>
<li>存储大小不同： 单个Cookie 保存的数据不能超过 4K，Session可存储数据远高于Cookie</li>
</ul>
<h4 id="30-浏览器禁用Cookie"><a href="#30-浏览器禁用Cookie" class="headerlink" title="30. 浏览器禁用Cookie"></a>30. 浏览器禁用Cookie</h4><p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递</p>
<h4 id="31-Cookie与Session选择"><a href="#31-Cookie与Session选择" class="headerlink" title="31. Cookie与Session选择"></a>31. Cookie与Session选择</h4><ul>
<li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存取任何类型的数据，因此在考虑数据复杂性时首选 Session</li>
<li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密</li>
<li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中</li>
</ul>
<h4 id="32-Unicode和ASCII以及Utf8的区别"><a href="#32-Unicode和ASCII以及Utf8的区别" class="headerlink" title="32. Unicode和ASCII以及Utf8的区别"></a>32. Unicode和ASCII以及Utf8的区别</h4><ul>
<li>Unicode 是字符集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储</li>
<li>ASCII 码一共规定了128个字符的编码，比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）</li>
<li>UTF-8 是编码规则</li>
</ul>
<h4 id="33-TFO的原理是什么"><a href="#33-TFO的原理是什么" class="headerlink" title="33. TFO的原理是什么"></a>33. TFO的原理是什么</h4><p>TCP快速打开（TCP Fast Open，TFO）是对TCP的一种简化握手手续的拓展，用于提高两端点间连接的打开速度</p>
<p>简而言之，就是在TCP的三次握手过程中传输实际有用的数据。这个扩展最初在Linux系统实现，Linux服务器，Linux系统上的Chrome浏览器，或运行在Linux上的其他支持的软件</p>
<p>它通过握手开始时的SYN包中的TFO cookie来验证一个之前连接过的客户端。如果验证成功，它可以在三次握手最终的ACK包收到之前就开始发送数据，这样便跳过了一个绕路的行为，更在传输开始时就降低了延迟</p>
<p>这个加密的Cookie被存储在客户端，在一开始的连接时被设定好。然后每当客户端连接时，这个Cookie被重复返回</p>
<p>请求Tcp Fast Open Cookie：</p>
<ul>
<li>客户端发送SYN数据包，该数据包包含Fast Open选项，且该选项的Cookie为空，这表明客户端请求Fast Open Cookie</li>
<li>支持TCP Fast Open的服务器生成Cookie，并将其置于SYN-ACK数据包中的Fast Open选项以发回客户端</li>
<li>客户端收到SYN-ACK后，缓存Fast Open选项中的Cookie</li>
</ul>
<h4 id="34-TIME-WAIT的作用"><a href="#34-TIME-WAIT的作用" class="headerlink" title="34. TIME_WAIT的作用"></a>34. TIME_WAIT的作用</h4><p>主动关闭的Socket端会进入TIME_WAIT状态，并且持续2MSL时间长度，MSL就是maximum segment lifetime(最大分节生命期），这是一个IP数据包能在互联网上生存的最长时间，超过这个时间将在网络中消失。MSL在RFC 1122上建议是2分钟，而源自berkeley的TCP实现传统上使用30秒，因而，TIME_WAIT状态一般维持在1-4分钟</p>
<ul>
<li>可靠地实现TCP全双工连接的终止</li>
<li>允许老的重复分节在网络中消逝</li>
</ul>
<h4 id="35-网络的性能指标有哪些"><a href="#35-网络的性能指标有哪些" class="headerlink" title="35. 网络的性能指标有哪些"></a>35. 网络的性能指标有哪些</h4><p>通常是以4个指标来衡量网络的性能，分别是带宽、延时、吞吐率、PPS（Packet Per Second），它们表示的意义如下：</p>
<ul>
<li>带宽：表示链路的最大传输速率，单位是 <code>b/s</code> （比特 &#x2F; 秒），带宽越大，其传输能力就越强</li>
<li>延时：表示请求数据包发送后，收到对端响应，所需要的时间延迟。不同的场景有着不同的含义，比如可以表示建立 <code>TCP</code> 连接所需的时间延迟，或一个数据包往返所需的时间延迟</li>
<li>吞吐率：表示单位时间内成功传输的数据量，单位是 <code>b/s</code>（比特 &#x2F; 秒）或者 <code>B/s</code>（字节 &#x2F; 秒），吞吐受带宽限制，带宽越大，吞吐率的上限才可能越高</li>
<li>PPS：全称是 <code>Packet Per Second</code>（包 &#x2F; 秒），表示以网络包为单位的传输速率，一般用来评估系统对于网络的转发能</li>
</ul>
<p>除了以上这四种基本的指标，还有一些其他常用的性能指标，比如：</p>
<ul>
<li>网络的可用性：表示网络能否正常通信</li>
<li>并发连接数：表示 TCP 连接数量</li>
<li>丢包率：表示所丢失数据包数量占所发送数据组的比率</li>
<li>重传率：表示重传网络包的比例</li>
</ul>
<h4 id="36-如何区分流量控制和拥塞控制"><a href="#36-如何区分流量控制和拥塞控制" class="headerlink" title="36. 如何区分流量控制和拥塞控制"></a>36. 如何区分流量控制和拥塞控制</h4><ul>
<li>拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷</li>
<li>拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素</li>
<li>流量控制往往指在给定的发送端和接收端之间的点对点通信量的控制</li>
<li>流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收</li>
<li>流量控制属于通信双方协商；拥塞控制涉及通信链路全局</li>
<li>流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整</li>
<li>实际最终发送窗口 &#x3D; min{流控发送窗口，拥塞窗口}</li>
</ul>
<h4 id="37-解释RTO，RTT和超时重传"><a href="#37-解释RTO，RTT和超时重传" class="headerlink" title="37. 解释RTO，RTT和超时重传"></a>37. 解释RTO，RTT和超时重传</h4><ul>
<li><strong>超时重传</strong>：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况：<ul>
<li>发送的数据没能到达接收端，所以对方没有响应。</li>
<li>接收端接收到数据，但是ACK报文在返回过程中丢失</li>
<li>接收端拒绝或丢弃数据</li>
</ul>
</li>
<li><strong>RTO</strong>：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间。就是重传间隔<ul>
<li>通常每次重传RTO是前一次重传间隔的两倍，计量单位通常是RTT。例：1RTT，2RTT，4RTT，8RTT……</li>
<li>重传次数到达上限之后停止重传</li>
</ul>
</li>
<li><strong>RTT</strong>：数据从发送到接收到对方响应之间的时间间隔，即数据报在网络中一个往返用时。大小不稳定</li>
</ul>
<h4 id="38-停止等待和超时重传"><a href="#38-停止等待和超时重传" class="headerlink" title="38. 停止等待和超时重传"></a>38. 停止等待和超时重传</h4><ul>
<li>停止等待：通常我们说如果A和B双方建立好tcp连接后就可以相互发送数据了，A为发送方，B为接收方。因为这里讨论可靠传输原理，所以把传输的数据单元称为分组。“停止等待”就是每发送完一个分组就停止发送，等待对方确认后再发送下一个分组。停止等待协议考虑了数据在网络中传输出现的几种情况来提供有效措施保障数据的可靠传输，下面我们就一一来介绍这几种情况</li>
<li>超时重传：原理是在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的ACK报文，那么就重新发送数据，直到发送成功为止。影响超时重传机制协议效率的一个关键参数是重传超时时间（RTO，Retransmission TimeOut）</li>
</ul>
<h4 id="39-交换机和路由器的区别"><a href="#39-交换机和路由器的区别" class="headerlink" title="39. 交换机和路由器的区别"></a>39. 交换机和路由器的区别</h4><ul>
<li>交换机是一根网线上网，但是大家上网是分别拨号，各自使用自己的宽带，大家上网没有影响。而路由器比交换机多了一个虚拟拨号功能，通过同一台路由器上网的电脑是共用一个宽带账号，大家上网要相互影响</li>
<li>交换机工作在中继层，交换机根据MAC地址寻址。路由器工作在网络层，根据IP地址寻址，路由器可以处理TCP&#x2F;IP协议，而交换机不可以</li>
<li>交换机可以使连接它的多台电脑组成局域网，如果还有代理服务器的话还可以实现同时上网功能而且局域网所有电脑是共享它的带宽速率的，但是交换机没有路由器的自动识别数据包发送和到达地址的功能。路由器可以自动识别数据包发送和到达的地址，路由器相当于马路上的警察，负责交通疏导和指路的</li>
<li>举几个例子,路由器是小邮局，就一个地址(IP)，负责一个地方的收发(个人电脑，某个服务器，所以你家上网要这个东西)，交换机是省里的大邮政中心，负责由一个地址给各个小地方的联系。简单的说路由器专管入网，交换机只管配送，路由路由就是给你找路让你上网的，交换机只负责开门，交换机上面要没有路由你是上不了网的</li>
<li>路由器提供了防火墙的服务。路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包传送和未知目标网络数据包的传送，从而可以防止广播风暴</li>
</ul>
<h4 id="40-子网掩码的作用"><a href="#40-子网掩码的作用" class="headerlink" title="40. 子网掩码的作用"></a>40. 子网掩码的作用</h4><p>内网中192.168.1.199的前三组是网络号，后一组是主机号，子网掩码就是255.255.255.0</p>
<p><strong>首先要说明的是</strong>：不是某个IP的网络号和主机号决定子网掩码是什么，而是子网掩码决定了某个IP地址的网络号与主机号是什么，IP地址是要搭配子网掩码使用的。例如上面的子网掩码决定了192.168.1.199的前三段192.168.1是网络号，最后一段199是主机号</p>
<p>我们再来理解子网掩码的作用，先举个例子，市面上的两个厂家都生产电子秤，每个厂家都坚称他们的秤最准，那你是怎么知道他们的秤到底准不准？很简单，你去找一个 1KG 的国际千克原器，各放到他们的秤上测量，如果秤的测量值是1KG，那这把秤就是准的，<strong>子网掩码的作用</strong>就相当于这个大家公认的国际千克原器，是我们测量两个IP是否属于同一个网段的一个工具（应该说是让你知道某个IP地址的网络号与主机号分别是什么） </p>
<hr>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
