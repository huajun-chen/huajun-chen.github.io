<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CodeTop算法题</title>
    <url>/2022/11/14/CodeTop%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    <content><![CDATA[<p>面试LeetCode算法题整理，按照出现的频率依次递减排序，题目类型包含：简单、中等、困难</p>
<p>CodeTop地址：<a href="https://codetop.cc/home">点击跳转</a></p>
<p><strong>备注：</strong>出现的频率会随时间变化而变化，具体以CodeTop出现频率为准，每个题目整理出<strong>题目</strong>、<strong>思路</strong>、<strong>代码</strong>三部分</p>
<h4 id="1-无重复字符的最长子串-中等"><a href="#1-无重复字符的最长子串-中等" class="headerlink" title="1. 无重复字符的最长子串-中等"></a><font color=DarkOrange>1. 无重复字符的最长子串-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度</p>
<p><strong>思路：</strong></p>
<p>滑动窗口</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-反转链表-简单"><a href="#2-反转链表-简单" class="headerlink" title="2. 反转链表-简单"></a><font color=DarkOrange>2. 反转链表-简单</font></h4><p><strong>题目：</strong></p>
<p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表</p>
<p><strong>思路：</strong></p>
<p>方法一：迭代</p>
<p>方法二：递归</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-LRU缓存-中等"><a href="#3-LRU缓存-中等" class="headerlink" title="3. LRU缓存-中等"></a><font color=DarkOrange>3. LRU缓存-中等</font></h4><p><strong>题目：</strong></p>
<p>请你设计并实现一个满足LRU (最近最少使用) 缓存约束的数据结构</p>
<p>实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li>
<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> </li>
<li>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字</li>
</ul>
<p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行</p>
<p><strong>思路：</strong></p>
<p>哈希表 + 双向链表</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-数组中的第K个最大元素-中等"><a href="#4-数组中的第K个最大元素-中等" class="headerlink" title="4. 数组中的第K个最大元素-中等"></a><font color=DarkOrange>4. 数组中的第K个最大元素-中等</font></h4><p><strong>题目：</strong></p>
<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素</p>
<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素</p>
<p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题</p>
<p><strong>思路：</strong></p>
<p>方法一：基于快速排序的选择方法</p>
<p>方法二：基于堆排序的选择方法</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-K个一组翻转链表-困难"><a href="#5-K个一组翻转链表-困难" class="headerlink" title="5. K个一组翻转链表-困难"></a><font color=DarkOrange>5. K个一组翻转链表-困难</font></h4><p><strong>题目：</strong></p>
<p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表</p>
<p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换</p>
<p><strong>思路：</strong></p>
<p>模拟</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="6-三数之和-中等"><a href="#6-三数之和-中等" class="headerlink" title="6. 三数之和-中等"></a><font color=DarkOrange>6. 三数之和-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个整数数组<code>nums</code> ，判断是否存在三元组<code>[nums[i], nums[j], nums[k]]</code>满足<code>i != j</code>、<code>i != k</code>且<code>j != k</code>，同时还满足<code>nums[i] + nums[j] + nums[k] == 0</code> </p>
<p>请你返回所有和为 <code>0</code> 且不重复的三元组</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组</p>
<p><strong>思路：</strong></p>
<p>排序 + 双指针</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="7-最大子数组和-中等"><a href="#7-最大子数组和-中等" class="headerlink" title="7. 最大子数组和-中等"></a><font color=DarkOrange>7. 最大子数组和-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和</p>
<p><strong>子数组</strong> 是数组中的一个连续部分</p>
<p><strong>思路：</strong></p>
<p>方法一：动态规划</p>
<p>方法二：分治</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="8-排序数组-快排-中等"><a href="#8-排序数组-快排-中等" class="headerlink" title="8. 排序数组-快排-中等"></a><font color=DarkOrange>8. 排序数组-快排-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列</p>
<p><strong>思路：</strong></p>
<p>通过划分将待排序的序列分成前后两部分，其中前一部分的数据都比后一部分的数据要小，然后再递归调用函数对两部分的序列分别进行快速排序</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="9-合并两个有序链表-简单"><a href="#9-合并两个有序链表-简单" class="headerlink" title="9. 合并两个有序链表-简单"></a><font color=DarkOrange>9. 合并两个有序链表-简单</font></h4><p><strong>题目：</strong></p>
<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的</p>
<p><strong>思路：</strong></p>
<p>方法一：递归</p>
<p>方法二：迭代</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="10-两数之和-简单"><a href="#10-两数之和-简单" class="headerlink" title="10. 两数之和-简单"></a><font color=DarkOrange>10. 两数之和-简单</font></h4><p><strong>题目：</strong></p>
<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现</p>
<p>你可以按任意顺序返回答案</p>
<p><strong>思路：</strong></p>
<p>方法一：暴力枚举</p>
<p>方法二：哈希表</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="11-二叉树的层序遍历-中等"><a href="#11-二叉树的层序遍历-中等" class="headerlink" title="11. 二叉树的层序遍历-中等"></a><font color=DarkOrange>11. 二叉树的层序遍历-中等</font></h4><p><strong>题目：</strong></p>
<p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）</p>
<p><strong>思路：</strong></p>
<p>广度优先搜索</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="12-搜索旋转排序数组-中等"><a href="#12-搜索旋转排序数组-中等" class="headerlink" title="12. 搜索旋转排序数组-中等"></a><font color=DarkOrange>12. 搜索旋转排序数组-中等</font></h4><p><strong>题目：</strong></p>
<p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> </p>
<p>在传递给函数之前，<code>nums</code>在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 旋转，使数组变为<code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 从 0 开始 计数）。例如，<code> [0,1,2,4,5,6,7]</code>在下标<code>3</code>处经旋转后可能变为<code>[4,5,6,7,0,1,2]</code> </p>
<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> </p>
<p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题</p>
<p><strong>思路：</strong></p>
<p>二分查找</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="13-买卖股票的最佳时机-简单"><a href="#13-买卖股票的最佳时机-简单" class="headerlink" title="13. 买卖股票的最佳时机-简单"></a><font color=DarkOrange>13. 买卖股票的最佳时机-简单</font></h4><p><strong>题目：</strong></p>
<p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> </p>
<p><strong>思路：</strong></p>
<p>方法一：暴力法</p>
<p>方法二：一次遍历</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="14-有效的括号-简单"><a href="#14-有效的括号-简单" class="headerlink" title="14. 有效的括号-简单"></a><font color=DarkOrange>14. 有效的括号-简单</font></h4><p><strong>题目：</strong></p>
<p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合</li>
<li>左括号必须以正确的顺序闭合</li>
<li>每个右括号都有一个对应的相同类型的左括号</li>
</ol>
<p><strong>思路：</strong></p>
<p>栈</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="15-岛屿数量-中等"><a href="#15-岛屿数量-中等" class="headerlink" title="15. 岛屿数量-中等"></a><font color=DarkOrange>15. 岛屿数量-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成</p>
<p>此外，你可以假设该网格的四条边均被水包围</p>
<p><strong>思路：</strong></p>
<p>方法一：深度优先搜索</p>
<p>方法二：广度优先搜索</p>
<p>方法三：并查集</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="16-环形链表-简单"><a href="#16-环形链表-简单" class="headerlink" title="16. 环形链表-简单"></a><font color=DarkOrange>16. 环形链表-简单</font></h4><p><strong>题目：</strong></p>
<p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环</p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况</p>
<p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> </p>
<p><strong>思路：</strong></p>
<p>方法一：哈希表</p>
<p>方法二：快慢指针</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="17-最长回文子串-中等"><a href="#17-最长回文子串-中等" class="headerlink" title="17. 最长回文子串-中等"></a><font color=DarkOrange>17. 最长回文子串-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串</p>
<p><strong>思路：</strong></p>
<p>方法一：动态规划</p>
<p>方法二：中心扩展算法</p>
<p>方法三：Manacher 算法</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="18-二叉树的锯齿形层序遍历-中等"><a href="#18-二叉树的锯齿形层序遍历-中等" class="headerlink" title="18. 二叉树的锯齿形层序遍历-中等"></a><font color=DarkOrange>18. 二叉树的锯齿形层序遍历-中等</font></h4><p><strong>题目：</strong></p>
<p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）</p>
<p><strong>思路：</strong></p>
<p>广度优先遍历</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="19-合并两个有序数组-简单"><a href="#19-合并两个有序数组-简单" class="headerlink" title="19. 合并两个有序数组-简单"></a><font color=DarkOrange>19. 合并两个有序数组-简单</font></h4><p><strong>题目：</strong></p>
<p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目</p>
<p>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列</p>
<p><strong>注意：</strong>最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> </p>
<p><strong>思路：</strong></p>
<p>方法一：直接合并后排序</p>
<p>方法二：双指针</p>
<p>方法三：逆向双指针</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="20-二叉树的最近公共祖先-中等"><a href="#20-二叉树的最近公共祖先-中等" class="headerlink" title="20. 二叉树的最近公共祖先-中等"></a><font color=DarkOrange>20. 二叉树的最近公共祖先-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）”</p>
<p><strong>思路：</strong></p>
<p>方法一：递归</p>
<p>方法二：存储父节点</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="21-全排列-中等"><a href="#21-全排列-中等" class="headerlink" title="21. 全排列-中等"></a><font color=DarkOrange>21. 全排列-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案</p>
<p><strong>思路：</strong></p>
<p>回溯</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="22-相交链表-简单"><a href="#22-相交链表-简单" class="headerlink" title="22. 相交链表-简单"></a><font color=DarkOrange>22. 相交链表-简单</font></h4><p><strong>题目：</strong></p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h87c37dsm4j311m0q40zb.jpg" alt="image.png" style="zoom:50%;" /></div>

<p><strong>思路：</strong></p>
<p>方法一：哈希集合</p>
<p>方法二：双指针</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="23-螺旋矩阵-中等"><a href="#23-螺旋矩阵-中等" class="headerlink" title="23. 螺旋矩阵-中等"></a><font color=DarkOrange>23. 螺旋矩阵-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素</p>
<p><strong>思路：</strong></p>
<p>方法一：模拟</p>
<p>方法二：按层模拟</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="24-合并K个升序链表-困难"><a href="#24-合并K个升序链表-困难" class="headerlink" title="24. 合并K个升序链表-困难"></a><font color=DarkOrange>24. 合并K个升序链表-困难</font></h4><p><strong>题目：</strong></p>
<p>给你一个链表数组，每个链表都已经按升序排列</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表</p>
<p><strong>思路：</strong></p>
<p>方法一：顺序合并</p>
<p>方法二：分治合并</p>
<p>方法三：使用优先队列合并</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="25-反转链表-II-中等"><a href="#25-反转链表-II-中等" class="headerlink" title="25. 反转链表 II-中等"></a><font color=DarkOrange>25. 反转链表 II-中等</font></h4><p><strong>题目：</strong></p>
<p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code>的链表节点，返回 <strong>反转后的链表</strong> </p>
<p><strong>思路：</strong></p>
<p>方法一：穿针引线</p>
<p>方法二：一次遍历「穿针引线」反转链表（头插法）</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="26-字符串相加-简单"><a href="#26-字符串相加-简单" class="headerlink" title="26. 字符串相加-简单"></a><font color=DarkOrange>26. 字符串相加-简单</font></h4><p><strong>题目：</strong></p>
<p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和并同样以字符串形式返回</p>
<p>你不能使用任何內建的用于处理大整数的库（比如 <code>BigInteger</code>）， 也不能直接将输入的字符串转换为整数形式</p>
<p><strong>思路：</strong></p>
<p>模拟</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="27-环形链表-II-中等"><a href="#27-环形链表-II-中等" class="headerlink" title="27. 环形链表 II-中等"></a><font color=DarkOrange>27. 环形链表 II-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 <code>null</code></p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况</p>
<p><strong>思路：</strong></p>
<p>方法一：哈希表</p>
<p>方法二：快慢指针</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="28-长递增子序列-中等"><a href="#28-长递增子序列-中等" class="headerlink" title="28. 长递增子序列-中等"></a><font color=DarkOrange>28. 长递增子序列-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度</p>
<p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列</p>
<p><strong>思路：</strong></p>
<p>方法一：动态规划</p>
<p>方法二：贪心 + 二分查找</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="29-接雨水-困难"><a href="#29-接雨水-困难" class="headerlink" title="29. 接雨水-困难"></a><font color=DarkOrange>29. 接雨水-困难</font></h4><p><strong>题目：</strong></p>
<p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水</p>
<p><strong>思路：</strong></p>
<p>方法一：动态规划</p>
<p>方法二：单调栈</p>
<p>方法三：双指针</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="30-二叉树中的最大路径和-困难"><a href="#30-二叉树中的最大路径和-困难" class="headerlink" title="30. 二叉树中的最大路径和-困难"></a><font color=DarkOrange>30. 二叉树中的最大路径和-困难</font></h4><p><strong>题目：</strong></p>
<p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点</p>
<p><strong>路径和</strong> 是路径中各节点值的总和</p>
<p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> </p>
<p><strong>思路：</strong></p>
<p>递归</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="31-重排链表-中等"><a href="#31-重排链表-中等" class="headerlink" title="31. 重排链表-中等"></a><font color=DarkOrange>31. 重排链表-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">L0 → L1 → … → Ln - 1 → Ln</span><br></pre></td></tr></table></figure>

<p>请将其重新排列后变为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</span><br></pre></td></tr></table></figure>

<p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换</p>
<p><strong>思路：</strong></p>
<p>方法一：线性表</p>
<p>方法二：寻找链表中点 + 链表逆序 + 合并链表</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="32-二叉树的中序遍历-简单"><a href="#32-二叉树的中序遍历-简单" class="headerlink" title="32. 二叉树的中序遍历-简单"></a><font color=DarkOrange>32. 二叉树的中序遍历-简单</font></h4><p><strong>题目：</strong></p>
<p>给定一个二叉树的根节点 <code>root</code> ，返回 它的 <strong>中序</strong>遍历</p>
<p><strong>思路：</strong></p>
<p>方法一：递归</p>
<p>方法二：迭代</p>
<p>方法三：Morris 中序遍历</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="33-二分查找-简单"><a href="#33-二分查找-简单" class="headerlink" title="33. 二分查找-简单"></a><font color=DarkOrange>33. 二分查找-简单</font></h4><p><strong>题目：</strong></p>
<p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code></p>
<p><strong>思路：</strong></p>
<p>二分查找</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="34-编辑距离-困难"><a href="#34-编辑距离-困难" class="headerlink" title="34. 编辑距离-困难"></a><font color=DarkOrange>34. 编辑距离-困难</font></h4><p><strong>题目：</strong></p>
<p>给你两个单词 <code>word1</code> 和 <code>word2</code>， 请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p><strong>思路：</strong></p>
<p>动态规划</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="35-用栈实现队列-简单"><a href="#35-用栈实现队列-简单" class="headerlink" title="35. 用栈实现队列-简单"></a><font color=DarkOrange>35. 用栈实现队列-简单</font></h4><p><strong>题目：</strong></p>
<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p>
<p>实现 <code>MyQueue</code> 类：</p>
<ul>
<li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li>
<li><code>int pop()</code> 从队列的开头移除并返回元素</li>
<li><code>int peek()</code> 返回队列开头的元素</li>
<li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li>
</ul>
<p>说明：</p>
<ul>
<li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可</li>
</ul>
<p><strong>思路：</strong></p>
<p>双栈</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="36-寻找两个正序数组的中位数-困难"><a href="#36-寻找两个正序数组的中位数-困难" class="headerlink" title="36. 寻找两个正序数组的中位数-困难"></a><font color=DarkOrange>36. 寻找两个正序数组的中位数-困难</font></h4><p><strong>题目：</strong></p>
<p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> </p>
<p>算法的时间复杂度应该为 <code>O(log (m+n))</code> </p>
<p><strong>思路：</strong></p>
<p>方法一：二分查找</p>
<p>方法二：划分数组</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="37-二叉树的右视图-中等"><a href="#37-二叉树的右视图-中等" class="headerlink" title="37. 二叉树的右视图-中等"></a><font color=DarkOrange>37. 二叉树的右视图-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值</p>
<p><strong>思路：</strong></p>
<p>方法一：深度优先搜索</p>
<p>方法二：广度优先搜索</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="38-除链表的倒数第N个结点-中等"><a href="#38-除链表的倒数第N个结点-中等" class="headerlink" title="38. 除链表的倒数第N个结点-中等"></a><font color=DarkOrange>38. 除链表的倒数第N个结点-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点</p>
<p><strong>思路：</strong></p>
<p>方法一：计算链表长度</p>
<p>方法二：栈</p>
<p>方法三：双指针</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="39-爬楼梯-简单"><a href="#39-爬楼梯-简单" class="headerlink" title="39. 爬楼梯-简单"></a><font color=DarkOrange>39. 爬楼梯-简单</font></h4><p><strong>题目：</strong></p>
<p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢</p>
<p><strong>思路：</strong></p>
<p>方法一：动态规划</p>
<p>方法二：矩阵快速幂</p>
<p>方法三：通项公式</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="40-合并区间-中等"><a href="#40-合并区间-中等" class="headerlink" title="40. 合并区间-中等"></a><font color=DarkOrange>40. 合并区间-中等</font></h4><p><strong>题目：</strong></p>
<p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</p>
<p><strong>思路：</strong></p>
<p>排序</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="41-排序链表-中等"><a href="#41-排序链表-中等" class="headerlink" title="41. 排序链表-中等"></a><font color=DarkOrange>41. 排序链表-中等</font></h4><p><strong>题目：</strong></p>
<p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> </p>
<p><strong>思路：</strong></p>
<p>方法一：自顶向下归并排序</p>
<p>方法二：自底向上归并排序</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="42-删除排序链表中的重复元素-II-中等"><a href="#42-删除排序链表中的重复元素-II-中等" class="headerlink" title="42. 删除排序链表中的重复元素 II-中等"></a><font color=DarkOrange>42. 删除排序链表中的重复元素 II-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一个已排序的链表的头<code>head</code>，删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表</p>
<p><strong>思路：</strong></p>
<p>一次遍历</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="43-下一个排列-中等"><a href="#43-下一个排列-中等" class="headerlink" title="43. 下一个排列-中等"></a><font color=DarkOrange>43. 下一个排列-中等</font></h4><p><strong>题目：</strong></p>
<p>整数数组的一个 <strong>排列</strong> 就是将其所有成员以序列或线性顺序排列</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code></li>
</ul>
<p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> </li>
<li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> </li>
<li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列</li>
</ul>
<p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列</p>
<p>必须<strong>原地</strong>修改，只允许使用额外常数空间</p>
<p><strong>思路：</strong></p>
<p>两遍扫描</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="44-x-的平方根-简单"><a href="#44-x-的平方根-简单" class="headerlink" title="44. x 的平方根 -简单"></a><font color=DarkOrange>44. x 的平方根 -简单</font></h4><p><strong>题目：</strong></p>
<p>给你一个非负整数 <code>x</code> ，计算并返回 <code>x</code> 的 <strong>算术平方根</strong> </p>
<p>由于返回类型是整数，结果只保留 <strong>整数部分</strong> ，小数部分将被 **舍去 **</p>
<p><strong>注意：</strong>不允许使用任何内置指数函数和算符，例如 <code>pow(x, 0.5)</code> 或者 <code>x ** 0.5</code>  </p>
<p><strong>思路：</strong></p>
<p>方法一：袖珍计算器算法</p>
<p>方法二：二分查找</p>
<p>方法三：牛顿迭代</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="45-两数相加-中等"><a href="#45-两数相加-中等" class="headerlink" title="45. 两数相加-中等"></a><font color=DarkOrange>45. 两数相加-中等</font></h4><p><strong>题目：</strong></p>
<p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头</p>
<p><strong>思路：</strong></p>
<p>模拟</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="46-字符串转换整数-atoi-中等"><a href="#46-字符串转换整数-atoi-中等" class="headerlink" title="46. 字符串转换整数 (atoi)-中等"></a><font color=DarkOrange>46. 字符串转换整数 (atoi)-中等</font></h4><p><strong>题目：</strong></p>
<p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C&#x2F;C++ 中的 <code>atoi</code> 函数）</p>
<p>函数 <code>myAtoi(string s)</code> 的算法如下：</p>
<ol>
<li>读入字符串并丢弃无用的前导空格</li>
<li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正</li>
<li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略</li>
<li>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）</li>
<li>如果整数数超过 32 位有符号整数范围 <code>[−231, 231 − 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <code>−231</code> 的整数应该被固定为 <code>−231</code> ，大于 <code>231 − 1</code> 的整数应该被固定为 <code>231 − 1</code> </li>
<li>返回整数作为最终结果</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>本题中的空白字符只包括空格字符 <code>&#39; &#39;</code> </li>
<li>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong> 任何其他字符</li>
</ul>
<p><strong>思路：</strong></p>
<p>自动机</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="47-最长公共子序列-中等"><a href="#47-最长公共子序列-中等" class="headerlink" title="47. 最长公共子序列-中等"></a><font color=DarkOrange>47. 最长公共子序列-中等</font></h4><p><strong>题目：</strong></p>
<p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> </p>
<p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串</p>
<ul>
<li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列</li>
</ul>
<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列</p>
<p><strong>思路：</strong></p>
<p>动态规划</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="48-括号生成-中等"><a href="#48-括号生成-中等" class="headerlink" title="48. 括号生成-中等"></a><font color=DarkOrange>48. 括号生成-中等</font></h4><p><strong>题目：</strong></p>
<p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合</p>
<p><strong>思路：</strong></p>
<p>方法一：暴力法</p>
<p>方法二：回溯法</p>
<p>方法三：按括号序列的长度递归</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="49-滑动窗口最大值-困难"><a href="#49-滑动窗口最大值-困难" class="headerlink" title="49. 滑动窗口最大值-困难"></a><font color=DarkOrange>49. 滑动窗口最大值-困难</font></h4><p><strong>题目：</strong></p>
<p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的<code>k</code> 个数字。滑动窗口每次只向右移动一位</p>
<p>返回 滑动窗口中的最大值</p>
<p><strong>思路：</strong></p>
<p>方法一：优先队列</p>
<p>方法二：单调队列</p>
<p>方法三：分块 + 预处理</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="50-复原-IP-地址-中等"><a href="#50-复原-IP-地址-中等" class="headerlink" title="50. 复原 IP 地址-中等"></a><font color=DarkOrange>50. 复原 IP 地址-中等</font></h4><p><strong>题目：</strong></p>
<p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>&#39;.&#39;</code> 分隔</p>
<ul>
<li>例如：<code>&quot;0.1.2.201&quot;</code> 和<code> &quot;192.168.1.1&quot;</code> 是 <strong>有效</strong> IP 地址，但是 <code>&quot;0.011.255.245&quot;</code>、<code>&quot;192.168.1.312&quot;</code> 和<code>&quot;192.168@1.1&quot;</code> 是 <strong>无效</strong> IP 地址</li>
</ul>
<p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入 <code>&#39;.&#39;</code> 来形成。你 <strong>不能</strong> 重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案</p>
<p><strong>思路：</strong></p>
<p>回溯</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="51-缺失的第一个正数-困难"><a href="#51-缺失的第一个正数-困难" class="headerlink" title="51. 缺失的第一个正数-困难"></a><font color=DarkOrange>51. 缺失的第一个正数-困难</font></h4><p><strong>题目：</strong></p>
<p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数</p>
<p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案</p>
<p><strong>思路：</strong></p>
<p>方法一：哈希表</p>
<p>方法二：置换</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="52-链表中倒数第k个节点-简单"><a href="#52-链表中倒数第k个节点-简单" class="headerlink" title="52. 链表中倒数第k个节点-简单"></a><font color=DarkOrange>52. 链表中倒数第k个节点-简单</font></h4><p><strong>题目：</strong></p>
<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点</p>
<p>例如，一个链表有 <code>6</code> 个节点，从头节点开始，它们的值依次是 <code>1、2、3、4、5、6</code>。这个链表的倒数第 <code>3</code> 个节点是值为 <code>4</code> 的节点</p>
<p><strong>思路：</strong></p>
<p>方法一：顺序查找</p>
<p>方法二：双指针</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="53-从前序与中序遍历序列构造二叉树-中等"><a href="#53-从前序与中序遍历序列构造二叉树-中等" class="headerlink" title="53. 从前序与中序遍历序列构造二叉树-中等"></a><font color=DarkOrange>53. 从前序与中序遍历序列构造二叉树-中等</font></h4><p><strong>题目：</strong></p>
<p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点</p>
<p><strong>思路：</strong></p>
<p>方法一：递归</p>
<p>方法二：迭代</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="54-比较版本号-中等"><a href="#54-比较版本号-中等" class="headerlink" title="54. 比较版本号-中等"></a><font color=DarkOrange>54. 比较版本号-中等</font></h4><p><strong>题目：</strong></p>
<p>给你两个版本号 <code>version1</code> 和 <code>version2</code> ，请你比较它们</p>
<p>版本号由一个或多个修订号组成，各修订号由一个 <code>&#39;.&#39;</code> 连接。每个修订号由 <strong>多位数字</strong> 组成，可能包含 <strong>前导零</strong> 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，<code>2.5.33</code> 和 <code>0.1</code> 都是有效的版本号</p>
<p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 <strong>忽略任何前导零后的整数值</strong> 。也就是说，修订号 <code>1</code> 和修订号 <code>001</code> <strong>相等</strong> 。如果版本号没有指定某个下标处的修订号，则该修订号视为 <code>0</code> 。例如，版本 <code>1.0</code> 小于版本<code>1.1</code> ，因为它们下标为 <code>0</code> 的修订号相同，而下标为 <code>1</code> 的修订号分别为 <code>0</code> 和 <code>1</code> ，<code>0 &lt; 1</code> </p>
<p>返回规则如下：</p>
<ul>
<li>如果 <code>*version1* &gt; *version2*</code> 返回 <code>1</code></li>
<li>如果 <code>*version1* &lt; *version2*</code> 返回 <code>-1</code></li>
<li>除此之外返回 <code>0</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：字符串分割</p>
<p>方法二：双指针</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="55-零钱兑换-中等"><a href="#55-零钱兑换-中等" class="headerlink" title="55. 零钱兑换-中等"></a><font color=DarkOrange>55. 零钱兑换-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额</p>
<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> </p>
<p>你可以认为每种硬币的数量是无限的</p>
<p><strong>思路：</strong></p>
<p>方法一：记忆化搜索</p>
<p>方法二：动态规划</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="56-最小覆盖子串-困难"><a href="#56-最小覆盖子串-困难" class="headerlink" title="56. 最小覆盖子串-困难"></a><font color=DarkOrange>56. 最小覆盖子串-困难</font></h4><p><strong>题目：</strong></p>
<p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> </p>
<p><strong>注意：</strong></p>
<ul>
<li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li>
<li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案</li>
</ul>
<p><strong>思路：</strong></p>
<p>滑动窗口</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="57-二叉树的前序遍历-简单"><a href="#57-二叉树的前序遍历-简单" class="headerlink" title="57. 二叉树的前序遍历-简单"></a><font color=DarkOrange>57. 二叉树的前序遍历-简单</font></h4><p><strong>题目：</strong></p>
<p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历</p>
<p><strong>思路：</strong></p>
<p>方法一：递归</p>
<p>方法二：迭代</p>
<p>方法三：Morris 遍历</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="58-反转字符串中的单词-中等"><a href="#58-反转字符串中的单词-中等" class="headerlink" title="58. 反转字符串中的单词-中等"></a><font color=DarkOrange>58. 反转字符串中的单词-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序</p>
<p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开</p>
<p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串</p>
<p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格</p>
<p><strong>思路：</strong></p>
<p>方法一：使用语言特性</p>
<p>方法二：自行编写对应的函数</p>
<p>方法三：双端队列</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="59-字符串相乘-中等"><a href="#59-字符串相乘-中等" class="headerlink" title="59. 字符串相乘-中等"></a><font color=DarkOrange>59. 字符串相乘-中等</font></h4><p><strong>题目：</strong></p>
<p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式</p>
<p><strong>注意：</strong>不能使用任何内置的 BigInteger 库或直接将输入转换为整数</p>
<p><strong>思路：</strong></p>
<p>方法一：做加法</p>
<p>方法二：做乘法</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="60-最小栈-中等"><a href="#60-最小栈-中等" class="headerlink" title="60. 最小栈-中等"></a><font color=DarkOrange>60. 最小栈-中等</font></h4><p><strong>题目：</strong></p>
<p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈</p>
<p>实现 <code>MinStack</code> 类：</p>
<ul>
<li><code>MinStack()</code> 初始化堆栈对象</li>
<li><code>void push(int val)</code> 将元素val推入堆栈</li>
<li><code>void pop()</code> 删除堆栈顶部的元素</li>
<li><code>int top()</code> 获取堆栈顶部的元素</li>
<li><code>int getMin()</code> 获取堆栈中的最小元素</li>
</ul>
<p><strong>思路：</strong></p>
<p>辅助栈</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="61-平衡二叉树-简单"><a href="#61-平衡二叉树-简单" class="headerlink" title="61. 平衡二叉树-简单"></a><font color=DarkOrange>61. 平衡二叉树-简单</font></h4><p><strong>题目：</strong></p>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<blockquote>
<p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 </p>
</blockquote>
<p><strong>思路：</strong></p>
<p>方法一：自顶向下的递归</p>
<p>方法二：自底向上的递归</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="62-子集-中等"><a href="#62-子集-中等" class="headerlink" title="62. 子集-中等"></a><font color=DarkOrange>62. 子集-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集</p>
<p><strong>思路：</strong></p>
<p>方法一：迭代法实现子集枚举</p>
<p>方法二：递归法实现子集枚举</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="63-二叉树的最大深度-简单"><a href="#63-二叉树的最大深度-简单" class="headerlink" title="63. 二叉树的最大深度-简单"></a><font color=DarkOrange>63. 二叉树的最大深度-简单</font></h4><p><strong>题目：</strong></p>
<p>给定一个二叉树，找出其最大深度</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点</p>
<p><strong>思路：</strong></p>
<p>方法一：深度优先搜索</p>
<p>方法二：广度优先搜索</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="64-求根节点到叶节点数字之和-中等"><a href="#64-求根节点到叶节点数字之和-中等" class="headerlink" title="64. 求根节点到叶节点数字之和-中等"></a><font color=DarkOrange>64. 求根节点到叶节点数字之和-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个二叉树的根节点 <code>root</code> ，树中每个节点都存放有一个 <code>0</code> 到 <code>9</code> 之间的数字</p>
<p>每条从根节点到叶节点的路径都代表一个数字：</p>
<ul>
<li>例如，从根节点到叶节点的路径 <code>1 -&gt; 2 -&gt; 3</code> 表示数字 <code>123</code></li>
</ul>
<p>计算从根节点到叶节点生成的 <strong>所有数字之和</strong> </p>
<p><strong>叶节点</strong> 是指没有子节点的节点</p>
<p><strong>思路：</strong></p>
<p>方法一：深度优先搜索</p>
<p>方法二：广度优先搜索</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="65-最长有效括号-困难"><a href="#65-最长有效括号-困难" class="headerlink" title="65. 最长有效括号-困难"></a><font color=DarkOrange>65. 最长有效括号-困难</font></h4><p><strong>题目：</strong></p>
<p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度</p>
<p><strong>思路：</strong></p>
<p>方法一：动态规划</p>
<p>方法二：栈</p>
<p>方法三：不需要额外的空间</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="66-对称二叉树-简单"><a href="#66-对称二叉树-简单" class="headerlink" title="66. 对称二叉树-简单"></a><font color=DarkOrange>66. 对称二叉树-简单</font></h4><p><strong>题目：</strong></p>
<p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称</p>
<p><strong>思路：</strong></p>
<p>方法一：递归</p>
<p>方法二：迭代</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="67-验证二叉搜索树-中等"><a href="#67-验证二叉搜索树-中等" class="headerlink" title="67. 验证二叉搜索树-中等"></a><font color=DarkOrange>67. 验证二叉搜索树-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树</p>
<p><strong>有效</strong> 二叉搜索树定义如下：</p>
<ul>
<li>节点的左子树只包含 <strong>小于</strong> 当前节点的数</li>
<li>节点的右子树只包含 <strong>大于</strong> 当前节点的数</li>
<li>所有左子树和右子树自身必须也是二叉搜索树</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一: 递归</p>
<p>方法二：中序遍历</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="68-最小路径和-中等"><a href="#68-最小路径和-中等" class="headerlink" title="68. 最小路径和-中等"></a><font color=DarkOrange>68. 最小路径和-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小</p>
<p><strong>说明：</strong>每次只能向下或者向右移动一步</p>
<p><strong>思路：</strong></p>
<p>动态规划</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="69-二叉树的直径-简单"><a href="#69-二叉树的直径-简单" class="headerlink" title="69. 二叉树的直径-简单"></a><font color=DarkOrange>69. 二叉树的直径-简单</font></h4><p><strong>题目：</strong></p>
<p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点</p>
<p><strong>思路：</strong></p>
<p>深度优先搜索</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="70-路径总和-II-中等"><a href="#70-路径总和-II-中等" class="headerlink" title="70. 路径总和 II-中等"></a><font color=DarkOrange>70. 路径总和 II-中等</font></h4><p><strong>题目：</strong></p>
<p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点</p>
<p><strong>思路：</strong></p>
<p>方法一：深度优先搜索</p>
<p>方法二：广度优先搜索</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="71-Rand7-实现-Rand10-简单"><a href="#71-Rand7-实现-Rand10-简单" class="headerlink" title="71.  Rand7() 实现 Rand10()-简单"></a><font color=DarkOrange>71.  Rand7() 实现 Rand10()-简单</font></h4><p><strong>题目：</strong></p>
<p>给定方法 <code>rand7</code> 可生成 <code>[1,7]</code> 范围内的均匀随机整数，试写一个方法 <code>rand10</code> 生成 <code>[1,10]</code> 范围内的均匀随机整数</p>
<p>你只能调用 <code>rand7()</code> 且不能调用其他方法。请不要使用系统的 <code>Math.random()</code> 方法</p>
<p>每个测试用例将有一个内部参数 <code>n</code>，即你实现的函数 <code>rand10()</code> 在测试时将被调用的次数。请注意，这不是传递给 <code>rand10()</code> 的参数</p>
<p><strong>思路：</strong></p>
<p>拒绝采样</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="72-组合总和-中等"><a href="#72-组合总和-中等" class="headerlink" title="72. 组合总和-中等"></a><font color=DarkOrange>72. 组合总和-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合</p>
<p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的</p>
<p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个</p>
<p><strong>思路：</strong></p>
<p>搜索回溯</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="73-旋转图像-中等"><a href="#73-旋转图像-中等" class="headerlink" title="73. 旋转图像-中等"></a><font color=DarkOrange>73. 旋转图像-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度</p>
<p>你必须在<strong>原地</strong> 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像</p>
<p><strong>思路：</strong></p>
<p>方法一：使用辅助数组</p>
<p>方法二：原地旋转</p>
<p>方法三：用翻转代替旋转</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="74-路径总和-简单"><a href="#74-路径总和-简单" class="headerlink" title="74. 路径总和-简单"></a><font color=DarkOrange>74. 路径总和-简单</font></h4><p><strong>题目：</strong></p>
<p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> </p>
<p><strong>叶子节点</strong> 是指没有子节点的节点</p>
<p><strong>思路：</strong></p>
<p>方法一：广度优先搜索</p>
<p>方法二：递归</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="75-回文链表-简单"><a href="#75-回文链表-简单" class="headerlink" title="75. 回文链表-简单"></a><font color=DarkOrange>75. 回文链表-简单</font></h4><p><strong>题目：</strong></p>
<p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> </p>
<p><strong>思路：</strong></p>
<p>方法一：将值复制到数组中后用双指针法</p>
<p>方法二：递归</p>
<p>方法三：快慢指针</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="76-多数元素-简单"><a href="#76-多数元素-简单" class="headerlink" title="76. 多数元素-简单"></a><font color=DarkOrange>76. 多数元素-简单</font></h4><p><strong>题目：</strong></p>
<p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素</p>
<p><strong>思路：</strong></p>
<p>方法一：哈希表</p>
<p>方法二：排序</p>
<p>方法三：随机化</p>
<p>方法四：分治</p>
<p>方法五：Boyer-Moore 投票算法</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="77-最长重复子数组-中等"><a href="#77-最长重复子数组-中等" class="headerlink" title="77. 最长重复子数组-中等"></a><font color=DarkOrange>77. 最长重复子数组-中等</font></h4><p><strong>题目：</strong></p>
<p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度 </p>
<p><strong>思路：</strong></p>
<p>方法一：动态规划</p>
<p>方法二：滑动窗口</p>
<p>方法三：二分查找 + 哈希</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="78-最大正方形-中等"><a href="#78-最大正方形-中等" class="headerlink" title="78. 最大正方形-中等"></a><font color=DarkOrange>78. 最大正方形-中等</font></h4><p><strong>题目：</strong></p>
<p>在一个由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的二维矩阵内，找到只包含 <code>&#39;1&#39;</code> 的最大正方形，并返回其面积</p>
<p><strong>思路：</strong></p>
<p>方法一：暴力法</p>
<p>方法二：动态规划</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="79-字符串解码-中等"><a href="#79-字符串解码-中等" class="headerlink" title="79. 字符串解码-中等"></a><font color=DarkOrange>79. 字符串解码-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一个经过编码的字符串，返回它解码后的字符串</p>
<p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入</p>
<p><strong>思路：</strong></p>
<p>方法一：栈操作</p>
<p>方法二：递归</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="80-搜索二维矩阵-II-中等"><a href="#80-搜索二维矩阵-II-中等" class="headerlink" title="80. 搜索二维矩阵 II-中等"></a><font color=DarkOrange>80. 搜索二维矩阵 II-中等</font></h4><p><strong>题目：</strong></p>
<p>编写一个高效的算法来搜索 <code>*m* x *n*</code> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列</li>
<li>每列的元素从上到下升序排列</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：直接查找</p>
<p>方法二：二分查找</p>
<p>方法三：Z 字形查找</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="81-翻转二叉树-简单"><a href="#81-翻转二叉树-简单" class="headerlink" title="81. 翻转二叉树-简单"></a><font color=DarkOrange>81. 翻转二叉树-简单</font></h4><p><strong>题目：</strong></p>
<p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点</p>
<p><strong>思路：</strong></p>
<p>递归</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="82-在排序数组中查找元素的第一个和最后一个位置-中等"><a href="#82-在排序数组中查找元素的第一个和最后一个位置-中等" class="headerlink" title="82. 在排序数组中查找元素的第一个和最后一个位置-中等"></a><font color=DarkOrange>82. 在排序数组中查找元素的第一个和最后一个位置-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置</p>
<p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code></p>
<p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题</p>
<p><strong>思路：</strong></p>
<p>二分查找</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="83-最长公共前缀-简单"><a href="#83-最长公共前缀-简单" class="headerlink" title="83. 最长公共前缀-简单"></a><font color=DarkOrange>83. 最长公共前缀-简单</font></h4><p><strong>题目：</strong></p>
<p>编写一个函数来查找字符串数组中的最长公共前缀</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code></p>
<p><strong>思路：</strong></p>
<p>方法一：横向扫描</p>
<p>方法二：纵向扫描</p>
<p>方法三：分治</p>
<p>方法四：二分查找</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="84-寻找峰值-中等"><a href="#84-寻找峰值-中等" class="headerlink" title="84. 寻找峰值-中等"></a><font color=DarkOrange>84. 寻找峰值-中等</font></h4><p><strong>题目：</strong></p>
<p>峰值元素是指其值严格大于左右相邻值的元素</p>
<p>给你一个整数数组 <code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可</p>
<p>你可以假设 <code>nums[-1] = nums[n] = -∞</code> </p>
<p>你必须实现时间复杂度为 <code>O(log n)</code> 的算法来解决此问题</p>
<p><strong>思路：</strong></p>
<p>方法一：寻找最大值</p>
<p>方法二：迭代爬坡</p>
<p>方法三：方法二的二分查找优化</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="85-最长连续序列-中等"><a href="#85-最长连续序列-中等" class="headerlink" title="85. 最长连续序列-中等"></a><font color=DarkOrange>85. 最长连续序列-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度</p>
<p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题</p>
<p><strong>思路：</strong></p>
<p>哈希表</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="86-基本计算器-II-中等"><a href="#86-基本计算器-II-中等" class="headerlink" title="86. 基本计算器 II-中等"></a><font color=DarkOrange>86. 基本计算器 II-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值</p>
<p>整数除法仅保留整数部分</p>
<p>你可以假设给定的表达式总是有效的。所有中间结果将在 <code>[-2^31, 2^31 - 1]</code> 的范围内</p>
<p><strong>注意：</strong>不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval()</code> </p>
<p><strong>思路：</strong></p>
<p>栈</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="87-岛屿的最大面积-中等"><a href="#87-岛屿的最大面积-中等" class="headerlink" title="87. 岛屿的最大面积-中等"></a><font color=DarkOrange>87. 岛屿的最大面积-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code> </p>
<p><strong>岛屿</strong> 是由一些相邻的 <code>1</code> (代表土地) 构成的组合，这里的「相邻」要求两个 <code>1</code> 必须在 <strong>水平或者竖直的四个方向上</strong> 相邻。你可以假设 <code>grid</code> 的四个边缘都被 <code>0</code>（代表水）包围着</p>
<p>岛屿的面积是岛上值为 <code>1</code> 的单元格的数目</p>
<p>计算并返回 <code>grid</code> 中最大的岛屿面积。如果没有岛屿，则返回面积为 <code>0</code> </p>
<p><strong>思路：</strong></p>
<p>方法一：深度优先搜索</p>
<p>方法二：深度优先搜索 + 栈</p>
<p>方法三：广度优先搜索</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="88-删除排序链表中的重复元素-简单"><a href="#88-删除排序链表中的重复元素-简单" class="headerlink" title="88. 删除排序链表中的重复元素-简单"></a><font color=DarkOrange>88. 删除排序链表中的重复元素-简单</font></h4><p><strong>题目：</strong></p>
<p>给定一个已排序的链表的头 <code>head</code> ， 删除所有重复的元素，使每个元素只出现一次 。返回已排序的链表</p>
<p><strong>思路：</strong></p>
<p>一次遍历</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="89-不同路径-中等"><a href="#89-不同路径-中等" class="headerlink" title="89. 不同路径-中等"></a><font color=DarkOrange>89. 不同路径-中等</font></h4><p><strong>题目：</strong></p>
<p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）</p>
<p>问总共有多少条不同的路径？</p>
<p><strong>思路：</strong></p>
<p>方法一：动态规划</p>
<p>方法二：组合数学</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="90-打家劫舍-中等"><a href="#90-打家劫舍-中等" class="headerlink" title="90. 打家劫舍-中等"></a><font color=DarkOrange>90. 打家劫舍-中等</font></h4><p><strong>题目：</strong></p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong></p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额</p>
<p><strong>思路：</strong></p>
<p>动态规划</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="91-买卖股票的最佳时机-II-中等"><a href="#91-买卖股票的最佳时机-II-中等" class="headerlink" title="91. 买卖股票的最佳时机 II-中等"></a><font color=DarkOrange>91. 买卖股票的最佳时机 II-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格</p>
<p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售</p>
<p>返回你能获得的 <strong>最大</strong> 利润</p>
<p><strong>思路：</strong></p>
<p>方法一：动态规划</p>
<p>方法二：贪心</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="92-两两交换链表中的节点-中等"><a href="#92-两两交换链表中的节点-中等" class="headerlink" title="92. 两两交换链表中的节点-中等"></a><font color=DarkOrange>92. 两两交换链表中的节点-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）</p>
<p><strong>思路：</strong></p>
<p>方法一：递归</p>
<p>方法二：迭代</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="93-乘积最大子数组-中等"><a href="#93-乘积最大子数组-中等" class="headerlink" title="93. 乘积最大子数组-中等"></a><font color=DarkOrange>93. 乘积最大子数组-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积</p>
<p>测试用例的答案是一个 <strong>32-位</strong> 整数</p>
<p><strong>子数组</strong> 是数组的连续子序列</p>
<p><strong>思路：</strong></p>
<p>动态规划</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="94-移动零-简单"><a href="#94-移动零-简单" class="headerlink" title="94. 移动零-简单"></a><font color=DarkOrange>94. 移动零-简单</font></h4><p><strong>题目：</strong></p>
<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序</p>
<p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作</p>
<p><strong>思路：</strong></p>
<p>双指针</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="95-二叉树最大宽度-中等"><a href="#95-二叉树最大宽度-中等" class="headerlink" title="95. 二叉树最大宽度-中等"></a><font color=DarkOrange>95. 二叉树最大宽度-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一棵二叉树的根节点 <code>root</code> ，返回树的 <strong>最大宽度</strong> </p>
<p>树的 <strong>最大宽度</strong> 是所有层中最大的 <strong>宽度</strong> </p>
<p>每一层的 <strong>宽度</strong> 被定义为该层最左和最右的非空节点（即，两个端点）之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的 <code>null</code> 节点，这些 <code>null</code> 节点也计入长度</p>
<p>题目数据保证答案将会在 <strong>32 位</strong> 带符号整数范围内</p>
<p><strong>思路：</strong></p>
<p>方法一：广度优先搜索</p>
<p>方法二：深度优先搜索</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="96-复制带随机指针的链表-中等"><a href="#96-复制带随机指针的链表-中等" class="headerlink" title="96. 复制带随机指针的链表-中等"></a><font color=DarkOrange>96. 复制带随机指针的链表-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点</p>
<p>构造这个链表的 <strong><a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin">深拷贝</a><strong>。 深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong> 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的<code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。</strong>复制链表中的指针都不应指向原链表中的节点</strong> </p>
<p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 <code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> </p>
<p>返回复制链表的头节点</p>
<p>用一个由 <code>n</code> 个节点组成的链表来表示输入&#x2F;输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p>
<ul>
<li><code>val</code>：一个表示 <code>Node.val</code> 的整数</li>
<li><code>random_index</code>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为 <code>null</code></li>
</ul>
<p>你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code> 作为传入参数</p>
<p><strong>思路：</strong></p>
<p>方法一：回溯 + 哈希表</p>
<p>方法二：迭代 + 节点拆分</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="97-排序数组-堆排序-中等"><a href="#97-排序数组-堆排序-中等" class="headerlink" title="97. 排序数组-堆排序-中等"></a><font color=DarkOrange>97. 排序数组-堆排序-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列</p>
<p><strong>思路：</strong></p>
<p>先将待排序的序列建成大根堆，使得每个父节点的元素大于等于它的子节点</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="98-寻找旋转排序数组中的最小值-中等"><a href="#98-寻找旋转排序数组中的最小值-中等" class="headerlink" title="98. 寻找旋转排序数组中的最小值-中等"></a><font color=DarkOrange>98. 寻找旋转排序数组中的最小值-中等</font></h4><p><strong>题目：</strong></p>
<p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p>
<ul>
<li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li>
<li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li>
</ul>
<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> </p>
<p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> </p>
<p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题</p>
<p><strong>思路：</strong></p>
<p>二分查找</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="99-最大数-中等"><a href="#99-最大数-中等" class="headerlink" title="99. 最大数-中等"></a><font color=DarkOrange>99. 最大数-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一组非负整数 <code>nums</code>，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数</p>
<p><strong>注意：</strong>输出结果可能非常大，所以你需要返回一个字符串而不是整数</p>
<p><strong>思路：</strong></p>
<p>排序</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="100-二叉树的序列化与反序列化-困难"><a href="#100-二叉树的序列化与反序列化-困难" class="headerlink" title="100. 二叉树的序列化与反序列化-困难"></a><font color=DarkOrange>100. 二叉树的序列化与反序列化-困难</font></h4><p><strong>题目：</strong></p>
<p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据</p>
<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 &#x2F; 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构</p>
<p><strong>思路：</strong></p>
<p>方法一：深度优先搜索</p>
<p>方法二：括号表示编码 + 递归下降解码</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="101-长度最小的子数组-中等"><a href="#101-长度最小的子数组-中等" class="headerlink" title="101. 长度最小的子数组-中等"></a><font color=DarkOrange>101. 长度最小的子数组-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> </p>
<p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> </p>
<p><strong>思路：</strong></p>
<p>方法一：暴力法</p>
<p>方法二：前缀和 + 二分查找</p>
<p>方法三：滑动窗口</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="102-单词拆分-中等"><a href="#102-单词拆分-中等" class="headerlink" title="102. 单词拆分-中等"></a><font color=DarkOrange>102. 单词拆分-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。请你判断是否可以利用字典中出现的单词拼接出 <code>s</code> </p>
<p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用</p>
<p><strong>思路：</strong></p>
<p>动态规划</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="103-验证IP地址-中等"><a href="#103-验证IP地址-中等" class="headerlink" title="103. 验证IP地址-中等"></a><font color=DarkOrange>103. 验证IP地址-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一个字符串 <code>queryIP</code>。如果是有效的 IPv4 地址，返回 <code>&quot;IPv4&quot;</code> ；如果是有效的 IPv6 地址，返回 <code>&quot;IPv6&quot;</code> ；如果不是上述类型的 IP 地址，返回 <code>&quot;Neither&quot;</code> </p>
<p><strong>有效的IPv4地址</strong> 是 <code>“x1.x2.x3.x4”</code> 形式的IP地址。 其中 <code>0 &lt;= xi &lt;= 255</code> 且 <code>xi</code> <strong>不能包含</strong> 前导零。例如: <code>“192.168.1.1”</code> 、 <code>“192.168.1.0”</code> 为有效IPv4地址， <code>“192.168.01.1”</code> 为无效IPv4地址; <code>“192.168.1.00”</code> 、 <code>“192.168@1.1”</code> 为无效IPv4地址</p>
<p><strong>一个有效的IPv6地址</strong> 是一个格式为<code>“x1:x2:x3:x4:x5:x6:x7:x8”</code> 的IP地址，其中：</p>
<ul>
<li><code>1 &lt;= xi.length &lt;= 4</code></li>
<li><code>xi</code> 是一个 <strong>十六进制字符串</strong> ，可以包含数字、小写英文字母( <code>&#39;a&#39;</code> 到 <code>&#39;f&#39;</code> )和大写英文字母( <code>&#39;A&#39;</code> 到 <code>&#39;F&#39;</code> )</li>
<li>在 <code>xi</code> 中允许前导零</li>
</ul>
<p>例如 <code>&quot;2001:0db8:85a3:0000:0000:8a2e:0370:7334&quot;</code> 和<code>&quot;2001:db8:85a3:0:0:8A2E:0370:7334&quot;</code> 是有效的 IPv6地址，而 <code>&quot;2001:0db8:85a3::8A2E:037j:7334&quot;</code> 和 <code>&quot;02001:0db8:85a3:0000:0000:8a2e:0370:7334&quot;</code> 是无效的 IPv6 地址</p>
<p><strong>思路：</strong></p>
<p>依次判断</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="104-和为-K-的子数组-中等"><a href="#104-和为-K-的子数组-中等" class="headerlink" title="104. 和为 K 的子数组-中等"></a><font color=DarkOrange>104. 和为 K 的子数组-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回该数组中和为 <code>k</code> 的连续子数组的个数</p>
<p><strong>思路：</strong></p>
<p>方法一：枚举</p>
<p>方法二：前缀和 + 哈希表优化</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="105-只出现一次的数字-简单"><a href="#105-只出现一次的数字-简单" class="headerlink" title="105. 只出现一次的数字-简单"></a><font color=DarkOrange>105. 只出现一次的数字-简单</font></h4><p><strong>题目：</strong></p>
<p>给你一个 <strong>非空</strong> 整数数组 <code>nums</code> ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素</p>
<p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间</p>
<p><strong>思路：</strong></p>
<p>位运算</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="106-用两个栈实现队列-简单"><a href="#106-用两个栈实现队列-简单" class="headerlink" title="106. 用两个栈实现队列-简单"></a><font color=DarkOrange>106. 用两个栈实现队列-简单</font></h4><p><strong>题目：</strong></p>
<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 )</p>
<p><strong>思路：</strong></p>
<p>双栈</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="107-对角线遍历-中等"><a href="#107-对角线遍历-中等" class="headerlink" title="107. 对角线遍历-中等"></a><font color=DarkOrange>107. 对角线遍历-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个大小为 m x n 的矩阵 mat ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素</p>
<p><strong>思路：</strong></p>
<p>直接模拟</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="108-移掉-K-位数字-中等"><a href="#108-移掉-K-位数字-中等" class="headerlink" title="108. 移掉 K 位数字-中等"></a><font color=DarkOrange>108. 移掉 K 位数字-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个以字符串表示的非负整数 <code>num</code> 和一个整数 <code>k</code> ，移除这个数中的 <code>k</code> 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字</p>
<p><strong>思路：</strong></p>
<p>贪心 + 单调栈</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="109-基本计算器-困难"><a href="#109-基本计算器-困难" class="headerlink" title="109. 基本计算器-困难"></a><font color=DarkOrange>109. 基本计算器-困难</font></h4><p><strong>题目：</strong></p>
<p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值</p>
<p>注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval()</code> </p>
<p><strong>思路：</strong></p>
<p>括号展开 + 栈</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="110-二叉搜索树与双向链表-中等"><a href="#110-二叉搜索树与双向链表-中等" class="headerlink" title="110. 二叉搜索树与双向链表-中等"></a><font color=DarkOrange>110. 二叉搜索树与双向链表-中等</font></h4><p><strong>题目：</strong></p>
<p><strong>思路：</strong></p>
<p><strong>代码：</strong></p>
<h4 id="111-排序数组-归并排序-中等"><a href="#111-排序数组-归并排序-中等" class="headerlink" title="111. 排序数组-归并排序-中等"></a><font color=DarkOrange>111. 排序数组-归并排序-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列</p>
<p><strong>思路：</strong></p>
<p>利用了分治的思想来对序列进行排序</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="112-LFU-缓存-困难"><a href="#112-LFU-缓存-困难" class="headerlink" title="112. LFU 缓存-困难"></a><font color=DarkOrange>112. LFU 缓存-困难</font></h4><p><strong>题目：</strong></p>
<p>请你为最不经常使用（LFU）缓存算法设计并实现数据结构</p>
<p>实现 <code>LFUCache</code> 类：</p>
<ul>
<li><code>LFUCache(int capacity)</code> - 用数据结构的容量 <code>capacity</code> 初始化对象</li>
<li><code>int get(int key)</code> - 如果键 <code>key</code> 存在于缓存中，则获取键的值，否则返回 <code>-1</code> </li>
<li><code>void put(int key, int value)</code> - 如果键 <code>key</code> 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 <code>capacity</code> 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 <strong>最近最久未使用</strong> 的键</li>
</ul>
<p>为了确定最不常使用的键，可以为缓存中的每个键维护一个 <strong>使用计数器</strong> 。使用计数最小的键是最久未使用的键</p>
<p>当一个键首次插入到缓存中时，它的使用计数器被设置为 <code>1</code> (由于 put 操作)。对缓存中的键执行 <code>get</code> 或 <code>put</code> 操作，使用计数器的值将会递增</p>
<p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行</p>
<p><strong>思路：</strong></p>
<p>方法一：哈希表 + 平衡二叉树</p>
<p>方法二：双哈希表</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="113-每日温度-中等"><a href="#113-每日温度-中等" class="headerlink" title="113. 每日温度-中等"></a><font color=DarkOrange>113. 每日温度-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替</p>
<p><strong>思路：</strong></p>
<p>方法一：暴力</p>
<p>方法二：单调栈</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="114-课程表-中等"><a href="#114-课程表-中等" class="headerlink" title="114. 课程表-中等"></a><font color=DarkOrange>114. 课程表-中等</font></h4><p><strong>题目：</strong></p>
<p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> </p>
<p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 <strong>必须</strong> 先学习课程 <code>bi</code> </p>
<ul>
<li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code></li>
</ul>
<p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> </p>
<p><strong>思路：</strong></p>
<p>方法一：深度优先搜索</p>
<p>方法二: 广度优先搜索</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="115-排序奇升偶降链表-中等"><a href="#115-排序奇升偶降链表-中等" class="headerlink" title="115. 排序奇升偶降链表-中等"></a><font color=DarkOrange>115. 排序奇升偶降链表-中等</font></h4><p><strong>题目：</strong></p>
<p>字节跳动高频题</p>
<p><strong>思路：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="116-二叉树的完全性检验-中等"><a href="#116-二叉树的完全性检验-中等" class="headerlink" title="116. 二叉树的完全性检验-中等"></a><font color=DarkOrange>116. 二叉树的完全性检验-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一个二叉树的 <code>root</code> ，确定它是否是一个完全二叉树</p>
<p>在一个 <strong>完全二叉树</strong> 中，除了最后一个关卡外，所有关卡都是完全被填满的，并且最后一个关卡中的所有节点都是尽可能靠左的。它可以包含 <code>1</code> 到 <code>2h</code> 节点之间的最后一级 <code>h</code> </p>
<p><strong>思路：</strong></p>
<p>广度优先搜索</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="117-检测循环依赖-中等"><a href="#117-检测循环依赖-中等" class="headerlink" title="117. 检测循环依赖-中等"></a><font color=DarkOrange>117. 检测循环依赖-中等</font></h4><p><strong>题目：</strong></p>
<p>补充题</p>
<p><strong>思路：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="118-二叉搜索树的第k大节点-简单"><a href="#118-二叉搜索树的第k大节点-简单" class="headerlink" title="118. 二叉搜索树的第k大节点-简单"></a><font color=DarkOrange>118. 二叉搜索树的第k大节点-简单</font></h4><p><strong>题目：</strong></p>
<p>给定一棵二叉搜索树，请找出其中第 k 大的节点的值</p>
<p><strong>思路：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="119-盛最多水的容器-中等"><a href="#119-盛最多水的容器-中等" class="headerlink" title="119. 盛最多水的容器-中等"></a><font color=DarkOrange>119. 盛最多水的容器-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> </p>
<p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水</p>
<p>返回容器可以储存的最大水量</p>
<p><strong>说明：</strong>你不能倾斜容器</p>
<p><strong>思路：</strong></p>
<p>双指针</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="120-单词搜索-中等"><a href="#120-单词搜索-中等" class="headerlink" title="120. 单词搜索-中等"></a><font color=DarkOrange>120. 单词搜索-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> </p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用</p>
<p><strong>思路：</strong></p>
<p>回溯</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="121-青蛙跳台阶问题-简单"><a href="#121-青蛙跳台阶问题-简单" class="headerlink" title="121. 青蛙跳台阶问题-简单"></a><font color=DarkOrange>121. 青蛙跳台阶问题-简单</font></h4><p><strong>题目：</strong></p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1</p>
<p><strong>思路：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="122-组合总和-II-中等"><a href="#122-组合总和-II-中等" class="headerlink" title="122. 组合总和 II-中等"></a><font color=DarkOrange>122. 组合总和 II-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合</p>
<p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> </p>
<p><strong>注意：</strong>解集不能包含重复的组合</p>
<p><strong>思路：</strong></p>
<p>回溯</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="123-跳跃游戏-中等"><a href="#123-跳跃游戏-中等" class="headerlink" title="123. 跳跃游戏-中等"></a><font color=DarkOrange>123. 跳跃游戏-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> </p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度</p>
<p>判断你是否能够到达最后一个下标</p>
<p><strong>思路：</strong></p>
<p>贪心</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="124-二叉树的后序遍历-简单"><a href="#124-二叉树的后序遍历-简单" class="headerlink" title="124. 二叉树的后序遍历-简单"></a><font color=DarkOrange>124. 二叉树的后序遍历-简单</font></h4><p><strong>题目：</strong></p>
<p>给你一棵二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>后序遍历</strong> </p>
<p><strong>思路：</strong></p>
<p>方法一：递归</p>
<p>方法二：迭代</p>
<p>方法三：Morris 遍历</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="125-数组中的逆序对-困难"><a href="#125-数组中的逆序对-困难" class="headerlink" title="125. 数组中的逆序对-困难"></a><font color=DarkOrange>125. 数组中的逆序对-困难</font></h4><p><strong>题目：</strong></p>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数</p>
<p><strong>思路：</strong></p>
<p>方法一：归并排序</p>
<p>方法二：离散化树状数组</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="126-螺旋矩阵-II-中等"><a href="#126-螺旋矩阵-II-中等" class="headerlink" title="126. 螺旋矩阵 II-中等"></a><font color=DarkOrange>126. 螺旋矩阵 II-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> </p>
<p><strong>思路：</strong></p>
<p>模拟</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="127-搜索二维矩阵-中等"><a href="#127-搜索二维矩阵-中等" class="headerlink" title="127. 搜索二维矩阵-中等"></a><font color=DarkOrange>127. 搜索二维矩阵-中等</font></h4><p><strong>题目：</strong></p>
<p>编写一个高效的算法来判断 <code>m x n</code> 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>
<ul>
<li>每行中的整数从左到右按升序排列</li>
<li>每行的第一个整数大于前一行的最后一个整数</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：两次二分查找</p>
<p>方法二：一次二分查找</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="128-删除有序数组中的重复项-简单"><a href="#128-删除有序数组中的重复项-简单" class="headerlink" title="128. 删除有序数组中的重复项-简单"></a><font color=DarkOrange>128. 删除有序数组中的重复项-简单</font></h4><p><strong>题目：</strong></p>
<p>给你一个 <strong>升序排列</strong> 的数组 <code>nums</code> ，请你<strong>原地</strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong></p>
<p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 <code>k</code> 个元素，那么 <code>nums</code> 的前 <code>k</code> 个元素应该保存最终结果</p>
<p>将最终结果插入 <code>nums</code> 的前 <code>k</code> 个位置后返回 <code>k</code> </p>
<p>不要使用额外的空间，你必须在 <strong>原地修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成</p>
<p><strong>思路：</strong></p>
<p>双指针</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="129-圆环回原点问题-中等"><a href="#129-圆环回原点问题-中等" class="headerlink" title="129. 圆环回原点问题-中等"></a><font color=DarkOrange>129. 圆环回原点问题-中等</font></h4><p><strong>题目：</strong></p>
<p>字节跳动高频题</p>
<p><strong>思路：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="130-全排列-II-中等"><a href="#130-全排列-II-中等" class="headerlink" title="130. 全排列 II-中等"></a><font color=DarkOrange>130. 全排列 II-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一个可包含重复数字的序列 <code>nums</code> ，<strong>按任意顺序</strong> 返回所有不重复的全排列</p>
<p><strong>思路：</strong></p>
<p>搜索回溯</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="131-零钱兑换-II-中等"><a href="#131-零钱兑换-II-中等" class="headerlink" title="131. 零钱兑换 II-中等"></a><font color=DarkOrange>131. 零钱兑换 II-中等</font></h4><p><strong>题目：</strong></p>
<p><strong>思路：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="132-斐波那契数列-简单"><a href="#132-斐波那契数列-简单" class="headerlink" title="132. 斐波那契数列-简单"></a><font color=DarkOrange>132. 斐波那契数列-简单</font></h4><p><strong>题目：</strong></p>
<p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure>

<p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1</p>
<p><strong>思路：</strong></p>
<p>方法一：动态规划</p>
<p>方法二：矩阵快速幂</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="133-Pow-x-n-中等"><a href="#133-Pow-x-n-中等" class="headerlink" title="133. Pow(x, n)-中等"></a><font color=DarkOrange>133. Pow(x, n)-中等</font></h4><p><strong>题目：</strong></p>
<p>实现pow(x, n) ，即计算 <code>x</code> 的整数 <code>n</code> 次幂函数（即，<code>x^n</code> ）</p>
<p><strong>思路：</strong></p>
<p>方法一：快速幂 + 递归</p>
<p>方法二：快速幂 + 迭代</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="134-旋转链表-中等"><a href="#134-旋转链表-中等" class="headerlink" title="134. 旋转链表-中等"></a><font color=DarkOrange>134. 旋转链表-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动 <code>k</code> 个位置</p>
<p><strong>思路：</strong></p>
<p>闭合为环</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="135-删除二叉搜索树中的节点-中等"><a href="#135-删除二叉搜索树中的节点-中等" class="headerlink" title="135. 删除二叉搜索树中的节点-中等"></a><font color=DarkOrange>135. 删除二叉搜索树中的节点-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用</p>
<p>一般来说，删除节点可分为两个步骤：</p>
<ol>
<li>首先找到需要删除的节点</li>
<li>如果找到了，删除它</li>
</ol>
<p><strong>思路：</strong></p>
<p>方法一：递归</p>
<p>方法二：迭代</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="136-最小的k个数-简单"><a href="#136-最小的k个数-简单" class="headerlink" title="136. 最小的k个数-简单"></a><font color=DarkOrange>136. 最小的k个数-简单</font></h4><p><strong>题目：</strong></p>
<p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4</p>
<p><strong>思路：</strong></p>
<p>方法一：排序</p>
<p>方法二：堆</p>
<p>方法三：快排思想</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="137-卖股票的最佳时机-III-困难"><a href="#137-卖股票的最佳时机-III-困难" class="headerlink" title="137. 卖股票的最佳时机 III-困难"></a><font color=DarkOrange>137. 卖股票的最佳时机 III-困难</font></h4><p><strong>题目：</strong></p>
<p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易</p>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）</p>
<p><strong>思路：</strong></p>
<p>动态规划</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="138-整数反转-简单"><a href="#138-整数反转-简单" class="headerlink" title="138. 整数反转-简单"></a><font color=DarkOrange>138. 整数反转-简单</font></h4><p><strong>题目：</strong></p>
<p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果</p>
<p>如果反转后整数超过 32 位的有符号整数的范围 <code>[−2^31, 2^31 − 1]</code> ，就返回 0</p>
<p><strong>假设环境不允许存储 64 位整数（有符号或无符号）</strong></p>
<p><strong>思路：</strong></p>
<p>数学</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="139-连续子数组的最大和-简单"><a href="#139-连续子数组的最大和-简单" class="headerlink" title="139. 连续子数组的最大和-简单"></a><font color=DarkOrange>139. 连续子数组的最大和-简单</font></h4><p><strong>题目：</strong></p>
<p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值</p>
<p>要求时间复杂度为O(n)</p>
<p><strong>思路：</strong></p>
<p>方法一：动态规划</p>
<p>方法二：分治</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="140-整数组顺序使奇数位于偶数前面-简单"><a href="#140-整数组顺序使奇数位于偶数前面-简单" class="headerlink" title="140. 整数组顺序使奇数位于偶数前面-简单"></a><font color=DarkOrange>140. 整数组顺序使奇数位于偶数前面-简单</font></h4><p><strong>题目：</strong></p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分</p>
<p><strong>思路：</strong></p>
<p>方法一：两次遍历</p>
<p>方法二：双指针 + 一次遍历</p>
<p>方法三：原地交换</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="141-二叉搜索树中第K小的元素-中等"><a href="#141-二叉搜索树中第K小的元素-中等" class="headerlink" title="141. 二叉搜索树中第K小的元素-中等"></a><font color=DarkOrange>141. 二叉搜索树中第K小的元素-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）</p>
<p><strong>思路：</strong></p>
<p>方法一：中序遍历</p>
<p>方法二：记录子树的结点数</p>
<p>方法三：平衡二叉搜索树</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="142-用队列实现栈-简单"><a href="#142-用队列实现栈-简单" class="headerlink" title="142. 用队列实现栈-简单"></a><font color=DarkOrange>142. 用队列实现栈-简单</font></h4><p><strong>题目：</strong></p>
<p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）</p>
<p>实现 <code>MyStack</code> 类：</p>
<ul>
<li><code>void push(int x)</code> 将元素 x 压入栈顶</li>
<li><code>int pop()</code> 移除并返回栈顶元素</li>
<li><code>int top()</code> 返回栈顶元素</li>
<li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code></li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>你只能使用队列的基本操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作</li>
<li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：两个队列</p>
<p>方法二：一个队列</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="143-字典序的第K小数字-困难"><a href="#143-字典序的第K小数字-困难" class="headerlink" title="143. 字典序的第K小数字-困难"></a><font color=DarkOrange>143. 字典序的第K小数字-困难</font></h4><p><strong>题目：</strong></p>
<p>给定整数 <code>n</code> 和 <code>k</code>，返回 <code>[1, n]</code> 中字典序第 <code>k</code> 小的数字</p>
<p><strong>思路：</strong></p>
<p>字典树思想</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="144-分发糖果-困难"><a href="#144-分发糖果-困难" class="headerlink" title="144. 分发糖果-困难"></a><font color=DarkOrange>144. 分发糖果-困难</font></h4><p><strong>题目：</strong></p>
<p><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分</p>
<p>你需要按照以下要求，给这些孩子分发糖果：</p>
<ul>
<li>每个孩子至少分配到 <code>1</code> 个糖果</li>
<li>相邻两个孩子评分更高的孩子会获得更多的糖果</li>
</ul>
<p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> </p>
<p><strong>思路：</strong></p>
<p>方法一：两次遍历</p>
<p>方法二：常数空间遍历</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="145-圆圈中最后剩下的数字-简单"><a href="#145-圆圈中最后剩下的数字-简单" class="headerlink" title="145. 圆圈中最后剩下的数字-简单"></a><font color=DarkOrange>145. 圆圈中最后剩下的数字-简单</font></h4><p><strong>题目：</strong></p>
<p>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3</p>
<p><strong>思路：</strong></p>
<p>方法一：数学 + 递归</p>
<p>方法二：数学 + 迭代</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="146-颜色分类-中等"><a href="#146-颜色分类-中等" class="headerlink" title="146. 颜色分类-中等"></a><font color=DarkOrange>146. 颜色分类-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一个包含红色、白色和蓝色、共 <code>n</code> 个元素的数组 <code>nums</code> ，<strong>原地</strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列</p>
<p>我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色</p>
<p>必须在不使用库的sort函数的情况下解决这个问题</p>
<p><strong>思路：</strong></p>
<p>方法一：单指针</p>
<p>方法二：双指针</p>
<p>方法三：双指针</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="147-矩阵中的最长递增路径-困难"><a href="#147-矩阵中的最长递增路径-困难" class="headerlink" title="147. 矩阵中的最长递增路径-困难"></a><font color=DarkOrange>147. 矩阵中的最长递增路径-困难</font></h4><p><strong>题目：</strong></p>
<p>给定一个 <code>m x n</code> 整数矩阵 <code>matrix</code> ，找出其中 <strong>最长递增路径</strong> 的长度</p>
<p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你 <strong>不能</strong> 在 <strong>对角线</strong> 方向上移动或移动到 <strong>边界外</strong>（即不允许环绕）</p>
<p><strong>思路：</strong></p>
<p>方法一：记忆化深度优先搜索</p>
<p>方法二：拓扑排序</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="148-二维数组中的查找-中等"><a href="#148-二维数组中的查找-中等" class="headerlink" title="148. 二维数组中的查找-中等"></a><font color=DarkOrange>148. 二维数组中的查找-中等</font></h4><p><strong>题目：</strong></p>
<p>在一个 n * m 的二维数组中，每一行都按照从左到右 <strong>非递减</strong> 的顺序排序，每一列都按照从上到下 <strong>非递减</strong> 的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数</p>
<p><strong>思路：</strong></p>
<p>方法一：直接查找</p>
<p>方法二：二分查找</p>
<p>方法三：Z 字形查找</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="149-奇偶链表-中等"><a href="#149-奇偶链表-中等" class="headerlink" title="149. 奇偶链表-中等"></a><font color=DarkOrange>149. 奇偶链表-中等</font></h4><p><strong>题目：</strong></p>
<p>给定单链表的头节点 <code>head</code> ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表</p>
<p><strong>第一个</strong>节点的索引被认为是 <strong>奇数</strong> ， <strong>第二个</strong>节点的索引为 <strong>偶数</strong> ，以此类推</p>
<p>请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致</p>
<p>你必须在 <code>O(1)</code> 的额外空间复杂度和 <code>O(n)</code> 的时间复杂度下解决这个问题</p>
<p><strong>思路：</strong></p>
<p>分离节点后合并</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="150-解码方法-中等"><a href="#150-解码方法-中等" class="headerlink" title="150. 解码方法-中等"></a><font color=DarkOrange>150. 解码方法-中等</font></h4><p><strong>题目：</strong></p>
<p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;A&#x27;</span> -&gt; <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="string">&#x27;B&#x27;</span> -&gt; <span class="string">&quot;2&quot;</span></span><br><span class="line">...</span><br><span class="line"><span class="string">&#x27;Z&#x27;</span> -&gt; <span class="string">&quot;26&quot;</span></span><br></pre></td></tr></table></figure>

<p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>&quot;11106&quot;</code> 可以映射为：</p>
<ul>
<li><code>&quot;AAJF&quot;</code> ，将消息分组为 <code>(1 1 10 6)</code></li>
<li><code>&quot;KJF&quot;</code> ，将消息分组为 <code>(11 10 6)</code></li>
</ul>
<p>注意，消息不能分组为 <code>(1 11 06)</code> ，因为 <code>&quot;06&quot;</code> 不能映射为 <code>&quot;F&quot;</code> ，这是由于 <code>&quot;6&quot;</code> 和 <code>&quot;06&quot;</code> 在映射中并不等价</p>
<p>给你一个只含数字的 <strong>非空</strong> 字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> </p>
<p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数</p>
<p><strong>思路：</strong></p>
<p>动态规划</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="151-另一棵树的子树-简单"><a href="#151-另一棵树的子树-简单" class="headerlink" title="151. 另一棵树的子树-简单"></a><font color=DarkOrange>151. 另一棵树的子树-简单</font></h4><p><strong>题目：</strong></p>
<p>给你两棵二叉树 <code>root</code> 和 <code>subRoot</code> 。检验 <code>root</code> 中是否包含和 <code>subRoot</code> 具有相同结构和节点值的子树。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> </p>
<p>二叉树 <code>tree</code> 的一棵子树包括 <code>tree</code> 的某个节点和这个节点的所有后代节点。<code>tree</code> 也可以看做它自身的一棵子树</p>
<p><strong>思路：</strong></p>
<p>方法一：深度优先搜索暴力匹配</p>
<p>方法二：深度优先搜索序列上做串匹配</p>
<p>方法三：树哈希</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="152-打乱数组-中等"><a href="#152-打乱数组-中等" class="headerlink" title="152. 打乱数组-中等"></a><font color=DarkOrange>152. 打乱数组-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个整数数组 <code>nums</code> ，设计算法来打乱一个没有重复元素的数组。打乱后，数组的所有排列应该是 <strong>等可能</strong> 的</p>
<p>实现 <code>Solution</code> class：</p>
<ul>
<li><code>Solution(int[] nums)</code> 使用整数数组 <code>nums</code> 初始化对象</li>
<li><code>int[] reset()</code> 重设数组到它的初始状态并返回</li>
<li><code>int[] shuffle()</code> 返回数组随机打乱后的结果</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：暴力</p>
<p>方法二：Fisher-Yates 洗牌算法</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="153-验证回文串-简单"><a href="#153-验证回文串-简单" class="headerlink" title="153. 验证回文串-简单"></a><font color=DarkOrange>153. 验证回文串-简单</font></h4><p><strong>题目：</strong></p>
<p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 <strong>回文串</strong> </p>
<p>字母和数字都属于字母数字字符</p>
<p>给你一个字符串 <code>s</code>，如果它是 <strong>回文串</strong> ，返回 <code>true</code> ；否则，返回 <code>false</code> </p>
<p><strong>思路：</strong></p>
<p>方法一：筛选 + 判断</p>
<p>方法二：在原字符串上直接判断</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="154-回文数-简单"><a href="#154-回文数-简单" class="headerlink" title="154. 回文数-简单"></a><font color=DarkOrange>154. 回文数-简单</font></h4><p><strong>题目：</strong></p>
<p>给你一个整数 <code>x</code> ，如果 <code>x</code> 是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code> </p>
<p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数</p>
<ul>
<li>例如，<code>121</code> 是回文，而 <code>123</code> 不是</li>
</ul>
<p><strong>思路：</strong></p>
<p>反转一半数字</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="154-轮转数组-中等"><a href="#154-轮转数组-中等" class="headerlink" title="154. 轮转数组-中等"></a><font color=DarkOrange>154. 轮转数组-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个数组，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数</p>
<p><strong>思路：</strong></p>
<p>方法一：使用额外的数组</p>
<p>方法二：环状替换</p>
<p>方法三：数组翻转</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="155-跳跃游戏-II-中等"><a href="#155-跳跃游戏-II-中等" class="headerlink" title="155. 跳跃游戏 II-中等"></a><font color=DarkOrange>155. 跳跃游戏 II-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的第一个位置</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置</p>
<p>假设你总是可以到达数组的最后一个位置</p>
<p><strong>思路：</strong></p>
<p>方法一：反向查找出发位置</p>
<p>方法二：正向查找可到达的最大位置</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="157-两数相加-II-中等"><a href="#157-两数相加-II-中等" class="headerlink" title="157. 两数相加 II-中等"></a><font color=DarkOrange>157. 两数相加 II-中等</font></h4><p><strong>题目：</strong></p>
<p>给你两个 <strong>非空</strong> 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表</p>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头</p>
<p><strong>思路：</strong></p>
<p>栈</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="158-二叉树的镜像-简单"><a href="#158-二叉树的镜像-简单" class="headerlink" title="158. 二叉树的镜像-简单"></a><font color=DarkOrange>158. 二叉树的镜像-简单</font></h4><p><strong>题目：</strong></p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h88ink6q3sj30hk0fi752.jpg" alt="image.png" style="zoom:67%;" /></div>

<p><strong>思路：</strong></p>
<p>递归</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="159-寻找重复数-中等"><a href="#159-寻找重复数-中等" class="headerlink" title="159. 寻找重复数-中等"></a><font color=DarkOrange>159. 寻找重复数-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code> ，其数字都在 <code>[1, n]</code> 范围内（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数</p>
<p>假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，返回 <strong>这个重复的数</strong> </p>
<p>你设计的解决方案必须 <strong>不修改</strong> 数组 <code>nums</code> 且只用常量级 <code>O(1)</code> 的额外空间</p>
<p><strong>思路：</strong></p>
<p>方法一：二分查找</p>
<p>方法二：二进制</p>
<p>方法三：快慢指针</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="160-实现-Trie-前缀树-中等"><a href="#160-实现-Trie-前缀树-中等" class="headerlink" title="160. 实现 Trie (前缀树)-中等"></a><font color=DarkOrange>160. 实现 Trie (前缀树)-中等</font></h4><p><strong>题目：</strong></p>
<p><strong>Trie</strong>（发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查</p>
<p>请你实现 Trie 类：</p>
<ul>
<li><code>Trie()</code> 初始化前缀树对象</li>
<li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> </li>
<li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> </li>
<li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>字典树</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="161-数据流的中位数-困难"><a href="#161-数据流的中位数-困难" class="headerlink" title="161. 数据流的中位数-困难"></a><font color=DarkOrange>161. 数据流的中位数-困难</font></h4><p><strong>题目：</strong></p>
<p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值</p>
<p>例如，</p>
<p>[2,3,4] 的中位数是 3</p>
<p>[2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<ul>
<li>void addNum(int num) - 从数据流中添加一个整数到数据结构中</li>
<li>double findMedian() - 返回目前所有元素的中位数</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：优先队列</p>
<p>方法二：有序集合 + 双指针</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="162-二叉树展开为链表-中等"><a href="#162-二叉树展开为链表-中等" class="headerlink" title="162. 二叉树展开为链表-中等"></a><font color=DarkOrange>162. 二叉树展开为链表-中等</font></h4><p><strong>题目：</strong></p>
<p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> </li>
<li>展开后的单链表应该与二叉树 <strong>先序遍历</strong> 顺序相同</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：前序遍历</p>
<p>方法二：前序遍历和展开同步进行</p>
<p>方法三：寻找前驱节点</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="163-接近的三数之和-中等"><a href="#163-接近的三数之和-中等" class="headerlink" title="163. 接近的三数之和-中等"></a><font color=DarkOrange>163. 接近的三数之和-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 和 一个目标值 <code>target</code>。请你从 <code>nums</code> 中选出三个整数，使它们的和与 <code>target</code> 最接近</p>
<p>返回这三个数的和</p>
<p>假定每组输入只存在恰好一个解</p>
<p><strong>思路：</strong></p>
<p>排序 + 双指针</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="164-打家劫舍-II-中等"><a href="#164-打家劫舍-II-中等" class="headerlink" title="164. 打家劫舍 II-中等"></a><font color=DarkOrange>164. 打家劫舍 II-中等</font></h4><p><strong>题目：</strong></p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> </p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额</p>
<p><strong>思路：</strong></p>
<p>动态规划</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="165-三角形最小路径和-中等"><a href="#165-三角形最小路径和-中等" class="headerlink" title="165. 三角形最小路径和-中等"></a><font color=DarkOrange>165. 三角形最小路径和-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一个三角形 <code>triangle</code> ，找出自顶向下的最小路径和</p>
<p>每一步只能移动到下一行中相邻的结点上。<strong>相邻的结点</strong> 在这里指的是 <strong>下标</strong> 与 <strong>上一层结点下标</strong> 相同或者等于 <strong>上一层结点下标 + 1</strong> 的两个结点。也就是说，如果正位于当前行的下标 <code>i</code> ，那么下一步可以移动到下一行的下标 <code>i</code> 或 <code>i + 1</code> </p>
<p><strong>思路：</strong></p>
<p>方法一：动态规划</p>
<p>方法二：动态规划 + 空间优化</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="166-顺时针打印矩阵-简单"><a href="#166-顺时针打印矩阵-简单" class="headerlink" title="166. 顺时针打印矩阵-简单"></a><font color=DarkOrange>166. 顺时针打印矩阵-简单</font></h4><p><strong>题目：</strong></p>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字</p>
<p><strong>思路：</strong></p>
<p>方法一：模拟</p>
<p>方法二：按层模拟</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="167-正则表达式匹配-困难"><a href="#167-正则表达式匹配-困难" class="headerlink" title="167. 正则表达式匹配-困难"></a><font color=DarkOrange>167. 正则表达式匹配-困难</font></h4><p><strong>题目：</strong></p>
<p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配</p>
<ul>
<li><code>&#39;.&#39;</code> 匹配任意单个字符</li>
<li><code>&#39;*&#39;</code> 匹配零个或多个前面的那一个元素</li>
</ul>
<p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 <code>s</code>的，而不是部分字符串</p>
<p><strong>思路：</strong></p>
<p>动态规划</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="168-从中序与后序遍历序列构造二叉树-中等"><a href="#168-从中序与后序遍历序列构造二叉树-中等" class="headerlink" title="168. 从中序与后序遍历序列构造二叉树-中等"></a><font color=DarkOrange>168. 从中序与后序遍历序列构造二叉树-中等</font></h4><p><strong>题目：</strong></p>
<p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗二叉树</p>
<p><strong>思路：</strong></p>
<p>方法一：递归</p>
<p>方法二：迭代</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="169-第-N-位数字-中等"><a href="#169-第-N-位数字-中等" class="headerlink" title="169. 第 N 位数字-中等"></a><font color=DarkOrange>169. 第 N 位数字-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个整数 <code>n</code> ，请你在无限的整数序列 <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...]</code> 中找出并返回第 <code>n</code> 位上的数字</p>
<p><strong>思路：</strong></p>
<p>方法一：二分查找</p>
<p>方法二：直接计算</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="170-树的子结构-中等"><a href="#170-树的子结构-中等" class="headerlink" title="170. 树的子结构-中等"></a><font color=DarkOrange>170. 树的子结构-中等</font></h4><p><strong>题目：</strong></p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h88j43kz1xj30p60gw40b.jpg" alt="image.png" style="zoom:67%;" /></div>

<p><strong>思路：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="171-链表求和-中等"><a href="#171-链表求和-中等" class="headerlink" title="171. 链表求和-中等"></a><font color=DarkOrange>171. 链表求和-中等</font></h4><p><strong>题目：</strong></p>
<p>给定两个用链表表示的整数，每个节点包含一个数位</p>
<p>这些数位是反向存放的，也就是个位排在链表首部</p>
<p>编写函数对这两个整数求和，并用链表形式返回结果</p>
<p><strong>思路：</strong></p>
<p>模拟</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="172-有效的括号字符串-中等"><a href="#172-有效的括号字符串-中等" class="headerlink" title="172. 有效的括号字符串-中等"></a><font color=DarkOrange>172. 有效的括号字符串-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一个只包含三种字符的字符串：<code>（ </code>，<code>）</code> 和 <code>*</code>，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：</p>
<ol>
<li>任何左括号 <code>(</code> 必须有相应的右括号 <code>)</code></li>
<li>任何右括号 <code>)</code> 必须有相应的左括号 <code>(</code> </li>
<li>左括号 <code>(</code> 必须在对应的右括号之前 <code>)</code></li>
<li><code>*</code> 可以被视为单个右括号 <code>)</code> ，或单个左括号 <code>(</code> ，或一个空字符串</li>
<li>一个空字符串也被视为有效字符串</li>
</ol>
<p><strong>思路：</strong></p>
<p>方法一：动态规划</p>
<p>方法二：栈</p>
<p>方法三：贪心</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="173-两个链表的第一个公共节点-简单"><a href="#173-两个链表的第一个公共节点-简单" class="headerlink" title="173. 两个链表的第一个公共节点-简单"></a><font color=DarkOrange>173. 两个链表的第一个公共节点-简单</font></h4><p><strong>题目：</strong></p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h88j86dqzej30lk0c6myc.jpg" alt="image.png" style="zoom:67%;" /></div>

<p><strong>思路：</strong></p>
<p>方法一：哈希集合</p>
<p>方法二：双指针</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="174-前-K-个高频元素-中等"><a href="#174-前-K-个高频元素-中等" class="headerlink" title="174. 前 K 个高频元素-中等"></a><font color=DarkOrange>174. 前 K 个高频元素-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案</p>
<p><strong>思路：</strong></p>
<p>方法一：堆</p>
<p>方法二：基于快速排序</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="175-不同的二叉搜索树-中等"><a href="#175-不同的二叉搜索树-中等" class="headerlink" title="175. 不同的二叉搜索树-中等"></a><font color=DarkOrange>175. 不同的二叉搜索树-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数</p>
<p><strong>思路：</strong></p>
<p>方法一：动态规划</p>
<p>方法二：数学</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="176-两个数组的交集-简单"><a href="#176-两个数组的交集-简单" class="headerlink" title="176. 两个数组的交集-简单"></a><font color=DarkOrange>176. 两个数组的交集-简单</font></h4><p><strong>题目：</strong></p>
<p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回它们的交集 。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> </p>
<p><strong>思路：</strong></p>
<p>方法一：两个集合</p>
<p>方法二：排序 + 双指针</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="177-36进制加法-中等"><a href="#177-36进制加法-中等" class="headerlink" title="177. 36进制加法-中等"></a><font color=DarkOrange>177. 36进制加法-中等</font></h4><p><strong>题目：</strong></p>
<p>字节高频题</p>
<p><strong>思路：</strong><br><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="178-数组中出现次数超过一半的数字-简单"><a href="#178-数组中出现次数超过一半的数字-简单" class="headerlink" title="178. 数组中出现次数超过一半的数字-简单"></a><font color=DarkOrange>178. 数组中出现次数超过一半的数字-简单</font></h4><p><strong>题目：</strong></p>
<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素</p>
<p><strong>思路：</strong></p>
<p>方法一：哈希表</p>
<p>方法二：排序</p>
<p>方法三：随机化</p>
<p>方法四：分治</p>
<p>方法五：Boyer-Moore 投票算法</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="179-Excel表列名称-简单"><a href="#179-Excel表列名称-简单" class="headerlink" title="179. Excel表列名称-简单"></a><font color=DarkOrange>179. Excel表列名称-简单</font></h4><p><strong>题目：</strong></p>
<p>给你一个整数 <code>columnNumber</code> ，返回它在 Excel 表中相对应的列名称</p>
<p>例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<p>数学</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="180-扑克牌中的顺子-简单"><a href="#180-扑克牌中的顺子-简单" class="headerlink" title="180. 扑克牌中的顺子-简单"></a><font color=DarkOrange>180. 扑克牌中的顺子-简单</font></h4><p><strong>题目：</strong></p>
<p>从<strong>若干副扑克牌</strong>中随机抽 <code>5</code> 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14</p>
<p><strong>思路：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="181-鸡蛋掉落-困难"><a href="#181-鸡蛋掉落-困难" class="headerlink" title="181. 鸡蛋掉落-困难"></a><font color=DarkOrange>181. 鸡蛋掉落-困难</font></h4><p><strong>题目：</strong></p>
<p>给你 <code>k</code> 枚相同的鸡蛋，并可以使用一栋从第 <code>1</code> 层到第 <code>n</code> 层共有 <code>n</code> 层楼的建筑</p>
<p>已知存在楼层 <code>f</code> ，满足 <code>0 &lt;= f &lt;= n</code> ，任何从 <strong>高于</strong> <code>f</code> 的楼层落下的鸡蛋都会碎，从 <code>f</code> 楼层或比它低的楼层落下的鸡蛋都不会破</p>
<p>每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 <code>x</code> 扔下（满足 <code>1 &lt;= x &lt;= n</code>）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 <strong>重复使用</strong> 这枚鸡蛋</p>
<p>请你计算并返回要确定 <code>f</code> <strong>确切的值</strong> 的 <strong>最小操作次数</strong> 是多少？</p>
<p><strong>思路：</strong></p>
<p>方法一：动态规划 + 二分查找</p>
<p>方法二：决策单调性</p>
<p>方法三：数学法</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="182-最长递增子序列的个数-中等"><a href="#182-最长递增子序列的个数-中等" class="headerlink" title="182. 最长递增子序列的个数-中等"></a><font color=DarkOrange>182. 最长递增子序列的个数-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一个未排序的整数数组 <code>nums</code> ， 返回最长递增子序列的个数</p>
<p><strong>注意</strong> 这个数列必须是 <strong>严格</strong> 递增的</p>
<p><strong>思路：</strong></p>
<p>方法一：动态规划</p>
<p>方法二：贪心 + 前缀和 + 二分查找</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="183-简化路径-中等"><a href="#183-简化路径-中等" class="headerlink" title="183. 简化路径-中等"></a><font color=DarkOrange>183. 简化路径-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个字符串 <code>path</code> ，表示指向某一文件或目录的 Unix 风格 <strong>绝对路径</strong> （以 <code>&#39;/&#39;</code> 开头），请你将其转化为更加简洁的规范路径</p>
<p>在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，<code>&#39;//&#39;</code>）都被视为单个斜杠 <code>&#39;/&#39;</code> 。 对于此问题，任何其他格式的点（例如，<code>&#39;...&#39;</code>）均被视为文件&#x2F;目录名称</p>
<p>请注意，返回的 <strong>规范路径</strong> 必须遵循下述格式：</p>
<ul>
<li>始终以斜杠 <code>&#39;/&#39;</code> 开头</li>
<li>两个目录名之间必须只有一个斜杠 <code>&#39;/&#39;</code> </li>
<li>最后一个目录名（如果存在）<strong>不能</strong> 以 <code>&#39;/&#39;</code> 结尾</li>
<li>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 <code>&#39;.&#39;</code> 或 <code>&#39;..&#39;</code>）</li>
</ul>
<p>返回简化后得到的 <strong>规范路径</strong> </p>
<p><strong>思路：</strong></p>
<p>栈</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="184-数组中重复的数据-中等"><a href="#184-数组中重复的数据-中等" class="headerlink" title="184. 数组中重复的数据-中等"></a><font color=DarkOrange>184. 数组中重复的数据-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，其中 <code>nums</code> 的所有整数都在范围 <code>[1, n]</code> 内，且每个整数出现 <strong>一次</strong> 或 <strong>两次</strong> 。请你找出所有出现 <strong>两次</strong> 的整数，并以数组形式返回</p>
<p>你必须设计并实现一个时间复杂度为 <code>O(n)</code> 且仅使用常量额外空间的算法解决此问题</p>
<p><strong>思路：</strong></p>
<p>方法一：将元素交换到对应的位置</p>
<p>方法二：使用正负号作为标记</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="185-斐波那契数-简单"><a href="#185-斐波那契数-简单" class="headerlink" title="185. 斐波那契数-简单"></a><font color=DarkOrange>185. 斐波那契数-简单</font></h4><p><strong>题目：</strong></p>
<p><strong>斐波那契数</strong> （通常用 <code>F(n)</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">F(0) = 0，F(1) = 1</span><br><span class="line">F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</span><br></pre></td></tr></table></figure>

<p>给定 <code>n</code> ，请计算 <code>F(n)</code> </p>
<p><strong>思路：</strong></p>
<p>方法一：动态规划</p>
<p>方法二：矩阵快速幂</p>
<p>方法三：通项公式</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="186-删除字符串中的所有相邻重复项-简单"><a href="#186-删除字符串中的所有相邻重复项-简单" class="headerlink" title="186. 删除字符串中的所有相邻重复项-简单"></a><font color=DarkOrange>186. 删除字符串中的所有相邻重复项-简单</font></h4><p><strong>题目：</strong></p>
<p>给出由小写字母组成的字符串 <code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一</p>
<p><strong>思路：</strong></p>
<p>栈</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="187-加油站-中等"><a href="#187-加油站-中等" class="headerlink" title="187. 加油站-中等"></a><font color=DarkOrange>187. 加油站-中等</font></h4><p><strong>题目：</strong></p>
<p>在一条环路上有 <code>n</code> 个加油站，其中第 <code>i</code> 个加油站有汽油 <code>gas[i]</code> 升</p>
<p>你有一辆油箱容量无限的的汽车，从第 <code>i</code> 个加油站开往第 <code>i+1</code> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空</p>
<p>给定两个整数数组 <code>gas</code> 和 <code>cost</code> ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 <code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的</p>
<p><strong>思路：</strong></p>
<p>一次遍历</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="188-有效三角形的个数-中等"><a href="#188-有效三角形的个数-中等" class="headerlink" title="188. 有效三角形的个数-中等"></a><font color=DarkOrange>188. 有效三角形的个数-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一个包含非负整数的数组 <code>nums</code> ，返回其中可以组成三角形三条边的三元组个数</p>
<p><strong>思路：</strong></p>
<p>方法一：排序 + 二分查找</p>
<p>方法二：排序 + 双指针</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="189-最大连续1的个数-III-中等"><a href="#189-最大连续1的个数-III-中等" class="headerlink" title="189. 最大连续1的个数 III-中等"></a><font color=DarkOrange>189. 最大连续1的个数 III-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一个二进制数组 <code>nums</code> 和一个整数 <code>k</code>，如果可以翻转最多 <code>k</code> 个 <code>0</code> ，则返回数组中连续 <code>1</code> 的最大个数 </p>
<p><strong>思路：</strong></p>
<p>方法一：二分查找</p>
<p>方法二：滑动窗口</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="190-二叉树中和为某一值的路径-中等"><a href="#190-二叉树中和为某一值的路径-中等" class="headerlink" title="190. 二叉树中和为某一值的路径-中等"></a><font color=DarkOrange>190. 二叉树中和为某一值的路径-中等</font></h4><p><strong>题目：</strong></p>
<p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点</p>
<p><strong>思路：</strong></p>
<p>方法一：深度优先搜索</p>
<p>方法二：广度优先搜索</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="191-在排序数组中查找数字-I-简单"><a href="#191-在排序数组中查找数字-I-简单" class="headerlink" title="191. 在排序数组中查找数字 I-简单"></a><font color=DarkOrange>191. 在排序数组中查找数字 I-简单</font></h4><p><strong>题目：</strong></p>
<p>统计一个数字在排序数组中出现的次数</p>
<p><strong>思路：</strong></p>
<p>二分查找</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="192-分隔链表-中等"><a href="#192-分隔链表-中等" class="headerlink" title="192. 分隔链表-中等"></a><font color=DarkOrange>192. 分隔链表-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个链表的头节点 <code>head</code> 和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有 <strong>小于</strong> <code>x</code> 的节点都出现在 <strong>大于或等于</strong> <code>x</code> 的节点之前</p>
<p>你应当 <strong>保留</strong> 两个分区中每个节点的初始相对位置</p>
<p><strong>思路：</strong></p>
<p>模拟</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="193-24-点游戏-困难"><a href="#193-24-点游戏-困难" class="headerlink" title="193. 24 点游戏-困难"></a><font color=DarkOrange>193. 24 点游戏-困难</font></h4><p><strong>题目：</strong></p>
<p>给定一个长度为4的整数数组 <code>cards</code> 。你有 <code>4</code> 张卡片，每张卡片上都包含一个范围在 <code>[1,9]</code> 的数字。您应该使用运算符 <code>[&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;]</code> 和括号 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 将这些卡片上的数字排列成数学表达式，以获得值24</p>
<p>你须遵守以下规则：</p>
<ul>
<li>除法运算符 <code>&#39;/&#39;</code> 表示实数除法，而不是整数除法<ul>
<li>例如， <code>4 /(1 - 2 / 3)= 4 /(1 / 3)= 12</code></li>
</ul>
</li>
<li>每个运算都在两个数字之间。特别是，不能使用 <code>“-”</code> 作为一元运算符<ul>
<li>例如，如果 <code>cards =[1,1,1,1]</code> ，则表达式 <code>“-1 -1 -1 -1”</code> 是 <strong>不允许</strong> 的</li>
</ul>
</li>
<li>你不能把数字串在一起<ul>
<li>例如，如果 <code>cards =[1,2,1,2]</code> ，则表达式 <code>“12 + 12”</code> 无效</li>
</ul>
</li>
</ul>
<p>如果可以得到这样的表达式，其计算结果为 <code>24</code> ，则返回 <code>true </code>，否则返回 <code>false</code> </p>
<p><strong>思路：</strong></p>
<p>回溯</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="194-二叉树的最小深度-简单"><a href="#194-二叉树的最小深度-简单" class="headerlink" title="194. 二叉树的最小深度-简单"></a><font color=DarkOrange>194. 二叉树的最小深度-简单</font></h4><p><strong>题目：</strong></p>
<p>给定一个二叉树，找出其最小深度</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量</p>
<p><strong>说明：</strong>叶子节点是指没有子节点的节点</p>
<p><strong>思路：</strong></p>
<p>方法一：深度优先搜索</p>
<p>方法二：广度优先搜索</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="195-下一个更大元素-III-中等"><a href="#195-下一个更大元素-III-中等" class="headerlink" title="195. 下一个更大元素 III-中等"></a><font color=DarkOrange>195. 下一个更大元素 III-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个正整数 <code>n</code> ，请你找出符合条件的最小整数，其由重新排列 <code>n</code> 中存在的每位数字组成，并且其值大于 <code>n</code> 。如果不存在这样的正整数，则返回 <code>-1</code> </p>
<p><strong>注意</strong> ，返回的整数应当是一个 <strong>32 位整数</strong> ，如果存在满足题意的答案，但不是 <strong>32 位整数</strong> ，同样返回 <code>-1</code> </p>
<p><strong>思路：</strong></p>
<p>方法一：下一个排列</p>
<p>方法二：数学</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="196-通配符匹配-困难"><a href="#196-通配符匹配-困难" class="headerlink" title="196. 通配符匹配-困难"></a><font color=DarkOrange>196. 通配符匹配-困难</font></h4><p><strong>题目：</strong></p>
<p>给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>) ，实现一个支持 <code>&#39;?&#39;</code> 和 <code>&#39;*&#39;</code> 的通配符匹配</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;?&#x27;</span> 可以匹配任何单个字符。</span><br><span class="line"><span class="string">&#x27;*&#x27;</span> 可以匹配任意字符串（包括空字符串）。</span><br></pre></td></tr></table></figure>

<p>两个字符串<strong>完全匹配</strong>才算匹配成功</p>
<p><strong>说明:</strong></p>
<ul>
<li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母</li>
<li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>?</code> 和 <code>*</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：动态规划</p>
<p>方法二：贪心算法</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="197-完全平方数-中等"><a href="#197-完全平方数-中等" class="headerlink" title="197. 完全平方数-中等"></a><font color=DarkOrange>197. 完全平方数-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个整数 <code>n</code> ，返回和为 <code>n</code> 的完全平方数的最少数量</p>
<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是</p>
<p><strong>思路：</strong></p>
<p>方法一：动态规划</p>
<p>方法二：数学</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="198-解数独-困难"><a href="#198-解数独-困难" class="headerlink" title="198. 解数独-困难"></a><font color=DarkOrange>198. 解数独-困难</font></h4><p><strong>题目：</strong></p>
<p>编写一个程序，通过填充空格来解决数独问题</p>
<p>数独的解法需 <strong>遵循如下规则</strong>：</p>
<ol>
<li>数字 <code>1-9</code> 在每一行只能出现一次</li>
<li>数字 <code>1-9</code> 在每一列只能出现一次</li>
<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次</li>
</ol>
<p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示</p>
<p><strong>思路：</strong></p>
<p>方法一：回溯</p>
<p>方法二：位运算优化</p>
<p>方法三：枚举优化</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="199-阿拉伯数字转中文数字-中等"><a href="#199-阿拉伯数字转中文数字-中等" class="headerlink" title="199. 阿拉伯数字转中文数字-中等"></a><font color=DarkOrange>199. 阿拉伯数字转中文数字-中等</font></h4><p><strong>题目：</strong><br><strong>思路：</strong><br><strong>代码：</strong></p>
<h4 id="200-反转字符串-简单"><a href="#200-反转字符串-简单" class="headerlink" title="200. 反转字符串-简单"></a><font color=DarkOrange>200. 反转字符串-简单</font></h4><p><strong>题目：</strong></p>
<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出</p>
<p>不要给另外的数组分配额外的空间，你必须<strong>原地修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题</p>
<p><strong>思路：</strong></p>
<p>双指针</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub + Go + Gin创建RESTful风格的项目</title>
    <url>/2022/12/03/GitHub%E5%88%9B%E5%BB%BAGo-Gin-RESTful%E9%A3%8E%E6%A0%BC%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>通过GitHub + Go + Gin创建RESTful风格的项目，搭建一个基础的脚手架</p>
<p>完整项目GitHub地址：<a href="https://github.com/huajun-chen/GinRESTful">点击跳转</a></p>
<h4 id="1-GutHub-New"><a href="#1-GutHub-New" class="headerlink" title="1. GutHub New"></a><font color=DarkOrange>1. GutHub New</font></h4><p>打开GitHub，进入首页，点击<code>New</code>开始创建新项目</p>
<p><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8qkp3xulaj328016g4qp.jpg" alt="image.png"></p>
<h4 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2. 创建项目"></a><font color=DarkOrange>2. 创建项目</font></h4><p>点击<code>New</code>之后，填写项目名、项目描述，填写完项目名之后，后面会显示此项目名是否可用，绿钩为可用，红叉为不可用，其他选项默认即可，然后点击<code>Create repository</code>按钮创建项目</p>
<p><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8qky746qaj3280160ndf.jpg" alt="image.png"></p>
<h4 id="3-创建成功"><a href="#3-创建成功" class="headerlink" title="3. 创建成功"></a><font color=DarkOrange>3. 创建成功</font></h4><p>创建项目成功之后页面会跳转，在此页面复制项目地址</p>
<p><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8ql0g1krlj328016gauw.jpg" alt="image.png"></p>
<h4 id="4-克隆项目"><a href="#4-克隆项目" class="headerlink" title="4. 克隆项目"></a><font color=DarkOrange>4. 克隆项目</font></h4><p>在本地电脑，进行需要存放项目的目录下，将项目克隆到本地，并且在本地新建<code>dev</code>开发分支</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 项目地址 // 克隆项目</span><br><span class="line"><span class="built_in">cd</span> 项目名 // 进行项目目录</span><br><span class="line">git checkout -b 分支名 // 新建分支并切换到此分支</span><br></pre></td></tr></table></figure>

<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8ql7fxamdj30ua0v2qlc.jpg" alt="image.png" style="zoom:50%;" /></div>

<h4 id="5-打开项目"><a href="#5-打开项目" class="headerlink" title="5. 打开项目"></a><font color=DarkOrange>5. 打开项目</font></h4><p>使用本地<code>IDE</code>打开项目（这里以<code>Goland IDE</code>演示），在项目里添加<code>GOPROXY</code></p>
<p>路径：<code>Goland</code>-&gt;<code>Preferences...</code>-&gt;<code>Go</code>-&gt;<code>Go Modules</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GOPROXY=https://goproxy.cn</span><br></pre></td></tr></table></figure>

<p><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8qlextrflj31ik13kwnl.jpg" alt="image.png"></p>
<h4 id="6-创建go-mod"><a href="#6-创建go-mod" class="headerlink" title="6. 创建go mod"></a><font color=DarkOrange>6. 创建go mod</font></h4><p>在编译器里，打开终端，在终端通过命令的方式创建<code>go mod</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go mod init 项目名</span><br></pre></td></tr></table></figure>

<p><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8qlkroqh3j32801cgn9j.jpg" alt="image.png"></p>
<h4 id="7-安装Gin"><a href="#7-安装Gin" class="headerlink" title="7. 安装Gin"></a><font color=DarkOrange>7. 安装Gin</font></h4><p>在终端通过命令的方式下载并安装<code>Gin</code>包</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure>

<p><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8qlpgvihqj32801cg1kx.jpg" alt="image.png"></p>
<h4 id="8-main程序"><a href="#8-main程序" class="headerlink" title="8. main程序"></a><font color=DarkOrange>8. main程序</font></h4><p>新建<code>main.go</code>文件，在<code>main</code>文件里编写第一个<code>Gin</code>示例</p>
<p>在<code>main</code>文件所在的目录下执行<code>go run main.go</code>运行<code>main</code>函数</p>
<p><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8qly589jgj32801ce1f4.jpg" alt="image.png"></p>
<h4 id="9-浏览器访问"><a href="#9-浏览器访问" class="headerlink" title="9. 浏览器访问"></a><font color=DarkOrange>9. 浏览器访问</font></h4><p>在浏览器通过访问<code>localhost:8080/ping</code>或<code>127.0.0.1:8080/ping</code>的方式访问服务</p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8qlxcsj7bj30pc09040d.jpg" alt="image.png" style="zoom:67%;" /></div>

<h4 id="10-添加文件"><a href="#10-添加文件" class="headerlink" title="10. 添加文件"></a><font color=DarkOrange>10. 添加文件</font></h4><p>在项目里添加<code>.gitignore</code>和<code>README.md</code>文件</p>
<p><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8qm74jjgtj31880sw791.jpg" alt="image.png"></p>
<h4 id="11-提交代码"><a href="#11-提交代码" class="headerlink" title="11. 提交代码"></a><font color=DarkOrange>11. 提交代码</font></h4><p>编写代码之后，在本地进行代码提交</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">git add 文件名</span><br><span class="line">git commit -m <span class="string">&quot;本次提交描述&quot;</span></span><br><span class="line">git push origin dev</span><br></pre></td></tr></table></figure>

<p><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8qmdi8artj32801cih82.jpg" alt="image.png"></p>
<h4 id="12-合并代码"><a href="#12-合并代码" class="headerlink" title="12. 合并代码"></a><font color=DarkOrange>12. 合并代码</font></h4><p>代码从本地提交到远程仓库之后，需要在远程仓库对代码进行合并</p>
<p><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8qn4b53z1j328016gdy4.jpg" alt="image.png"></p>
<p><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8qn5bc2u0j328016g7ma.jpg" alt="image.png"></p>
<p><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8qn67pkhaj328016i1ew.jpg" alt="image.png"></p>
<p>此项目会继续更新，敬请期待…</p>
<hr>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go-设计模式</title>
    <url>/2022/11/24/Go-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>设计模式是软件工程中各种常见问题的经典解决方案，设计模式不只是代码，而是组织代码的方式。假设一行行的代码是砖，设计模式就是蓝图</p>
<table>
<thead>
<tr>
<th><div style="width: 32pt">类型</div></th>
<th><div style="width: 63pt">设计模式</div></th>
<th>简述</th>
<th><div style="width: 25pt">常用</div></th>
</tr>
</thead>
<tbody><tr>
<td>创建型</td>
<td>工厂模式</td>
<td>定义一个创建对象的接口，让其子类自己决定范例化哪一个工厂类，是最常用的设计模式之一</td>
<td><font color=Forestgreen>yes</font></td>
</tr>
<tr>
<td></td>
<td>抽象工厂模式</td>
<td>为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构</td>
<td><font color=Forestgreen>yes</font></td>
</tr>
<tr>
<td></td>
<td>建造者模式</td>
<td>将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成</td>
<td><font color=Forestgreen>yes</font></td>
</tr>
<tr>
<td></td>
<td>原型模式</td>
<td>用一个已经创建的范例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象</td>
<td><font color=Red>no</font></td>
</tr>
<tr>
<td></td>
<td>单例模式</td>
<td>保证一个类仅有一个范例，并提供一个访问它的全局访问点单例模式只涉及到一个类，该类负责创建自己的对象，而且确保只有单个对象被创建</td>
<td><font color=Forestgreen>yes</font></td>
</tr>
<tr>
<td>结构型</td>
<td>适配器模式</td>
<td>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作</td>
<td><font color=Forestgreen>yes</font></td>
</tr>
<tr>
<td></td>
<td>桥接模式</td>
<td>将抽象与实现分离，使两者可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度</td>
<td><font color=Forestgreen>yes</font></td>
</tr>
<tr>
<td></td>
<td>组合模式</td>
<td><strong>对象树模式&#x2F;整体-部分模式</strong>。将对象组合成树状的层次结构的模式，用来表示“整体-部分”的关系，使用户对单个对象和组合对象具有一致的访问性</td>
<td><font color=Red>no</font></td>
</tr>
<tr>
<td></td>
<td>装饰器模式</td>
<td>动态地给一个对象添加一些额外的职责。允许向一个现有的对象添加新的功能，同时又不改变其结构</td>
<td><font color=Forestgreen>yes</font></td>
</tr>
<tr>
<td></td>
<td>外观模式</td>
<td>又称为门面模式，它为子系统中的接口提供一个一致的接口，来隐藏子系统内部的复杂性，使得子系统更加容易使用</td>
<td><font color=Red>no</font></td>
</tr>
<tr>
<td></td>
<td>享元模式</td>
<td>运用共享技术有效地支持大量细粒度的对象，减少对象的创建数量，以节省内存占用和提高性能</td>
<td><font color=Red>no</font></td>
</tr>
<tr>
<td></td>
<td>代理模式</td>
<td>由于某些原因需要为某对象提供一种代理以控制对该对象的访问当访问对象不适合或者不能直接引用目标对象的时候，可以通过代理对象作为访问对象和目标对象之间的中介</td>
<td><font color=Forestgreen>yes</font></td>
</tr>
<tr>
<td>行为型</td>
<td>责任链模式</td>
<td>为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止</td>
<td><font color=Forestgreen>yes</font></td>
</tr>
<tr>
<td></td>
<td>命令模式</td>
<td>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作</td>
<td><font color=Red>no</font></td>
</tr>
<tr>
<td></td>
<td>迭代器模式</td>
<td>提供了一种方法顺序访问一个聚合对象中的所有元素，而又不暴露该聚合对象的内部表示用于顺序访问集合对象的元素，调用者无需知道集合对象的底层表示，从而实现调用者和聚合对象的解耦</td>
<td><font color=Forestgreen>yes</font></td>
</tr>
<tr>
<td></td>
<td>中介者模式</td>
<td>用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护</td>
<td><font color=Red>no</font></td>
</tr>
<tr>
<td></td>
<td>备忘录模式</td>
<td>保存一个对象的某个状态，以便在适当的时候恢复对象</td>
<td><font color=Red>no</font></td>
</tr>
<tr>
<td></td>
<td>观察者模式</td>
<td>定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新</td>
<td><font color=Forestgreen>yes</font></td>
</tr>
<tr>
<td></td>
<td>状态模式</td>
<td>对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为</td>
<td><font color=Forestgreen>yes</font></td>
</tr>
<tr>
<td></td>
<td>策略模式</td>
<td>通过定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户</td>
<td><font color=Forestgreen>yes</font></td>
</tr>
<tr>
<td></td>
<td>模板方法模式</td>
<td>定义一个操作中的算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构,即可重定义该算法的某些特定步骤</td>
<td><font color=Forestgreen>yes</font></td>
</tr>
<tr>
<td></td>
<td>访问者模式</td>
<td>将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式</td>
<td><font color=Red>no</font></td>
</tr>
</tbody></table>
<h4 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1. 工厂模式"></a><font color=DarkOrange>1. 工厂模式</font></h4><p><strong>问题</strong></p>
<p><strong>解决</strong></p>
<h4 id="2-抽象工厂模式"><a href="#2-抽象工厂模式" class="headerlink" title="2. 抽象工厂模式"></a><font color=DarkOrange>2. 抽象工厂模式</font></h4><p><strong>问题</strong></p>
<p><strong>解决</strong></p>
<h4 id="3-建造者模式"><a href="#3-建造者模式" class="headerlink" title="3. 建造者模式"></a><font color=DarkOrange>3. 建造者模式</font></h4><p><strong>问题</strong></p>
<p><strong>解决</strong></p>
<h4 id="4-原型模式"><a href="#4-原型模式" class="headerlink" title="4. 原型模式"></a><font color=DarkOrange>4. 原型模式</font></h4><p><strong>问题</strong></p>
<p><strong>解决</strong></p>
<h4 id="5-单例模式"><a href="#5-单例模式" class="headerlink" title="5. 单例模式"></a><font color=DarkOrange>5. 单例模式</font></h4><p><strong>问题</strong></p>
<p><strong>解决</strong></p>
<h4 id="6-适配器模式"><a href="#6-适配器模式" class="headerlink" title="6. 适配器模式"></a><font color=DarkOrange>6. 适配器模式</font></h4><p><strong>问题</strong></p>
<p><strong>解决</strong></p>
<h4 id="7-桥接模式"><a href="#7-桥接模式" class="headerlink" title="7. 桥接模式"></a><font color=DarkOrange>7. 桥接模式</font></h4><p><strong>问题</strong></p>
<p><strong>解决</strong></p>
<h4 id="8-组合模式"><a href="#8-组合模式" class="headerlink" title="8. 组合模式"></a><font color=DarkOrange>8. 组合模式</font></h4><p><strong>问题</strong></p>
<p><strong>解决</strong></p>
<h4 id="9-装饰器模式"><a href="#9-装饰器模式" class="headerlink" title="9. 装饰器模式"></a><font color=DarkOrange>9. 装饰器模式</font></h4><p><strong>问题</strong></p>
<p><strong>解决</strong></p>
<h4 id="10-外观模式"><a href="#10-外观模式" class="headerlink" title="10. 外观模式"></a><font color=DarkOrange>10. 外观模式</font></h4><p><strong>问题</strong></p>
<p><strong>解决</strong></p>
<h4 id="11-享元模式"><a href="#11-享元模式" class="headerlink" title="11. 享元模式"></a><font color=DarkOrange>11. 享元模式</font></h4><p><strong>问题</strong></p>
<p><strong>解决</strong></p>
<h4 id="12-代理模式"><a href="#12-代理模式" class="headerlink" title="12. 代理模式"></a><font color=DarkOrange>12. 代理模式</font></h4><p><strong>问题</strong></p>
<p><strong>解决</strong></p>
<h4 id="13-责任链模式"><a href="#13-责任链模式" class="headerlink" title="13. 责任链模式"></a><font color=DarkOrange>13. 责任链模式</font></h4><p><strong>问题</strong></p>
<p><strong>解决</strong></p>
<h4 id="14-命令模式"><a href="#14-命令模式" class="headerlink" title="14. 命令模式"></a><font color=DarkOrange>14. 命令模式</font></h4><p><strong>问题</strong></p>
<p><strong>解决</strong></p>
<h4 id="15-迭代器模式"><a href="#15-迭代器模式" class="headerlink" title="15. 迭代器模式"></a><font color=DarkOrange>15. 迭代器模式</font></h4><p><strong>问题</strong></p>
<p><strong>解决</strong></p>
<h4 id="16-中介者模式"><a href="#16-中介者模式" class="headerlink" title="16. 中介者模式"></a><font color=DarkOrange>16. 中介者模式</font></h4><p><strong>问题</strong></p>
<p><strong>解决</strong></p>
<h4 id="17-备忘录模式"><a href="#17-备忘录模式" class="headerlink" title="17. 备忘录模式"></a><font color=DarkOrange>17. 备忘录模式</font></h4><p><strong>问题</strong></p>
<p><strong>解决</strong></p>
<h4 id="18-观察者模式"><a href="#18-观察者模式" class="headerlink" title="18. 观察者模式"></a><font color=DarkOrange>18. 观察者模式</font></h4><p><strong>问题</strong></p>
<p><strong>解决</strong></p>
<h4 id="19-状态模式"><a href="#19-状态模式" class="headerlink" title="19. 状态模式"></a><font color=DarkOrange>19. 状态模式</font></h4><p><strong>问题</strong></p>
<p><strong>解决</strong></p>
<h4 id="20-策略模式"><a href="#20-策略模式" class="headerlink" title="20. 策略模式"></a><font color=DarkOrange>20. 策略模式</font></h4><p><strong>问题</strong></p>
<p><strong>解决</strong></p>
<h4 id="21-模板方法模式"><a href="#21-模板方法模式" class="headerlink" title="21. 模板方法模式"></a><font color=DarkOrange>21. 模板方法模式</font></h4><p><strong>问题</strong></p>
<p><strong>解决</strong></p>
<h4 id="22-访问者模式"><a href="#22-访问者模式" class="headerlink" title="22. 访问者模式"></a><font color=DarkOrange>22. 访问者模式</font></h4><p><strong>问题</strong></p>
<p><strong>解决</strong></p>
<h4 id="23-设计模式的“道”"><a href="#23-设计模式的“道”" class="headerlink" title="23. 设计模式的“道”"></a><font color=DarkOrange>23. 设计模式的“道”</font></h4><p>设计模式分为“术”的部分和“道”的部分，上面那些设计模式就是“术”的部分，他们是一些围绕着设计模式核心思路的经典解决方案。换句话说，重要的是理解为什么要用那些设计模式，具体问题，具体分析，而不是把某种设计模式生搬硬套进代码</p>
<p>设计模式有6大原则，以上的设计模式目的就是为了使软件系统能达到这些原则：</p>
<ul>
<li>开闭原则<ul>
<li>软件应该对扩展开放，对修改关闭</li>
<li>对系统进行扩展，而无需修改现有的代码。这可以降低软件的维护成本，同时也增加可扩展性</li>
</ul>
</li>
<li>里氏替换原则<ul>
<li>任何基类可以出现的地方，子类一定可以出现</li>
<li>里氏替换原则是对开闭原则的补充，实现开闭原则的关键步骤就是抽象化，基类与子类的关系就是要尽可能的抽象化</li>
</ul>
</li>
<li>依赖倒置原则<ul>
<li>面向接口编程，抽象不应该依赖于具体类，具体类应当依赖于抽象</li>
<li>这是为了减少类间的耦合，使系统更适宜于扩展，也更便于维护</li>
</ul>
</li>
<li>单一职责原则<ul>
<li>一个类应该只有一个发生变化的原因</li>
<li>一个类承载的越多，耦合度就越高。如果类的职责单一，就可以降低出错的风险，也可以提高代码的可读性</li>
</ul>
</li>
<li>最少知道原则<ul>
<li>一个实体应当尽量少地与其他实体之间发生相互作用</li>
<li>还是为了降低耦合，一个类与其他类的关联越少，越易于扩展</li>
</ul>
</li>
<li>接口分离原则<ul>
<li>使用多个专门的接口，而不使用高耦合的单一接口</li>
<li>避免同一个接口占用过多的职责，更明确的划分，可以降低耦合。高耦合会导致程序不易扩展，提高出错的风险</li>
</ul>
</li>
</ul>
<hr>
<p>编程宝库链接：<a href="http://www.codebaoku.com/design-pattern/design-pattern-index.html">点击跳转</a></p>
<p>掘金链接：<a href="https://juejin.cn/post/7095581880200167432">点击跳转</a></p>
<p>华为云链接：<a href="https://bbs.huaweicloud.com/blogs/279505">点击跳转</a></p>
<hr>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch面试题</title>
    <url>/2022/10/30/Elasticsearch%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>ES常见面试题</p>
<h4 id="1-什么是ES"><a href="#1-什么是ES" class="headerlink" title="1. 什么是ES"></a><font color=DarkOrange>1. 什么是ES</font></h4><p>Elasticsearch是一个基于Lucene的开源搜索和分析引擎，旨在快速、可扩展、具有高度可靠性和易于管理的特性。它可以处理各种类型的数据，包括文本、数字、地理空间等，可以进行全文搜索、结构化搜索、分析和可视化等操作</p>
<p>Elasticsearch采用分布式架构，可以轻松地扩展到数百台服务器，并支持水平扩展和垂直扩展。它还提供了一个强大的RESTful API，可以与各种编程语言和工具进行集成</p>
<p>Elasticsearch还有许多相关的工具和插件，例如Kibana、Logstash、Beats等，它们可以帮助用户进行数据收集、分析和可视化等操作，形成了一个完整的ELK（Elasticsearch、Logstash、Kibana）堆栈</p>
<h4 id="2-ES的基本概念有哪些"><a href="#2-ES的基本概念有哪些" class="headerlink" title="2. ES的基本概念有哪些"></a><font color=DarkOrange>2. ES的基本概念有哪些</font></h4><ol>
<li>Index（索引）：Elasticsearch中的基本单元，类似于数据库中的表。它包含了一系列文档和它们的属性</li>
<li>Document（文档）：Elasticsearch中的文本数据单元，存储为JSON格式。一个文档可以看作是一个类似于数据库中行的数据结构</li>
<li>Field（字段）：文档中的属性，类似于数据库中的列</li>
<li>Mapping（映射）：定义索引中每个字段的数据类型和属性的过程。它类似于关系型数据库中的模式定义</li>
<li>Type（类型）：在Elasticsearch 7.x及以后的版本中已经不再使用，而在之前版本中，Type是在索引中定义的逻辑类别，一个索引可以包含多个Type，每个Type中包含多个Document</li>
<li>Query（查询）：用于搜索文档的语句，可以根据不同的条件过滤文档</li>
<li>Aggregation（聚合）：对搜索结果进行统计和分析的操作，例如计算平均值、最大值、最小值等</li>
<li>Analyzer（分析器）：将文本数据分解成有意义的词语的过程，包括分词、过滤、归一化等</li>
<li>Shards（分片）：Elasticsearch将索引分成多个分片进行存储和处理，以实现水平扩展和负载均衡</li>
<li>Replica（副本）：为了提高可用性和容错性，Elasticsearch可以将每个分片的副本存储在不同的节点上</li>
</ol>
<h4 id="3-ES与传统数据库的区别是什么"><a href="#3-ES与传统数据库的区别是什么" class="headerlink" title="3. ES与传统数据库的区别是什么"></a><font color=DarkOrange>3. ES与传统数据库的区别是什么</font></h4><ol>
<li>数据存储方式：传统数据库采用基于行和列的表格形式存储数据，而Elasticsearch使用文档存储方式，即将所有相关数据存储在一个文档中。这种文档存储方式使得Elasticsearch更加灵活和可扩展</li>
<li>查询方式：传统数据库使用结构化查询语言(SQL)进行查询，而Elasticsearch使用自己的查询语言，可以根据多种条件进行复杂的全文搜索和分析</li>
<li>数据处理方式：传统数据库是事务性的，即支持ACID（原子性、一致性、隔离性、持久性）特性，可以保证数据的完整性和一致性。而Elasticsearch是面向文档的，不支持ACID特性，但是具有强大的搜索和分析能力</li>
<li>水平扩展：传统数据库在数据量增加时，需要更换更强大的服务器或升级硬件，而Elasticsearch采用分布式架构，可以通过增加节点来水平扩展，实现更好的性能和可扩展性</li>
<li>多用途性：传统数据库一般用于事务性的数据存储和管理，而Elasticsearch可以用于全文搜索、日志分析、数据可视化等多种用途</li>
</ol>
<h4 id="4-ES的数据结构是什么"><a href="#4-ES的数据结构是什么" class="headerlink" title="4. ES的数据结构是什么"></a><font color=DarkOrange>4. ES的数据结构是什么</font></h4><ol>
<li>Index（索引）：Elasticsearch中的基本单元，类似于数据库中的表。一个索引可以包含多个文档和它们的属性，每个文档都有一个唯一的ID标识</li>
<li>Document（文档）：Elasticsearch中的文本数据单元，存储为JSON格式。一个文档可以看作是一个类似于数据库中行的数据结构，包含了一个或多个字段（Field）和其对应的值</li>
<li>Field（字段）：文档中的属性，类似于数据库中的列。每个字段都有一个数据类型，例如文本、数字、日期等，以及一些属性，例如分词器、存储方式等</li>
<li>Mapping（映射）：定义索引中每个字段的数据类型和属性的过程。它类似于关系型数据库中的模式定义。Elasticsearch会自动推断每个字段的数据类型，但也可以手动定义映射</li>
<li>Analyzer（分析器）：将文本数据分解成有意义的词语的过程，包括分词、过滤、归一化等。Elasticsearch提供了一些内置的分析器，也支持自定义分析器</li>
<li>Shards（分片）：Elasticsearch将索引分成多个分片进行存储和处理，以实现水平扩展和负载均衡。每个分片都是一个完整的Lucene索引</li>
<li>Replica（副本）：为了提高可用性和容错性，Elasticsearch可以将每个分片的副本存储在不同的节点上。每个分片可以有多个副本，副本与原始分片数据保持同步</li>
</ol>
<h4 id="5-ES的索引是什么（Index）"><a href="#5-ES的索引是什么（Index）" class="headerlink" title="5. ES的索引是什么（Index）"></a><font color=DarkOrange>5. ES的索引是什么（Index）</font></h4><p>索引（Index）是一个逻辑命名空间，用于组织和存储相关文档的集合。索引在某种程度上类似于关系型数据库中的表，它们都是用于存储数据的基本单元</p>
<p>一个Elasticsearch集群可以包含多个索引，每个索引可以包含多个文档。每个文档都是以JSON格式表示的，它包含了一个或多个字段和对应的值。文档可以根据唯一的ID进行查找和访问</p>
<p>索引可以包含多个分片（Shards），每个分片是一个独立的Lucene索引，它可以存储一部分文档数据。分片可以在不同的节点上进行分布式存储，以提高性能和可扩展性。此外，Elasticsearch还支持索引的副本（Replicas），副本是分片的拷贝，用于提高可用性和容错性</p>
<p>索引的创建需要定义映射（Mapping），映射定义了索引中每个字段的数据类型和属性。Elasticsearch可以自动推断每个字段的数据类型，也可以手动指定映射</p>
<p>索引是Elasticsearch中的基本单元之一，它提供了一个灵活的数据存储和查询机制，可以用于多种用途，例如全文搜索、数据分析等</p>
<h4 id="6-怎么样创建一个索引（Index）"><a href="#6-怎么样创建一个索引（Index）" class="headerlink" title="6. 怎么样创建一个索引（Index）"></a><font color=DarkOrange>6. 怎么样创建一个索引（Index）</font></h4><ol>
<li><p>确定索引名称和映射（Mapping）：索引名称是唯一的，用于标识索引。映射定义了索引中每个字段的数据类型和属性</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;title&quot;</span>: &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span> &#125;,</span><br><span class="line">      <span class="string">&quot;content&quot;</span>: &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span> &#125;,</span><br><span class="line">      <span class="string">&quot;date&quot;</span>: &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个请求会创建一个名为“my_index”的索引，并定义了三个字段（title、content和date）及其数据类型（分别为文本、文本和日期）</p>
</li>
<li><p>发送创建索引请求：使用Elasticsearch提供的API（如HTTP API或Java API）发送创建索引的请求。请求中需要指定索引名称和映射</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl -X PUT <span class="string">&quot;http://localhost:9200/my_index&quot;</span> -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -d<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;mappings&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;properties&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;title&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125;,</span></span><br><span class="line"><span class="string">      &quot;content&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125;,</span></span><br><span class="line"><span class="string">      &quot;date&quot;: &#123; &quot;type&quot;: &quot;date&quot; &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个请求也会创建一个名为“my_index”的索引，并定义了相同的映射</p>
</li>
</ol>
<p>创建索引时，还可以指定分片和副本的数量、设置索引的设置等。创建索引后，可以使用其他API来添加、更新或查询文档数据</p>
<h4 id="7-ES中的映射（Mapping）是什么"><a href="#7-ES中的映射（Mapping）是什么" class="headerlink" title="7. ES中的映射（Mapping）是什么"></a><font color=DarkOrange>7. ES中的映射（Mapping）是什么</font></h4><p>映射（Mapping）是定义索引中字段的数据类型和属性的过程。它告诉Elasticsearch如何处理文档中的字段，包括如何索引和搜索它们、如何分析它们的内容等</p>
<p>映射是可选的，如果没有指定映射，Elasticsearch会自动推断字段的数据类型。但是，如果需要更精确地控制字段的处理方式，就需要显式地指定映射</p>
<p>映射可以定义以下内容：</p>
<ul>
<li>字段的数据类型：如文本（text）、数字（integer、float、double等）、日期（date）等</li>
<li>字段的属性：如是否可以搜索、是否可以聚合、是否存储原始值、是否需要分析等</li>
<li>对于复杂类型的字段，如嵌套对象（nested object）、数组（array）等，还需要定义它们的子字段和属性</li>
</ul>
<p>映射可以通过API进行创建和更新。以下是一个映射的示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PUT my_index/_mapping</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">      <span class="string">&quot;analyzer&quot;</span>: <span class="string">&quot;english&quot;</span>,</span><br><span class="line">      <span class="string">&quot;fields&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;keyword&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;content&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">      <span class="string">&quot;analyzer&quot;</span>: <span class="string">&quot;english&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;date&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span>,</span><br><span class="line">      <span class="string">&quot;format&quot;</span>: <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个映射定义了一个名为“my_index”的索引，包含三个字段（title、content和date），每个字段都有不同的数据类型和属性。例如，title字段使用英语分析器（analyzer）进行分析，同时还定义了一个名为“keyword”的子字段，用于精确匹配。content字段也使用英语分析器，但没有定义子字段。date字段定义了日期格式</p>
<h4 id="8-什么是分片（Shard）？为什么需要分片"><a href="#8-什么是分片（Shard）？为什么需要分片" class="headerlink" title="8. 什么是分片（Shard）？为什么需要分片"></a><font color=DarkOrange>8. 什么是分片（Shard）？为什么需要分片</font></h4><p>分片（Shard）是将索引拆分成多个部分的过程。每个分片都是一个独立的Lucene索引，可以在多个节点上分布存储和处理。分片是实现Elasticsearch分布式架构的关键之一</p>
<p>分片可以带来以下好处：</p>
<ol>
<li>提高性能：将索引分成多个分片，可以将大量数据分散到多个节点上进行处理，从而提高查询和写入的性能</li>
<li>支持扩展：通过添加更多的节点和分片，可以轻松地扩展Elasticsearch集群的容量和吞吐量</li>
<li>提高可用性：如果某个节点或分片发生故障，其他节点和分片可以接管工作，从而保证系统的可用性</li>
</ol>
<p>在创建索引时，可以指定分片的数量。默认情况下，每个索引有5个主分片和1个副本分片。这意味着，每个索引可以在最多5个节点上进行存储和处理，同时还有1个副本分片可以在其他节点上进行复制和备份</p>
<p><strong>注意：</strong>分片的数量对性能和可用性都有重要影响。如果分片过多，可能会导致过多的网络流量和磁盘IO，从而降低性能。同时，如果分片数量不足，可能会限制集群的容量和吞吐量。因此，分片的数量需要根据实际需求进行合理的配置</p>
<h4 id="9-ES数据的增删改查"><a href="#9-ES数据的增删改查" class="headerlink" title="9. ES数据的增删改查"></a><font color=DarkOrange>9. ES数据的增删改查</font></h4><ol>
<li><p>增加数据（Create&#x2F;Index API）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PUT /my_index/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;Elasticsearch 101&quot;</span>,</span><br><span class="line">  <span class="string">&quot;content&quot;</span>: <span class="string">&quot;Introduction to Elasticsearch&quot;</span>,</span><br><span class="line">  <span class="string">&quot;date&quot;</span>: <span class="string">&quot;2022-03-24&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个API将一个新文档添加到名为“my_index”的索引中。文档的ID是“1”，包含三个字段：title、content和date。如果该ID已经存在，则会抛出一个异常。如果想要强制覆盖现有文档，则需要使用Update API</p>
</li>
<li><p>修改数据（Update API）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">POST /my_index/_doc/1/_update</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;doc&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;Elasticsearch 201&quot;</span>,</span><br><span class="line">    <span class="string">&quot;content&quot;</span>: <span class="string">&quot;Advanced Elasticsearch Techniques&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个API将现有文档的title和content字段进行更新。注意，这里使用了POST请求而不是PUT请求，因为我们只是对文档进行部分更新。如果要替换整个文档，可以使用Create&#x2F;Index API</p>
</li>
<li><p>删除数据（Delete API）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">DELETE /my_index/_doc/1</span><br></pre></td></tr></table></figure>

<p>这个API将ID为“1”的文档从“my_index”索引中删除</p>
</li>
<li><p>查询数据（Search API）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;title&quot;</span>: <span class="string">&quot;Elasticsearch&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个API将从“my_index”索引中查询所有title字段包含“Elasticsearch”的文档。查询结果将包含匹配的文档及其相关信息，如分数、ID、索引、字段等</p>
</li>
</ol>
<h4 id="10-ES的写入流程"><a href="#10-ES的写入流程" class="headerlink" title="10. ES的写入流程"></a><font color=DarkOrange>10. ES的写入流程</font></h4><ol>
<li>客户端向Elasticsearch集群发送写入请求，请求中包含待写入的文档数据</li>
<li>Elasticsearch将请求发送给相关的分片（Shard），根据文档的ID计算出文档所属的分片编号，然后将文档写入对应的主分片（Primary Shard）</li>
<li>主分片将文档写入自己的本地Lucene索引中，并将文档复制到相关的副本分片（Replica Shard）中。副本分片是主分片的精确副本，可以用于提高可用性和查询性能</li>
<li>分片将写入成功的响应返回给客户端。客户端可以选择等待分片复制完成后再执行后续操作，也可以立即继续执行其他操作</li>
<li>后台进程（如refresh进程）会定期刷新主分片的Lucene索引，使新写入的文档能够被搜索和查询。同时，副本分片也会在后台复制主分片的数据，并保持与主分片同步</li>
</ol>
<p><strong>注意：</strong>Elasticsearch的写入流程是异步的，即写入请求只是将文档添加到主分片中，而不会立即将文档复制到所有副本分片中。因此，在写入文档后，可能需要等待一段时间才能确保所有副本分片中都存在该文档。另外，写入流程中可能会涉及到一些其他的优化和调整，如分片的路由策略、并发控制、冲突检测等</p>
<h4 id="11-ES的搜索流程"><a href="#11-ES的搜索流程" class="headerlink" title="11. ES的搜索流程"></a><font color=DarkOrange>11. ES的搜索流程</font></h4><ol>
<li>客户端向Elasticsearch集群发送查询请求，请求中包含查询条件和搜索选项</li>
<li>Elasticsearch将请求发送给相关的分片（Shard），根据查询条件和索引的映射信息确定需要查询哪些分片。如果查询涉及多个分片，则每个分片都会返回一个局部结果</li>
<li>分片在本地Lucene索引中执行查询操作，并计算每个文档的匹配度得分（Score）。匹配度得分是根据文档与查询条件的匹配程度计算出来的，越匹配得分越高</li>
<li>分片将局部结果返回给协调节点（Coordination Node），协调节点将所有分片的结果进行合并，并计算每个文档的最终得分</li>
<li>协调节点将结果返回给客户端，客户端可以根据得分排序和筛选结果，并获取与每个文档相关的信息，如ID、索引、字段等</li>
</ol>
<p><strong>注意：</strong>Elasticsearch的搜索流程是分布式的，并且支持实时查询和深度分析。搜索请求可以同时查询多个索引和分片，可以使用各种查询语法和过滤器，还可以进行复杂的聚合和分析操作。另外，Elasticsearch还支持基于近似算法（如Bloom过滤器和k-近邻搜索）的高效搜索，可以快速定位包含某些关键词或特征的文档</p>
<h4 id="12-ES的更新流程"><a href="#12-ES的更新流程" class="headerlink" title="12. ES的更新流程"></a><font color=DarkOrange>12. ES的更新流程</font></h4><ol>
<li>客户端向Elasticsearch集群发送更新请求，请求中包含待更新文档的ID和更新内容</li>
<li>Elasticsearch将请求发送给相关的分片（Shard），根据文档的ID计算出文档所属的分片编号，然后检查文档是否存在于对应的主分片（Primary Shard）中</li>
<li>如果文档存在于主分片中，则将更新内容写入到主分片的Lucene索引中，并将文档更新操作复制到相关的副本分片（Replica Shard）中</li>
<li>分片将更新成功的响应返回给客户端。客户端可以选择等待分片复制完成后再执行后续操作，也可以立即继续执行其他操作</li>
<li>后台进程（如refresh进程）会定期刷新主分片的Lucene索引，使更新后的文档能够被搜索和查询。同时，副本分片也会在后台复制主分片的数据，并保持与主分片同步</li>
</ol>
<p><strong>注意：</strong>Elasticsearch的更新流程实际上是一种合并更新（Merge Update）的方式。即先将原始文档从主分片中检索出来，将更新内容与原始文档合并，然后将合并后的文档写入主分片。这种方式可以保证更新的原子性和一致性，同时还能够减少存储空间和I&#x2F;O操作。另外，更新流程中可能会涉及到一些其他的优化和调整，如并发控制、冲突检测、数据合并等</p>
<h4 id="13-ES的删除流程"><a href="#13-ES的删除流程" class="headerlink" title="13. ES的删除流程"></a><font color=DarkOrange>13. ES的删除流程</font></h4><ol>
<li>客户端向Elasticsearch集群发送删除请求，请求中包含待删除文档的ID和删除选项</li>
<li>Elasticsearch将请求发送给相关的分片（Shard），根据文档的ID计算出文档所属的分片编号，然后检查文档是否存在于对应的主分片（Primary Shard）中</li>
<li>如果文档存在于主分片中，则将文档的删除标记设置为true，并将文档删除操作复制到相关的副本分片（Replica Shard）中</li>
<li>分片将删除成功的响应返回给客户端。客户端可以选择等待分片复制完成后再执行后续操作，也可以立即继续执行其他操作</li>
<li>后台进程（如refresh进程）会定期刷新主分片的Lucene索引，将删除标记的文档从索引中删除。同时，副本分片也会在后台复制主分片的数据，并保持与主分片同步</li>
</ol>
<p><strong>注意：</strong>Elasticsearch的删除流程实际上是一种逻辑删除（Logical Delete）的方式。即并不是真正地从磁盘上删除文档，而是将文档的删除标记设置为true，并在查询和搜索时过滤掉已经删除的文档。这种方式可以保证删除的原子性和一致性，同时还能够减少存储空间和I&#x2F;O操作。另外，删除流程中可能会涉及到一些其他的优化和调整，如回收未使用的存储空间、合并碎片等</p>
<h4 id="14-ES中text和keyword类型的区别"><a href="#14-ES中text和keyword类型的区别" class="headerlink" title="14. ES中text和keyword类型的区别"></a><font color=DarkOrange>14. ES中text和keyword类型的区别</font></h4><p>text和keyword是两种不同的字段类型，主要用于存储文本和字符串类型的数据</p>
<ol>
<li>text类型：text类型的字段用于存储长文本，它会被分析器（Analyzer）处理，并将文本分成单独的单词（Term），并将这些单词保存到倒排索引（Inverted Index）中，以支持全文搜索和模糊匹配。text类型的字段通常用于存储文章、博客、评论等文本类型的数据</li>
<li>keyword类型：keyword类型的字段用于存储短文本和精确值，它不会被分析器处理，而是直接将整个文本保存到倒排索引中，以支持精确匹配和聚合操作。keyword类型的字段通常用于存储关键词、标签、ID等短文本类型的数据</li>
</ol>
<p><strong>总结：</strong>text类型适用于全文搜索和模糊匹配，而keyword类型适用于精确匹配和聚合操作。在实际使用中，需要根据具体的业务需求来选择合适的字段类型，并考虑相关的存储空间、查询性能和分析效果等因素</p>
<h4 id="15-ES中query和filter的区别"><a href="#15-ES中query和filter的区别" class="headerlink" title="15. ES中query和filter的区别"></a><font color=DarkOrange>15. ES中query和filter的区别</font></h4><p>query和filter是两种不同的查询方式，主要区别在于它们对搜索结果的计算和缓存方式不同，以及对搜索性能和精度的影响不同</p>
<ol>
<li>Query查询：Query查询是一种评分（Scoring）查询方式，它会将所有符合查询条件的文档进行打分，并按照分数从高到低排序返回结果。Query查询通常用于全文搜索和模糊匹配，它可以支持复杂的查询表达式和搜索语法，并且可以对搜索结果进行相关性排序和分页处理。由于Query查询需要计算每个文档的得分，因此对搜索性能的影响较大，但可以提供更加准确和灵活的搜索结果</li>
<li>Filter查询：Filter查询是一种过滤（Filtering）查询方式，它会根据查询条件对所有符合条件的文档进行过滤，并返回一个包含所有符合条件的文档的结果集。Filter查询通常用于精确匹配和聚合操作，它可以快速地过滤掉不符合条件的文档，并且可以对搜索结果进行缓存，以提高查询性能和减少计算开销。由于Filter查询不需要计算每个文档的得分，因此对搜索性能的影响较小，但可能会导致搜索结果缺乏相关性排序和分页处理的功能</li>
</ol>
<p><strong>总结：</strong>Query查询适用于全文搜索和模糊匹配，可以提供更加准确和灵活的搜索结果，但对搜索性能的影响较大；Filter查询适用于精确匹配和聚合操作，可以提高查询性能和缓存效果，但可能会导致搜索结果缺乏相关性排序和分页处理的功能。在实际使用中，需要根据具体的业务需求和查询场景来选择合适的查询方式，并权衡搜索性能和搜索精度的需求</p>
<h4 id="16-ES在高并发下如何保证读写一致性"><a href="#16-ES在高并发下如何保证读写一致性" class="headerlink" title="16. ES在高并发下如何保证读写一致性"></a><font color=DarkOrange>16. ES在高并发下如何保证读写一致性</font></h4><ol>
<li>分片和副本：Elasticsearch将索引划分为多个分片，每个分片可以被分配到不同的节点上进行读写操作，这样可以有效地分散读写压力。同时，每个分片还可以设置多个副本，当主分片出现故障时，副本可以接管主分片的读写操作，从而保证系统的高可用性和数据的一致性</li>
<li>数据同步：在Elasticsearch中，每个节点上的分片和副本之间会定时进行数据同步，以保证分片和副本之间的数据一致性。数据同步过程中，节点会通过版本控制机制来判断哪些文档需要被更新或删除，并将最新的文档同步到所有相关的分片和副本上</li>
<li>乐观并发控制：Elasticsearch采用乐观并发控制（Optimistic Concurrency Control）机制来保证多个客户端同时修改同一文档时的数据一致性。在这种机制下，每个文档都会有一个版本号，当多个客户端同时修改同一文档时，Elasticsearch会比较每个客户端提交的版本号和当前文档的版本号，如果版本号一致，则说明文档没有被其他客户端修改，可以直接提交；如果版本号不一致，则说明文档已经被其他客户端修改，需要进行冲突解决</li>
<li>索引刷新和提交：在Elasticsearch中，写入操作默认是异步执行的，即当写入请求被接收后，并不会立即写入到磁盘上，而是先写入到内存缓冲区中，等待一定时间后再进行索引刷新和提交操作。索引刷新操作会将内存缓冲区中的数据写入到磁盘上，但并不保证数据的可见性；提交操作则会将索引刷新后的数据更新到主分片和副本中，并保证数据的可见性。在高并发下，可以通过控制索引刷新和提交的间隔时间来平衡数据一致性和写入性能</li>
</ol>
<p><strong>总结：</strong>Elasticsearch通过分片和副本、数据同步、乐观并发控制以及索引刷新和提交等机制来保证高并发下的读写一致性，从而提高系统的可用性和性能</p>
<h4 id="17-ES支持哪些查询方式"><a href="#17-ES支持哪些查询方式" class="headerlink" title="17. ES支持哪些查询方式"></a><font color=DarkOrange>17. ES支持哪些查询方式</font></h4><ol>
<li>Match Query：基于文本匹配的查询，可以进行全文搜索，支持模糊查询、短语匹配、前缀匹配等</li>
<li>Term Query：基于词项匹配的查询，可以精确匹配一个词项</li>
<li>Range Query：用于匹配一定范围内的数值、日期或者时间，支持大于、小于、大于等于、小于等于等多种查询</li>
<li>Prefix Query：用于匹配一个前缀的词项</li>
<li>Wildcard Query：用于匹配带有通配符的词项，支持 * 和 ? 通配符</li>
<li>Bool Query：用于组合多个查询条件，支持逻辑运算符 AND、OR、NOT</li>
<li>Nested Query：用于查询嵌套的文档</li>
<li>Fuzzy Query：模糊查询，支持模糊匹配和模糊距离调整</li>
<li>Regexp Query：用于匹配正则表达式的文本</li>
<li>Term Aggregation：用于对某个字段进行聚合计算，例如计算每个词项的出现次数</li>
<li>Range Aggregation：用于对某个字段进行范围聚合计算</li>
<li>Date Histogram Aggregation：按照日期或者时间间隔进行聚合计算</li>
<li>Geospatial Query：用于地理位置查询</li>
<li>Script Query：用于执行自定义的查询脚本</li>
<li>More Like This Query：用于查询和指定文档类似的文档</li>
</ol>
<p><strong>总结：</strong>Elasticsearch提供了丰富的查询方式，支持文本、数值、日期、地理位置等多种数据类型的查询和聚合计算，可以满足不同场景下的查询需求</p>
<h4 id="18-什么是聚合（Aggregation）"><a href="#18-什么是聚合（Aggregation）" class="headerlink" title="18. 什么是聚合（Aggregation）"></a><font color=DarkOrange>18. 什么是聚合（Aggregation）</font></h4><p>聚合（Aggregation）是对数据进行分组、统计和计算的一种功能，可以帮助用户更好地理解数据，从而支持更复杂的分析和挖掘</p>
<p>通过聚合，用户可以对文档进行分组，然后在每个分组内进行各种统计操作，例如求和、计数、平均值、最大值、最小值等等。聚合可以支持多层嵌套，以实现更加复杂的统计计算，例如按照日期、时间范围、地理位置等进行聚合计算</p>
<p>聚合可以通过REST API、DSL查询语言或者客户端库来使用，通常需要在查询语句中指定聚合名称、聚合类型以及聚合字段等参数。聚合的结果会以JSON格式返回，可以方便地在应用程序中进行解析和使用</p>
<p>聚合是Elasticsearch中非常重要的功能，它可以帮助用户快速、准确地获取数据的统计信息，支持复杂的数据分析和挖掘，为业务决策提供有力的支持</p>
<h4 id="19-ES中的过滤器（Filter）是什么"><a href="#19-ES中的过滤器（Filter）是什么" class="headerlink" title="19. ES中的过滤器（Filter）是什么"></a><font color=DarkOrange>19. ES中的过滤器（Filter）是什么</font></h4><p>过滤器(Filter)是一种用于过滤搜索结果的机制。与查询(Query)不同，过滤器不会影响搜索结果的相关性得分，而是根据用户定义的条件过滤掉不符合条件的文档，以便于精确地获取所需的结果</p>
<p>过滤器通常用于对搜索结果进行精确的筛选和过滤，例如根据时间范围、价格区间、地理位置、文档类型等条件来过滤文档。过滤器还可以缓存结果，以便于在下次查询时快速返回</p>
<p>Elasticsearch提供了丰富的过滤器类型，包括Term Filter、Range Filter、Bool Filter、Exists Filter、Missing Filter、Prefix Filter、Wildcard Filter、Regexp Filter、Fuzzy Filter、Geo Distance Filter、Geo Bounding Box Filter等等。用户可以根据自己的需求选择合适的过滤器类型，以实现更精确、更高效的搜索和过滤</p>
<p>过滤器(Filter)可以通过REST API、DSL查询语言或者客户端库来使用。在查询语句中指定过滤器名称、过滤器类型以及过滤器参数等参数。过滤器的结果会以JSON格式返回，可以方便地在应用程序中进行解析和使用</p>
<h4 id="20-ES中的搜索建议（Suggestion）是什么"><a href="#20-ES中的搜索建议（Suggestion）是什么" class="headerlink" title="20. ES中的搜索建议（Suggestion）是什么"></a><font color=DarkOrange>20. ES中的搜索建议（Suggestion）是什么</font></h4><p>搜索建议（Suggestion）是一种自动完成和矫正用户输入的搜索功能。它可以根据用户输入的搜索关键词，快速地生成一组相关的搜索建议，以便于用户更快地找到所需的信息</p>
<p>搜索建议通常分为两种类型：一是自动完成建议（Completion Suggestion），它能够根据用户输入的搜索关键词，快速地返回与之匹配的文档、词条或短语；另一种是矫正建议（Correction Suggestion），它能够根据用户输入的搜索关键词，自动矫正拼写错误或纠正语法问题，以便于返回更加精确的搜索结果</p>
<p>ElasticSearch支持多种搜索建议算法，包括Term Suggestion、Phrase Suggestion、Completion Suggestion、Context Suggestion等等。用户可以根据自己的需求选择合适的建议算法，以实现更好的搜索建议效果</p>
<p>搜索建议可以通过REST API、DSL查询语言或者客户端库来使用。在查询语句中指定建议名称、建议类型以及建议参数等参数。建议的结果会以JSON格式返回，可以方便地在应用程序中进行解析和使用</p>
<h4 id="21-什么是倒排索引（Inverted-Index）"><a href="#21-什么是倒排索引（Inverted-Index）" class="headerlink" title="21. 什么是倒排索引（Inverted Index）"></a><font color=DarkOrange>21. 什么是倒排索引（Inverted Index）</font></h4><p>倒排索引（Inverted Index）是一种数据结构，用于支持文本搜索。它通过建立单词（Term）到文档（Document）的映射，以便于在文本中查找某个单词时能够快速地定位到包含该单词的所有文档</p>
<p>倒排索引的基本思想是将文档集合中的每个文档分解成一个个单词（或称为术语、Term），并记录每个单词所出现的位置信息及所出现的文档编号。这样就可以通过单词在索引中的位置，快速地找到包含该单词的所有文档，从而实现高效的文本搜索功能</p>
<p>具体来说，倒排索引通常包括两个主要的部分：词表（Vocabulary）和倒排列表（Inverted List）。词表记录了所有不重复的单词，以及它们在文档集合中出现的次数、文档频率（DF）等信息；倒排列表则记录了每个单词所出现的所有文档，以及每个文档中出现该单词的位置信息、出现次数、单词频率（TF）等信息</p>
<p>倒排索引是搜索引擎实现的基础之一，Elasticsearch就是基于倒排索引实现的。它能够高效地支持各种搜索和过滤操作，从而使得在海量文本数据中进行精准的搜索和分析变得更加容易和快速</p>
<h4 id="22-ES中的评分机制（Scoring）是什么"><a href="#22-ES中的评分机制（Scoring）是什么" class="headerlink" title="22. ES中的评分机制（Scoring）是什么"></a><font color=DarkOrange>22. ES中的评分机制（Scoring）是什么</font></h4><p>评分机制（Scoring）是Elasticsearch用来计算查询结果与搜索关键词的匹配程度的机制。评分机制根据搜索结果的匹配度，将结果按照相关度进行排序，并返回前N个最相关的结果</p>
<p>评分机制的核心是TF-IDF算法，其中TF表示Term Frequency，表示某个词在文档中出现的频率；IDF表示Inverse Document Frequency，表示某个词的重要程度，通常被定义为整个文档集合中文档数量与包含该词的文档数量之比的对数的倒数。TF-IDF算法的基本思想是，某个词对于文档的重要程度越高，它在文档中的频率越高，但同时它在整个文档集合中的出现频率越低，则该词的TF-IDF值越大，对于文档的相关性也就越大</p>
<p>Elasticsearch中的评分机制通过计算每个查询词的TF-IDF得分，并根据这些得分来确定查询结果的排名和相关度。在计算TF-IDF得分时，Elasticsearch还考虑了一些其他的因素，如文档长度归一化、域归一化、文档时间等，以提高评分机制的准确性</p>
<p>评分机制是Elasticsearch的核心功能之一，它能够为用户提供高效、准确的搜索结果，并支持多种查询方式和高级功能，如搜索建议、聚合分析、多语言搜索等</p>
<h4 id="23-ES的集群（Cluster）是什么"><a href="#23-ES的集群（Cluster）是什么" class="headerlink" title="23. ES的集群（Cluster）是什么"></a><font color=DarkOrange>23. ES的集群（Cluster）是什么</font></h4><p>Elasticsearch的集群（Cluster）是由多个节点组成的一个分布式系统。一个集群可以包含任意数量的节点，这些节点可以在同一台机器上或者在不同的机器上，它们通过网络协作来共同完成数据存储和搜索等任务</p>
<p>在Elasticsearch中，集群的主要作用是实现数据的高可用和横向扩展。当一个节点失效或者宕机时，集群可以自动将数据重新分布到其他节点上，从而保证系统的可用性。同时，当数据量增加时，通过增加节点的数量可以实现集群的横向扩展，从而提高系统的性能和吞吐量</p>
<p>在集群中，每个节点都有一个唯一的名称和一个集群名称，用来标识它所属的集群。节点之间通过TCP&#x2F;IP网络相互通信，并通过内部协议来协调各种操作，如数据分片、负载均衡、故障检测和自动恢复等</p>
<p>Elasticsearch的集群架构非常灵活，可以根据需要对节点进行动态的增加或删除，以适应不同的应用场景和负载需求。同时，集群还提供了一系列的管理工具和API，可以用来监控集群的状态、配置和性能等信息，帮助用户快速诊断和解决各种问题</p>
<h4 id="24-ES的集群如何选举Master节点"><a href="#24-ES的集群如何选举Master节点" class="headerlink" title="24. ES的集群如何选举Master节点"></a><font color=DarkOrange>24. ES的集群如何选举Master节点</font></h4><p>集群的Master节点是用来协调各个节点之间的操作，如分配和重分配分片、管理索引、控制节点加入和退出等。当Master节点失效或无法正常工作时，集群需要从剩余的节点中选举一个新的Master节点来继续处理集群操作</p>
<p>集群中的Master节点的选举过程如下：</p>
<ol>
<li>各个节点启动时，会互相发现对方，并通过内部协议来建立连接和交换信息</li>
<li>如果一个节点发现了当前集群中还没有Master节点，它会自己尝试竞选Master节点</li>
<li>节点会先将自己提名为候选人，并向其他节点发送选举请求</li>
<li>如果其他节点同意该候选人成为Master节点，它就会成为Master节点</li>
<li>如果没有任何节点同意该候选人成为Master节点，它就会放弃竞选</li>
</ol>
<p>在选举Master节点的过程中，各个节点会基于一些条件来决定哪个节点可以成为Master节点，包括节点的版本号、集群名称、节点的稳定性、节点的资源占用情况等。同时，为了防止选举过程中出现“分裂脑”，集群还支持设置优先级、手动指定Master节点等措施来保证选举的正确性和稳定性</p>
<h4 id="25-ES的分布式原理"><a href="#25-ES的分布式原理" class="headerlink" title="25. ES的分布式原理"></a><font color=DarkOrange>25. ES的分布式原理</font></h4><p>Elasticsearch是一个分布式搜索引擎，可以通过将数据分布在多个节点上来实现高吞吐量、高可用性和水平扩展等特性。下面是Elasticsearch的分布式原理：</p>
<ol>
<li>集群：Elasticsearch的所有节点都是集群的一部分，每个节点都有一个唯一的名称，并且可以通过共享相同的集群名称来加入相同的集群</li>
<li>节点：每个节点是Elasticsearch中的一个实例，可以存储数据、处理搜索请求、管理索引等</li>
<li>分片：Elasticsearch将数据划分为多个分片，每个分片都是一个独立的Lucene索引，可以存储在不同的节点上</li>
<li>副本：Elasticsearch还支持将每个分片的副本存储在其他节点上，以提高数据的可用性和容错性</li>
<li>路由：当客户端发送搜索请求时，Elasticsearch会将请求路由到包含相关数据的分片或副本上，从而最大限度地减少网络流量和响应时间</li>
<li>负载均衡：Elasticsearch还支持自动均衡分片和副本之间的负载，以确保每个节点都具有相似的负载</li>
<li>故障转移：当节点失效或无法正常工作时，Elasticsearch会自动将其上的分片和副本重新分配到其他节点上，以确保数据的可用性和一致性</li>
</ol>
<p><strong>总结：</strong>Elasticsearch通过将数据分布在多个节点上，以及使用分片、副本、路由、负载均衡和故障转移等机制，实现了高可用性、高性能和水平扩展等特性。这些机制让Elasticsearch可以轻松地处理大规模数据和高并发请求，并保证数据的安全和可靠性</p>
<h4 id="26-ES如何避免脑裂现象"><a href="#26-ES如何避免脑裂现象" class="headerlink" title="26. ES如何避免脑裂现象"></a><font color=DarkOrange>26. ES如何避免脑裂现象</font></h4><p>脑裂是指当一个分布式系统中的节点之间失去联系或无法通信时，可能导致系统出现不一致的状态。为了避免脑裂现象，Elasticsearch引入了Zen Discovery机制，该机制包括以下几个方面：</p>
<ol>
<li>基于quorum的Master选举：Elasticsearch中的每个集群都有一个Master节点，它负责协调整个集群的工作。当Master节点失效或无法通信时，Zen Discovery会使用基于quorum的选举算法来选出新的Master节点，以避免出现脑裂现象</li>
<li>基于多播协议的节点发现：Elasticsearch中的节点可以使用多播协议来自动发现其他节点，并加入到集群中。这种自动发现机制可以避免手动配置和单点故障</li>
<li>心跳检测和故障检测：Elasticsearch中的节点会定期发送心跳信息和状态信息到其他节点，以检测节点的状态和故障情况。如果节点无法正常工作，其他节点会将其标记为失效，并将分片和副本重新分配到其他节点上，以确保数据的可用性和一致性</li>
<li>拆分大型集群：为了避免集群规模过大而导致的管理和维护困难，Elasticsearch建议将大型集群拆分成多个较小的集群，以便更好地管理和维护</li>
</ol>
<p><strong>总结：</strong>Elasticsearch通过引入Zen Discovery机制，包括基于quorum的Master选举、基于多播协议的节点发现、心跳检测和故障检测等，来避免脑裂现象，保证集群的可用性和一致性。同时，为了更好地管理和维护集群，Elasticsearch还建议将大型集群拆分成多个较小的集群</p>
<h4 id="27-ES中的路由（Routing）是什么"><a href="#27-ES中的路由（Routing）是什么" class="headerlink" title="27. ES中的路由（Routing）是什么"></a><font color=DarkOrange>27. ES中的路由（Routing）是什么</font></h4><p>路由（Routing）是指决定文档在分片（Shard）之间分配的规则。具体来说，路由是基于文档ID计算出的分片ID，决定了文档应该存储在哪个分片中</p>
<p>路由的作用在于，当我们进行搜索时，ElasticSearch只需要搜索涉及到的那些分片，而不需要搜索集群中的所有分片。因此，通过合理地设置路由，我们可以在搜索效率和分片负载均衡之间做出权衡</p>
<p>默认情况下，ElasticSearch会根据文档的ID来计算路由值。也可以在索引创建时自定义路由值，通过指定文档中的某个字段来计算路由值。这种方式可以让具有相同路由值的文档被分配到同一个分片中，从而加速搜索</p>
<h4 id="28-怎么样实现数据备份和恢复"><a href="#28-怎么样实现数据备份和恢复" class="headerlink" title="28. 怎么样实现数据备份和恢复"></a><font color=DarkOrange>28. 怎么样实现数据备份和恢复</font></h4><ol>
<li>使用快照和恢复 API：Elasticsearch的快照和恢复 API 可以将整个索引或者集群进行备份和恢复，同时还支持增量备份和恢复。备份时可以将快照存储在本地或者远程仓库中，例如：Amazon S3，Hadoop Distributed File System（HDFS）等。恢复时可以从存储库中恢复快照到本地或者远程的Elasticsearch集群中</li>
<li>使用 Elasticsearch Curator：Elasticsearch Curator是一个Python应用程序，它可以管理Elasticsearch索引、快照和集群状态。Curator提供了一系列的命令行工具，可以进行索引删除、备份、快照、还原等操作</li>
<li>复制索引到远程集群：Elasticsearch支持将本地索引的数据复制到远程集群中，这个功能可以用于实现数据备份和灾难恢复</li>
<li>通过文件系统备份：可以直接备份Elasticsearch的数据目录，这种方式比较简单但是备份和恢复速度较慢</li>
</ol>
<p><strong>注意：</strong>在进行数据备份和恢复时，需要保证备份和恢复的版本和配置与原始数据完全一致，否则可能会导致数据损坏或丢失。因此，建议在备份和恢复数据之前，先进行版本和配置检查</p>
<h4 id="29-ES支持哪些插件（Plugin）"><a href="#29-ES支持哪些插件（Plugin）" class="headerlink" title="29. ES支持哪些插件（Plugin）"></a><font color=DarkOrange>29. ES支持哪些插件（Plugin）</font></h4><ol>
<li>Analysis插件：提供了各种文本分析器、过滤器和标记器，用于对文本进行分析和处理</li>
<li>Ingest插件：用于在ElasticSearch索引数据之前对数据进行预处理，例如将数据解析成JSON格式，对字段进行加密等</li>
<li>Discovery插件：用于从多个节点中发现ElasticSearch集群，包括Zen Discovery、EC2 Discovery等</li>
<li>Monitoring插件：用于监控ElasticSearch集群的健康状态、性能指标等</li>
<li>Security插件：提供了认证、授权和加密等安全功能，用于保护ElasticSearch集群的数据安全</li>
<li>SQL插件：将ElasticSearch查询语言扩展到SQL语言中，使得用户可以使用SQL来查询ElasticSearch数据</li>
<li>Machine Learning插件：提供了一系列的机器学习算法和工具，用于对ElasticSearch数据进行预测分析和模型训练</li>
<li>Graph插件：提供了一种可视化方式来探索ElasticSearch中的数据关系，包括节点和边的展示、聚类分析等</li>
</ol>
<h4 id="30-ES的性能优化有哪些方面需要考虑"><a href="#30-ES的性能优化有哪些方面需要考虑" class="headerlink" title="30. ES的性能优化有哪些方面需要考虑"></a><font color=DarkOrange>30. ES的性能优化有哪些方面需要考虑</font></h4><ol>
<li>索引设计优化：索引的分片、副本数量、映射类型和字段类型的选择等都会影响查询和写入的性能</li>
<li>硬件优化：优化服务器硬件配置、磁盘的I&#x2F;O、内存、网络带宽等都可以提高ElasticSearch的性能</li>
<li>查询优化：优化查询语句、合理使用查询缓存、避免不必要的查询等可以提高查询性能</li>
<li>索引优化：使用bulk API进行批量写入、减少索引更新的频率、使用refresh_interval参数调整刷新间隔等可以提高索引性能</li>
<li>内存管理优化：合理使用内存、调整内存池大小等可以提高性能</li>
<li>网络优化：合理设置网络参数、使用高速网络、避免网络拥堵等可以提高性能</li>
<li>监控和调优：使用ElasticSearch的监控工具和日志，定期检查和调整性能参数，及时发现和解决性能问题</li>
<li>集群：Elasticsearch可以配置为具有多个节点和集群，这可以提高可用性和性能。可以使用分片和副本来平衡负载，并使用集群协调器来协调节点之间的通信</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言使用Validator进行参数校验</title>
    <url>/2022/12/08/Go%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8Validator%E8%BF%9B%E8%A1%8C%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[<p>Validator包是一个用于验证数据的库。它可以帮助您确保输入数据符合您的预期格式，以避免在应用程序中出现错误。它可以验证数据类型、字符串格式、数字范围等内容。例如，您可以使用它来验证用户提供的电子邮件地址是否有效，或者确保输入的年龄在合法范围内</p>
<p>Validator包地址：<a href="https://pkg.go.dev/github.com/go-playground/validator/v10">点击跳转</a></p>
<h4 id="1-安装使用"><a href="#1-安装使用" class="headerlink" title="1. 安装使用"></a><font color=DarkOrange>1. 安装使用</font></h4><p>首先，需要安装Validator包。可以使用以下命令安装：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u gopkg.in/<span class="keyword">go</span>-playground/validator.v10</span><br></pre></td></tr></table></figure>

<p>安装完成后，在代码中引入validator包：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;gopkg.in/go-playground/validator.v10&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-简单示例"><a href="#2-简单示例" class="headerlink" title="2. 简单示例"></a><font color=DarkOrange>2. 简单示例</font></h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;gopkg.in/go-playground/validator.v10&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="type">string</span> <span class="string">`validate:&quot;required&quot;`</span></span><br><span class="line">	Age   <span class="type">int</span>    <span class="string">`validate:&quot;gte=0,lte=130&quot;`</span></span><br><span class="line">	Email <span class="type">string</span> <span class="string">`validate:&quot;required,email&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	user := &amp;User&#123;</span><br><span class="line">		Name:  <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">		Age:   <span class="number">40</span>,</span><br><span class="line">		Email: <span class="string">&quot;john.doe@example.com&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	validate := validator.New()</span><br><span class="line"></span><br><span class="line">	err := validate.Struct(user)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 参数校验失败，输出错误信息</span></span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们定义了一个User结构体，用于表示用户信息。结构体字段上使用了validate标签，用于指定字段的约束条件。在上面的例子中，Name字段被设置为必填，Age字段的值必须大于等于0且小于等于130，Email字段的值必须是一个有效的邮件地址</p>
<p>在主函数中，我们实例化了一个User对象，并将其传入Validator的Struct方法中。Validator会对结构体中的每个字段进行校验，如果某个字段不符合约束条件，则会返回错误信息</p>
<p>除了使用结构体的方式进行校验之外，Validator还提供了各种其他验证函数，可以用来验证单个字段。例如，下面是一个验证字符串长度的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := validate.Var(user.Name, <span class="string">&quot;required,min=3,max=100&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 字符串长度不符合要求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-操作符"><a href="#3-操作符" class="headerlink" title="3. 操作符"></a><font color=DarkOrange>3. 操作符</font></h4><table>
<thead>
<tr>
<th>标记</th>
<th>标记说明</th>
</tr>
</thead>
<tbody><tr>
<td>,</td>
<td>分割多个操作符，多个操作符之间使用,进行分割</td>
</tr>
<tr>
<td>|</td>
<td>或操作；使用多个约束，只需要满足其中一个，例如：rgb|rgba</td>
</tr>
<tr>
<td>-</td>
<td>跳过该字段验证，不检验</td>
</tr>
</tbody></table>
<h4 id="4-常用标记"><a href="#4-常用标记" class="headerlink" title="4. 常用标记"></a><font color=DarkOrange>4. 常用标记</font></h4><p><strong>在定义结构体时使用<code>binding</code>或<code>validate</code>标识相关校验规则</strong></p>
<table>
<thead>
<tr>
<th>标记</th>
<th>标记说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>required</td>
<td>必填</td>
<td>Field或Struct <code>validate:&quot;required&quot;</code></td>
</tr>
<tr>
<td>omitempty</td>
<td>空时忽略</td>
<td>Field或Struct <code>validate:&quot;omitempty&quot;</code></td>
</tr>
<tr>
<td>len</td>
<td>长度</td>
<td>Field <code>validate:&quot;len=0&quot;</code></td>
</tr>
<tr>
<td>eq</td>
<td>等于</td>
<td>Field <code>validate:&quot;eq=0&quot;</code></td>
</tr>
<tr>
<td>gt</td>
<td>大于</td>
<td>Field <code>validate:&quot;gt=0&quot;</code></td>
</tr>
<tr>
<td>gte</td>
<td>大于等于</td>
<td>Field <code>validate:&quot;gte=0&quot;</code></td>
</tr>
<tr>
<td>lt</td>
<td>小于</td>
<td>Field <code>validate:&quot;lt=0&quot;</code></td>
</tr>
<tr>
<td>lte</td>
<td>小于等于</td>
<td>Field <code>validate:&quot;lte=0&quot;</code></td>
</tr>
<tr>
<td>eqfield</td>
<td>同一结构体字段相等</td>
<td>Field <code>validate:&quot;eqfield=Field2&quot;</code></td>
</tr>
<tr>
<td>nefield</td>
<td>同一结构体字段不相等</td>
<td>Field <code>validate:&quot;nefield=Field2&quot;</code></td>
</tr>
<tr>
<td>gtfield</td>
<td>大于同一结构体字段</td>
<td>Field <code>validate:&quot;gtfield=Field2&quot;</code></td>
</tr>
<tr>
<td>gtefield</td>
<td>大于等于同一结构体字段</td>
<td>Field <code>validate:&quot;gtefield=Field2&quot;</code></td>
</tr>
<tr>
<td>ltfield</td>
<td>小于同一结构体字段</td>
<td>Field <code>validate:&quot;ltfield=Field2&quot;</code></td>
</tr>
<tr>
<td>ltefield</td>
<td>小于等于同一结构体字段</td>
<td>Field <code>validate:&quot;ltefield=Field2&quot;</code></td>
</tr>
<tr>
<td>eqcsfield</td>
<td>跨不同结构体字段相等</td>
<td>Struct1.Field <code>validate:&quot;eqcsfield=Struct2.Field2&quot;</code></td>
</tr>
<tr>
<td>necsfield</td>
<td>跨不同结构体字段不相等</td>
<td>Struct1.Field <code>validate:&quot;necsfield=Struct2.Field2&quot;</code></td>
</tr>
<tr>
<td>gtcsfield</td>
<td>大于跨不同结构体字段</td>
<td>Struct1.Field <code>validate:&quot;gtcsfield=Struct2.Field2&quot;</code></td>
</tr>
<tr>
<td>gtecsfield</td>
<td>大于等于跨不同结构体字段</td>
<td>Struct1.Field <code>validate:&quot;gtecsfield=Struct2.Field2&quot;</code></td>
</tr>
<tr>
<td>ltcsfield</td>
<td>小于跨不同结构体字段</td>
<td>Struct1.Field <code>validate:&quot;ltcsfield=Struct2.Field2&quot;</code></td>
</tr>
<tr>
<td>ltecsfield</td>
<td>小于等于跨不同结构体字段</td>
<td>Struct1.Field <code>validate:&quot;ltecsfield=Struct2.Field2&quot;</code></td>
</tr>
<tr>
<td>min</td>
<td>最大值</td>
<td>Field <code>validate:&quot;min=1&quot;</code></td>
</tr>
<tr>
<td>max</td>
<td>最小值</td>
<td>Field <code>validate:&quot;max=2&quot;</code></td>
</tr>
<tr>
<td>structonly</td>
<td>仅验证结构体，不验证任何结构体字段</td>
<td>Struct <code>validate:&quot;structonly&quot;</code></td>
</tr>
<tr>
<td>nostructlevel</td>
<td>不运行任何结构级别的验证</td>
<td>Struct <code>validate:&quot;nostructlevel&quot;</code></td>
</tr>
<tr>
<td>dive</td>
<td>向下延伸验证，多层向下需要多个dive标记</td>
<td>[][]string <code>validate:&quot;gt=0,dive,len=1,dive,required&quot;</code></td>
</tr>
<tr>
<td>dive Keys &amp; EndKeys</td>
<td>与dive同时使用，用于对map对象的键的和值的验证，keys为键，endkeys为值</td>
<td>map[string]string <code>validate:&quot;gt=0,dive,keys,eq=1|eq=2,endkeys,required&quot;</code></td>
</tr>
<tr>
<td>required_with</td>
<td>其他字段其中一个不为空且当前字段不为空</td>
<td>Field <code>validate:&quot;required_with=Field1 Field2&quot;</code></td>
</tr>
<tr>
<td>required_with_all</td>
<td>其他所有字段不为空且当前字段不为空</td>
<td>Field <code>validate:&quot;required_with_all=Field1 Field2&quot;</code></td>
</tr>
<tr>
<td>required_without</td>
<td>其他字段其中一个为空且当前字段不为空</td>
<td>Field &#96;validate:”required_without&#x3D;Field1 Field2”</td>
</tr>
<tr>
<td>required_without_all</td>
<td>其他所有字段为空且当前字段不为空</td>
<td>Field <code>validate:&quot;required_without_all=Field1 Field2&quot;</code></td>
</tr>
<tr>
<td>isdefault</td>
<td>是默认值</td>
<td>Field <code>validate:&quot;isdefault=0&quot;</code></td>
</tr>
<tr>
<td>oneof</td>
<td>其中之一</td>
<td>Field <code>validate:&quot;oneof=5 7 9&quot;</code></td>
</tr>
<tr>
<td>containsfield</td>
<td>字段包含另一个字段</td>
<td>Field <code>validate:&quot;containsfield=Field2&quot;</code></td>
</tr>
<tr>
<td>excludesfield</td>
<td>字段不包含另一个字段</td>
<td>Field <code>validate:&quot;excludesfield=Field2&quot;</code></td>
</tr>
<tr>
<td>unique</td>
<td>是否唯一，通常用于切片或结构体</td>
<td>Field <code>validate:&quot;unique&quot;</code></td>
</tr>
<tr>
<td>alphanum</td>
<td>字符串值是否只包含 ASCII 字母数字字符</td>
<td>Field <code>validate:&quot;alphanum&quot;</code></td>
</tr>
<tr>
<td>alphaunicode</td>
<td>字符串值是否只包含 unicode 字符</td>
<td>Field <code>validate:&quot;alphaunicode&quot;</code></td>
</tr>
<tr>
<td>alphanumunicode</td>
<td>字符串值是否只包含 unicode 字母数字字符</td>
<td>Field <code>validate:&quot;alphanumunicode&quot;</code></td>
</tr>
<tr>
<td>numeric</td>
<td>字符串值是否包含基本的数值</td>
<td>Field <code>validate:&quot;numeric&quot;</code></td>
</tr>
<tr>
<td>hexadecimal</td>
<td>字符串值是否包含有效的十六进制</td>
<td>Field <code>validate:&quot;hexadecimal&quot;</code></td>
</tr>
<tr>
<td>hexcolor</td>
<td>字符串值是否包含有效的十六进制颜色</td>
<td>Field <code>validate:&quot;hexcolor&quot;</code></td>
</tr>
<tr>
<td>lowercase</td>
<td>符串值是否只包含小写字符</td>
<td>Field <code>validate:&quot;lowercase&quot;</code></td>
</tr>
<tr>
<td>uppercase</td>
<td>符串值是否只包含大写字符</td>
<td>Field <code>validate:&quot;uppercase&quot;</code></td>
</tr>
<tr>
<td>email</td>
<td>字符串值包含一个有效的电子邮件</td>
<td>Field <code>validate:&quot;email&quot;</code></td>
</tr>
<tr>
<td>json</td>
<td>字符串值是否为有效的 JSON</td>
<td>Field <code>validate:&quot;json&quot;</code></td>
</tr>
<tr>
<td>file</td>
<td>符串值是否包含有效的文件路径，以及该文件是否存在于计算机上</td>
<td>Field <code>validate:&quot;file&quot;</code></td>
</tr>
<tr>
<td>url</td>
<td>符串值是否包含有效的 url</td>
<td>Field <code>validate:&quot;url&quot;</code></td>
</tr>
<tr>
<td>uri</td>
<td>符串值是否包含有效的 uri</td>
<td>Field <code>validate:&quot;uri&quot;</code></td>
</tr>
<tr>
<td>base64</td>
<td>字符串值是否包含有效的 base64值</td>
<td>Field <code>validate:&quot;base64&quot;</code></td>
</tr>
<tr>
<td>contains</td>
<td>字符串值包含子字符串值</td>
<td>Field <code>validate:&quot;contains=@&quot;</code></td>
</tr>
<tr>
<td>containsany</td>
<td>字符串值包含子字符串值中的任何字符</td>
<td>Field <code>validate:&quot;containsany=abc&quot;</code></td>
</tr>
<tr>
<td>containsrune</td>
<td>字符串值包含提供的特殊符号值</td>
<td>Field <code>validate:&quot;containsrune=☢&quot;</code></td>
</tr>
<tr>
<td>excludes</td>
<td>字符串值不包含子字符串值</td>
<td>Field <code>validate:&quot;excludes=@&quot;</code></td>
</tr>
<tr>
<td>excludesall</td>
<td>字符串值不包含任何子字符串值</td>
<td>Field <code>validate:&quot;excludesall=abc&quot;</code></td>
</tr>
<tr>
<td>excludesrune</td>
<td>字符串值不包含提供的特殊符号值</td>
<td>Field <code>validate:&quot;containsrune=☢&quot;</code></td>
</tr>
<tr>
<td>startswith</td>
<td>字符串以提供的字符串值开始</td>
<td>Field <code>validate:&quot;startswith=abc&quot;</code></td>
</tr>
<tr>
<td>endswith</td>
<td>字符串以提供的字符串值结束</td>
<td>Field <code>validate:&quot;endswith=abc&quot;</code></td>
</tr>
<tr>
<td>ip</td>
<td>字符串值是否包含有效的 IP 地址</td>
<td>Field <code>validate:&quot;ip&quot;</code></td>
</tr>
<tr>
<td>ipv4</td>
<td>字符串值是否包含有效的 ipv4地址</td>
<td>Field <code>validate:&quot;ipv4&quot;</code></td>
</tr>
<tr>
<td>datetime</td>
<td>字符串值是否包含有效的 日期</td>
<td>Field <code>validate:&quot;datetime&quot;</code></td>
</tr>
</tbody></table>
<h4 id="5-使用注意"><a href="#5-使用注意" class="headerlink" title="5. 使用注意"></a><font color=DarkOrange>5. 使用注意</font></h4><p>当搜索条件与特殊标记冲突时,如：逗号（,），或操作（|），中横线（-）等则需要使用 UTF-8十六进制表示形式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">	Field1 <span class="type">string</span> <span class="string">`validate:&quot;excludesall=|&quot;`</span>    <span class="comment">// 错误</span></span><br><span class="line">	Field2 <span class="type">string</span> <span class="string">`validate:&quot;excludesall=0x7C&quot;`</span> <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka面试题</title>
    <url>/2022/10/30/Kafka%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>Kafka面试题</p>
<h4 id="1-Kafka都有哪些特点"><a href="#1-Kafka都有哪些特点" class="headerlink" title="1. Kafka都有哪些特点"></a><font color=DarkOrange>1. Kafka都有哪些特点</font></h4><ul>
<li>高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒，每个topic可以分多个partition, consumer group 对partition进行consume操作</li>
<li>可扩展性：kafka集群支持热扩展</li>
<li>持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</li>
<li>容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）</li>
<li>高并发：支持数千个客户端同时读写</li>
</ul>
<h4 id="2-请简述下你在哪些场景下会选择Kafka"><a href="#2-请简述下你在哪些场景下会选择Kafka" class="headerlink" title="2. 请简述下你在哪些场景下会选择Kafka"></a><font color=DarkOrange>2. 请简述下你在哪些场景下会选择Kafka</font></h4><ul>
<li>日志收集：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、HBase、Solr等</li>
<li>消息系统：解耦和生产者和消费者、缓存消息等</li>
<li>用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘</li>
<li>运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告</li>
<li>流式处理：比如spark streaming和 Flink</li>
</ul>
<h4 id="3-Kafka的设计架构你知道吗"><a href="#3-Kafka的设计架构你知道吗" class="headerlink" title="3. Kafka的设计架构你知道吗"></a><font color=DarkOrange>3. Kafka的设计架构你知道吗</font></h4><p>Kafka架构分为以下几个部分：</p>
<ul>
<li>Producer ：消息生产者，就是向 kafka broker 发消息的客户端</li>
<li>Consumer ：消息消费者，向 kafka broker 取消息的客户端</li>
<li>Topic ：可以理解为一个队列，一个 Topic 又分为一个或多个分区</li>
<li>Consumer Group：这是 kafka 用来实现一个 topic 消息的广播（发给所有的 consumer）和单播（发给任意一个 consumer）的手段。一个 topic 可以有多个 Consumer Group</li>
<li>Broker ：一台 kafka 服务器就是一个 broker。一个集群由多个 broker 组成。一个 broker 可以容纳多个 topic</li>
<li>Partition：为了实现扩展性，一个非常大的 topic 可以分布到多个 broker上，每个 partition 是一个有序的队列。partition 中的每条消息都会被分配一个有序的id（offset）。将消息发给 consumer，kafka 只保证按一个 partition 中的消息的顺序，不保证一个 topic 的整体（多个 partition 间）的顺序</li>
<li>Offset：kafka 的存储文件都是按照 offset.kafka 来命名，用 offset 做名字的好处是方便查找。例如你想找位于 2049 的位置，只要找到 2048.kafka 的文件即可。当然 the first offset 就是 00000000000.kafka</li>
</ul>
<h4 id="4-Kafka分区的目的"><a href="#4-Kafka分区的目的" class="headerlink" title="4. Kafka分区的目的"></a><font color=DarkOrange>4. Kafka分区的目的</font></h4><p>分区对于 Kafka 集群的好处是：实现负载均衡。分区对于消费者来说，可以提高并发度，提高效率</p>
<h4 id="5-你知道Kafka是如何做到消息的有序性"><a href="#5-你知道Kafka是如何做到消息的有序性" class="headerlink" title="5. 你知道Kafka是如何做到消息的有序性"></a><font color=DarkOrange>5. 你知道Kafka是如何做到消息的有序性</font></h4><p>kafka 中的每个 partition 中的消息在写入时都是有序的，而且单独一个 partition 只能由一个消费者去消费，可以在里面保证消息的顺序性。但是分区之间的消息是不保证有序的</p>
<h4 id="6-Kafka的高可靠性是怎么实现的"><a href="#6-Kafka的高可靠性是怎么实现的" class="headerlink" title="6. Kafka的高可靠性是怎么实现的"></a><font color=DarkOrange>6. Kafka的高可靠性是怎么实现的</font></h4><p>参考：Kafka 是如何保证数据可靠性和一致性</p>
<h4 id="7-请谈一谈Kafka数据一致性原理"><a href="#7-请谈一谈Kafka数据一致性原理" class="headerlink" title="7. 请谈一谈Kafka数据一致性原理"></a><font color=DarkOrange>7. 请谈一谈Kafka数据一致性原理</font></h4><h4 id="8-ISR、OSR、AR-是什么"><a href="#8-ISR、OSR、AR-是什么" class="headerlink" title="8. ISR、OSR、AR 是什么"></a><font color=DarkOrange>8. ISR、OSR、AR 是什么</font></h4><ul>
<li>SR：In-Sync Replicas 副本同步队列</li>
<li>OSR：Out-of-Sync Replicas</li>
<li>AR：Assigned Replicas 所有副本</li>
</ul>
<p>ISR是由leader维护，follower从leader同步数据有一些延迟，超过相应的阈值会把 follower 剔除出 ISR, 存入OSR（Out-of-Sync Replicas ）列表，新加入的follower也会先存放在OSR中。AR&#x3D;ISR+OSR</p>
<h4 id="9-LEO、HW、LSO、LW等分别代表什么"><a href="#9-LEO、HW、LSO、LW等分别代表什么" class="headerlink" title="9. LEO、HW、LSO、LW等分别代表什么"></a><font color=DarkOrange>9. LEO、HW、LSO、LW等分别代表什么</font></h4><ul>
<li>LEO：是 LogEndOffset 的简称，代表当前日志文件中下一条</li>
<li>HW：水位或水印（watermark）一词，也可称为高水位(high watermark)，通常被用在流式处理领域（比如Apache Flink、Apache Spark等），以表征元素或事件在基于时间层面上的进度。在Kafka中，水位的概念反而与时间无关，而是与位置信息相关。严格来说，它表示的就是位置信息，即位移（offset）。取 partition 对应的 ISR中 最小的 LEO 作为 HW，consumer 最多只能消费到 HW 所在的位置上一条信息</li>
<li>LSO：是 LastStableOffset 的简称，对未完成的事务而言，LSO 的值等于事务中第一条消息的位置(firstUnstableOffset)，对已完成的事务而言，它的值同 HW 相同</li>
<li>LW：Low Watermark 低水位, 代表 AR 集合中最小的 logStartOffset 值</li>
</ul>
<h4 id="10-Kafka在什么情况下会出现消息丢失"><a href="#10-Kafka在什么情况下会出现消息丢失" class="headerlink" title="10. Kafka在什么情况下会出现消息丢失"></a><font color=DarkOrange>10. Kafka在什么情况下会出现消息丢失</font></h4><p>参考：Kafka 是如何保证数据可靠性和一致性</p>
<h4 id="11-怎么尽可能保证Kafka的可靠性"><a href="#11-怎么尽可能保证Kafka的可靠性" class="headerlink" title="11. 怎么尽可能保证Kafka的可靠性"></a><font color=DarkOrange>11. 怎么尽可能保证Kafka的可靠性</font></h4><p>参考：Kafka 是如何保证数据可靠性和一致性</p>
<h4 id="12-消费者和消费者组有什么关系"><a href="#12-消费者和消费者组有什么关系" class="headerlink" title="12. 消费者和消费者组有什么关系"></a><font color=DarkOrange>12. 消费者和消费者组有什么关系</font></h4><h4 id="13-Kafka的每个分区只能被一个消费者线程，如何做到多个线程同时消费一个分区"><a href="#13-Kafka的每个分区只能被一个消费者线程，如何做到多个线程同时消费一个分区" class="headerlink" title="13. Kafka的每个分区只能被一个消费者线程，如何做到多个线程同时消费一个分区"></a><font color=DarkOrange>13. Kafka的每个分区只能被一个消费者线程，如何做到多个线程同时消费一个分区</font></h4><h4 id="14-数据传输的事务有几种"><a href="#14-数据传输的事务有几种" class="headerlink" title="14. 数据传输的事务有几种"></a><font color=DarkOrange>14. 数据传输的事务有几种</font></h4><p>数据传输的事务定义通常有以下三种级别：</p>
<ul>
<li>最多一次：消息不会被重复发送，最多被传输一次，但也有可能一次不传输</li>
<li>最少一次：消息不会被漏发送，最少被传输一次，但也有可能被重复传输</li>
<li>精确的一次（Exactly once）：不会漏传输也不会重复传输，每个消息都传输被</li>
</ul>
<h4 id="15-Kafka消费者是否可以消费指定分区消息"><a href="#15-Kafka消费者是否可以消费指定分区消息" class="headerlink" title="15. Kafka消费者是否可以消费指定分区消息"></a><font color=DarkOrange>15. Kafka消费者是否可以消费指定分区消息</font></h4><p>Kafa consumer消费消息时，向broker发出fetch请求去消费特定分区的消息，consumer指定消息在日志中的偏移量（offset），就可以消费从这个位置开始的消息，customer拥有了offset的控制权，可以向后回滚去重新消费之前的消息，这是很有意义的</p>
<h4 id="16-Kafka消息是采用Pull模式，还是Push模式"><a href="#16-Kafka消息是采用Pull模式，还是Push模式" class="headerlink" title="16. Kafka消息是采用Pull模式，还是Push模式"></a><font color=DarkOrange>16. Kafka消息是采用Pull模式，还是Push模式</font></h4><p>Kafka最初考虑的问题是，customer应该从brokes拉取消息还是brokers将消息推送到consumer，也就是pull还push。在这方面，Kafka遵循了一种大部分消息系统共同的传统的设计：producer将消息推送到broker，consumer从broker拉取消息</p>
<p>一些消息系统比如Scribe和Apache Flume采用了push模式，将消息推送到下游的consumer。这样做有好处也有坏处：由broker决定消息推送的速率，对于不同消费速率的consumer就不太好处理了。消息系统都致力于让consumer以最大的速率最快速的消费消息，但不幸的是，push模式下，当broker推送的速率远大于consumer消费的速率时，consumer恐怕就要崩溃了。最终Kafka还是选取了传统的pull模式</p>
<p>Pull模式的另外一个好处是consumer可以自主决定是否批量的从broker拉取数据。Push模式必须在不知道下游consumer消费能力和消费策略的情况下决定是立即推送每条消息还是缓存之后批量推送。如果为了避免consumer崩溃而采用较低的推送速率，将可能导致一次只推送较少的消息而造成浪费。Pull模式下，consumer就可以根据自己的消费能力去决定这些策略</p>
<p>Pull有个缺点是，如果broker没有可供消费的消息，将导致consumer不断在循环中轮询，直到新消息到t达。为了避免这点，Kafka有个参数可以让consumer阻塞知道新消息到达(当然也可以阻塞知道消息的数量达到某个特定的量这样就可以批量发</p>
<h4 id="17-Kafka-消息格式的演变清楚吗"><a href="#17-Kafka-消息格式的演变清楚吗" class="headerlink" title="17. Kafka 消息格式的演变清楚吗"></a><font color=DarkOrange>17. Kafka 消息格式的演变清楚吗</font></h4><h4 id="18-Kafka-偏移量的演变清楚吗"><a href="#18-Kafka-偏移量的演变清楚吗" class="headerlink" title="18. Kafka 偏移量的演变清楚吗"></a><font color=DarkOrange>18. Kafka 偏移量的演变清楚吗</font></h4><h4 id="19-Kafka高效文件存储设计特点"><a href="#19-Kafka高效文件存储设计特点" class="headerlink" title="19. Kafka高效文件存储设计特点"></a><font color=DarkOrange>19. Kafka高效文件存储设计特点</font></h4><ul>
<li>Kafka把topic中一个parition大文件分成多个小文件段，通过多个小文件段，就容易定期清除或删除已经消费完文件，减少磁盘占用</li>
<li>通过索引信息可以快速定位message和确定response的最大大小</li>
<li>通过index元数据全部映射到memory，可以避免segment file的IO磁盘操作</li>
<li>通过索引文件稀疏存储，可以大幅降低index文件元数据占用空间大小</li>
</ul>
<h4 id="20-Kafka创建Topic时如何将分区放置到不同的Broker中"><a href="#20-Kafka创建Topic时如何将分区放置到不同的Broker中" class="headerlink" title="20. Kafka创建Topic时如何将分区放置到不同的Broker中"></a><font color=DarkOrange>20. Kafka创建Topic时如何将分区放置到不同的Broker中</font></h4><h4 id="21-Kafka新建的分区会在哪个目录下创建"><a href="#21-Kafka新建的分区会在哪个目录下创建" class="headerlink" title="21. Kafka新建的分区会在哪个目录下创建"></a><font color=DarkOrange>21. Kafka新建的分区会在哪个目录下创建</font></h4><h4 id="22-谈一谈Kafka的再均衡"><a href="#22-谈一谈Kafka的再均衡" class="headerlink" title="22. 谈一谈Kafka的再均衡"></a><font color=DarkOrange>22. 谈一谈Kafka的再均衡</font></h4><p>在Kafka中，当有新消费者加入或者订阅的topic数发生变化时，会触发Rebalance(再均衡：在同一个消费者组当中，分区的所有权从一个消费者转移到另外一个消费者)机制，Rebalance顾名思义就是重新均衡消费者消费。Rebalance的过程如下：</p>
<ul>
<li>第一步：所有成员都向coordinator发送请求，请求入组。一旦所有成员都发送了请求，coordinator会从中选择一个consumer担任leader的角色，并把组成员信息以及订阅信息发给leader</li>
<li>第二步：leader开始分配消费方案，指明具体哪个consumer负责消费哪些topic的哪些partition。一旦完成分配，leader会将这个方案发给coordinator。coordinator接收到分配方案之后会把方案发给各个consumer，这样组内的所有成员就都知道自己应该消费哪些分区了</li>
</ul>
<p>所以对于Rebalance来说，Coordinator起着至关重要的作用</p>
<h4 id="23-谈谈Kafka分区分配策略"><a href="#23-谈谈Kafka分区分配策略" class="headerlink" title="23. 谈谈Kafka分区分配策略"></a><font color=DarkOrange>23. 谈谈Kafka分区分配策略</font></h4><h4 id="24-Kafka-Producer是如何动态感知主题分区数变化的"><a href="#24-Kafka-Producer是如何动态感知主题分区数变化的" class="headerlink" title="24. Kafka Producer是如何动态感知主题分区数变化的"></a><font color=DarkOrange>24. Kafka Producer是如何动态感知主题分区数变化的</font></h4><h4 id="25-Kafka是如何实现高吞吐率的"><a href="#25-Kafka是如何实现高吞吐率的" class="headerlink" title="25. Kafka是如何实现高吞吐率的"></a><font color=DarkOrange>25. Kafka是如何实现高吞吐率的</font></h4><p>Kafka是分布式消息系统，需要处理海量的消息，Kafka的设计是把所有的消息都写入速度低容量大的硬盘，以此来换取更强的存储能力，但实际上，使用硬盘并没有带来过多的性能损失。kafka主要使用了以下几个方式实现了超高的吞吐率：</p>
<ul>
<li>顺序读写</li>
<li>零拷贝</li>
<li>文件分段</li>
<li>批量发送</li>
<li>数据压缩</li>
</ul>
<h4 id="26-Kafka监控都有哪些"><a href="#26-Kafka监控都有哪些" class="headerlink" title="26. Kafka监控都有哪些"></a><font color=DarkOrange>26. Kafka监控都有哪些</font></h4><h4 id="27-如何为Kafka集群选择合适的Topics-x2F-Partitions数量"><a href="#27-如何为Kafka集群选择合适的Topics-x2F-Partitions数量" class="headerlink" title="27. 如何为Kafka集群选择合适的Topics&#x2F;Partitions数量"></a><font color=DarkOrange>27. 如何为Kafka集群选择合适的Topics&#x2F;Partitions数量</font></h4><h4 id="28-谈谈你对Kafka事务的了解"><a href="#28-谈谈你对Kafka事务的了解" class="headerlink" title="28. 谈谈你对Kafka事务的了解"></a><font color=DarkOrange>28. 谈谈你对Kafka事务的了解</font></h4><h4 id="29-谈谈你对Kafka幂等的了解"><a href="#29-谈谈你对Kafka幂等的了解" class="headerlink" title="29. 谈谈你对Kafka幂等的了解"></a><font color=DarkOrange>29. 谈谈你对Kafka幂等的了解</font></h4><h4 id="30-Kafka缺点"><a href="#30-Kafka缺点" class="headerlink" title="30. Kafka缺点"></a><font color=DarkOrange>30. Kafka缺点</font></h4><ul>
<li>由于是批量发送，数据并非真正的实时</li>
<li>对于mqtt协议不支持</li>
<li>不支持物联网传感数据直接接入</li>
<li>仅支持统一分区内消息有序，无法实现全局消息有序</li>
<li>监控不完善，需要安装插件</li>
<li>依赖zookeeper进行元数据管理</li>
</ul>
<h4 id="31-Kafka新旧消费者的区别"><a href="#31-Kafka新旧消费者的区别" class="headerlink" title="31. Kafka新旧消费者的区别"></a><font color=DarkOrange>31. Kafka新旧消费者的区别</font></h4><p>旧的 Kafka 消费者 API 主要包括：SimpleConsumer（简单消费者） 和 ZookeeperConsumerConnectir（高级消费者）。SimpleConsumer 名字看起来是简单消费者，但是其实用起来很不简单，可以使用它从特定的分区和偏移量开始读取消息。高级消费者和现在新的消费者有点像，有消费者群组，有分区再均衡，不过它使用 ZK 来管理消费者群组，并不具备偏移量和再均衡的可操控性</p>
<h4 id="32-Kafka分区数可以增加或减少吗？为什么"><a href="#32-Kafka分区数可以增加或减少吗？为什么" class="headerlink" title="32. Kafka分区数可以增加或减少吗？为什么"></a><font color=DarkOrange>32. Kafka分区数可以增加或减少吗？为什么</font></h4><p>我们可以使用 bin&#x2F;kafka-topics.sh 命令对 Kafka 增加 Kafka 的分区数据，但是 Kafka 不支持减少分区数</p>
<p>Kafka 分区数据不支持减少是由很多原因的，比如减少的分区其数据放到哪里去？是删除，还是保留？删除的话，那么这些没消费的消息不就丢了。如果保留这些消息如何放到其他分区里面？追加到其他分区后面的话那么就破坏了 Kafka 单个分区的有序性。如果要保证删除分区数据插入到其他分区保证有序性，那么实现起来逻辑就会非常复杂</p>
<hr>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux操作系统面试题</title>
    <url>/2022/10/28/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>Linux常见面试题整理</p>
<hr>
<p><strong>50个最常用的Unix&#x2F;Linux命令</strong></p>
<h4 id="1-tar"><a href="#1-tar" class="headerlink" title="1. tar"></a><font color=DarkOrange>1. tar</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar cvf archive_name.tar <span class="built_in">dirname</span>/ 创建一个新的tar文件</span><br><span class="line">tar xvf archive_name.tar 解压tar文件</span><br><span class="line">tar tvf archive_name.tar 查看tar文件</span><br></pre></td></tr></table></figure>

<h4 id="2-grep"><a href="#2-grep" class="headerlink" title="2. grep"></a><font color=DarkOrange>2. grep</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">grep -i <span class="string">&quot;the&quot;</span> demo_file 在文件中查找字符串(不区分大小写)</span><br><span class="line">grep -A 3 -i <span class="string">&quot;example&quot;</span> demo_text 输出成功匹配的行，以及该行之后的三行</span><br><span class="line">grep -r <span class="string">&quot;ramesh&quot;</span> * 在一个文件夹中递归查询包含指定字符串的文件</span><br></pre></td></tr></table></figure>

<h4 id="3-find"><a href="#3-find" class="headerlink" title="3. find"></a><font color=DarkOrange>3. find</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">find -iname <span class="string">&quot;MyProgram.c&quot;</span> 查找指定文件名的文件(不区分大小写)</span><br><span class="line">find -iname <span class="string">&quot;MyProgram.c&quot;</span> -<span class="built_in">exec</span> <span class="built_in">md5sum</span> &#123;&#125; \; 对找到的文件执行某个命令</span><br><span class="line">find ~ -empty 查找home目录下的所有空文件</span><br></pre></td></tr></table></figure>

<h4 id="4-ssh"><a href="#4-ssh" class="headerlink" title="4. ssh"></a><font color=DarkOrange>4. ssh</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh -l jsmith remotehost.example.com 登录到远程主机</span><br><span class="line">ssh -v -l jsmith remotehost.example.com 调试ssh客户端</span><br><span class="line">ssh -V 显示ssh客户端版本</span><br></pre></td></tr></table></figure>

<h4 id="5-sed"><a href="#5-sed" class="headerlink" title="5. sed"></a><font color=DarkOrange>5. sed</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/.$//&#x27;</span> filename 当你将Dos系统中的文件复制到Unix/Linux后，这个文件每行都会以\r\n结尾，sed可以轻易将其转换为Unix格式的文件，使用\n结尾的文件</span><br><span class="line">sed -n <span class="string">&#x27;1!G; h; p&#x27;</span> filename 反转文件内容并输出</span><br><span class="line">sed <span class="string">&#x27;/./=&#x27;</span> thegeekstuff.txt | sed <span class="string">&#x27;N; s/\n/ /&#x27;</span> 为非空行添加行号</span><br></pre></td></tr></table></figure>

<h4 id="6-awk"><a href="#6-awk" class="headerlink" title="6. awk"></a><font color=DarkOrange>6. awk</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;!($0 in array) &#123; array[$0]; print&#125;&#x27;</span> temp 删除重复行</span><br><span class="line">awk -F <span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;$3=$4&#x27;</span> /etc/passwd 打印/etc/passwd中所有包含同样的uid和gid的行</span><br><span class="line">awk <span class="string">&#x27;&#123;print $2,$5;&#125;&#x27;</span> employee.txt 打印文件中的指定部分的字段</span><br></pre></td></tr></table></figure>

<h4 id="7-vim"><a href="#7-vim" class="headerlink" title="7. vim"></a><font color=DarkOrange>7. vim</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim +10 filename.txt 打开文件并跳到第10行</span><br><span class="line">vim +/search-term filename.txt 打开文件跳到第一个匹配的行</span><br><span class="line">vim -R /etc/passwd 以只读模式打开文件</span><br></pre></td></tr></table></figure>

<h4 id="8-diff"><a href="#8-diff" class="headerlink" title="8. diff"></a><font color=DarkOrange>8. diff</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">diff -w name_list.txt name_list_new.txt 比较的时候忽略空白符</span><br></pre></td></tr></table></figure>

<h4 id="9-sort"><a href="#9-sort" class="headerlink" title="9. sort"></a><font color=DarkOrange>9. sort</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span> names.txt 以升序对文件内容排序</span><br><span class="line"><span class="built_in">sort</span> -r names.txt 以降序对文件内容排序</span><br><span class="line"><span class="built_in">sort</span> -t: -k 3n /etc/passwd | more 以第三个字段对/etc/passwd的内容排序</span><br></pre></td></tr></table></figure>

<h4 id="10-export"><a href="#10-export" class="headerlink" title="10. export"></a><font color=DarkOrange>10. export</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> | grep ORCALE 输出跟字符串oracle匹配的环境变量</span><br><span class="line"><span class="built_in">export</span> ORACLE_HOME=/u01/app/oracle/product/10.2.0 设置全局环境变量</span><br></pre></td></tr></table></figure>

<h4 id="11-xargs"><a href="#11-xargs" class="headerlink" title="11. xargs"></a><font color=DarkOrange>11. xargs</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> *.jpg | xargs -n1 -i <span class="built_in">cp</span> &#123;&#125; /external-hard-drive/directory 将所有图片文件拷贝到外部驱动器</span><br><span class="line">find / -name *.jpg -<span class="built_in">type</span> f -<span class="built_in">print</span> | xargs tar -cvzf images.tar.gz 将系统中所有jpd文件压缩打包</span><br><span class="line"><span class="built_in">cat</span> url-list.txt | xargs wget –c 下载文件中列出的所有url对应的页面</span><br></pre></td></tr></table></figure>

<h4 id="12-ls"><a href="#12-ls" class="headerlink" title="12. ls"></a><font color=DarkOrange>12. ls</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lh 以易读的方式显示文件大小(显示为MB,GB...)</span><br><span class="line"><span class="built_in">ls</span> -ltr 以最后修改时间升序列出文件</span><br><span class="line"><span class="built_in">ls</span> -F 在文件名后面显示文件类型</span><br></pre></td></tr></table></figure>

<h4 id="13-pwd"><a href="#13-pwd" class="headerlink" title="13. pwd"></a><font color=DarkOrange>13. pwd</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">输出当前工作目录</span><br></pre></td></tr></table></figure>

<h4 id="14-cd"><a href="#14-cd" class="headerlink" title="14. cd"></a><font color=DarkOrange>14. cd</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> 可以在最近工作的两个目录间切换</span><br><span class="line"><span class="built_in">cd</span> ../ 跳到上级目录</span><br><span class="line"><span class="built_in">cd</span> /opt 不管现在到那直接跳到指定的opt文件夹中</span><br><span class="line"><span class="built_in">cd</span> ~ 切换当前用户的家目录。root用户的家目录就是root目录</span><br></pre></td></tr></table></figure>

<h4 id="15-gzip"><a href="#15-gzip" class="headerlink" title="15. gzip"></a><font color=DarkOrange>15. gzip</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gzip test.txt 创建一个*.gz的压缩文件</span><br><span class="line">gzip -d test.txt.gz 解压*.gz文件</span><br><span class="line">gzip -l *.gz 显示压缩的比率</span><br></pre></td></tr></table></figure>

<h4 id="16-bzip2"><a href="#16-bzip2" class="headerlink" title="16. bzip2"></a><font color=DarkOrange>16. bzip2</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bzip2 test.txt 创建*.bz2压缩文件</span><br><span class="line">bzip2 -d test.txt.bz2 解压*.bz2文件</span><br></pre></td></tr></table></figure>

<h4 id="17-uzip"><a href="#17-uzip" class="headerlink" title="17. uzip"></a><font color=DarkOrange>17. uzip</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">unzip test.zip 解压*.zip文件</span><br><span class="line">unzip -l jasper.zip 查看*.zip文件的内容</span><br></pre></td></tr></table></figure>

<h4 id="18-shutdown"><a href="#18-shutdown" class="headerlink" title="18. shutdown"></a><font color=DarkOrange>18. shutdown</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">shutdown -h now 关闭系统并立即关机</span><br><span class="line">shutdown -h +10 10分钟后关机</span><br><span class="line">shutdown -r now 重启</span><br><span class="line">shutdown -Fr now 重启期间强制进行系统检查</span><br></pre></td></tr></table></figure>

<h4 id="19-ftp"><a href="#19-ftp" class="headerlink" title="19. ftp"></a><font color=DarkOrange>19. ftp</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ftp IP/hostname ftp命令和sftp命令的用法基本相似连接ftp服务器并下载多个文件</span><br><span class="line">ftp&gt; mls *.html - 显示远程主机上文件列表</span><br></pre></td></tr></table></figure>

<h4 id="20-crontab"><a href="#20-crontab" class="headerlink" title="20. crontab"></a><font color=DarkOrange>20. crontab</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">crontab -u john -l 查看某个用户的crontab入口</span><br><span class="line">*/10 * * * * /home/ramesh/check-disk-space 设置一个每十分钟执行一次的计划任务</span><br></pre></td></tr></table></figure>

<h4 id="21-service"><a href="#21-service" class="headerlink" title="21. service"></a><font color=DarkOrange>21. service</font></h4><p>service命令用于运行System V init脚本，这些脚本一般位于&#x2F;etc&#x2F;init.d文件下，这个命令可以直接运行这个文件夹里面的脚本，而不用加上路径</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">service ssh status 查看服务状态</span><br><span class="line">service --status-all 查看所有服务状态</span><br><span class="line">service ssh restart 重启服务</span><br></pre></td></tr></table></figure>

<h4 id="22-ps"><a href="#22-ps" class="headerlink" title="22. ps"></a><font color=DarkOrange>22. ps</font></h4><p>ps命令用于显示正在运行中的进程的信息，ps命令有很多选项，这里只列出了几个</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps -ef | more 查看当前正在运行的所有进程</span><br><span class="line">ps -efH | more 以树状结构显示当前正在运行的进程，H选项表示显示进程的层次结构</span><br></pre></td></tr></table></figure>

<h4 id="23-free"><a href="#23-free" class="headerlink" title="23. free"></a><font color=DarkOrange>23. free</font></h4><p>这个命令用于显示系统当前内存的使用情况，包括已用内存、可用内存和交换内存的情况</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">free 默认情况下free会以字节为单位输出内存的使用量</span><br><span class="line">free -g 如果你想以其他单位输出内存的使用量，需要加一个选项，-g为GB，-m为MB，-k为KB，-b为字节</span><br><span class="line">free -t 如果你想查看所有内存的汇总，请使用-t选项，使用这个选项会在输出中加一个汇总行</span><br></pre></td></tr></table></figure>

<h4 id="24-top"><a href="#24-top" class="headerlink" title="24. top"></a><font color=DarkOrange>24. top</font></h4><p>top命令会显示当前系统中占用资源最多的一些进程（默认以CPU占用率排序）如果你想改变排序方式，可以在结果列表中点击O（大写字母O）会显示所有可用于排序的列，这个时候你就可以选择你想排序的列</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">top -u oracle 如果只想显示某个特定用户的进程，可以使用-u选项</span><br></pre></td></tr></table></figure>

<h4 id="25-df"><a href="#25-df" class="headerlink" title="25. df"></a><font color=DarkOrange>25. df</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> -k 显示文件系统的磁盘使用情况，默认情况下<span class="built_in">df</span> -k 将以字节为单位输出磁盘的使用量</span><br><span class="line"><span class="built_in">df</span> -h 使用-h选项可以以更符合阅读习惯的方式显示磁盘使用量</span><br><span class="line"><span class="built_in">df</span> -T 使用-T选项显示文件系统类型</span><br></pre></td></tr></table></figure>

<h4 id="26-kill"><a href="#26-kill" class="headerlink" title="26. kill"></a><font color=DarkOrange>26. kill</font></h4><p>kill用于终止一个进程。一般我们会先用<code>ps -ef</code>查找某个进程得到它的进程号，然后再使用<code>kill -9 进程号</code>终止该进程。你还可以使用killall、pkill、xkill来终止进程</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps -ef | grep vim</span><br><span class="line">	ramesh    7243  7222  9 22:43 pts/2    00:00:00 vim</span><br><span class="line"><span class="built_in">kill</span> -9 7243</span><br></pre></td></tr></table></figure>

<h4 id="27-rm"><a href="#27-rm" class="headerlink" title="27. rm"></a><font color=DarkOrange>27. rm</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -i filename.txt 删除文件前先确认</span><br><span class="line"><span class="built_in">rm</span> -i file* 在文件名中使用shell的元字符会非常有用。删除文件前先打印文件名并进行确认</span><br><span class="line"><span class="built_in">rm</span> -r example 递归删除文件夹下所有文件，并删除该文件夹</span><br></pre></td></tr></table></figure>

<h4 id="28-cp"><a href="#28-cp" class="headerlink" title="28. cp"></a><font color=DarkOrange>28. cp</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> -p file1 file2 拷贝文件1到文件2，并保持文件的权限、属主和时间戳</span><br><span class="line"><span class="built_in">cp</span> -i file1 file2 拷贝file1到file2，如果file2存在会提示是否覆盖</span><br></pre></td></tr></table></figure>

<h4 id="29-mv"><a href="#29-mv" class="headerlink" title="29. mv"></a><font color=DarkOrange>29. mv</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">注意如果使用-f选项则不会进行提示</span><br><span class="line"><span class="built_in">mv</span> -i file1 file2 将文件名file1重命名为file2，如果file2存在则提示是否覆盖</span><br><span class="line"><span class="built_in">mv</span> -v file1 file2 -v会输出重命名的过程，当文件名中包含通配符时，这个选项会非常方便</span><br></pre></td></tr></table></figure>

<h4 id="30-cat"><a href="#30-cat" class="headerlink" title="30. cat"></a><font color=DarkOrange>30. cat</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> file1 file2 你可以一次查看多个文件的内容，下面的命令会先打印file1的内容，然后打印file2的内容</span><br><span class="line"><span class="built_in">cat</span> -n /etc/logrotate.conf -n命令可以在每行的前面加上行号</span><br></pre></td></tr></table></figure>

<h4 id="31-mount"><a href="#31-mount" class="headerlink" title="31. mount"></a><font color=DarkOrange>31. mount</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /u01</span><br><span class="line">mount /dev/sdb1 /u01 如果要挂载一个文件系统，需要先创建一个目录，然后将这个文件系统挂载到这个目录上</span><br><span class="line">/dev/sdb1 /u01 ext2 defaults 0 2 也可以把它添加到fstab中进行自动挂载，这样任何时候系统重启的时候，文件系统都会被加载</span><br></pre></td></tr></table></figure>

<h4 id="32-chmod"><a href="#32-chmod" class="headerlink" title="32. chmod"></a><font color=DarkOrange>32. chmod</font></h4><p>chmod用于改变文件和目录的权限</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> ug+rwx file.txt 给指定文件的属主和属组所有权限(包括读、写、执行)</span><br><span class="line"><span class="built_in">chmod</span> g-rwx file.txt 删除指定文件的属组的所有权限</span><br><span class="line"><span class="built_in">chmod</span> -R ug+rwx file.txt 修改目录的权限，以及递归修改目录下面所有文件和子目录的权限</span><br></pre></td></tr></table></figure>

<h4 id="33-chown"><a href="#33-chown" class="headerlink" title="33. chown"></a><font color=DarkOrange>33. chown</font></h4><p>chown用于改变文件属主和属组</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chown</span> oracle:dba dbora.sh 同时将某个文件的属主改为oracle，属组改为db</span><br><span class="line"><span class="built_in">chown</span> -R oracle:dba /home/oracle 使用-R选项对目录和目录下的文件进行递归修改</span><br></pre></td></tr></table></figure>

<h4 id="34-passwd"><a href="#34-passwd" class="headerlink" title="34. passwd"></a><font color=DarkOrange>34. passwd</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">passwd passwd用于在命令行修改密码，使用这个命令会要求你先输入旧密码，然后输入新密码</span><br><span class="line">passwd USERNAME 超级用户可以用这个命令修改其他用户的密码，这个时候不需要输入用户的密码</span><br><span class="line">passwd -d USERNAME passwd还可以删除某个用户的密码，这个命令只有root用户才能操作，删除密码后，这个用户不需要输入密码就可以登录到系统</span><br></pre></td></tr></table></figure>

<h4 id="35-mkdir"><a href="#35-mkdir" class="headerlink" title="35. mkdir"></a><font color=DarkOrange>35. mkdir</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/temp 在home目录下创建一个名为temp的目录</span><br><span class="line"><span class="built_in">mkdir</span> -p dir1/dir2/dir3/dir4/ 使用-p选项可以创建一个路径上所有不存在的目录</span><br></pre></td></tr></table></figure>

<h4 id="36-ifconfig"><a href="#36-ifconfig" class="headerlink" title="36. ifconfig"></a><font color=DarkOrange>36. ifconfig</font></h4><p>ifconfig用于查看和配置Linux系统的网络接口</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ifconfig -a 查看所有网络接口及其状态</span><br><span class="line">ifconfig eth0 up 使用up命令启动某个接口</span><br><span class="line">ifconfig eth0 down 使用down命令停止某个接口</span><br></pre></td></tr></table></figure>

<h4 id="37-uname"><a href="#37-uname" class="headerlink" title="37. uname"></a><font color=DarkOrange>37. uname</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a <span class="built_in">uname</span>可以显示一些重要的系统信息，例如内核名称、主机名、内核版本号、处理器类型之类的信息</span><br></pre></td></tr></table></figure>

<h4 id="38-whereis"><a href="#38-whereis" class="headerlink" title="38. whereis"></a><font color=DarkOrange>38. whereis</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">whereis <span class="built_in">ls</span> 当你不知道某个命令的位置时可以使用whereis命令，下面使用whereis查找<span class="built_in">ls</span>的位置</span><br><span class="line">whereis -u -B /tmp -f lsmk 当你想查找某个可执行程序的位置，但这个程序又不在whereis的默认目录下，你可以使用-B选项，并指定目录作为这个选项的参数。下面的命令在/tmp目录下查找lsmk命令</span><br></pre></td></tr></table></figure>

<h4 id="39-whatis"><a href="#39-whatis" class="headerlink" title="39. whatis"></a><font color=DarkOrange>39. whatis</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">whatis <span class="built_in">ls</span> wathis显示某个命令的描述信息</span><br><span class="line">whatis ifconfig wathis显示某个命令的描述信息</span><br></pre></td></tr></table></figure>

<h4 id="40-locate"><a href="#40-locate" class="headerlink" title="40. locate"></a><font color=DarkOrange>40. locate</font></h4><p>locate命名可以显示某个指定文件（或一组文件）的路径，它会使用由updatedb创建的数据库</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">locate crontab 命令会显示系统中所有包含crontab字符串的文件</span><br></pre></td></tr></table></figure>

<h4 id="41-man"><a href="#41-man" class="headerlink" title="41. man"></a><font color=DarkOrange>41. man</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">man crontab 显示某个命令的man页面</span><br><span class="line">man SECTION-NUMBER commandname 有些命令可能会有多个man页面，每个man页面对应一种命令类型</span><br></pre></td></tr></table></figure>

<h4 id="42-tail"><a href="#42-tail" class="headerlink" title="42. tail"></a><font color=DarkOrange>42. tail</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tail</span> filename.txt <span class="built_in">tail</span>命令默认显示文件最后的10行文本</span><br><span class="line"><span class="built_in">tail</span> -n N filename.txt 你可以使用-n选项指定要显示的行数</span><br><span class="line"><span class="built_in">tail</span> -f log-file 你也可以使用-f选项进行实时查看，这个命令执行后会等待，如果有新行添加到文件尾部，它会继续输出新的行，在查看日志时这个选项会非常有用。你可以通过CTRL-C终止命令的执行</span><br></pre></td></tr></table></figure>

<h4 id="43-less"><a href="#43-less" class="headerlink" title="43. less"></a><font color=DarkOrange>43. less</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">less huge-log-file.log 这个命名可以在不加载整个文件的前提下显示文件内容，在查看大型日志文件的时候这个命令会非常有用</span><br></pre></td></tr></table></figure>

<h4 id="44-su"><a href="#44-su" class="headerlink" title="44. su"></a><font color=DarkOrange>44. su</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">su - USERNAME su命令用于切换用户账号，超级用户使用这个命令可以切换到任何其他用户而不用输入密码</span><br><span class="line">su -s <span class="string">&#x27;SHELLNAME&#x27;</span> USERNAME 用指定用户登录，并且使用指定的shell程序，而不用默认的</span><br></pre></td></tr></table></figure>

<h4 id="45-mysql"><a href="#45-mysql" class="headerlink" title="45. mysql"></a><font color=DarkOrange>45. mysql</font></h4><p>mysql可能是Linux上使用最广泛的数据库，即使你没有在你的服务器上安装mysql，你也可以使用mysql客户端连接到远程的mysql服务器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql -u root -p -h 192.168.1.2 连接一个远程数据库，需要输入密码</span><br><span class="line">mysql -u root -p 连接本地数据库</span><br></pre></td></tr></table></figure>

<p>你也可以在命令行中输入数据库密码，只需要在-p后面加上密码作为参数，可以直接写在p后面而不用加空格</p>
<h4 id="46-yum"><a href="#46-yum" class="headerlink" title="46. yum"></a><font color=DarkOrange>46. yum</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install httpd 使用yum安装apache</span><br><span class="line">yum update httpd 更新apache</span><br><span class="line">yum remove httpd 卸载/删除apache</span><br></pre></td></tr></table></figure>

<h4 id="47-rpm"><a href="#47-rpm" class="headerlink" title="47. rpm"></a><font color=DarkOrange>47. rpm</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rpm -ivh httpd-2.2.3-22.0.1.el5.i386.rpm 使用rpm安装apache</span><br><span class="line">rpm -uvh httpd-2.2.3-22.0.1.el5.i386.rpm 更新apache</span><br><span class="line">rpm -ev httpd 卸载/删除apache</span><br></pre></td></tr></table></figure>

<h4 id="48-ping"><a href="#48-ping" class="headerlink" title="48. ping"></a><font color=DarkOrange>48. ping</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ping -c 5 gmail.com ping一个远程主机，只发5个数据包</span><br></pre></td></tr></table></figure>

<h4 id="49-date"><a href="#49-date" class="headerlink" title="49. date"></a><font color=DarkOrange>49. date</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">date</span> -s <span class="string">&quot;01/31/2010 23:59:53&quot;</span> 设置系统日期</span><br><span class="line">---</span><br><span class="line">当你修改了系统时间，你需要同步硬件时间和系统时间</span><br><span class="line">hwclock –systohc</span><br><span class="line">hwclock --systohc –utc</span><br></pre></td></tr></table></figure>

<h4 id="50-wget"><a href="#50-wget" class="headerlink" title="50. wget"></a><font color=DarkOrange>50. wget</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget http://prdownloads.sourceforge.net/sourceforge/nagios/nagios-3.2.1.tar.gz 使用wget从网上下载软件、音乐、视频</span><br><span class="line">wget -O taglist.zip http://www.vim.org/scripts/download_script.php?src_id=7701 下载文件并以指定的文件名保存文件</span><br></pre></td></tr></table></figure>

<h4 id="51-CPU100-怎么排查和处理"><a href="#51-CPU100-怎么排查和处理" class="headerlink" title="51. CPU100%怎么排查和处理"></a><font color=DarkOrange>51. CPU100%怎么排查和处理</font></h4><p>使用top命令定位进程，再用top命令定位线程，再打印线程堆栈查看运行情况</p>
<ol>
<li><code>top</code>命令显示进程运行列表，找到最耗<code>CPU</code>的进程<code>PID</code></li>
<li>找到最耗<code>CPU</code>的线程，<code>top -Hp 进程PID号</code>，显示进程的线程运行列表，找到最耗<code>CPU</code>的线程<code>PID</code></li>
<li>将线程<code>PID</code>转化为16进制，<code>printf &quot;%x\n&quot; 线程PID号</code>，因为在堆栈里，线程<code>ID</code>是用16进制表示的</li>
<li>查看堆栈，找到线程在干嘛，<code>pstack/jstack/grep</code>，<code>jstack 进程PID | grep ‘线程PID的16进制数’ -C5 --color</code>打印进程堆栈，通过线程<code>ID</code>，过滤得到线程堆栈，根据线程<code>PID</code>的16进制数找到消耗<code>CPU</code>高的线程对应的线程的名称，以及看到了改线程正在执行代码的堆栈</li>
</ol>
<h4 id="52"><a href="#52" class="headerlink" title="52. "></a><font color=DarkOrange>52. </font></h4><h4 id="53"><a href="#53" class="headerlink" title="53. "></a><font color=DarkOrange>53. </font></h4><h4 id="54"><a href="#54" class="headerlink" title="54. "></a><font color=DarkOrange>54. </font></h4><h4 id="55"><a href="#55" class="headerlink" title="55."></a><font color=DarkOrange>55.</font></h4><h4 id="56"><a href="#56" class="headerlink" title="56. "></a><font color=DarkOrange>56. </font></h4><h4 id="57"><a href="#57" class="headerlink" title="57. "></a><font color=DarkOrange>57. </font></h4><hr>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker、k8s、etcd面试题</title>
    <url>/2022/11/24/Docker%E3%80%81k8s%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>常见Docker、K8S、etcd面试题整理</p>
<hr>
<h4 id="1-什么是Docker"><a href="#1-什么是Docker" class="headerlink" title="1. 什么是Docker"></a><font color=DarkOrange>1. 什么是Docker</font></h4><ol>
<li>Docker是一种开源的容器化平台</li>
<li>它允许开发者在容器中打包、部署和运行应用程序</li>
<li>Docker容器是一种轻量级、可移植的虚拟化技术</li>
<li>Docker平台的优点是它可以将应用程序及其所有依赖项打包成一个轻量级的容器</li>
<li>这些容器可以在任何地方运行，无需对底层系统进行修改</li>
<li>Docker容器提供了一种更加简单和高效的方式来管理应用程序的生命周期，从开发、测试到部署和运行</li>
</ol>
<h4 id="2-Docker镜像和容器之间有什么区别"><a href="#2-Docker镜像和容器之间有什么区别" class="headerlink" title="2. Docker镜像和容器之间有什么区别"></a><font color=DarkOrange>2. Docker镜像和容器之间有什么区别</font></h4><ol>
<li>镜像是一个文件，它包含了应用程序和运行时所需要的依赖库、环境变量、配置文件等，它是只读的。容器则是在镜像的基础上创建的一个可运行的实例，它可以被启动、停止、删除，容器中的数据可以进行修改和存储</li>
<li>镜像可以看作是容器的模板，容器的创建需要基于某个镜像。一个镜像可以创建多个容器，这些容器都是基于同一个镜像创建的，但它们可以有不同的配置和数据</li>
<li>镜像是静态的，一旦创建后就不会发生变化，如果需要更新镜像，需要重新构建一个新的镜像。容器则是动态的，可以随时启动、停止、删除、修改</li>
</ol>
<p><strong>注意：</strong>镜像是一个静态的文件，而容器是一个动态的实例。通过使用Docker镜像和容器，可以方便地部署和管理应用程序，使应用程序的开发和部署更加快速、可靠、灵活</p>
<h4 id="3-Docker的优势是什么"><a href="#3-Docker的优势是什么" class="headerlink" title="3. Docker的优势是什么"></a><font color=DarkOrange>3. Docker的优势是什么</font></h4><ol>
<li>简化开发流程：Docker 可以将应用程序及其依赖项打包成一个容器，使得开发人员可以在任何环境中运行相同的应用程序，避免了因开发和生产环境差异导致的应用程序运行异常</li>
<li>快速部署和扩展：使用 Docker 部署应用程序非常快速和简便，只需要在主机上运行 Docker 容器即可。此外，可以根据需要快速地扩展应用程序的容量，而无需更改代码或重新配置服务器</li>
<li>节省资源：Docker 可以在同一台主机上运行多个容器，每个容器都是相互隔离的，不会相互干扰，因此可以更有效地利用服务器的资源，提高服务器的利用率</li>
<li>更好的可移植性：Docker 容器可以在任何支持 Docker 的系统中运行，使得应用程序更容易地在不同的平台上进行部署和迁移</li>
<li>更好的安全性：Docker 容器可以提供更好的安全性，容器之间相互隔离，可以避免应用程序和操作系统之间的相互干扰，同时也可以更好地控制应用程序的运行环境和访问权限</li>
</ol>
<h4 id="4-Docker的工作原理是什么"><a href="#4-Docker的工作原理是什么" class="headerlink" title="4. Docker的工作原理是什么"></a><font color=DarkOrange>4. Docker的工作原理是什么</font></h4><p>Docker 的工作原理是将应用程序及其依赖项打包成一个容器，并在主机上运行这个容器，从而实现应用程序的部署和管理。同时，Docker 容器之间相互隔离，使得容器之间不会相互干扰，从而提高了应用程序的安全性和稳定性</p>
<ol>
<li>创建 Docker 镜像：将应用程序和其依赖项打包成一个 Docker 镜像文件，Docker 镜像是只读的，可以被用来创建多个容器</li>
<li>运行 Docker 容器：使用 Docker 镜像创建一个容器，容器是 Docker 镜像的一个运行实例，容器是可读写的，并可以被启动、停止、删除</li>
<li>容器与主机系统的通信：Docker 容器与主机系统之间可以进行通信，容器可以访问主机系统上的文件系统和网络资源，而主机系统也可以访问容器的文件系统和网络资源</li>
<li>容器之间的隔离：Docker 容器之间是相互隔离的，每个容器都有自己的文件系统、网络和进程空间，避免了容器之间的相互干扰</li>
<li>Docker 仓库：Docker 仓库是用于存储和分享 Docker 镜像的地方，用户可以将自己创建的 Docker 镜像上传到 Docker 仓库，也可以从 Docker 仓库中下载别人创建的 Docker 镜像</li>
</ol>
<h4 id="5-如何在Docker中创建镜像"><a href="#5-如何在Docker中创建镜像" class="headerlink" title="5. 如何在Docker中创建镜像"></a><font color=DarkOrange>5. 如何在Docker中创建镜像</font></h4><ol>
<li>创建 Dockerfile：Dockerfile 是一个文本文件，用于描述如何构建 Docker 镜像。它包括基础镜像、应用程序代码、依赖项和配置等信息</li>
<li>编写 Dockerfile：在 Dockerfile 中，可以使用各种 Docker 指令来构建镜像，例如 FROM、RUN、COPY、EXPOSE、CMD 等。FROM 指令指定基础镜像，RUN 指令用于执行命令，COPY 指令用于复制文件，EXPOSE 指令用于声明容器将监听哪些端口，CMD 指令用于定义容器启动后要执行的命令</li>
<li>构建 Docker 镜像：使用 docker build 命令来构建 Docker 镜像，需要指定 Dockerfile 的路径和镜像名称及版本号。例如，docker build -t myimage:v1.0</li>
<li>测试和上传 Docker 镜像：构建完成后，可以使用 docker run 命令来启动容器测试镜像。如果测试通过，可以使用 docker push 命令将镜像上传到 Docker Hub 或其他 Docker 仓库中，以供其他人使用</li>
</ol>
<h4 id="6-Docker有哪些常用命令"><a href="#6-Docker有哪些常用命令" class="headerlink" title="6. Docker有哪些常用命令"></a><font color=DarkOrange>6. Docker有哪些常用命令</font></h4><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>docker run</code></td>
<td>运行一个容器</td>
</tr>
<tr>
<td><code>docker stop</code></td>
<td>停止一个或多个容器</td>
</tr>
<tr>
<td><code>docker ps</code></td>
<td>列出运行中的容器</td>
</tr>
<tr>
<td><code>docker images</code></td>
<td>列出本地镜像</td>
</tr>
<tr>
<td><code>docker build</code></td>
<td>根据 Dockerfile 创建镜像</td>
</tr>
<tr>
<td><code>docker pull</code></td>
<td>从 Docker 镜像仓库中拉取镜像</td>
</tr>
<tr>
<td><code>docker push</code></td>
<td>将本地镜像推送到 Docker 镜像仓库</td>
</tr>
<tr>
<td><code>docker exec</code></td>
<td>在运行中的容器中执行命令</td>
</tr>
<tr>
<td><code>docker rm</code></td>
<td>删除一个或多个容器</td>
</tr>
<tr>
<td><code>docker rmi</code></td>
<td>删除一个或多个镜像</td>
</tr>
<tr>
<td><code>docker inspect</code></td>
<td>显示容器或镜像的详细信息</td>
</tr>
<tr>
<td><code>docker logs</code></td>
<td>查看容器的日志输出</td>
</tr>
<tr>
<td><code>docker network</code></td>
<td>管理 Docker 网络</td>
</tr>
<tr>
<td><code>docker-compose</code></td>
<td>使用 Compose 定义和运行多容器应用程序</td>
</tr>
<tr>
<td><code>docker attach</code></td>
<td>连接到正在运行的容器的 STDIN、STDOUT 和 STDERR</td>
</tr>
</tbody></table>
<h4 id="7-如何在Docker容器内执行命令"><a href="#7-如何在Docker容器内执行命令" class="headerlink" title="7. 如何在Docker容器内执行命令"></a><font color=DarkOrange>7. 如何在Docker容器内执行命令</font></h4><p>可以使用<code>docker exec</code>命令在Docker容器内部执行命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> [OPTIONS] CONTAINER COMMAND [ARG...]</span><br></pre></td></tr></table></figure>

<p>其中，<code>OPTIONS</code>表示执行命令的一些选项，例如：</p>
<ul>
<li><code>-i</code>：表示使用交互模式（stdin）</li>
<li><code>-t</code>：表示使用终端模式（tty）</li>
</ul>
<p><code>CONTAINER</code>表示要执行命令的容器的名称或ID</p>
<p><code>COMMAND</code>表示要在容器中执行的命令</p>
<p><code>ARG</code>表示命令的参数</p>
<p>例如，要在名为<code>my-container</code>的容器中执行<code>ls -l</code>命令，可以使用以下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it my-container <span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure>

<h4 id="8-如何在Docker容器之间进行通信"><a href="#8-如何在Docker容器之间进行通信" class="headerlink" title="8. 如何在Docker容器之间进行通信"></a><font color=DarkOrange>8. 如何在Docker容器之间进行通信</font></h4><p>Docker会自动创建一个默认的 bridge 网络来为容器提供网络服务，也可以通过创建自定义网络来实现容器之间的通信</p>
<ol>
<li>使用容器 IP 地址进行通信：每个容器都有一个唯一的 IP 地址，可以通过这个地址来实现容器之间的通信。例如，可以在一个容器中使用另一个容器的 IP 地址来进行网络通信</li>
<li>使用容器名称进行通信：Docker 容器可以使用 <code>--name</code> 参数指定容器名称，可以在容器之间使用名称来进行通信。例如，可以在一个容器中使用 <code>ping</code> 命令来测试另一个容器的可达性</li>
<li>使用容器端口进行通信：容器可以通过暴露端口来与外部网络进行通信，也可以通过容器之间的端口映射来实现容器之间的通信。例如，可以在一个容器中使用另一个容器的暴露端口来进行网络通信</li>
<li>使用 Docker 网络进行通信：Docker 提供了多种网络驱动程序来支持容器之间的通信，可以使用 <code>docker network create</code> 命令来创建自定义网络，并使用 <code>--network</code> 参数指定容器所属的网络。例如，可以在一个容器中使用另一个容器的 IP 地址或容器名称来进行网络通信</li>
</ol>
<p><strong>注意：</strong>如果容器之间需要进行通信，需要在启动容器时使用 <code>--link</code> 参数或在创建自定义网络时进行相关配置，以便容器能够互相发现和访问</p>
<h4 id="9-Docker容器的生命周期是什么"><a href="#9-Docker容器的生命周期是什么" class="headerlink" title="9. Docker容器的生命周期是什么"></a><font color=DarkOrange>9. Docker容器的生命周期是什么</font></h4><ol>
<li>创建阶段：通过 <code>docker run</code> 命令创建一个容器，Docker 会从镜像中创建容器，并分配唯一的容器 ID。在创建容器时，可以设置容器的名称、网络配置、端口映射等参数</li>
<li>运行阶段：在容器创建后，可以使用 <code>docker start</code> 命令来启动容器。一旦容器启动，Docker 就会在容器中执行指定的命令或应用程序。在运行阶段，可以使用 <code>docker stop</code> 命令停止容器，或使用 <code>docker restart</code> 命令重新启动容器</li>
<li>暂停阶段：在容器运行中，可以使用 <code>docker pause</code> 命令将容器暂停，此时容器中的所有进程都会被挂起。可以使用 <code>docker unpause</code> 命令恢复容器运行</li>
<li>终止阶段：当容器不再需要时，可以使用 <code>docker rm</code> 命令删除容器。在删除容器之前，需要先停止容器。可以使用 <code>docker kill</code> 命令强制停止容器</li>
<li>导出和导入阶段：在容器运行中，可以使用 <code>docker export</code> 命令将容器打包为一个 tar 文件，然后可以将这个文件拷贝到另一个 Docker 主机上进行导入，使用 <code>docker import</code> 命令导入镜像</li>
</ol>
<h4 id="10-如何在Docker中进行数据管理"><a href="#10-如何在Docker中进行数据管理" class="headerlink" title="10. 如何在Docker中进行数据管理"></a><font color=DarkOrange>10. 如何在Docker中进行数据管理</font></h4><ol>
<li>数据卷（Volume）：数据卷是一种持久化存储的方式，可以将宿主机上的目录或文件夹挂载到容器中，从而实现在容器中对数据进行持久化存储的目的。使用数据卷可以将数据独立于容器进行管理，使容器的生命周期与数据的生命周期分离。可以使用 <code>docker volume</code> 命令创建和管理数据卷</li>
<li>绑定挂载（Bind Mount）：绑定挂载是一种将宿主机上的文件或目录直接挂载到容器中的方式，可以将宿主机上的文件直接暴露给容器，从而实现容器与宿主机之间的数据共享。使用绑定挂载可以方便地在容器和宿主机之间进行数据传输。可以使用 <code>docker run</code> 命令的 <code>-v</code> 参数指定绑定挂载</li>
<li>共享存储（Shared Storage）：共享存储是一种将数据存储在独立的存储系统中，并将存储系统挂载到多个容器中的方式，可以实现多个容器之间的数据共享。使用共享存储可以避免数据重复存储，节省存储空间，同时也能够提高数据的可靠性和可用性。常见的共享存储包括 NFS、GlusterFS、Ceph 等</li>
<li>Docker Compose：Docker Compose 是一种用于定义和运行多个 Docker 容器的工具，可以通过编写 YAML 文件来定义容器的运行方式、数据卷、网络、环境变量等属性，从而实现对多个容器的统一管理和协调。通过 Docker Compose，可以方便地进行数据管理，实现容器之间的数据共享和传输</li>
</ol>
<h4 id="11-Docker和虚拟机的区别是什么"><a href="#11-Docker和虚拟机的区别是什么" class="headerlink" title="11. Docker和虚拟机的区别是什么"></a><font color=DarkOrange>11. Docker和虚拟机的区别是什么</font></h4><ol>
<li>架构差异：虚拟机是基于硬件的虚拟化技术，通过在物理主机上安装虚拟机监控器（Hypervisor）来模拟硬件，从而实现在虚拟机中运行多个操作系统。而 Docker 则是基于容器的虚拟化技术，利用 Linux 内核的容器特性，在单个物理主机上运行多个容器，每个容器都是相互隔离的运行环境</li>
<li>资源占用：由于虚拟机需要模拟硬件环境，因此每个虚拟机都需要独立的操作系统和硬件资源，包括 CPU、内存、硬盘等，相对于 Docker 耗费更多的资源。而 Docker 则是共享物理主机的资源，容器之间共享操作系统和内核，不需要额外的资源占用</li>
<li>启动速度：由于虚拟机需要启动一个完整的操作系统和硬件环境，因此启动时间较长，一般需要几分钟的时间。而 Docker 则可以在几秒钟内启动一个容器，由于容器是共享物理主机的操作系统和内核，因此启动速度相对较快</li>
<li>部署与管理：虚拟机通常需要进行全量部署和管理，包括操作系统、应用程序和依赖库等，相对较为复杂。而 Docker 则可以将应用程序及其依赖库打包成一个容器镜像，可以快速部署和管理，避免了应用程序的依赖问题</li>
</ol>
<p>Docker和虚拟机的区别主要在于架构、资源占用、启动速度和部署与管理等方面。相对于虚拟机，Docker 更加轻量级，启动速度更快，部署和管理更加方便，更适合于微服务架构和容器化部署</p>
<h4 id="12-如何进行Docker的日志管理"><a href="#12-如何进行Docker的日志管理" class="headerlink" title="12. 如何进行Docker的日志管理"></a><font color=DarkOrange>12. 如何进行Docker的日志管理</font></h4><ol>
<li><p>使用 Docker logs 命令：可以使用 Docker logs 命令查看容器的日志</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker logs &lt;container_name or container_id&gt;</span><br></pre></td></tr></table></figure>

<p>此命令可以查看容器的标准输出和标准错误输出。默认情况下，容器的日志会输出到控制台。可以使用 –tail 参数指定输出日志的行数，使用 -f 参数实时跟踪容器日志</p>
</li>
<li><p>挂载日志目录：可以通过挂载容器的日志目录到本地主机，实现容器日志的持久化存储和管理。可以使用 -v 参数将主机目录挂载到容器中</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name my_container -v /path/to/logs:/logs my_image</span><br></pre></td></tr></table></figure>

<p>此命令将本地主机上的 &#x2F;path&#x2F;to&#x2F;logs 目录挂载到容器中的 &#x2F;logs 目录。容器中的日志将会保存到本地主机的 &#x2F;path&#x2F;to&#x2F;logs 目录下</p>
</li>
<li><p>使用第三方日志收集工具：可以使用第三方日志收集工具，如 Fluentd、Logstash、Graylog 等，实现容器日志的集中管理和分析。这些工具可以将容器日志收集到统一的地方，并提供日志搜索、过滤、分析和可视化等功能</p>
</li>
</ol>
<h4 id="13-Docker的网络模式有哪些"><a href="#13-Docker的网络模式有哪些" class="headerlink" title="13. Docker的网络模式有哪些"></a><font color=DarkOrange>13. Docker的网络模式有哪些</font></h4><ol>
<li>桥接模式（Bridge）：Docker 默认采用桥接模式，每个容器都分配一个 IP 地址，并可以通过容器名称进行互相访问。桥接模式适用于单机多容器的情况</li>
<li>主机模式（Host）：容器与主机共享网络栈，使用主机的 IP 地址，适用于需要最大网络性能和最小网络延迟的情况</li>
<li>网络模式（Network）：容器可以通过连接到同一个网络来进行通信。可以使用 Docker 自带的 bridge 网络或者用户自定义网络</li>
<li>空网络模式（None）：容器没有网络接口，适用于不需要网络访问的容器</li>
<li>Overlay 网络模式：适用于跨多个 Docker 宿主机的容器网络通信，可以在 Docker Swarm 中使用</li>
</ol>
<h4 id="14-如何在Docker中使用环境变量"><a href="#14-如何在Docker中使用环境变量" class="headerlink" title="14. 如何在Docker中使用环境变量"></a><font color=DarkOrange>14. 如何在Docker中使用环境变量</font></h4><p>在 Docker 中，可以使用环境变量来传递配置信息，例如数据库连接地址、端口号、用户名、密码等敏感信息。在容器启动时，可以将环境变量传递给容器，并在容器中使用这些环境变量</p>
<p>Docker 支持两种方式来设置环境变量：</p>
<ol>
<li><p>Dockerfile 中使用 ENV 指令：在 Dockerfile 中可以使用 ENV 指令来设置环境变量</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:latest</span><br><span class="line"><span class="keyword">ENV</span> DB_HOST=localhost \</span><br><span class="line">    DB_PORT=<span class="number">3306</span> \</span><br><span class="line">    DB_USER=root \</span><br><span class="line">    DB_PASS=<span class="number">123456</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在容器启动时使用 -e 参数：可以在启动容器时使用 -e 参数来设置环境变量</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name my_container -e DB_HOST=localhost -e DB_PORT=3306 my_image</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="15-如何在Docker中使用卷"><a href="#15-如何在Docker中使用卷" class="headerlink" title="15. 如何在Docker中使用卷"></a><font color=DarkOrange>15. 如何在Docker中使用卷</font></h4><p>在 Docker 中，可以使用卷（Volume）来管理容器中的数据，卷可以将主机文件系统或其他容器的文件系统挂载到容器中，从而实现容器中数据的持久化和共享</p>
<p>Docker 支持三种类型的卷：</p>
<ol>
<li><p>绑定挂载（Bind Mount）：将主机文件系统中的目录或文件挂载到容器中，可以通过 -v 参数来实现</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -v /path/on/host:/path/on/container my_image</span><br></pre></td></tr></table></figure>

<p>这个命令将会将主机文件系统中的 &#x2F;path&#x2F;on&#x2F;host 目录挂载到容器中的 &#x2F;path&#x2F;on&#x2F;container 目录。</p>
</li>
<li><p>匿名卷（Anonymous Volume）：Docker 会自动为容器创建一个匿名卷，可以使用 -v 参数来实现</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -v /path/on/container my_image</span><br></pre></td></tr></table></figure>

<p>这个命令将会为容器创建一个匿名卷，并将其挂载到容器中的 &#x2F;path&#x2F;on&#x2F;container 目录</p>
</li>
<li><p>命名卷（Named Volume）：可以为容器创建一个命名卷，并将其挂载到容器中，可以使用 -v 参数来实现，例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -v my_volume:/path/on/container my_image</span><br></pre></td></tr></table></figure>

<p>这个命令将会创建一个名为 my_volume 的命名卷，并将其挂载到容器中的 &#x2F;path&#x2F;on&#x2F;container 目录</p>
</li>
</ol>
<p>在容器中使用卷时，可以像使用普通目录一样使用，数据将会持久化到卷中，即使容器被删除也不会丢失。可以使用<code>docker volume ls</code>命令来查看当前主机上的卷列表，使用<code>docker volume rm</code>命令来删除不需要的卷</p>
<h4 id="16-如何在Docker中进行多容器管理"><a href="#16-如何在Docker中进行多容器管理" class="headerlink" title="16. 如何在Docker中进行多容器管理"></a><font color=DarkOrange>16. 如何在Docker中进行多容器管理</font></h4><p>使用Docker Compose来进行多容器管理。Docker Compose是一个命令行工具，可用于定义和运行多容器Docker应用程序</p>
<ol>
<li><p>创建Docker Compose文件：使用YAML格式定义多容器应用程序的服务、网络和卷等元素</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8000:8000&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">.:/code</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">POSTGRES_PASSWORD:</span> <span class="string">example</span></span><br></pre></td></tr></table></figure>

<p>在此示例中，定义了两个服务：web和db。Web服务构建了一个本地Dockerfile，将端口8000映射到主机上，并将当前目录挂载到容器中的&#x2F;code目录。它还依赖于db服务。db服务使用PostgreSQL映像，并设置一个环境变量来设置数据库密码</p>
</li>
<li><p>启动多容器应用程序：使用Docker Compose启动应用程序</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure>

<p>此命令将启动定义在Docker Compose文件中的所有服务</p>
</li>
<li><p>关闭多容器应用程序：使用Docker Compose停止应用程序</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker-compose down</span><br></pre></td></tr></table></figure>

<p>此命令将停止所有正在运行的容器，并删除它们</p>
</li>
</ol>
<h4 id="17-如何进行Docker的安全管理"><a href="#17-如何进行Docker的安全管理" class="headerlink" title="17. 如何进行Docker的安全管理"></a><font color=DarkOrange>17. 如何进行Docker的安全管理</font></h4><ol>
<li>更新Docker版本：保持Docker版本最新可以避免已知的漏洞和安全问题</li>
<li>安全的镜像源：使用官方的Docker Hub镜像源，避免使用未知的镜像源</li>
<li>配置安全的Docker daemon：Docker daemon是Docker的后台进程，需要进行安全配置，包括限制网络访问和授权用户权限等</li>
<li>配置容器的安全性：可以通过限制容器的资源使用和网络访问等方式提高容器的安全性</li>
<li>使用安全的应用程序：选择安全的应用程序和镜像，并配置适当的安全策略</li>
<li>实施适当的访问控制：限制Docker daemon和容器的访问权限，并限制用户的权限</li>
<li>监控和日志：实时监控Docker daemon和容器，并记录日志以便跟踪和审计</li>
</ol>
<h4 id="18-Docker-Compose是什么"><a href="#18-Docker-Compose是什么" class="headerlink" title="18. Docker Compose是什么"></a><font color=DarkOrange>18. Docker Compose是什么</font></h4><p>Docker Compose是Docker的一个工具，用于定义和运行多个Docker容器的应用程序。它允许开发人员在单个配置文件中定义一个应用程序的多个服务，以便可以方便地启动、停止和管理整个应用程序。Docker Compose的主要目的是简化多个容器的应用程序的部署和管理过程</p>
<p>使用Docker Compose，开发人员可以使用一个YAML文件来定义整个应用程序的服务、网络和卷等元素。在该文件中，开发人员可以定义每个服务的容器镜像、容器名称、容器端口、环境变量、容器间网络连接等等。Docker Compose还可以自动启动容器并将它们连接在一起，从而创建一个完整的应用程序</p>
<p>Docker Compose还支持覆盖（override）和扩展（extend），这使得在不同的环境中部署应用程序变得更加灵活和便捷。例如，可以在开发环境中覆盖一些配置，以适应生产环境中的需求，或者可以在多个部署环境中共享基本配置，以简化部署流程</p>
<h4 id="19-如何在Docker中使用多阶段构建"><a href="#19-如何在Docker中使用多阶段构建" class="headerlink" title="19. 如何在Docker中使用多阶段构建"></a><font color=DarkOrange>19. 如何在Docker中使用多阶段构建</font></h4><p>多阶段构建（multi-stage build）是一种技术，它可以将一个Dockerfile分为多个阶段，每个阶段都可以使用不同的基础镜像，并可以共享文件系统。使用多阶段构建，可以将一个大型应用程序的构建过程分解成多个步骤，从而优化构建过程的速度和容器大小</p>
<ol>
<li><p>在Dockerfile中定义多个阶段，并为每个阶段选择不同的基础镜像</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">FROM</span> <span class="string">node:10-alpine</span> <span class="string">AS</span> <span class="string">builder</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义第一个阶段</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="string">FROM</span> <span class="string">nginx:alpine</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义第二个阶段</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">...</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在每个阶段中执行相应的构建命令，并将结果保存到容器中</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">FROM</span> <span class="string">node:10-alpine</span> <span class="string">AS</span> <span class="string">builder</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建应用程序</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">&amp;&amp;</span> <span class="string">npm</span> <span class="string">build</span></span><br><span class="line"></span><br><span class="line"><span class="string">FROM</span> <span class="string">nginx:alpine</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制应用程序到nginx镜像中</span></span><br><span class="line"><span class="string">COPY</span> <span class="string">--from=builder</span> <span class="string">/app/dist</span> <span class="string">/usr/share/nginx/html</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在最终的容器中只包含必要的文件和组件，以减少容器的大小</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">FROM</span> <span class="string">nginx:alpine</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只复制必要的文件</span></span><br><span class="line"><span class="string">COPY</span> <span class="string">--from=builder</span> <span class="string">/app/dist</span> <span class="string">/usr/share/nginx/html</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>使用多阶段构建可以有效地减少Docker镜像的大小，并加快应用程序的构建过程。同时，由于每个阶段都可以使用不同的基础镜像，可以选择最适合特定用途的镜像，从而提高应用程序的性能和安全性</p>
<h4 id="20-如何在Docker中进行负载均衡"><a href="#20-如何在Docker中进行负载均衡" class="headerlink" title="20. 如何在Docker中进行负载均衡"></a><font color=DarkOrange>20. 如何在Docker中进行负载均衡</font></h4><ol>
<li><p>使用Docker Swarm模式</p>
<p>Docker Swarm是Docker官方提供的容器编排工具，它可以管理多个Docker容器并将它们分布在多个节点上。在Docker Swarm模式下，可以使用内置的负载均衡机制进行服务发现和路由，从而实现负载均衡</p>
<p>首先，需要创建一个Docker Swarm集群，然后在集群中创建服务并指定多个副本。Swarm会自动将服务副本分布在不同的节点上，并使用内置的负载均衡机制将请求路由到适当的服务副本</p>
</li>
<li><p>使用第三方负载均衡器</p>
<p>除了使用Docker Swarm内置的负载均衡机制外，还可以使用第三方负载均衡器进行负载均衡。常用的负载均衡器包括Nginx、HAProxy、Traefik等</p>
<p>使用第三方负载均衡器需要将负载均衡器部署在Docker集群的外部，并将请求路由到集群内的Docker容器。为了实现这一点，可以使用Docker的服务发现机制和网络机制</p>
<p>具体地，需要在Docker容器中定义一个共享的网络，并将每个服务都加入到这个网络中。然后，使用负载均衡器将请求路由到网络中的容器。可以使用Docker的DNS解析服务来查找容器的IP地址</p>
</li>
</ol>
<hr>
<hr>
<h4 id="21-什么是K8S"><a href="#21-什么是K8S" class="headerlink" title="21. 什么是K8S"></a><font color=DarkOrange>21. 什么是K8S</font></h4><p>Kubernetes（通常简称为“K8s”）是一个开源的容器编排和管理平台，它最初由Google开发，并于2014年发布为开源软件。Kubernetes可以自动化地部署、扩展和管理容器化的应用程序，提供了诸如负载均衡、自动伸缩、容器间通信、存储管理等功能，使得应用程序更加易于部署、管理和扩展</p>
<p>Kubernetes提供了一组API和工具，可以管理由多个Docker容器组成的应用程序，这些容器可以在多个节点上运行，并可以自动扩展和收缩以满足负载要求。Kubernetes支持多种容器运行时，包括Docker、containerd、CRI-O等</p>
<p>Kubernetes的核心概念包括：</p>
<ul>
<li>Pod：Kubernetes中最小的调度单元，由一个或多个紧密相关的容器组成，可以共享网络和存储。</li>
<li>Service：为一组Pod提供稳定的网络端口和DNS名称，使得应用程序可以轻松地与其他组件进行通信</li>
<li>ReplicaSet：用于控制一组Pod的副本数量，确保应用程序具有所需的可用性和性能</li>
<li>Deployment：用于管理Pod和ReplicaSet的更新，支持滚动更新和回滚操作</li>
<li>ConfigMap和Secret：用于管理应用程序的配置和敏感信息</li>
<li>Volume：提供可插拔的存储插件，用于管理应用程序的数据持久化</li>
</ul>
<p>Kubernetes是一个强大而灵活的容器编排平台，它可以简化容器化应用程序的部署、管理和扩展，并提供了丰富的功能和API，支持在多云环境中无缝运行</p>
<h4 id="22-K8S的核心概念有哪些"><a href="#22-K8S的核心概念有哪些" class="headerlink" title="22. K8S的核心概念有哪些"></a><font color=DarkOrange>22. K8S的核心概念有哪些</font></h4><ol>
<li>Pod：Kubernetes中最小的调度单元，由一个或多个紧密相关的容器组成，可以共享网络和存储。Pod是Kubernetes中最基本的部署单元，是一个可以运行容器的环境</li>
<li>Service：为一组Pod提供稳定的网络端口和DNS名称，使得应用程序可以轻松地与其他组件进行通信。Service是Pod的抽象，是一组Pod的逻辑分组，可以在Kubernetes集群内提供稳定的服务发现和负载均衡</li>
<li>ReplicaSet：用于控制一组Pod的副本数量，确保应用程序具有所需的可用性和性能。ReplicaSet是一种控制器，它可以根据用户定义的期望状态来管理Pod的副本数量</li>
<li>Deployment：用于管理Pod和ReplicaSet的更新，支持滚动更新和回滚操作。Deployment是一种高级控制器，可以管理多个ReplicaSet，支持无宕机更新和自动回滚操作</li>
<li>ConfigMap和Secret：用于管理应用程序的配置和敏感信息。ConfigMap用于存储应用程序的配置信息，Secret用于存储敏感信息，如密码和证书</li>
<li>Volume：提供可插拔的存储插件，用于管理应用程序的数据持久化。Volume是一种抽象，它可以将物理存储和应用程序的文件系统抽象为一个逻辑卷</li>
<li>Namespace：用于隔离和管理Kubernetes集群内的资源，可以将一个集群划分为多个虚拟集群。Namespace提供了一种逻辑隔离的机制，使得不同的用户或应用程序可以共享同一个Kubernetes集群而不会相互干扰</li>
</ol>
<h4 id="23-K8S的工作原理是什么"><a href="#23-K8S的工作原理是什么" class="headerlink" title="23. K8S的工作原理是什么"></a><font color=DarkOrange>23. K8S的工作原理是什么</font></h4><p><strong>工作原理：</strong></p>
<ol>
<li>Master组件：Kubernetes集群的控制中心，主要由以下组件组成：</li>
</ol>
<ul>
<li>API Server：提供REST API，用于接收和处理集群内的各种请求</li>
<li>etcd：分布式键值存储，用于存储Kubernetes集群的配置信息和状态</li>
<li>Controller Manager：用于管理集群内的各种控制器，如ReplicaSet、Deployment等</li>
<li>Scheduler：用于调度Pod到合适的Node上运行</li>
</ul>
<ol start="2">
<li>Node组件：运行应用程序容器的主机，主要由以下组件组成：</li>
</ol>
<ul>
<li>kubelet：运行在每个Node上的代理程序，负责管理Node上的容器</li>
<li>kube-proxy：负责为Service提供网络代理和负载均衡功能</li>
<li>容器运行时：负责运行应用程序容器，如Docker、rkt等</li>
</ul>
<ol start="3">
<li>Pod：Kubernetes中最小的调度单元，由一个或多个紧密相关的容器组成，可以共享网络和存储</li>
<li>Service：为一组Pod提供稳定的网络端口和DNS名称，使得应用程序可以轻松地与其他组件进行通信</li>
</ol>
<p><strong>工作流程：</strong></p>
<ol>
<li>用户通过kubectl或其他工具向Kubernetes集群发送请求，请求可能是创建、更新、删除Pod、Service等对象</li>
<li>API Server接收并处理请求，将对象的配置信息和状态信息存储到etcd中</li>
<li>Controller Manager通过监听etcd的变化，发现有新的或修改的对象时，会相应地更新集群内的控制器（如ReplicaSet、Deployment等）</li>
<li>Scheduler根据集群内的资源情况和Pod的需求，将Pod调度到合适的Node上运行</li>
<li>kubelet在Node上创建和管理Pod，并与API Server保持联系，汇报Pod的状态和健康情况</li>
<li>kube-proxy为Service提供网络代理和负载均衡功能，使得应用程序可以通过Service访问到集群内的其他组件</li>
</ol>
<h4 id="24-如何在K8S中创建Pod"><a href="#24-如何在K8S中创建Pod" class="headerlink" title="24. 如何在K8S中创建Pod"></a><font color=DarkOrange>24. 如何在K8S中创建Pod</font></h4><p>在Kubernetes中创建Pod需要编写一个Pod描述文件，其中包括Pod的名称、容器镜像、容器端口等信息。然后使用kubectl工具或其他工具将该描述文件提交给Kubernetes集群即可</p>
<p>下面是一个简单的Pod描述文件示例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>该描述文件中定义了一个名为<code>my-pod</code>的Pod，其中包含一个名为<code>my-container</code>的容器，使用<code>nginx:latest</code>镜像，并将容器的端口映射到80端口</p>
<p>要将该描述文件提交给Kubernetes集群，可以使用以下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl create -f my-pod.yaml</span><br></pre></td></tr></table></figure>

<p>该命令将读取<code>my-pod.yaml</code>文件中的Pod描述信息，并创建该Pod</p>
<p>除了使用描述文件创建Pod外，还可以使用kubectl命令直接创建Pod。例如，以下命令将创建一个名为<code>my-pod</code>的Pod，并使用<code>nginx:latest</code>镜像：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl run my-pod --image=nginx:latest</span><br></pre></td></tr></table></figure>

<p>无论使用描述文件还是kubectl命令创建Pod，Kubernetes都会将该Pod的定义信息存储在etcd中，并使用调度器将其调度到集群中的某个Node上运行</p>
<h4 id="25-如何在K8S中扩展集群"><a href="#25-如何在K8S中扩展集群" class="headerlink" title="25. 如何在K8S中扩展集群"></a><font color=DarkOrange>25. 如何在K8S中扩展集群</font></h4><p>在Kubernetes中，可以通过添加更多的Node节点来扩展集群。Kubernetes集群的Node节点是运行容器和Pod的主机，因此增加Node节点可以增加集群的容量和计算资源</p>
<p>以下是在Kubernetes中扩展集群的一般步骤：</p>
<ol>
<li>获取新的Node节点：可以在公共云上购买新的虚拟机，或者在本地环境中添加新的物理机器</li>
<li>配置新的Node节点：需要在新的Node节点上安装Docker、kubelet和kubectl等必要的软件组件，并配置它们与Kubernetes集群通信。可以使用kubeadm等工具来简化这个过程</li>
<li>将新的Node节点添加到Kubernetes集群：可以使用kubeadm工具或其他工具将新的Node节点加入到Kubernetes集群中。在加入集群之前，需要将新的Node节点与Kubernetes集群中的其他节点进行身份验证和授权</li>
<li>部署Pod和服务：当新的Node节点加入到Kubernetes集群中后，可以使用Kubernetes API和kubectl命令来部署新的Pod和服务，并将它们调度到新的Node节点上运行</li>
</ol>
<p><strong>注意：</strong>当集群规模变大时，需要考虑集群管理的自动化和标准化。可以使用Kubernetes Operator、自动扩缩容等工具来简化集群管理的流程，并确保集群的稳定性和高可用性</p>
<h4 id="26-如何在K8S中进行滚动升级"><a href="#26-如何在K8S中进行滚动升级" class="headerlink" title="26. 如何在K8S中进行滚动升级"></a><font color=DarkOrange>26. 如何在K8S中进行滚动升级</font></h4><p>在Kubernetes中进行滚动升级需要更新应用程序的镜像或配置等内容，并将其逐步应用到集群中的Pod中，从而实现无缝的升级</p>
<p>以下是在Kubernetes中进行滚动升级的一般步骤：</p>
<ol>
<li>编写新的镜像或配置：需要先准备新的镜像或配置文件，这些内容将会被用于更新集群中的Pod</li>
<li>创建新的Deployment：可以使用kubectl命令或编写yaml文件来创建一个新的Deployment，其中指定新的镜像或配置文件。该Deployment将创建一个新的副本集（ReplicaSet），并将逐步替换旧的Pod</li>
<li>执行滚动升级：可以使用kubectl命令或编辑yaml文件来执行滚动升级。具体来说，需要将新的Deployment的副本数逐渐增加，同时将旧的Deployment的副本数逐渐减少。Kubernetes将自动在新旧Deployment之间进行流量切换，并确保每个Pod的生命周期在切换期间不受影响</li>
<li>检查升级结果：可以使用kubectl命令或Kubernetes Dashboard等工具来检查升级结果。需要确保新的Pod已经启动，并且应用程序的功能和性能没有受到影响</li>
</ol>
<p><strong>注意：</strong>滚动升级的速度可以根据实际情况进行调整。如果升级速度过快，可能会导致过多的资源消耗和应用程序的不可用。如果升级速度过慢，可能会导致应用程序的版本不一致和不必要的停机时间。可以使用kubectl命令或Kubernetes Dashboard等工具来监控升级过程，以确保升级速度的合适和应用程序的稳定性</p>
<h4 id="27-如何在K8S中进行水平扩展"><a href="#27-如何在K8S中进行水平扩展" class="headerlink" title="27. 如何在K8S中进行水平扩展"></a><font color=DarkOrange>27. 如何在K8S中进行水平扩展</font></h4><p>在Kubernetes中，可以通过水平扩展来增加应用程序的容量和性能，从而满足不断增长的业务需求。水平扩展是指增加应用程序的实例数，以平衡负载和提高容错能力</p>
<p>以下是在Kubernetes中进行水平扩展的一般步骤：</p>
<ol>
<li>编写Deployment或StatefulSet配置：需要在Deployment或StatefulSet的配置文件中指定应用程序的副本数。可以使用kubectl命令或编辑yaml文件来进行配置</li>
<li>执行水平扩展：可以使用kubectl命令或编辑yaml文件来执行水平扩展。具体来说，需要将Deployment或StatefulSet的副本数逐渐增加，从而增加应用程序的实例数。Kubernetes将自动将负载分配给不同的Pod，以平衡负载</li>
<li>监控扩展结果：可以使用kubectl命令或Kubernetes Dashboard等工具来监控扩展结果。需要确保新的Pod已经启动，并且应用程序的功能和性能没有受到影响</li>
</ol>
<p><strong>注意：</strong>水平扩展可能会导致过多的资源消耗和应用程序的不可用。可以使用Kubernetes的自动扩展功能来自动增加和减少应用程序的实例数，以满足变化的负载需求。可以使用kubectl命令或Kubernetes Dashboard等工具来监控自动扩展功能的状态和效果</p>
<h4 id="28-K8S中的Service是什么"><a href="#28-K8S中的Service是什么" class="headerlink" title="28. K8S中的Service是什么"></a><font color=DarkOrange>28. K8S中的Service是什么</font></h4><p>在Kubernetes中，Service是一种抽象概念，用于定义一组Pod的访问方式和网络策略。Service为一组Pod提供了一个稳定的IP地址和DNS名称，以便其他应用程序可以使用这些标识符来访问这组Pod</p>
<p>具体来说，Kubernetes中的Service可以将多个Pod组合成一个逻辑单元，并为这些Pod提供一个单独的入口点，从而隐藏了底层的复杂性和细节。通过定义Service，您可以轻松地让其他应用程序访问这些Pod，而无需了解这些Pod的具体细节和位置</p>
<p>Service还可以通过定义不同的负载均衡策略来平衡流量，以确保各个Pod之间的负载均衡。此外，Service还可以配置相关的网络策略，例如访问控制和安全策略，以确保您的应用程序网络安全</p>
<h4 id="29-如何在K8S中进行资源配额管理"><a href="#29-如何在K8S中进行资源配额管理" class="headerlink" title="29. 如何在K8S中进行资源配额管理"></a><font color=DarkOrange>29. 如何在K8S中进行资源配额管理</font></h4><p>使用资源配额（Resource Quotas）来限制每个命名空间（Namespace）中的资源使用量。资源配额可以限制 Pod、Deployment、ReplicaSet、Service 等资源的数量，还可以限制 CPU 和内存等资源的使用量</p>
<ol>
<li><p>创建一个命名空间（如果没有现成的命名空间）：<code>kubectl create namespace &lt;namespace-name&gt;</code></p>
</li>
<li><p>创建一个资源配额定义文件。示例如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ResourceQuota</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">quota-example</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">&lt;namespace-name&gt;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hard:</span></span><br><span class="line">    <span class="attr">pods:</span> <span class="string">&quot;10&quot;</span></span><br><span class="line">    <span class="attr">requests.cpu:</span> <span class="string">&quot;2&quot;</span></span><br><span class="line">    <span class="attr">requests.memory:</span> <span class="string">2Gi</span></span><br><span class="line">    <span class="attr">limits.cpu:</span> <span class="string">&quot;4&quot;</span></span><br><span class="line">    <span class="attr">limits.memory:</span> <span class="string">4Gi</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们定义了一个名为 <code>quota-example</code> 的资源配额，限制了该命名空间中的 Pod 数量为 10，requests.cpu 的总计算能力为 2 CPU，requests.memory 的总内存为 2GB，limits.cpu 的总计算能力为 4 CPU，limits.memory 的总内存为 4GB</p>
</li>
<li><p>应用资源配额：<code>kubectl apply -f &lt;filename.yaml&gt;</code></p>
</li>
<li><p>检查资源配额：<code>kubectl describe quota quota-example -n &lt;namespace-name&gt;</code></p>
</li>
</ol>
<p>如果命名空间中的任何资源超过了资源配额中定义的限制，那么 Kubernetes 会拒绝创建新资源，直到该命名空间中的某些资源被删除或限制得到了放宽</p>
<h4 id="30-如何在K8S中进行多集群管理"><a href="#30-如何在K8S中进行多集群管理" class="headerlink" title="30. 如何在K8S中进行多集群管理"></a><font color=DarkOrange>30. 如何在K8S中进行多集群管理</font></h4><ol>
<li>使用 Kubernetes 多集群管理工具：Kubernetes 多集群管理工具（例如 kubeadm，kubespray 或 Rancher）可以帮助您在多个 Kubernetes 集群之间进行资源管理。这些工具提供了一个控制面板，可以帮助您轻松地管理和监控多个 Kubernetes 集群</li>
<li>使用 Kubernetes API Server：Kubernetes API Server 允许您在不同的 Kubernetes 集群之间共享资源和管理多个集群。通过配置不同集群的 API Server，您可以轻松地将资源从一个集群复制到另一个集群</li>
<li>使用 Istio：Istio 是一个流量管理和安全控制平台，可以帮助您在多个 Kubernetes 集群之间进行服务发现和负载均衡。使用 Istio，您可以轻松地将服务从一个集群路由到另一个集群</li>
<li>使用 Kubernetes 的自定义资源定义（CRD）：使用 Kubernetes 的自定义资源定义，您可以定义和扩展 Kubernetes 中的资源类型。通过使用 CRD，您可以在多个 Kubernetes 集群之间共享自定义资源类型和资源</li>
<li>使用 Kubernetes 跨集群服务（Kubernetes Cross-Cluster Services，KCCS）：KCCS 是 Kubernetes 的一项实验性功能，可以将服务暴露给多个集群，从而实现跨集群服务发现和负载均衡</li>
</ol>
<h4 id="31-如何在K8S中使用ConfigMap"><a href="#31-如何在K8S中使用ConfigMap" class="headerlink" title="31. 如何在K8S中使用ConfigMap"></a><font color=DarkOrange>31. 如何在K8S中使用ConfigMap</font></h4><p>在 Kubernetes 中，ConfigMap 是一种存储配置信息的资源对象。ConfigMap 可以存储一些配置文件、命令行参数、环境变量等，然后将这些配置信息注入到容器中，使得容器可以获取到正确的配置信息</p>
<ol>
<li><p>创建一个 ConfigMap 对象，可以通过以下命令创建：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl create configmap my-config --from-file=config-file.yaml</span><br></pre></td></tr></table></figure>

<p>该命令会创建一个名为 <code>my-config</code> 的 ConfigMap 对象，并将 <code>config-file.yaml</code> 文件中的内容存储在该对象中</p>
</li>
<li><p>在 Pod 的 YAML 文件中添加 ConfigMap 的引用，例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">my-image</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_CONFIG</span></span><br><span class="line">      <span class="attr">valueFrom:</span></span><br><span class="line">        <span class="attr">configMapKeyRef:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">my-config</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">config-file.yaml</span></span><br></pre></td></tr></table></figure>

<p>在该 YAML 文件中，我们在容器的环境变量中定义了一个名为 <code>MY_CONFIG</code> 的变量，并且使用 <code>configMapKeyRef</code> 引用了 <code>my-config</code> 中的 <code>config-file.yaml</code> 文件中的内容</p>
</li>
<li><p>使用 <code>kubectl apply</code> 命令创建 Pod 对象</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl apply -f my-pod.yaml</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用 <code>kubectl get configmaps</code> 命令来查看 ConfigMap 对象的信息，例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl get configmaps</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>kubectl describe configmap</code> 命令来查看 ConfigMap 对象的详细信息，例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl describe configmap my-config</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>注意：</strong>如果 ConfigMap 中存储的配置信息发生了变化，需要重新创建 Pod 对象才能使新的配置信息生效</p>
<h4 id="32-如何在K8S中使用Secret"><a href="#32-如何在K8S中使用Secret" class="headerlink" title="32. 如何在K8S中使用Secret"></a><font color=DarkOrange>32. 如何在K8S中使用Secret</font></h4><p>在 Kubernetes 中，Secret 是一种用于存储敏感数据的资源对象，如密码、API 密钥等，Secret 可以保证敏感数据的安全性，不被泄露</p>
<ol>
<li><p>创建一个 Secret 对象，可以通过以下命令创建：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl create secret generic my-secret --from-literal=password=xxx</span><br></pre></td></tr></table></figure>

<p>该命令会创建一个名为 <code>my-secret</code> 的 Secret 对象，并将 <code>password</code> 值设置为 <code>xxx</code></p>
</li>
<li><p>在 Pod 的 YAML 文件中添加 Secret 的引用，例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">my-image</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_PASSWORD</span></span><br><span class="line">      <span class="attr">valueFrom:</span></span><br><span class="line">        <span class="attr">secretKeyRef:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">my-secret</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">password</span></span><br></pre></td></tr></table></figure>

<p>在该 YAML 文件中，我们在容器的环境变量中定义了一个名为 <code>MY_PASSWORD</code> 的变量，并且使用 <code>secretKeyRef</code> 引用了 <code>my-secret</code> 中的 <code>password</code> 值</p>
</li>
<li><p>使用 <code>kubectl apply</code> 命令创建 Pod 对象</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl apply -f my-pod.yaml</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用 <code>kubectl get secrets</code> 命令来查看 Secret 对象的信息，例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl get secrets</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>kubectl describe secret</code> 命令来查看 Secret 对象的详细信息，例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl describe secret my-secret</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>注意：</strong>Secret 对象的数据会以 base64 编码的形式存储在 etcd 中，因此需要确保敏感数据在存储和传输过程中的安全性</p>
<h4 id="33-如何在K8S中管理存储卷"><a href="#33-如何在K8S中管理存储卷" class="headerlink" title="33. 如何在K8S中管理存储卷"></a><font color=DarkOrange>33. 如何在K8S中管理存储卷</font></h4><ol>
<li>创建存储卷：您可以使用 Kubernetes 中的 PersistentVolume（PV）和 PersistentVolumeClaim（PVC）对象来创建存储卷。PV 是集群级别的资源，而 PVC 是应用程序级别的资源。您可以创建 PV，然后在应用程序中使用 PVC 来引用它</li>
<li>选择存储类型：Kubernetes 支持多种存储类型，包括本地存储、网络附加存储和云存储。您需要根据应用程序的要求选择适合的存储类型</li>
<li>配置存储卷访问模式：您可以为存储卷设置不同的访问模式，包括 ReadWriteOnce、ReadOnlyMany 和 ReadWriteMany。这些访问模式决定了存储卷可以被多少个容器同时访问以及它们可以读写的次数</li>
<li>部署 Pod 并挂载存储卷：您可以使用 Kubernetes 中的 Pod 对象来部署应用程序，并使用 volume 属性将存储卷挂载到容器中。您需要确保在部署应用程序之前，存储卷已经被创建并配置正确</li>
<li>监控和维护存储卷：一旦应用程序部署成功，您需要监控存储卷并确保它们正常运行。您可以使用 Kubernetes 的监控工具来监视存储卷，例如 Prometheus 和 Grafana</li>
</ol>
<h4 id="34-K8S中的控制器-Controller-是什么"><a href="#34-K8S中的控制器-Controller-是什么" class="headerlink" title="34. K8S中的控制器(Controller)是什么"></a><font color=DarkOrange>34. K8S中的控制器(Controller)是什么</font></h4><p>在 Kubernetes 中，Controller 是一种控制器模式，它用于管理和操作应用程序中的多个副本。Controller 负责确保在任何时候应用程序的副本数都符合定义的期望状态，同时可以自动修复应用程序中出现的故障</p>
<p>Controller 可以基于不同的策略来管理应用程序的副本，其中最常见的包括以下几种：</p>
<ol>
<li>ReplicationController：用于管理 Pod 的数量，确保在任何时候都有指定数量的 Pod 在运行</li>
<li>ReplicaSet：与 ReplicationController 类似，但它提供了更灵活的选择器机制，以便更好地匹配 Pod</li>
<li>Deployment：建立在 ReplicaSet 之上，提供了对应用程序的版本控制和回滚支持</li>
<li>StatefulSet：用于管理有状态应用程序的副本，例如数据库和缓存应用程序</li>
<li>DaemonSet：用于在每个节点上运行一个副本，例如网络代理和日志收集器</li>
<li>Job 和 CronJob：用于管理短期和定期任务，例如批处理作业和定时任务</li>
</ol>
<p>控制器通过监视 Kubernetes API 中的对象状态来工作，例如 Pod 和 ReplicaSet。它们会检查这些对象的状态并根据定义的策略执行必要的操作，例如创建、删除或替换对象。控制器还提供了一些高级功能，例如自动伸缩、滚动升级和故障转移</p>
<h4 id="35-如何进行K8S中的升级和回滚操作"><a href="#35-如何进行K8S中的升级和回滚操作" class="headerlink" title="35. 如何进行K8S中的升级和回滚操作"></a><font color=DarkOrange>35. 如何进行K8S中的升级和回滚操作</font></h4><p>在 Kubernetes 中进行应用程序升级和回滚操作是非常常见的任务。下面是一些常用的方法：</p>
<p><strong>升级：</strong></p>
<ol>
<li>创建新版本：首先，您需要为应用程序创建一个新版本，并将其部署到 Kubernetes 集群中。您可以使用 Kubernetes 中的 Deployment 对象来管理应用程序的版本，该对象可以自动管理副本集并提供回滚支持</li>
<li>部署新版本：一旦您创建了新版本，您可以使用 kubectl apply 命令将其部署到集群中。这将触发 Kubernetes 进行滚动更新，并将新版本逐步应用到所有副本中。在此过程中，您可以使用 kubectl rollout status 命令来监视更新的进度</li>
<li>验证新版本：一旦新版本已经部署成功，您需要验证它是否正常运行，并且没有引入新的问题或故障。您可以使用 Kubernetes 中的服务对象来公开新版本，并使用端口转发或负载均衡器将流量路由到新版本</li>
</ol>
<p><strong>回滚：</strong></p>
<ol>
<li>确定回滚版本：如果您需要回滚应用程序的版本，首先需要确定要回滚到哪个版本。您可以使用 kubectl rollout history 命令查看历史版本，并选择要回滚的版本</li>
<li>执行回滚：一旦您确定了回滚版本，您可以使用 kubectl rollout undo 命令来回滚应用程序。该命令将删除当前版本，并将所有副本回滚到先前的版本</li>
<li>验证回滚：一旦回滚完成，您需要验证应用程序是否已成功回滚，并且没有引入新的问题或故障。您可以使用 Kubernetes 中的服务对象来公开回滚版本，并使用端口转发或负载均衡器将流量路由到回滚版本</li>
</ol>
<p><strong>注意：</strong>Kubernetes 中的升级和回滚操作需要谨慎处理，需要确保新版本能够正常运行，并且在回滚时不会引入新的问题或故障。通过使用 Kubernetes 提供的 Deployment 对象和相关命令，您可以轻松地进行升级和回滚操作，并保持应用程序的可用性和稳定性</p>
<h4 id="36-如何在K8S中进行自动伸缩操作"><a href="#36-如何在K8S中进行自动伸缩操作" class="headerlink" title="36. 如何在K8S中进行自动伸缩操作"></a><font color=DarkOrange>36. 如何在K8S中进行自动伸缩操作</font></h4><ol>
<li>水平自动伸缩：在 Kubernetes 中，您可以使用 Horizontal Pod Autoscaler (HPA) 对象来自动伸缩应用程序的副本数。 HPA 监视与指定标签匹配的 Pod 集合，根据 CPU 使用率或自定义指标进行扩展或收缩 Pod 的数量</li>
<li>基于流量的自动伸缩：除了水平自动伸缩之外，Kubernetes 还提供了基于流量的自动伸缩，可以根据流量负载自动调整应用程序的副本数。您可以使用 Kubernetes 中的 Service 对象来实现基于流量的自动伸缩，将流量路由到多个 Pod 上，并使用 Kubernetes 中的负载均衡器来自动调整 Pod 的数量</li>
<li>垂直自动伸缩：除了水平自动伸缩之外，Kubernetes 还提供了垂直自动伸缩，可以根据应用程序的内存或其他资源使用情况自动调整容器的 CPU 和内存限制</li>
</ol>
<h4 id="37-如何在K8S中进行容器间的通信"><a href="#37-如何在K8S中进行容器间的通信" class="headerlink" title="37. 如何在K8S中进行容器间的通信"></a><font color=DarkOrange>37. 如何在K8S中进行容器间的通信</font></h4><ol>
<li>使用 Kubernetes 中的 Service：Kubernetes 中的 Service 是一种抽象，用于公开应用程序内部的一组 Pod，可以将流量路由到该组 Pod 中的任何一个。您可以将多个容器包含在同一个 Pod 中，并在 Kubernetes 中创建一个 Service 来公开这些容器，使它们能够通过 Service 名称和端口相互通信</li>
<li>使用 Kubernetes 中的 DNS：Kubernetes 中的 DNS 服务为集群中的容器提供了可靠的域名解析服务。您可以使用 DNS 来解析 Service 名称，以便容器可以相互通信</li>
<li>使用 Kubernetes 中的 Network Policy：Kubernetes 中的 Network Policy 可以定义网络规则，以允许或拒绝 Pod 之间的流量。通过定义 Network Policy，您可以控制容器之间的通信，并保护您的应用程序免受潜在的网络攻击</li>
<li>使用 Kubernetes 中的容器间通信插件：Kubernetes 中有许多容器间通信插件可供选择，如 Flannel、Calico 等。这些插件可以帮助容器在不同节点之间进行通信，并提供额外的网络功能，如网络隔离、负载均衡和安全性</li>
</ol>
<h4 id="38-什么是Liveness和Readiness探针"><a href="#38-什么是Liveness和Readiness探针" class="headerlink" title="38. 什么是Liveness和Readiness探针"></a><font color=DarkOrange>38. 什么是Liveness和Readiness探针</font></h4><p>Liveness 和 Readiness 探针是 Kubernetes 中的两种不同类型的探测机制，用于确保容器在运行期间保持健康，并且可以接收流量。它们的主要区别在于它们检查的方面和作用时间</p>
<ol>
<li>Liveness 探针：Liveness 探针用于检查容器是否仍在运行。如果 Liveness 探针探测到容器已停止工作，则 Kubernetes 会尝试重启该容器。例如，您可以配置 Liveness 探针来检查容器的关键进程或应用程序状态，以确保容器在运行期间保持健康</li>
<li>Readiness 探针：Readiness 探针用于检查容器是否准备好接收流量。如果一个容器没有就绪，Kubernetes 将不会将流量发送到该容器，直到它就绪为止。例如，您可以配置 Readiness 探针来检查容器是否已完成启动过程，并已成功地连接到所需的后端服务或数据库</li>
</ol>
<p>这两种探针都使用相同的机制：它们会定期向容器发送请求，并根据响应结果来确定容器的状态。如果容器返回成功的响应，探针将标记容器为就绪或活着，否则将标记为未就绪或死亡</p>
<h4 id="39-如何在K8S中实现容器的亲和性和反亲和性"><a href="#39-如何在K8S中实现容器的亲和性和反亲和性" class="headerlink" title="39. 如何在K8S中实现容器的亲和性和反亲和性"></a><font color=DarkOrange>39. 如何在K8S中实现容器的亲和性和反亲和性</font></h4><p>在 Kubernetes 中，亲和性（Affinity）和反亲和性（Anti-Affinity）是两种常用的机制，用于控制 Pod 和 Node 之间的互动。亲和性用于控制 Pod 如何选择一个节点进行调度，而反亲和性用于防止在同一节点上调度相似的 Pod。下面是一些实现容器亲和性和反亲和性的方法：</p>
<ol>
<li>使用亲和性和反亲和性规则：在 Kubernetes 中，您可以使用亲和性和反亲和性规则，以控制 Pod 如何选择一个节点进行调度。例如，您可以使用 nodeSelector，podAffinity 和 podAntiAffinity 等规则来控制 Pod 和节点之间的关系</li>
<li>使用 Kubernetes 调度器的拓扑感知特性：Kubernetes 调度器支持拓扑感知特性，该特性可以根据节点之间的拓扑关系进行 Pod 调度。您可以使用 topologyKey 和 topologySpreadConstraints 来控制 Pod 和节点之间的亲和性和反亲和性</li>
<li>使用 Kubernetes 的自定义调度器：Kubernetes 还支持自定义调度器，该调度器可以根据您的特定需求调度 Pod。通过自定义调度器，您可以更加灵活地控制 Pod 的调度，并实现容器亲和性和反亲和性</li>
</ol>
<p>在 Kubernetes 中实现容器的亲和性和反亲和性需要使用一些特定的工具和机制，例如亲和性和反亲和性规则、拓扑感知特性和自定义调度器。通过使用这些工具和机制，您可以更好地控制 Pod 和节点之间的互动，从而实现容器的高效调度和部署</p>
<h4 id="40-如何在K8S中进行日志管理"><a href="#40-如何在K8S中进行日志管理" class="headerlink" title="40. 如何在K8S中进行日志管理"></a><font color=DarkOrange>40. 如何在K8S中进行日志管理</font></h4><ol>
<li>使用 Kubernetes API 打印日志：Kubernetes API 提供了一个 &#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;{namespace}&#x2F;pods&#x2F;{podName}&#x2F;log API，通过该 API 可以打印容器的日志。您可以使用该 API 通过 kubectl 命令行工具或 API 访问端点来打印容器的日志</li>
<li>使用集中式日志记录工具：Kubernetes 中支持使用集中式日志记录工具，例如 Elasticsearch、Fluentd 和 Kibana（EFK）等。通过将这些工具部署到 Kubernetes 中，您可以将日志收集到一个中心位置，以便更容易地搜索和分析它们</li>
<li>使用容器日志驱动程序：Kubernetes 支持使用容器日志驱动程序，例如 json-file、syslog、journald 等。这些驱动程序可以配置容器日志的格式和位置。您可以使用 kubectl logs 命令行工具来访问容器日志</li>
<li>使用第三方日志管理工具：除了使用 Kubernetes 提供的日志管理功能外，您还可以使用第三方日志管理工具，例如 Logstash、Prometheus 和 Grafana 等。这些工具提供了更高级的日志管理和监控功能，可以帮助您更好地了解您的应用程序的运行状况</li>
</ol>
<hr>
<hr>
<h4 id="41-你对etcd的了解是什么"><a href="#41-你对etcd的了解是什么" class="headerlink" title="41. 你对etcd的了解是什么"></a><font color=DarkOrange>41. 你对etcd的了解是什么</font></h4><p>Etcd是一个分布式的键值存储系统，它被广泛应用于构建分布式系统和容器编排平台中。它使用Raft算法实现了高可用性，确保数据的一致性和可靠性</p>
<p>Etcd的主要功能是提供分布式的键值存储服务，可以用于存储配置数据、服务注册、服务发现等。它具有以下特点：</p>
<ol>
<li>分布式：Etcd使用Raft算法来保证分布式系统的可用性和数据一致性</li>
<li>高可用性：Etcd使用Raft算法来实现多节点之间的数据同步和决策，从而保证了系统的高可用性和数据的可靠性</li>
<li>快速：Etcd使用基于内存的存储引擎，可以提供高速的读写性能</li>
<li>安全：Etcd支持SSL&#x2F;TLS加密，可以保证数据的安全性</li>
<li>简单：Etcd提供了简单易用的API，可以快速地存储和检索键值对</li>
</ol>
<p><strong>总结：</strong>Etcd是一个可靠、高效、安全、简单的分布式键值存储系统，适用于构建大规模分布式系统和容器编排平台</p>
<h4 id="42-请讲解一下etcd的数据模型是什么样子的"><a href="#42-请讲解一下etcd的数据模型是什么样子的" class="headerlink" title="42. 请讲解一下etcd的数据模型是什么样子的"></a><font color=DarkOrange>42. 请讲解一下etcd的数据模型是什么样子的</font></h4><p>Etcd的数据模型可以被看作一个分层的键值存储系统，其中键和值都是字符串类型</p>
<p>在Etcd中，数据被组织成一个树形结构，每个节点都可以是一个键值对。一个节点可以拥有多个子节点，每个子节点都有一个唯一的名称（即键），而每个节点的值可以是一个字符串</p>
<p>Etcd中的每个键都必须唯一，并且可以包含任意数量的目录和子目录。因此，可以将Etcd看作一个类似于文件系统的结构</p>
<p>除了键值对之外，Etcd还支持将一个键下的所有子键作为一个目录或命名空间进行管理。这可以通过在键的末尾添加一个斜杠（&#x2F;）来实现，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/foo/      <span class="comment"># 表示一个名为 foo 的目录</span></span><br><span class="line">/foo/bar   <span class="comment"># 表示一个名为 bar 的键，它是 /foo/ 目录下的子键</span></span><br></pre></td></tr></table></figure>

<p>Etcd还支持事务操作，它可以将多个读写操作作为一个原子操作进行提交或回滚。这些操作可以是写入、更新、删除或者获取数据等</p>
<h4 id="43-在etcd集群中如何实现高可用性"><a href="#43-在etcd集群中如何实现高可用性" class="headerlink" title="43. 在etcd集群中如何实现高可用性"></a><font color=DarkOrange>43. 在etcd集群中如何实现高可用性</font></h4><p>Etcd使用Raft协议实现高可用性，该协议是一种分布式一致性算法，可以保证在节点出现故障时，集群仍然可以继续工作并保持数据的一致性</p>
<p>具体来说，Etcd将节点划分为三个角色：Leader、Follower和Candidate。Leader节点是负责处理客户端请求的节点，Follower节点是通过复制Leader的日志来保持与Leader同步的节点，Candidate节点是在选举过程中处于“投票状态”的节点</p>
<p>Etcd中的选举过程如下：</p>
<ol>
<li>每个节点都是一个Follower，一旦节点发现Leader失联，就会进入“选举状态”，发出一个选举请求</li>
<li>其他节点收到请求后，如果没有投过票，就会把票投给请求者，并将自己的状态设为Candidate</li>
<li>当一个Candidate获得多数投票时，就成为新的Leader，其他节点成为Follower并开始复制新Leader的日志</li>
<li>如果没有Candidate获得多数投票，则进行新一轮选举，直到某个节点成为Leader</li>
</ol>
<p>通过这样的选举过程，Etcd可以保证在出现节点故障的情况下，集群可以继续工作并保持数据的一致性。同时，Etcd还支持动态添加或删除节点，从而实现了集群的动态扩容和缩容</p>
<h4 id="44-etcd支持哪些数据存储后端？如何选择适合自己的存储后端"><a href="#44-etcd支持哪些数据存储后端？如何选择适合自己的存储后端" class="headerlink" title="44. etcd支持哪些数据存储后端？如何选择适合自己的存储后端"></a><font color=DarkOrange>44. etcd支持哪些数据存储后端？如何选择适合自己的存储后端</font></h4><p>Etcd支持多种数据存储后端，包括内存、磁盘和云存储等。其中，内存存储后端提供了最快的读写速度，但是在节点重启或者宕机时会导致数据的丢失；磁盘存储后端则可以持久化数据，但是读写速度相对较慢；云存储后端可以将数据存储在云平台的对象存储服务中，具有高可用性和可扩展性</p>
<p>在选择存储后端时，应该根据实际需求来选择适合自己的方案。如果需要高速读写和对数据可靠性要求不高，可以选择内存存储后端；如果对数据可靠性要求比较高，可以选择磁盘存储后端；如果需要高可用性和可扩展性，可以选择云存储后端</p>
<p>此外，还需要考虑存储后端的成本和复杂性。内存存储后端成本较低，但是数据丢失的风险较高，需要备份和恢复机制；磁盘存储后端成本适中，但是需要进行备份和数据清理，以防止数据堆积和损坏；云存储后端成本较高，但是具有高可用性和可扩展性，可以实现自动备份和恢复</p>
<p>综上所述，选择合适的存储后端需要根据实际需求来进行评估和比较</p>
<h4 id="45-如何通过etcd实现分布式锁"><a href="#45-如何通过etcd实现分布式锁" class="headerlink" title="45. 如何通过etcd实现分布式锁"></a><font color=DarkOrange>45. 如何通过etcd实现分布式锁</font></h4><ol>
<li>创建一个etcd客户端实例并连接到etcd服务器</li>
<li>使用etcd的事务API创建一个键，并将其值设置为唯一的标识符，例如UUID。这个键将用于表示锁定状态</li>
<li>使用etcd的事务API将此键设置为有租期（TTL）。租期是在etcd中维护的一段时间，在此期间键将保持活动状态。如果租期过期，etcd将自动删除该键。通过设置租期，您可以避免出现死锁的情况</li>
<li>如果设置键的操作成功，则表示客户端已获得锁。如果操作失败，则表示另一个客户端已经持有该锁。在这种情况下，客户端可以使用etcd的Watcher API等待另一个客户端释放锁</li>
<li>当客户端完成工作并释放锁时，使用etcd的事务API删除该键</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 导入etcd相关包</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;go.etcd.io/etcd/clientv3&quot;</span></span><br><span class="line">    <span class="string">&quot;go.etcd.io/etcd/clientv3/concurrency&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义etcd客户端</span></span><br><span class="line"><span class="keyword">var</span> etcdClient *clientv3.Client</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 初始化etcd客户端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initEtcd</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">    etcdClient, err = clientv3.New(clientv3.Config&#123;</span><br><span class="line">        Endpoints:   []<span class="type">string</span>&#123;<span class="string">&quot;localhost:2379&quot;</span>&#125;, <span class="comment">// etcd集群地址</span></span><br><span class="line">        DialTimeout: <span class="number">5</span> * time.Second,            <span class="comment">// 连接超时时间</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 获取etcd分布式锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getEtcdLock</span><span class="params">(key <span class="type">string</span>)</span></span> (*concurrency.Mutex, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建etcd分布式锁</span></span><br><span class="line">    session, err := concurrency.NewSession(etcdClient)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> concurrency.NewMutex(session, key), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 使用etcd分布式锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">useEtcdLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取etcd分布式锁</span></span><br><span class="line">    lock, err := getEtcdLock(<span class="string">&quot;my-lock&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    err = lock.Lock(context.Background())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="keyword">defer</span> lock.Unlock(context.Background())</span><br><span class="line">    <span class="comment">// 执行业务逻辑</span></span><br><span class="line">    log.Println(<span class="string">&quot;do something with etcd lock&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化etcd客户端</span></span><br><span class="line">    initEtcd()</span><br><span class="line">    <span class="comment">// 使用etcd分布式锁</span></span><br><span class="line">    useEtcdLock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="46-请讲解一下etcd的watch机制是如何实现的"><a href="#46-请讲解一下etcd的watch机制是如何实现的" class="headerlink" title="46. 请讲解一下etcd的watch机制是如何实现的"></a><font color=DarkOrange>46. 请讲解一下etcd的watch机制是如何实现的</font></h4><p>Etcd的watch机制是一种客户端订阅数据更改的方式，可以让客户端在发生变化时及时收到通知，从而避免了客户端频繁轮询的开销。实现watch机制的核心是利用etcd的watch接口</p>
<p>Etcd的watch机制包括以下几个步骤：</p>
<ol>
<li>客户端通过etcd API向etcd服务器注册一个watcher对象，并指定需要监听的键值</li>
<li>当etcd服务器上被监听的键值发生变化时，etcd会将变化通知给所有对应的watcher对象</li>
<li>watcher对象在收到通知后，将变化的内容返回给客户端</li>
<li>客户端收到变化的内容后，可以根据需要进行相应的处理</li>
</ol>
<p>在实现watch机制时，etcd利用了其内部的事件循环机制。当客户端注册watcher对象时，etcd会将其加入到内部的事件循环队列中。当etcd服务器上的数据发生变化时，etcd会将变化事件加入到事件循环队列中，然后依次处理队列中的事件，并将变化通知给相应的watcher对象</p>
<p><strong>注意：</strong>etcd的watch机制并不是完全实时的，因为etcd需要处理多个客户端的watch请求，因此存在一定的延迟。同时，etcd还会使用心跳机制来保证watcher对象的健康状态，如果watcher对象出现故障，etcd会将其从事件循环队列中移除，避免对etcd服务器的性能造成影响</p>
<h4 id="47-如何通过etcd实现配置中心"><a href="#47-如何通过etcd实现配置中心" class="headerlink" title="47. 如何通过etcd实现配置中心"></a><font color=DarkOrange>47. 如何通过etcd实现配置中心</font></h4><ol>
<li>使用etcd的watch机制 etcd提供了watch机制，可以监控etcd中某个key的变化。可以将配置信息存储在etcd中的某个key下，然后通过watch机制来监控该key的变化</li>
<li>使用etcd的租约机制 etcd提供了租约机制，可以为某个key设置一个过期时间。可以将配置信息存储在etcd中的某个key下，并为该key设置一个较短的过期时间，然后在应用程序中定时从etcd中读取该key的值</li>
<li>使用etcd的分布式锁机制 etcd提供了分布式锁机制，可以保证在分布式环境下的互斥访问。可以将配置信息存储在etcd中的某个key下，并使用etcd的分布式锁机制来保证在多个应用程序同时访问该key时的互斥性</li>
<li>使用etcd的事务机制 etcd提供了事务机制，可以保证多个操作的原子性。可以将配置信息存储在etcd中的多个key下，并使用etcd的事务机制来保证多个操作的原子性</li>
<li>使用etcd的目录机制 etcd提供了目录机制，可以将多个key组织成一个目录。可以将配置信息存储在etcd中的某个目录下，并使用etcd的目录机制来组织这些key</li>
</ol>
<h4 id="48-etcd在网络分区情况下会发生什么"><a href="#48-etcd在网络分区情况下会发生什么" class="headerlink" title="48. etcd在网络分区情况下会发生什么"></a><font color=DarkOrange>48. etcd在网络分区情况下会发生什么</font></h4><p>在网络分区情况下，即网络被切割成两个或多个部分时，etcd 集群可能会发生以下情况：</p>
<ol>
<li><p>分裂脑</p>
<p>如果网络分区不被处理，etcd 集群中可能会出现“分裂脑”现象，即两个或多个集群成为相互独立的子集群，各自进行操作，可能导致数据不一致、冲突等问题。</p>
</li>
<li><p>选举失败</p>
<p>etcd 使用 Raft 算法进行主节点选举。在网络分区情况下，如果多个节点同时发起选举，可能会导致选举失败，无法确定主节点，从而导致 etcd 集群无法正常工作</p>
</li>
<li><p>数据不一致</p>
<p>如果网络分区期间 etcd 集群中的某些节点更新了数据，而其他节点无法获取到最新数据，则可能导致数据不一致问题</p>
</li>
</ol>
<p>为了解决以上问题，可以采取以下措施：</p>
<ol>
<li>使用 etcd 集群自带的分区处理机制，比如“Split-Brain Prevention”（SBP）和“Majority-Based Partition Tolerance”（MBPT），来避免“分裂脑”问题</li>
<li>在网络分区情况下，禁止数据的写入操作，只允许读取操作，以避免数据不一致问题</li>
<li>当网络分区恢复后，etcd 集群需要进行数据同步和节点选举等操作，以确保集群正常工作</li>
</ol>
<h4 id="49-如何在K8S中使用etcd"><a href="#49-如何在K8S中使用etcd" class="headerlink" title="49. 如何在K8S中使用etcd"></a><font color=DarkOrange>49. 如何在K8S中使用etcd</font></h4><ol>
<li>使用etcd作为Kubernetes的后端存储 Kubernetes使用etcd作为其后端存储，存储了Kubernetes集群的所有状态信息。在Kubernetes集群中，每个节点都运行一个etcd实例，这些etcd实例组成了一个etcd集群，用于存储Kubernetes集群的状态信息</li>
<li>使用etcd作为Kubernetes的配置中心 Kubernetes中的许多组件都需要配置信息，可以使用etcd作为Kubernetes的配置中心，将配置信息存储在etcd中，并通过etcd的watch机制来监控配置信息的变化，从而实现动态配置</li>
<li>使用etcd作为Kubernetes的服务发现 Kubernetes中的服务发现功能可以使用etcd来实现。可以将服务的地址信息存储在etcd中，并使用etcd的watch机制来监控服务地址信息的变化，从而实现动态服务发现</li>
<li>使用etcd作为Kubernetes的分布式锁 Kubernetes中的许多组件需要在分布式环境下保证互斥访问，可以使用etcd的分布式锁机制来实现分布式锁。可以将锁信息存储在etcd中，并使用etcd的分布式锁机制来保证在多个组件同时访问锁时的互斥性</li>
<li>使用etcd作为Kubernetes的租约机制 Kubernetes中的许多组件需要在一定时间内完成某个任务，可以使用etcd的租约机制来实现任务的超时控制。可以将任务信息存储在etcd中，并为该任务设置一个较短的过期时间，然后在组件中定时从etcd中读取该任务的状态，从而实现任务的超时控制</li>
</ol>
<h4 id="50-如何保证etcd集群的安全性"><a href="#50-如何保证etcd集群的安全性" class="headerlink" title="50. 如何保证etcd集群的安全性"></a><font color=DarkOrange>50. 如何保证etcd集群的安全性</font></h4><ol>
<li>使用TLS加密etcd通信 在etcd集群中，所有节点之间的通信都是通过网络进行的，因此需要使用TLS来加密etcd通信。可以通过在etcd配置文件中设置TLS证书和密钥来实现TLS加密。具体可以参考etcd官方文档中的相关内容</li>
<li>使用客户端证书认证 为了保证etcd集群的安全性，可以使用客户端证书认证来限制etcd集群的访问。可以通过在etcd配置文件中设置客户端证书和密钥来实现客户端证书认证。具体可以参考etcd官方文档中的相关内容</li>
<li>使用访问控制列表（ACL） etcd支持使用访问控制列表（ACL）来限制etcd集群的访问。可以通过在etcd配置文件中设置ACL规则来实现ACL。具体可以参考etcd官方文档中的相关内容</li>
<li>使用网络隔离 为了保证etcd集群的安全性，可以使用网络隔离来限制etcd集群的访问。可以通过在etcd集群所在的网络中设置网络隔离规则来实现网络隔离。具体可以参考网络隔离相关的文档</li>
<li>定期备份etcd数据 为了保证etcd集群的安全性，需要定期备份etcd数据。可以使用etcdctl命令行工具来备份etcd数据。具体可以参考etcd官方文档中的相关内容</li>
</ol>
<hr>
<p>阿里云开发者社区docker、k8s面试总结链接：<a href="https://developer.aliyun.com/article/873550">点击跳转</a></p>
<hr>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>云原生</tag>
      </tags>
  </entry>
  <entry>
    <title>Go-面试题</title>
    <url>/2022/10/28/Golang%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>Go常见面试题分享，涵盖了常见的Go面试八股文</p>
<h4 id="Go语言特点"><a href="#Go语言特点" class="headerlink" title="Go语言特点"></a><font color=DarkOrange>Go语言特点</font></h4><p>Go语言是一种开源的编程语言，由Google开发，主要用于编写高效、可维护的系统软件。以下是Go语言的一些特性：</p>
<ol>
<li>并发编程：Go语言天生支持并发编程，内置goroutine（协程）和channel（通道）机制，简化了并发编程的实现</li>
<li>内存管理：Go语言自带的垃圾回收机制可以自动管理内存，减少了程序员的负担，提高了代码的健壮性和可靠性</li>
<li>语法简洁：Go语言的语法简洁明了，支持面向对象和函数式编程风格，使得代码易读易写</li>
<li>高效编译：Go语言编译速度快，可生成可执行文件，可以在不同的平台上轻松地交叉编译</li>
<li>强类型语言：Go语言是一种强类型语言，可以在编译时检查类型错误，避免了一些常见的程序错误</li>
<li>标准库丰富：Go语言的标准库提供了丰富的API，包括网络编程、文件操作、加密、并发等方面，使得开发者可以更快地实现功能。</li>
<li>可靠性：Go语言的设计注重可靠性和健壮性，可以有效地避免空指针和数组越界等常见的编程错误</li>
</ol>
<p>总的来说，Go语言具有简洁、高效、并发、可靠等特性，适合用于编写高性能的服务器端、分布式系统和网络应用等</p>
<h4 id="1-无缓冲Chan的发送和接收是否同步"><a href="#1-无缓冲Chan的发送和接收是否同步" class="headerlink" title="1. 无缓冲Chan的发送和接收是否同步"></a><font color=DarkOrange>1. 无缓冲Chan的发送和接收是否同步</font></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ch := make(chan int)    无缓冲的channel由于没有缓冲发送和接收需要同步</span><br><span class="line">ch := make(chan int, 2) 有缓冲channel不要求发送和接收操作同步</span><br></pre></td></tr></table></figure>

<ul>
<li>channel无缓冲时，发送阻塞直到数据被接收，接收阻塞直到读到数据</li>
<li>channel有缓冲时，当缓冲满时发送阻塞，当缓冲空时接收阻塞</li>
</ul>
<h4 id="2-什么是channel，为什么它可以做到线程安全"><a href="#2-什么是channel，为什么它可以做到线程安全" class="headerlink" title="2. 什么是channel，为什么它可以做到线程安全"></a><font color=DarkOrange>2. 什么是channel，为什么它可以做到线程安全</font></h4><ul>
<li>Channel是Go中的一个核心类型，可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication)，Channel也可以理解是一个先进先出的队列，通过管道进行通信</li>
<li>Golang的Channel，发送一个数据到Channel和从Channel接收一个数据都是原子性的</li>
<li>Go的设计思想就是，不要通过共享内存来通信，而是通过通信来共享内存，前者就是传统的加锁，后者就是Channel</li>
<li>设计Channel的主要目的就是在多任务间传递数据的，本身就是安全的</li>
</ul>
<h4 id="3-Goroutine和Channel的作用分别是什么"><a href="#3-Goroutine和Channel的作用分别是什么" class="headerlink" title="3. Goroutine和Channel的作用分别是什么"></a><font color=DarkOrange>3. Goroutine和Channel的作用分别是什么</font></h4><p>进程是内存资源管理和cpu调度的执行单元。为了有效利用多核处理器的优势，将进程进一步细分，允许一个进程里存在多个线程，这多个线程还是共享同一片内存空间，但cpu调度的最小单元变成了线程</p>
<p>协程，可以看作是轻量级的线程。但与线程不同的是，线程的切换是由操作系统控制的，而协程的切换则是由用户控制的</p>
<p>Go中的goroutinue就是协程，可以实现并行，多个协程可以在多个处理器同时跑。而协程同一时刻只能在一个处理器上跑（可以把宿主语言想象成单线程的就好了）</p>
<p>多个goroutine之间的通信是通过channel，在Golang中channel则是goroutinues之间进行通信的渠道。可以把channel形象比喻为工厂里的传送带，一头的生产者goroutine往传输带放东西，另一头的消费者goroutinue则从输送带取东西。channel实际上是一个有类型的消息队列，遵循先进先出的特点</p>
<h4 id="4-Channel是同步的还是异步的"><a href="#4-Channel是同步的还是异步的" class="headerlink" title="4. Channel是同步的还是异步的"></a><font color=DarkOrange>4. Channel是同步的还是异步的</font></h4><p>Channel是异步进行的，channel存在3种状态：</p>
<ul>
<li>nil，未初始化的状态，只进行了声明，或者手动赋值为nil</li>
<li>active，正常的channel，可读或者可写</li>
<li>closed，已关闭，千万不要误认为关闭channel后，channel的值是nil</li>
</ul>
<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">一个零值nil通道</th>
<th align="left">一个非零值但已关闭的通道</th>
<th align="left">一个非零值且尚未关闭的通道</th>
</tr>
</thead>
<tbody><tr>
<td align="left">关闭</td>
<td align="left">产生恐慌</td>
<td align="left">产生恐慌</td>
<td align="left">成功关闭</td>
</tr>
<tr>
<td align="left">发送数据</td>
<td align="left">永久阻塞</td>
<td align="left">产生恐慌</td>
<td align="left">阻塞或者成功发送</td>
</tr>
<tr>
<td align="left">接收数据</td>
<td align="left">永久阻塞</td>
<td align="left">永不阻塞</td>
<td align="left">阻塞或者成功接收</td>
</tr>
</tbody></table>
<h4 id="5-Go中的channel的实现"><a href="#5-Go中的channel的实现" class="headerlink" title="5. Go中的channel的实现"></a><font color=DarkOrange>5. Go中的channel的实现</font></h4><p>在Go中最常见的就是通信顺序进程（Communicating sequential processes，CSP）的并发模型，通过共享通信，来实现共享内存，这里就提到了channel。Goroutine 和 Channel 分别对应 CSP 中的实体和传递信息的媒介，Go 语言中的 Goroutine 会通过 Channel 传递数据</p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7no7xmdcgj313c0b0jtt.jpg" alt="image.png" style="zoom:25%;" /></div>

<p>Goroutine通过使用channel传递数据，一个会向 Channel 中发送数据，另一个会从 Channel 中接收数据，它们两者能够独立运行并不存在直接关联，但是能通过 Channel 间接完成通信</p>
<p>Channel 收发操作均遵循了先入先出（FIFO）的设计，具体规则如下：</p>
<ul>
<li>先从 Channel 读取数据的 Goroutine 会先接收到数据</li>
<li>先向 Channel 发送数据的 Goroutine 会得到先发送数据的权利</li>
</ul>
<p>Channel 通常会有以下三种类型：</p>
<ul>
<li>同步 Channel — 不需要缓冲区，发送方会直接将数据交给（Handoff）接收方</li>
<li>异步 Channel：基于环形缓存的传统生产者消费者模型</li>
<li><code>chan struct&#123;&#125;</code> 类型的异步 <code>Channel</code> 的 <code>struct&#123;&#125;</code> 类型不占用内存空间，不需要实现缓冲区和直接发送（Handoff）的语义</li>
</ul>
<p>Channel 在运行时使用 <code>runtime.hchan</code> 结构体表示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="type">uint</span>           <span class="comment">// 当前队列里还剩余元素个数</span></span><br><span class="line">    dataqsiz <span class="type">uint</span>           <span class="comment">// 环形队列长度，即缓冲区的大小，即make(chan T,N) 中的N</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// 环形队列指针</span></span><br><span class="line">    elemsize <span class="type">uint16</span>         <span class="comment">// 每个元素的大小</span></span><br><span class="line">    closed   <span class="type">uint32</span>         <span class="comment">// 标识当前通道是否处于关闭状态，创建通道后，该字段设置0，即打开通道；通道调用close将其设置为1，通道关闭</span></span><br><span class="line">    elemtype *_type         <span class="comment">// 元素类型，用于数据传递过程中的赋值</span></span><br><span class="line">    sendx    <span class="type">uint</span>           <span class="comment">// 环形缓冲区的状态字段，它只是缓冲区的当前索引-支持数组，它可以从中发送数据</span></span><br><span class="line">    recvx    <span class="type">uint</span>          <span class="comment">// 环形缓冲区的状态字段，它只是缓冲区当前索引-支持数组，它可以从中接受数据</span></span><br><span class="line">    recvq    waitq         <span class="comment">// 等待读消息的goroutine队列</span></span><br><span class="line">    sendq    waitq         <span class="comment">// 等待写消息的goroutine队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">    <span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line">    <span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">    <span class="comment">// with stack shrinking.</span></span><br><span class="line">    lock mutex           <span class="comment">// 互斥锁，为每个读写操作锁定通道，因为发送和接受必须是互斥操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">    first *sudog</span><br><span class="line">    last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中hchan结构体中有五个字段是构建底层的循环队列：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">qcount：Channel中的元素个数</span><br><span class="line">dataqsiz：Channel中的循环队列的长度</span><br><span class="line">buf：Channel的缓冲区数据指针</span><br><span class="line">sendx：Channel的发送操作处理到的位置</span><br><span class="line">recvx：Channel的接收操作处理到的位置</span><br></pre></td></tr></table></figure>

<h4 id="6-Golang并发机制以及它所使用的CSP并发模型"><a href="#6-Golang并发机制以及它所使用的CSP并发模型" class="headerlink" title="6. Golang并发机制以及它所使用的CSP并发模型"></a><font color=DarkOrange>6. Golang并发机制以及它所使用的CSP并发模型</font></h4><p>在计算机科学中，通信顺序过程（communicating sequential processes，CSP）是一种描述并发系统中交互模式的正式语言，它是并发数学理论家族中的一个成员，被称为过程算法（process algebras），或者说过程计算（process calculate），是基于消息的通道传递的数学理论</p>
<p>Golang中的Goroutine的特性：</p>
<p>Golang内部有三个对象： P对象(processor) 代表上下文（或者可以认为是cpu），M(work thread)代表工作线程，G对象（goroutine）</p>
<p>正常情况下一个cpu对象启一个工作线程对象，线程去检查并执行goroutine对象。碰到goroutine对象阻塞的时候，会启动一个新的工作线程，以充分利用cpu资源。所以有时候线程对象会比处理器对象多很多</p>
<ul>
<li>G（Goroutine） ：我们所说的协程，为用户级的轻量级线程，每个Goroutine对象中的sched保存着其上下文信息</li>
<li>M（Machine） ：对Os内核级线程的封装，数量对应真实的CPU数（真正干活的对象）</li>
<li>P（Processor） ：逻辑处理器，即为G和M的调度对象，用来调度G和M之间的关联关系，其数量可通过GOMAXPROCS()来设置，默认为核心数</li>
</ul>
<p>在单核情况下，所有Goroutine运行在同一个线程（M0）中，每一个线程维护一个上下文（P），任何时刻，一个上下文中只有一个Goroutine，其他Goroutine在runqueue中等待。一个Goroutine运行完自己的时间片后，让出上下文，自己回到runqueue中（如下图所示）</p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7nojprq3uj30ns0kgdi9.jpg" alt="image.png" style="zoom:38%;" /></div>

<p>当正在运行的G0阻塞的时候（可以需要IO），会再创建一个线程（M1），P转到新的线程中去运行</p>
<p>当M0返回时，它会尝试从其他线程中“偷”一个上下文过来，如果没有偷到，会把Goroutine放到Global runqueue中去，然后把自己放入线程缓存中。上下文会定时检查Global runqueue</p>
<p>Golang的CSP并发模型，是通过Goroutine和Channel来实现的</p>
<p>因此，GPM的简要概括即为：事件循环，线程池，工作队列</p>
<h4 id="7-Go的GPM如何调度"><a href="#7-Go的GPM如何调度" class="headerlink" title="7. Go的GPM如何调度"></a><font color=DarkOrange>7. Go的GPM如何调度</font></h4><p>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此，协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置</p>
<p>线程和进程的操作是由程序触发系统接口，最后的执行者是系统；协程的操作执行者则是用户自身程序，goroutine也是协程</p>
<p>groutine能拥有强大的并发实现是通过GPM调度模型实现</p>
<p>Go的调度器内部有四个重要的结构：M，G，P，Sched：</p>
<ul>
<li>M：M代表内核级线程，一个M就是一个线程，goroutine就是跑在M之上的；M是一个很大的结构，里面维护小对象内存cache（mcache）、当前执行的goroutine、随机数发生器等等非常多的信息</li>
<li>G：代表一个goroutine，它有自己的栈，instruction pointer和其他信息（正在等待的channel等等），用于调度</li>
<li>P：P全称是Processor，逻辑处理器，它的主要用途就是用来执行goroutine的，所以它也维护了一个goroutine队列，里面存储了所有需要它来执行的goroutine</li>
<li>Sched：代表调度器，它维护有存储M和G的队列以及调度器的一些状态信息等</li>
</ul>
<hr>
<ol>
<li>新创建的Goroutine会先存放在Global全局队列中，等待Go调度器进行调度，随后Goroutine被分配给其中的一个逻辑处理器P，并放到这个逻辑处理器对应的Local本地运行队列中，最终等待被逻辑处理器P执行即可</li>
<li>在M与P绑定后，M会不断从P的Local队列中无锁地取出G，并切换到G的堆栈执行，当P的Local队列中没有G时，再从Global队列中获取一个G，当Global队列中也没有待运行的G时，则尝试从其它的P窃取部分G来执行相当于P之间的负载均衡</li>
<li>每一个M都拥有一个处理器P，每一个也都有一个正在运行的goroutine。P的数量可以通过GOMAXPROCS()来设置，它其实也就代表了真正的并发度，即有多少个goroutine可以同时运行</li>
<li>对于没有运行的goroutine，而是出于ready的就绪态，正在等待被调度。P维护着这个队列（称之为runqueue），Go语言里，启动一个goroutine很容易：go function 就行，所以每有一个go语句被执行，runqueue队列就在其末尾加入一个goroutine，在下一个调度点，就从runqueue中取出（如何决定取哪个goroutine？）一个goroutine执行</li>
<li>当一个OS线程M0陷入阻塞时，P转而在运行M1，图中的M1可能是正被创建，或者从线程缓存中取出</li>
<li>当MO返回时，它必须尝试取得一个P来运行goroutine，一般情况下，它会从其他的OS线程那里拿一个P过来，如果没有拿到的话，它就把goroutine放在一个<code>global runqueue</code>里，然后自己睡眠（放入线程缓存里）。所有的P也会周期性的检查<code>global runqueue</code>并运行其中的goroutine，否则<code>global runqueue</code>上的goroutine永远无法执行</li>
<li>另一种情况是P所分配的任务G很快就执行完了（分配不均），这就导致了这个处理器P处于空闲的状态，但是此时其他的P还有任务，此时如果global runqueue没有任务G了，那么这个P就会从其他的P里偷取一些G来执行。通常来说，如果P从其他的P那里要拿任务的话，一般就拿<code>run queue</code>的一半，这就确保了每个OS线程都能充分的使用</li>
</ol>
<h4 id="8-Golang中常用的并发模型"><a href="#8-Golang中常用的并发模型" class="headerlink" title="8. Golang中常用的并发模型"></a><font color=DarkOrange>8. Golang中常用的并发模型</font></h4><p>Golang中常用的并发模型有三种:</p>
<ul>
<li>通过channel通知实现并发控制</li>
<li>通过sync包中的WaitGroup实现并发控制</li>
<li>在Go1.7以后引进的强大的Context上下文，实现并发控制</li>
</ul>
<ol>
<li><p>通过channel通知实现并发控制</p>
<p>无缓冲的通道指的是通道的大小为0，也就是说，这种类型的通道在接收前没有能力保存任何值，它要求发送 goroutine 和接收 goroutine 同时准备好，才可以完成发送和接收操作</p>
<p>发送 goroutine 和接收 gouroutine 必须是同步的，同时准备后，如果没有同时准备好的话，先执行的操作就会阻塞等待，直到另一个相对应的操作准备好为止</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;start working&quot;</span>)</span><br><span class="line">        time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">        ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;-ch</span><br><span class="line">    fmt.Println(<span class="string">&quot;finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当主 goroutine 运行到 <code>&lt;-ch</code> 接受 channel 的值的时候，如果该 channel 中没有数据，就会一直阻塞等待，直到有值。 这样就可以简单实现并发控制</p>
<hr>
</li>
<li><p>通过sync包中的WaitGroup实现并发控制</p>
<p>Goroutine是异步执行的，有的时候为了防止在结束main函数的时候结束掉Goroutine，所以需要同步等待，这个时候就需要用 WaitGroup了，在sync包中，提供了WaitGroup，它会等待它收集的所有Goroutine任务全部完成。在WaitGroup里主要有三个方法:</p>
<ul>
<li>Add，可以添加或减少Goroutine的数量</li>
<li>Done，相当于Add(-1)</li>
<li>Wait，执行后会堵塞主线程，直到WaitGroup里的值减至0</li>
</ul>
<p>在主 goroutine 中 Add(delta int) 索要等待goroutine 的数量。在每一个 goroutine 完成后 Done() 表示这一个goroutine 已经完成，当所有的 goroutine 都完成后，在主 goroutine 中 WaitGroup 返回</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">var</span> urls = []<span class="type">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;http://www.golang.org/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://www.google.com/&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            http.Get(url)</span><br><span class="line">        &#125;(url)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Golang官网中对于WaitGroup介绍是<code>A WaitGroup must not be copied after first use</code>,在 WaitGroup第一次使用后，不能被拷贝</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(wg sync.WaitGroup, i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;i:%d&quot;</span>, i)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(wg, i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;exit&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之后会报错：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">i:1i:3i:2i:0i:4fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine 1 [semacquire]:</span><br><span class="line">sync.runtime_Semacquire(0xc000094018)</span><br><span class="line">        /home/keke/soft/go/src/runtime/sema.go:56 +0x39</span><br><span class="line"><span class="built_in">sync</span>.(*WaitGroup).Wait(0xc000094010)</span><br><span class="line">        /home/keke/soft/go/src/sync/waitgroup.go:130 +0x64</span><br><span class="line">main.main()</span><br><span class="line">        /home/keke/go/Test/wait.go:17 +0xab</span><br><span class="line"><span class="built_in">exit</span> status 2</span><br></pre></td></tr></table></figure>

<p>它提示所有的 <code>goroutine</code> 都已经睡眠了，出现了死锁。这是因为wg给拷贝传递到了goroutine中，导致只有Add操作，其实Done操作是在wg的副本执行的，因此 Wait 就会死锁</p>
<ul>
<li><p>这个第一个修改方式：将匿名函数中wg的传入类型改为 <code>*sync.WaitGroup，</code>这样就能引用到正确的<code>WaitGroup</code>了</p>
</li>
<li><p>这个第二个修改方式：将匿名函数中的wg的传入参数去掉，因为Go支持闭包类型，在匿名函数中可以直接使用外面的wg变量</p>
</li>
</ul>
<hr>
</li>
<li><p>Context上下文实现并发控制</p>
<p>通常，在一些简单场景下使用channel和WaitGroup已经足够了，但是当面临一些复杂多变的网络并发场景下channel和WaitGroup显得有些力不从心了，比如一个网络请求Request，每个Request都需要开启一个goroutine做一些事情，这些goroutine又可能会开启其他的goroutine，比如数据库和RPC服务</p>
<p>所以我们需要一种可以跟踪goroutine的方案，才可以达到控制他们的目的，这就是Go语言为我们提供的Context，称之为上下文非常贴切，它就是goroutine的上下文，它是包括一个程序的运行环境、现场和快照等。每个程序要运行时，都需要知道当前程序的运行状态，通常Go将这些封装在一个 Context里，再将它传给要执行的goroutine ，context包主要是用来处理多个goroutine之间共享数据，及多个goroutine的管理</p>
<p>context包的核心是struct Context，接口声明如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Context carries a deadline, cancelation signal, and request-scoped values</span></span><br><span class="line"><span class="comment">// across API boundaries. Its methods are safe for simultaneous use by multiple</span></span><br><span class="line"><span class="comment">// goroutines.</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Done returns a channel that is closed when this `Context` is canceled</span></span><br><span class="line">    <span class="comment">// or times out.</span></span><br><span class="line">    <span class="comment">// Done() 返回一个只能接受数据的channel类型，当该context关闭或者超时时间到了的时候，该channel就会有一个取消信号</span></span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Err indicates why this Context was canceled, after the Done channel</span></span><br><span class="line">    <span class="comment">// is closed.</span></span><br><span class="line">    <span class="comment">// Err() 在Done() 之后，返回context 取消的原因。</span></span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deadline returns the time when this Context will be canceled, if any.</span></span><br><span class="line">    <span class="comment">// Deadline() 设置该context cancel的时间点</span></span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Value returns the value associated with key or nil if none.</span></span><br><span class="line">    <span class="comment">// Value() 方法允许 Context 对象携带request作用域的数据，该数据必须是线程安全的。</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Context对象是线程安全的，你可以把一个Context对象传递给任意个数的gorotuine，对它执行 取消 操作时，所有goroutine都会接收到取消信号。一个Context不能拥有Cancel方法，同时我们也只能Done channel接收数据。其中的原因是一致的：接收取消信号的函数和发送信号的函数通常不是一个。典型的场景是：父操作为子操作操作启动goroutine，子操作也就不能取消父操作</p>
</li>
</ol>
<h4 id="9-并发编程概念是什么"><a href="#9-并发编程概念是什么" class="headerlink" title="9. 并发编程概念是什么"></a><font color=DarkOrange>9. 并发编程概念是什么</font></h4><ul>
<li>并行是指两个或者多个事件在同一时刻发生；并发是指两个或多个事件在同一时间间隔发生</li>
<li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群</li>
<li>并发偏重于多个任务交替执行，而多个任务之间有可能还是串行的。而并行是真正意义上的“同时执行”</li>
<li>并发编程是指在一台处理器上“同时”处理多个任务。并发是在同一实体上的多个事件。多个事件在同一时间间隔发生。并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能</li>
</ul>
<h4 id="10-怎么查看Goroutine的数量"><a href="#10-怎么查看Goroutine的数量" class="headerlink" title="10. 怎么查看Goroutine的数量"></a><font color=DarkOrange>10. 怎么查看Goroutine的数量</font></h4><p>在Golang中，<code>GOMAXPROCS</code>中控制的是未被阻塞的所有Goroutine，可以被 <code>Multiplex</code> 到多少个线程上运行，通过<code>GOMAXPROCS</code>可以查看Goroutine的数量</p>
<h4 id="11-怎么限制Goroutine的数量"><a href="#11-怎么限制Goroutine的数量" class="headerlink" title="11. 怎么限制Goroutine的数量"></a><font color=DarkOrange>11. 怎么限制Goroutine的数量</font></h4><p>在Golang中，Goroutine虽然很好，但是数量太多了，往往会带来很多麻烦，比如耗尽系统资源导致程序崩溃，或者CPU使用率过高导致系统忙不过来。所以我们可以限制下Goroutine的数量，这样就需要在每一次执行go之前判断goroutine的数量，如果数量超了，就要阻塞go的执行</p>
<ul>
<li>使用通道，每次执行的go之前向通道写入值，直到通道满的时候就阻塞了</li>
<li>但是新的问题于是就出现了，因为并不是所有的goroutine都执行完了，在main函数退出之后，还有一些goroutine没有执行完就被强制结束了。这个时候我们就需要用到sync.WaitGroup。使用WaitGroup等待所有的goroutine退出</li>
<li>Go的GOMAXPROCS默认值已经设置为CPU的核数， 这里允许我们的Go程序充分使用机器的每一个CPU，最大程度的提高我们程序的并发性能。<code>runtime.NumGoroutine</code>函数在被调用后，会返回系统中的处于特定状态的Goroutine的数量。这里的特指是指<code>Grunnable\Gruning\Gsyscall\Gwaition</code>。处于这些状态的Groutine即被看做是活跃的或者说正在被调度</li>
<li><strong>注意：</strong> 垃圾回收所在Groutine的状态也处于这个范围内的话，也会被纳入该计数器</li>
</ul>
<h4 id="12-Goroutine和线程的区别"><a href="#12-Goroutine和线程的区别" class="headerlink" title="12. Goroutine和线程的区别"></a><font color=DarkOrange>12. Goroutine和线程的区别</font></h4><p>从调度上看，goroutine的调度开销远远小于线程调度开销</p>
<ul>
<li>线程：OS的线程由OS内核调度，每隔几毫秒，一个硬件时钟中断发到CPU，CPU调用一个调度器内核函数。这个函数暂停当前正在运行的线程，把他的寄存器信息保存到内存中，查看线程列表并决定接下来运行哪一个线程，再从内存中恢复线程的注册表信息，最后继续执行选中的线程。这种线程切换需要一个完整的上下文切换：即保存一个线程的状态到内存，再恢复另外一个线程的状态，最后更新调度器的数据结构。某种意义上，这种操作还是很慢的</li>
<li>goroutine：Go运行的时候包涵一个自己的调度器，这个调度器使用一个称为一个M:N调度技术，m个goroutine到n个os线程（可以用GOMAXPROCS来控制n的数量），Go的调度器不是由硬件时钟来定期触发的，而是由特定的go语言结构来触发的，他不需要切换到内核语境，所以调度一个goroutine比调度一个线程的成本低很多</li>
</ul>
<p>从栈空间上，goroutine的栈空间更加动态灵活</p>
<p>每个OS的线程都有一个固定大小的栈内存，通常是2MB，栈内存用于保存在其他函数调用期间哪些正在执行或者临时暂停的函数的局部变量。这个固定的栈大小，如果对于goroutine来说，可能是一种巨大的浪费。作为对比goroutine在生命周期开始只有一个很小的栈，典型情况是2KB, 在go程序中，一次创建十万左右的goroutine也不罕见（2KB*100,000&#x3D;200MB）。而且goroutine的栈不是固定大小，它可以按需增大和缩小，最大限制可以到1GB</p>
<p>goroutine没有一个特定的标识</p>
<p>在大部分支持多线程的操作系统和编程语言中，线程有一个独特的标识，通常是一个整数或者指针，这个特性可以让我们构建一个线程的局部存储，本质是一个全局的map，以线程的标识作为键，这样每个线程可以独立使用这个map存储和获取值，不受其他线程干扰</p>
<p>goroutine中没有可供程序员访问的标识，原因是一种纯函数的理念，不希望滥用线程局部存储导致一个不健康的超距作用，即函数的行为不仅取决于它的参数，还取决于运行它的线程标识</p>
<h4 id="13-在Go函数中为什么会发生内存泄露，Goroutine发生了泄漏如何检测"><a href="#13-在Go函数中为什么会发生内存泄露，Goroutine发生了泄漏如何检测" class="headerlink" title="13. 在Go函数中为什么会发生内存泄露，Goroutine发生了泄漏如何检测"></a><font color=DarkOrange>13. 在Go函数中为什么会发生内存泄露，Goroutine发生了泄漏如何检测</font></h4><p>内存泄漏，指的是能够预期的能很快被释放的内存由于附着在了长期存活的内存上、或生命期意外地被延长，导致预计能够立即回收的内存而长时间得不到回收</p>
<ul>
<li>预期能被快速释放的内存因被根对象引用而没有得到迅速释放；当有一个全局对象时，可能不经意间将某个变量附着在其上，且忽略的将其进行释放，则该内存永远不会得到释放</li>
<li>Goroutine泄漏；Goroutine作为一种逻辑上理解的轻量级线程，需要维护执行用户代码的上下文信息。在运行过程中也需要消耗一定的内存来保存这类信息，而这些内存在目前版本的 Go 中是不会被释放的。因此，如果一个程序持续不断地产生新的 goroutine、且不结束已经创建的goroutine并复用这部分内存，就会造成内存泄漏的现象</li>
<li>检测方法：通过Go自带的工具pprof或者使用Gops去检测诊断当前在系统上运行的Go进程的占用的资源</li>
</ul>
<hr>
<h5 id="13-1-PProf是什么"><a href="#13-1-PProf是什么" class="headerlink" title="13.1 PProf是什么"></a><font color=DarkOrange>13.1 PProf是什么</font></h5><ol>
<li><code>PProf</code>是一个<code>Go</code>程序性能分析工具，可以分析<code>CPU</code>，内存等性能</li>
<li><code>Go</code>在语言层面上集成了<code>profile</code>采样工具，只需要在代码中简单的引入<code>runtime/ppro</code>或者<code>net/http/pprof</code>包即可获取程序的<code>profile</code>文件，并通过该文件来进行性能分析</li>
<li><code>runtime/pprof</code>还可以为控制台程序或者测试程序产生<code>pprof</code>数据</li>
<li>其实<code>net/http/pprof</code>中只是使用<code>runtime/pprof</code>包来进行封装了一下，并在<code>HTTP</code>端口上暴露出来</li>
</ol>
<h5 id="13-2-PProf使用"><a href="#13-2-PProf使用" class="headerlink" title="13.2 PProf使用"></a><font color=DarkOrange>13.2 PProf使用</font></h5><p>在<code>gin</code>的路由中注册<code>pprof</code>的路由</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pprof router</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-contrib/pprof&quot;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">	Router = gin.New()</span><br><span class="line">	pprof.Register(Router)</span><br></pre></td></tr></table></figure>

<p>通过<code>go tool pprof http://127.0.0.1/debug/pprof/profile</code>可以获取<code>profile</code>采集信息并分析</p>
<p>也可以直接在浏览器访问<code>http://localhost:8080/debug/pprof</code>来查看当前<code>API</code>服务的状态，包括<code>CPU</code>占用情况和内存使用情况等</p>
<p>通过<code>topN</code>的输出可以分析出哪些函数占用<code>CPU</code>时间片最多，这些函数可能存在性能问题。此命名用于显示<code>profile</code>文件中的最靠前的N个样本（默认前10个<code>sample</code>），它的输出格式字段的含义依次是：</p>
<ul>
<li>采样点落在该函数中的总时间</li>
<li>采样点落在该函数中的百分比</li>
<li>上一项的累积百分比</li>
<li>采样点落在该函数，以及被它调用的函数中的总时间</li>
<li>采样点落在该函数，以及被它调用的函数中的总次数百分比</li>
<li>函数名</li>
</ul>
<p>如果觉得不直观，可以直接再生成函数调用图，通过调用图来判断哪些函数耗时最久，在<code>pprof</code>交互界面，执行<code>svg</code>生成<code>svg</code>文件</p>
<p>但是需要确保系统已经安装<code>graphviz</code>命令（<code>Mac OS:brew install graphviz; CentOS: yum -y install graphviz.x86_64</code>）</p>
<h4 id="14-Goroutine和内核线程（KernelThread）之间是什么关系"><a href="#14-Goroutine和内核线程（KernelThread）之间是什么关系" class="headerlink" title="14. Goroutine和内核线程（KernelThread）之间是什么关系"></a><font color=DarkOrange>14. Goroutine和内核线程（KernelThread）之间是什么关系</font></h4><p>进程、线程、协程的关系和区别：</p>
<ul>
<li>进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度</li>
<li>线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)</li>
<li>协程和线程一样共享堆，不共享栈，协程由程序开发者在协程的代码里显示调度</li>
</ul>
<p>为什么协程比线程轻量？</p>
<ul>
<li>go协程调用跟切换比线程效率高<ul>
<li>线程并发执行流程: 线程是内核对外提供的服务，应用程序可以通过系统调用让内核启动线程，由内核来负责线程调度和切换。线程在等待IO操作时线程变为unrunnable状态会触发上下文切换。现代操作系统一般都采用抢占式调度，上下文切换一般发生在时钟中断和系统调用返回前，调度器计算当前线程的时间片，如果需要切换就从运行队列中选出一个目标线程，保存当前线程的环境，并且恢复目标线程的运行环境，最典型的就是切换ESP指向目标线程内核堆栈，将EIP指向目标线程上次被调度出时的指令地址</li>
<li>go协程并发执行流程：不依赖操作系统和其提供的线程，golang自己实现的CSP并发模型实现：M, P, G .go协程也叫用户态线程，协程之间的切换发生在用户态。在用户态没有时钟中断，系统调用等机制,因此效率高</li>
</ul>
</li>
<li>go协程占用内存少<ul>
<li>执行go协程只需要极少的栈内存（大概是4～5KB），默认情况下，线程栈的大小为1MB。goroutine就是一段代码，一个函数入口，以及在堆上为其分配的一个堆栈。所以它非常廉价，我们可以很轻松的创建上万个goroutine，但它们并不是被操作系统所调度执行</li>
<li>因此协程和线程一样共享堆，不共享栈，协程由用户态下面的轻量级线程</li>
</ul>
</li>
</ul>
<h4 id="15-协程和线程和进程的区别"><a href="#15-协程和线程和进程的区别" class="headerlink" title="15. 协程和线程和进程的区别"></a><font color=DarkOrange>15. 协程和线程和进程的区别</font></h4><ul>
<li>进程：是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。<br>每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全</li>
<li>线程：是进程的一个实体，线程是内核态，而且是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据</li>
<li>协程：是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快</li>
</ul>
<h4 id="16-G0的作用"><a href="#16-G0的作用" class="headerlink" title="16. G0的作用"></a><font color=DarkOrange>16. G0的作用</font></h4><ul>
<li>在Go中g0作为一个特殊的goroutine，为scheduler执行调度循环提供了场地（栈）。对于一个线程来说，g0总是它第一个创建的 goroutine。之后，它会不断地寻找其他普通的goroutine来执行，直到进程退出</li>
<li>当需要执行一些任务，且不想扩栈时，就可以用到 g0了，因为g0的栈比较大</li>
<li>g0 其他的一些“职责”有：创建 <code>goroutine</code>、<code>deferproc</code> 函数里新建 <code>_defer</code>、垃圾回收相关的工作（例如stw、扫描goroutine的执行栈、一些标识清扫的工作、栈增长）等等</li>
</ul>
<h4 id="17-Golang的内存模型中为什么小对象多了会造成GC压力"><a href="#17-Golang的内存模型中为什么小对象多了会造成GC压力" class="headerlink" title="17. Golang的内存模型中为什么小对象多了会造成GC压力"></a><font color=DarkOrange>17. Golang的内存模型中为什么小对象多了会造成GC压力</font></h4><p>通常小对象过多会导致GC三色法消耗过多的CPU。优化思路：减少对象分配</p>
<h4 id="18-Go的对象在内存中是怎样分配的"><a href="#18-Go的对象在内存中是怎样分配的" class="headerlink" title="18. Go的对象在内存中是怎样分配的"></a><font color=DarkOrange>18. Go的对象在内存中是怎样分配的</font></h4><p>Go中的内存分类并不像TCMalloc那样分成小、中、大对象，但是它的小对象里又细分了一个Tiny对象，Tiny对象指大小在1Byte到16Byte之间并且不包含指针的对象。小对象和大对象只用大小划定，无其他区分</p>
<p>大对象指大小大于32kb，小对象是在mcache中分配的，而大对象是直接从mheap分配的，从小对象的内存分配看起</p>
<p>Go的内存分配原则：</p>
<ul>
<li>Go在程序启动的时候，会先向操作系统申请一块内存（注意这时还只是一段虚拟的地址空间，并不会真正地分配内存），切成小块后自己进行管理</li>
<li>申请到的内存块被分配了三个区域，在X64上分别是512MB，16GB，512GB大小</li>
<li>arena区域就是我们所谓的堆区，Go动态分配的内存都是在这个区域，它把内存分割成8KB大小的页，一些页组合起来称为mspan</li>
<li>bitmap区域标识arena区域哪些地址保存了对象，并且用4bit标志位表示对象是否包含指针、GC标记信息。bitmap中一个byte大小的内存对应arena区域中4个指针大小（指针大小为 8B ）的内存，所以bitmap区域的大小是<code>512GB/(4*8B)=16GB</code></li>
<li>bitmap的高地址部分指向arena区域的低地址部分，这里bitmap的地址是由高地址向低地址增长的</li>
<li>spans区域存放mspan（是一些arena分割的页组合起来的内存管理基本单元，后文会再讲）的指针，每个指针对应一页，所以spans区域的大小就是<code>512GB/8KB*8B=512MB</code></li>
<li>除以8KB是计算arena区域的页数，而最后乘以8是计算spans区域所有指针的大小。创建mspan的时候，按页填充对应的spans区域，在回收object时，根据地址很容易就能找到它所属的mspan</li>
</ul>
<h4 id="19-栈的内存是怎么分配的"><a href="#19-栈的内存是怎么分配的" class="headerlink" title="19. 栈的内存是怎么分配的"></a><font color=DarkOrange>19. 栈的内存是怎么分配的</font></h4><p>栈和堆只是虚拟内存上2块不同功能的内存区域：</p>
<ul>
<li>栈在高地址，从高地址向低地址增长</li>
<li>堆在低地址，从低地址向高地址增长</li>
</ul>
<p>栈和堆相比优势：</p>
<ul>
<li>栈的内存管理简单，分配比堆上快。</li>
<li>栈的内存不需要回收，而堆需要，无论是主动free，还是被动的垃圾回收，这都需要花费额外的CPU。</li>
<li>栈上的内存有更好的局部性，堆上内存访问就不那么友好了，CPU访问的2块数据可能在不同的页上，CPU访问数据的时间可能就上去了</li>
</ul>
<h4 id="20-堆内存管理怎么分配的"><a href="#20-堆内存管理怎么分配的" class="headerlink" title="20. 堆内存管理怎么分配的"></a><font color=DarkOrange>20. 堆内存管理怎么分配的</font></h4><ul>
<li>通常在Golang中，当我们谈论内存管理的时候，主要是指堆内存的管理，因为栈的内存管理不需要程序去操心</li>
<li>堆内存管理中主要是三部分, 1.分配内存块，2.回收内存块, 3.组织内存块</li>
<li>一个内存块包含了3类信息：元数据、用户数据和对齐字段，内存对齐是为了提高访问效率。申请内存的时候，就需要进行内存对齐</li>
<li>释放内存实质是把使用的内存块从链表中取出来，然后标记为未使用，当分配内存块的时候，可以从未使用内存块中有先查找大小相近的内存块，如果找不到，再从未分配的内存中分配内存</li>
<li>因为随着内存不断的申请和释放，内存上会存在大量的碎片，降低内存的使用率。为了解决内存碎片，可以将2个连续的未使用的内存块合并，减少碎片</li>
</ul>
<h4 id="21-在Go函数中为什么会发生内存泄露"><a href="#21-在Go函数中为什么会发生内存泄露" class="headerlink" title="21. 在Go函数中为什么会发生内存泄露"></a><font color=DarkOrange>21. 在Go函数中为什么会发生内存泄露</font></h4><p>同上13</p>
<h4 id="22-Go语言的栈空间管理是怎么样的"><a href="#22-Go语言的栈空间管理是怎么样的" class="headerlink" title="22. Go语言的栈空间管理是怎么样的"></a><font color=DarkOrange>22. Go语言的栈空间管理是怎么样的</font></h4><p>Go语言的运行环境（runtime）会在goroutine需要的时候动态地分配栈空间，而不是给每个goroutine分配固定大小的内存空间。这样就避免了需要程序员来决定栈的大小</p>
<p>分块式的栈是最初Go语言组织栈的方式。当创建一个goroutine的时候，它会分配一个8KB的内存空间来给goroutine的栈使用。我们可能会考虑当这8KB的栈空间被用完的时候该怎么办？</p>
<p>为了处理这种情况，每个Go函数的开头都有一小段检测代码。这段代码会检查我们是否已经用完了分配的栈空间。如果是的话，它会调用<code>morestack</code>函数。<code>morestack</code>函数分配一块新的内存作为栈空间，并且在这块栈空间的底部填入各种信息（包括之前的那块栈地址）。在分配了这块新的栈空间之后，它会重试刚才造成栈空间不足的函数。这个过程叫做栈分裂（stack split）</p>
<p>在新分配的栈底部，还插入了一个叫做<code>lessstack</code>的函数指针。这个函数还没有被调用。这样设置是为了从刚才造成栈空间不足的那个函数返回时做准备的。当我们从那个函数返回时，它会跳转到<code>lessstack</code>。<code>lessstack</code>函数会查看在栈底部存放的数据结构里的信息，然后调整栈指针（stack pointer）。这样就完成了从新的栈块到老的栈块的跳转。接下来，新分配的这个块栈空间就可以被释放掉了</p>
<h4 id="23-Go中的逃逸分析是什么"><a href="#23-Go中的逃逸分析是什么" class="headerlink" title="23. Go中的逃逸分析是什么"></a><font color=DarkOrange>23. Go中的逃逸分析是什么</font></h4><p>在Go中逃逸分析是一种确定指针动态范围的方法，可以分析在程序的哪些地方可以访问到指针。它涉及到指针分析和形状分析</p>
<p>当一个变量(或对象)在子程序中被分配时，一个指向变量的指针可能逃逸到其它执行线程中，或者去调用子程序。如果使用尾递归优化（通常在函数编程语言中是需要的），对象也可能逃逸到被调用的子程序中。 如果一个子程序分配一个对象并返回一个该对象的指针，该对象可能在程序中的任何一个地方被访问到——这样指针就成功“逃逸”了</p>
<p>如果指针存储在全局变量或者其它数据结构中，它们也可能发生逃逸，这种情况是当前程序中的指针逃逸。 逃逸分析需要确定指针所有可以存储的地方，保证指针的生命周期只在当前进程或线程中</p>
<p>导致内存逃逸的情况比较多，有些可能还是官方未能够实现精确的分析逃逸情况的 bug，通常来讲就是如果变量的作用域不会扩大并且其行为或者大小能够在编译的时候确定，一般情况下都是分配到栈上，否则就可能发生内存逃逸分配到堆上</p>
<p>内存逃逸的五种情况：</p>
<ol>
<li>发送指针的指针或值包含了指针到<code>channel</code> 中，由于在编译阶段无法确定其作用域与传递的路径，所以一般都会逃逸到堆上分配</li>
<li>slices 中的值是指针的指针或包含指针字段。一个例子是类似<code>[]*string</code> 的类型。这总是导致 slice 的逃逸。即使切片的底层存储数组仍可能位于堆栈上，数据的引用也会转移到堆中。</li>
<li>slice 由于 append 操作超出其容量，因此会导致 slice 重新分配。这种情况下，由于在编译时 slice 的初始大小的已知情况下，将会在栈上分配。如果 slice 的底层存储必须基于仅在运行时数据进行扩展，则它将分配在堆上</li>
<li>调用接口类型的方法。接口类型的方法调用是动态调度，实际使用的具体实现只能在运行时确定。考虑一个接口类型为 io.Reader 的变量 r。对 r.Read(b) 的调用将导致 r 的值和字节片b的后续转义并因此分配到堆上</li>
<li>尽管能够符合分配到栈的场景，但是其大小不能够在在编译时候确定的情况，也会分配到堆上</li>
</ol>
<p>有效的避免上述的五种逃逸的情况，就可以避免内存逃逸</p>
<h4 id="24-Go函数返回局部变量的指针是否安全"><a href="#24-Go函数返回局部变量的指针是否安全" class="headerlink" title="24. Go函数返回局部变量的指针是否安全"></a><font color=DarkOrange>24. Go函数返回局部变量的指针是否安全</font></h4><p>在Go中是安全的，Go编译器将会对每个局部变量进行逃逸分析。如果发现局部变量的作用域超出该函数，则不会将内存分配在栈上，而是分配在堆上</p>
<h4 id="25-Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量"><a href="#25-Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量" class="headerlink" title="25. Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量"></a><font color=DarkOrange>25. Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量</font></h4><p>Golang中Goroutine可以通过Channel进行安全读写共享变量，还可以通过原子性操作进行</p>
<h4 id="26-Go中的锁有哪些"><a href="#26-Go中的锁有哪些" class="headerlink" title="26. Go中的锁有哪些"></a><font color=DarkOrange>26. Go中的锁有哪些</font></h4><p>Go中的三种锁包括：</p>
<ul>
<li>互斥锁</li>
<li>读写锁</li>
<li>sync.Map安全锁</li>
</ul>
<ol>
<li><p>互斥锁</p>
<p>Go并发程序对共享资源进行访问控制的主要手段，由标准库代码包中sync中的Mutex结构体表示，sync.Mutex包中的类型只有两个公开的指针方法Lock和Unlock</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Locker表示可以锁定和解锁的对象。</span></span><br><span class="line"> <span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 锁定当前的互斥量</span></span><br><span class="line"> <span class="comment">// 如果锁已被使用，则调用goroutine</span></span><br><span class="line"> <span class="comment">// 阻塞直到互斥锁可用。</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() </span><br><span class="line"></span><br><span class="line"> <span class="comment">// 对当前互斥量进行解锁</span></span><br><span class="line"> <span class="comment">// 如果在进入解锁时未锁定m，则为运行时错误。</span></span><br><span class="line"> <span class="comment">// 锁定的互斥锁与特定的goroutine无关。</span></span><br><span class="line"> <span class="comment">// 允许一个goroutine锁定Mutex然后安排另一个goroutine来解锁它。</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock()</span><br></pre></td></tr></table></figure>

<p>如果对一个已经上锁的对象再次上锁，那么就会导致该锁定操作被阻塞，直到该互斥锁回到被解锁状态。互斥锁锁定操作的逆操作并不会导致协程阻塞，但是有可能导致引发一个无法恢复的运行时的panic，比如对一个未锁定的互斥锁进行解锁时就会发生panic。避免这种情况的最有效方式就是使用defer</p>
<hr>
</li>
<li><p>读写锁</p>
<p>读写锁是针对读写操作的互斥锁，可以分别针对读操作与写操作进行锁定和解锁操作 。读写锁的访问控制规则如下：</p>
<ul>
<li>多个写操作之间是互斥的</li>
<li>写操作与读操作之间也是互斥的</li>
<li>多个读操作之间不是互斥的</li>
</ul>
<p>在这样的控制规则下，读写锁可以大大降低性能损耗。sync中的RWMutex有以下几种方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对读操作的锁定</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//对读操作的解锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//对写操作的锁定</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//对写操作的解锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个实现了sync.Locker接口类型的值，实际上是回调rw.RLock and rw.RUnlock.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLocker() Locker</span><br></pre></td></tr></table></figure>

<ul>
<li>若对一个未被写锁定的读写锁进行写解锁，就会引发一个不可恢复的panic，同理对一个未被读锁定的读写锁进行读写锁也会如此。</li>
<li>由于读写锁控制下的多个读操作之间不是互斥的，因此对于读解锁更容易被忽视。对于同一个读写锁，添加多少个读锁定，就必要有等量的读解锁，这样才能其他协程有机会进行操作</li>
<li>因此Go中读写锁，在多个读线程可以同时访问共享数据,写线程必须等待所有读线程都释放锁以后，才能取得锁</li>
<li>同样的，读线程必须等待写线程释放锁后，才能取得锁，也就是说读写锁要确保的是如下互斥关系，可以同时读，但是读-写，写-写都是互斥的</li>
</ul>
<hr>
</li>
<li><p>sync.Map安全锁</p>
<p>golang中的sync.Map是并发安全的，其实也就是sync包中golang自定义的一个名叫Map的结构体</p>
<ul>
<li>Delete 方法</li>
<li>Store 方法</li>
<li>Load方法</li>
</ul>
<p>sync.Map是通过冗余的两个数据结构(read、dirty)，实现性能的提升。为了提升性能，load、delete、store等操作尽量使用只读的read；为了提高read的key击中概率，采用动态调整，将dirty数据提升为read；对于数据的删除，采用延迟标记删除法，只有在提升dirty的时候才删除</p>
</li>
</ol>
<h4 id="27-Go中的锁如何实现"><a href="#27-Go中的锁如何实现" class="headerlink" title="27. Go中的锁如何实现"></a><font color=DarkOrange>27. Go中的锁如何实现</font></h4><p>锁是一种同步机制，用于在多任务环境中限制资源的访问，以满足互斥需求</p>
<p>go源码sync包中经常用于同步操作的方式：</p>
<ul>
<li>原子操作</li>
<li>互斥锁</li>
<li>读写锁</li>
<li>waitgroup</li>
</ul>
<p>互斥锁的数据结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Mutex is a mutual exclusion lock.</span></span><br><span class="line"><span class="comment">// The zero value for a Mutex is an unlocked mutex.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A Mutex must not be copied after first use.</span></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    state <span class="type">int32</span>   <span class="comment">// 互斥锁上锁状态枚举值如下所示</span></span><br><span class="line">    sema  <span class="type">uint32</span>  <span class="comment">// 信号量，向处于Gwaitting的G发送信号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// 值为1，表示在state中由低向高第1位，意义：锁是否可用,0可用，1不可用,锁定中</span></span><br><span class="line">    mutexWoken   <span class="comment">// 值为2，表示在state中由低向高第2位，意义：mutex是否被唤醒</span></span><br><span class="line">    mutexStarving <span class="comment">// 当前的互斥锁进入饥饿状态；</span></span><br><span class="line">    mutexWaiterShift = <span class="literal">iota</span>  <span class="comment">//值为2，表示state中统计阻塞在此mutex上goroutine的数目需要位移的偏移量</span></span><br><span class="line">    starvationThresholdNs = <span class="number">1e6</span> </span><br></pre></td></tr></table></figure>

<p>state和sema两个加起来只占 8 字节空间的结构体表示了 Go 语言中的互斥锁</p>
<p>在默认情况下，互斥锁的所有状态位都是 0，int32 中的不同位分别表示了不同的状态：</p>
<ul>
<li>mutexLocked 表示互斥锁的锁定状态；</li>
<li>mutexWoken 表示从正常模式被从唤醒；</li>
<li>mutexStarving 当前的互斥锁进入饥饿状态</li>
<li>waitersCount 当前互斥锁上等待的 Goroutine 个数</li>
</ul>
<p>sync.Mutex 有两种模式，正常模式和饥饿模式：</p>
<ul>
<li>正常模式：锁的等待者会按照先进先出的顺序获取锁。但是刚被唤起的 <code>Goroutine</code> 与新创建的 <code>Goroutine</code> 竞争时，大概率会获取不到锁，为了减少这种情况的出现，一旦 Goroutine 超过 1ms 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止部分 Goroutine 被饿死</li>
<li>饥饿模式：饥饿模式是在 Go 语言 1.9 版本引入的优化的，引入的目的是保证互斥锁的公平性（Fairness）。在饥饿模式中，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会被切换回正常模式</li>
</ul>
<p>相比于饥饿模式，正常模式下的互斥锁能够提供更好地性能，饥饿模式的能避免 Goroutine 由于陷入等待无法获取锁而造成的高尾延时</p>
<h4 id="28-Go中数据竞争问题怎么解决"><a href="#28-Go中数据竞争问题怎么解决" class="headerlink" title="28. Go中数据竞争问题怎么解决"></a><font color=DarkOrange>28. Go中数据竞争问题怎么解决</font></h4><ul>
<li>数据竞争问题可以使用互斥锁sync.Mutex，或者也可以通过CAS无锁并发解决</li>
<li>其中使用同步访问共享数据或者CAS无锁并发是处理数据竞争的一种有效的方法</li>
<li>golang在1.1之后引入了竞争检测机制，可以使用 <code>go run -race</code> 或者 <code>go build -race</code>来进行静态检测。其在内部的实现是，开启多个协程执行同一个命令， 并且记录下每个变量的状态</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> test -race mypkg    <span class="comment">// 测试包</span></span><br><span class="line"><span class="keyword">go</span> run -race mysrc.<span class="keyword">go</span>  <span class="comment">// 编译和运行程序</span></span><br><span class="line"><span class="keyword">go</span> build -race mycmd   <span class="comment">// 构建程序</span></span><br><span class="line"><span class="keyword">go</span> install -race mypkg <span class="comment">// 安装程序</span></span><br></pre></td></tr></table></figure>

<h4 id="29-Go中CAS是怎么回事"><a href="#29-Go中CAS是怎么回事" class="headerlink" title="29. Go中CAS是怎么回事"></a><font color=DarkOrange>29. Go中CAS是怎么回事</font></h4><p>CAS算法（Compare And Swap），是原子操作的一种，CAS算法是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题</p>
<p>该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值</p>
<p>Go中的CAS操作是借用了CPU提供的原子性指令来实现。CAS操作修改共享变量时候不需要对共享变量加锁，而是通过类似乐观锁的方式进行检查，本质还是不断的占用CPU 资源换取加锁带来的开销（比如上下文切换开销）</p>
<p>Go中CAS操作可以有效的减少使用锁所带来的开销，但是需要注意在高并发下这是使用cpu资源做交换的</p>
<h4 id="30-Go主协程如何等其余协程完再操作"><a href="#30-Go主协程如何等其余协程完再操作" class="headerlink" title="30. Go主协程如何等其余协程完再操作"></a><font color=DarkOrange>30. Go主协程如何等其余协程完再操作</font></h4><ul>
<li>Go提供了更简单的方法——使用<code>sync.WaitGroup</code>。<code>WaitGroup</code>，就是用来等待一组操作完成的。<code>WaitGroup</code>内部实现了一个计数器，用来记录未完成的操作个数</li>
<li>它提供了三个方法，<code>Add()</code>用来添加计数。<code>Done()</code>用来在操作结束时调用，使计数减一。<code>Wait()</code>用来等待所有的操作结束，即计数变为0，该函数会在计数不为0时等待，在计数为0时立即返回</li>
</ul>
<h4 id="31-Context包的用途是什么"><a href="#31-Context包的用途是什么" class="headerlink" title="31. Context包的用途是什么"></a><font color=DarkOrange>31. Context包的用途是什么</font></h4><p>在 Go http包的Server中，每一个请求在都有一个对应的 goroutine 去处理。请求处理函数通常会启动额外的 goroutine 用来访问后端服务，比如数据库和RPC服务。用来处理一个请求的 goroutine 通常需要访问一些与请求特定的数据，比如终端用户的身份认证信息、验证相关的token、请求的截止时间。 当一个请求被取消或超时时，所有用来处理该请求的 goroutine 都应该迅速退出，然后系统才能释放这些 goroutine 占用的资源</p>
<p>在Google 内部，我们开发了 Context 包，专门用来简化 对于处理单个请求的多个 goroutine 之间与请求域的数据、取消信号、截止时间等相关操作，这些操作可能涉及多个 API 调用</p>
<p>Context中的方法：</p>
<ul>
<li>Done会返回一个channel，当该context被取消的时候，该channel会被关闭，同时对应的使用该context的routine也应该结束并返回</li>
<li>Context中的方法是协程安全的，这也就代表了在父routine中创建的context，可以传递给任意数量的routine并让他们同时访问</li>
<li>Deadline会返回一个超时时间，routine获得了超时时间后，可以对某些io操作设定超时时间</li>
<li>Value可以让routine共享一些数据，当然获得数据是协程安全的</li>
</ul>
<p>这里需要注意一点的是在goroutine中使用context包的时候，通常我们需要在goroutine中新创建一个上下文的context，原因是：如果直接传递外部context到协层中，一个请求可能在主函数中已经结束，在goroutine中如果还没有结束的话，会直接导致goroutine中的运行的被取消</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">   _, ctx, _ := log.FromContextOrNew(context.Background(), <span class="literal">nil</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>context.Background函数的返回值是一个空的context，经常作为树的根结点，它一般由接收请求的第一个routine创建，不能被取消、没有值、也没有过期时间</p>
<p>Context上下文数据的存储就像一个树，每个结点只存储一个<code>key/value</code>对。WithValue()保存一个<code>key/value</code>对，它将父context嵌入到新的子context，并在节点中保存了<code>key/value</code>数据。Value()查询key对应的value数据，会从当前context中查询，如果查不到，会递归查询父context中的数据</p>
<p>值得注意的是，context中的上下文数据并不是全局的，它只查询本节点及父节点们的数据，不能查询兄弟节点的数据</p>
<p>Context 使用原则：</p>
<ul>
<li>不要把Context放在结构体中，要以参数的方式传递</li>
<li>以Context作为参数的函数方法，应该把Context作为第一个参数，放在第一位</li>
<li>给一个函数方法传递Context的时候，不要传递nil，如果不知道传递什么，就使用context.TODO</li>
<li>Context的Value相关方法应该传递必须的数据，不要什么数据都使用这个传递</li>
<li>Context是线程安全的，可以放心的在多个goroutine中传递</li>
</ul>
<h4 id="32-Go中对nil的Slice和空Slice的处理是一致的吗"><a href="#32-Go中对nil的Slice和空Slice的处理是一致的吗" class="headerlink" title="32. Go中对nil的Slice和空Slice的处理是一致的吗"></a><font color=DarkOrange>32. Go中对nil的Slice和空Slice的处理是一致的吗</font></h4><p>在Go中，<code>nil slice</code>和<code>空 slice</code>是有区别的</p>
<ul>
<li><code>nil slice</code>是一个指向<code>nil</code>的指针，它没有分配任何内存空间</li>
<li><code>空 slice</code>是一个长度为0的切片，它指向一块已经分配的内存空间</li>
</ul>
<p>在对 <code>nil slice</code>执行任何操作之前，必须将其初始化为空切片，否则会出现空指针异常。而对于<code>空 slice</code>，可以直接进行操作而不会出现异常</p>
<hr>
<p>Go的JSON 标准库对 <code>nil slice</code> 和 <code>空 slice</code> 的处理是不一致</p>
<p>通常错误的用法，会报数组越界的错误，因为只是声明了slice，却没有给实例化的对象。nil的slice定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>此时slice的值是nil，这种情况可以用于需要返回slice的函数，当函数出现异常的时候，保证函数依然会有nil的返回值</p>
<hr>
<p>空的slice是指slice不为nil，但是slice没有值，slice的底层的空间是空的，空的slice定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>）</span><br><span class="line">slice := []<span class="type">int</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>当我们查询或者处理一个空的列表的时候，这非常有用，它会告诉我们返回的是一个列表，但是列表内没有任何值</p>
<p><strong>总结：</strong> nil的slice和空的slice是不同的东西，需要我们加以区分</p>
<h4 id="33-Go的Slice如何扩容"><a href="#33-Go的Slice如何扩容" class="headerlink" title="33. Go的Slice如何扩容"></a><font color=DarkOrange>33. Go的Slice如何扩容</font></h4><h5 id="33-1-数组Array和切片Slice"><a href="#33-1-数组Array和切片Slice" class="headerlink" title="33.1 数组Array和切片Slice"></a><font color=DarkOrange>33.1 数组Array和切片Slice</font></h5><ol>
<li>数组和切片都是用来存储相同数据类型的数据结构</li>
<li>数组在初始化或者是定义的时候就必须指明长度，或者初始化的时候使用…自动推导其数组的长度，数组初始化后其长度就是固定不变的；切片在初始化或定义的时候无需声明其长度，可以往切片里追加元素，追加元素可能导致切片扩容</li>
<li>数组和切片都可以通过内置函数<code>len</code>求元素个数，都可以通过下标索引获取相对应的元素值，都可以通过<code>for range</code>进行遍历</li>
<li>函数参数：<strong>数组</strong>作为函数参数时，必须指定参数数组的大小，且传入的数组大小必须与指定的大小一致，数组为按值传递的，函数内对数组的值的改变不影响初始数组；<strong>切片</strong>作为函数参数传递时为按引用传递的，函数内对切片内元素的修改将导致函数外的值也发生改变，不过由于传入函数的是一个指针的副本，所以对该指针的修改不会导致原来的指针的变化（例如append函数不会改变原来的切片的值）</li>
</ol>
<hr>
<ul>
<li>slice是Go中的一种基本的数据结构，使用这种结构可以用来管理数据集合。但是slice本身并不是动态数据或者数组指针。slice常见的操作有 reslice、append、copy</li>
<li>slice自身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。slice本身是一个只读对象，其工作机制类似数组指针的一种封装</li>
<li>slice是对数组一个连续片段的引用，所以切片是一个引用类型。这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集</li>
<li>slice的结构体由3部分构成，Pointer 是指向一个数组的指针，len 代表当前切片的长度，cap 是当前切片的容量。cap 总是大于等于 len 的</li>
</ul>
<p>通常我们在对slice进行append等操作时，可能会造成slice的自动扩容</p>
<ul>
<li><strong>1.18版本之前：</strong> 当原slice容量小于1024的时候，新slice容量变成原来的2倍；原slice容量超过1024，新slice容量变成原来的1.25倍</li>
<li><strong>1.18版本之后：</strong> 当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的2倍；原slice容量超过256，新slice容量newcap &#x3D; oldcap+(oldcap+3*256)&#x2F;4</li>
<li><strong>最后：</strong> 扩容后的容量并不一定就是按照以上公式计算的结果，容量可能会存在小的差异，主要原因是扩容后会有内存对齐，导致容量不是百分百按照公式计算的结果。如果扩容之后，还没有触及原数组的容量，那么，切片中的指针指向的位置，就还是原数组，如果扩容之后，超过了原数组的容量，那么，Go就会开辟一块新的内存，把原来的值拷贝过来，这种情况丝毫不会影响到原数组</li>
</ul>
<h4 id="34-Go的Struct能不能比较"><a href="#34-Go的Struct能不能比较" class="headerlink" title="34. Go的Struct能不能比较"></a><font color=DarkOrange>34. Go的Struct能不能比较</font></h4><ul>
<li>相同struct类型的可以比较</li>
<li>不同struct类型的不可以比较，编译都不过，类型不匹配</li>
</ul>
<h4 id="35-Go中的map的实现"><a href="#35-Go中的map的实现" class="headerlink" title="35. Go中的map的实现"></a><font color=DarkOrange>35. Go中的map的实现</font></h4><p>Go中Map是一个KV对集合。底层使用<code>hash table</code>，用链表来解决冲突 ，出现冲突时，不是每一个Key都申请一个结构通过链表串起来，而是以bmap为最小粒度挂载，一个bmap可以放8个kv</p>
<p>在哈希函数的选择上，会在程序启动时，检测 cpu 是否支持 <code>aes</code>，如果支持，则使用<code>aes hash</code>，否则使用<code>memhash</code></p>
<p>每个map的底层结构是hmap，是有若干个结构为bmap的bucket组成的数组。每个bucket底层都采用链表结构</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count     <span class="type">int</span>    <span class="comment">// 元素个数</span></span><br><span class="line">    flags     <span class="type">uint8</span>  <span class="comment">// 用来标记状态</span></span><br><span class="line">    B         <span class="type">uint8</span>  <span class="comment">// 扩容常量相关字段B是buckets数组的长度的对数 2^B</span></span><br><span class="line">    noverflow <span class="type">uint16</span> <span class="comment">// noverflow是溢出桶的数量，当B&lt;16时，为精确值,当B&gt;=16时，为估计值                       </span></span><br><span class="line">    hash0     <span class="type">uint32</span> <span class="comment">// 是哈希的种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定，并在调用哈希函数时作为参数传入</span></span><br><span class="line"></span><br><span class="line">    buckets    unsafe.Pointer <span class="comment">// 桶的地址 </span></span><br><span class="line">    oldbuckets unsafe.Pointer <span class="comment">// 旧桶的地址，用于扩容 </span></span><br><span class="line">    nevacuate  <span class="type">uintptr</span>        <span class="comment">// 搬迁进度，扩容需要将旧数据搬迁至新数据，这里是利用指针来比较判断有没有迁移 </span></span><br><span class="line"></span><br><span class="line">    extra *mapextra <span class="comment">// 用于扩容的指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">    overflow    *[]*bmap</span><br><span class="line">    oldoverflow *[]*bmap</span><br><span class="line">    <span class="comment">// nextOverflow holds a pointer to a free overflow bucket.</span></span><br><span class="line">    nextOverflow *bmap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A bucket for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    tophash [bucketCnt]<span class="type">uint8</span>  <span class="comment">// tophash用于记录8个key哈希值的高8位，这样在寻找对应key的时候可以更快，不必每次都对key做全等判断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际上编辑期间会动态生成一个新的结构体</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    topbits  [<span class="number">8</span>]<span class="type">uint8</span></span><br><span class="line">    keys     [<span class="number">8</span>]keytype</span><br><span class="line">    values   [<span class="number">8</span>]valuetype</span><br><span class="line">    pad      <span class="type">uintptr</span></span><br><span class="line">    overflow <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bmap 就是我们常说的“桶”，桶里面会最多装 8 个 key，这些 key之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果是“一类”的，关于key的定位我们在map的查询和赋值中详细说明</p>
<p>在桶内，又会根据key计算出来的hash值的高8位来决定 key到底落入桶内的哪个位置（一个桶内最多有8个位置)</p>
<p>当map的key和value都不是指针，并且 size都小于128字节的情况下，会把bmap标记为不含指针，这样可以避免gc时扫描整个hmap</p>
<p>bmap其实有一个overflow的字段，是指针类型的，破坏了 bmap 不含指针的设想，这时会把overflow移动到 hmap的extra 字段来</p>
<p>这样随着哈希表存储的数据逐渐增多，我们会扩容哈希表或者使用额外的桶存储溢出的数据，不会让单个桶中的数据超过 8 个，不过溢出桶只是临时的解决方案，创建过多的溢出桶最终也会导致哈希的扩容</p>
<h4 id="36-Go中的map如何实现顺序读取"><a href="#36-Go中的map如何实现顺序读取" class="headerlink" title="36. Go中的map如何实现顺序读取"></a><font color=DarkOrange>36. Go中的map如何实现顺序读取</font></h4><p>Go中map如果要实现顺序读取的话，先把map中的key添加到数组（array）或切片（slice）中，然后通过sort包对数组或切片进行排序，最后在遍历数组或切片的时候将map中key以及对应的value取出来</p>
<h4 id="37-Go中new和make的区别"><a href="#37-Go中new和make的区别" class="headerlink" title="37. Go中new和make的区别"></a><font color=DarkOrange>37. Go中new和make的区别</font></h4><ul>
<li>值类型：int，float，bool，string，struct和array。变量直接存储值，分配栈区的内存空间，这些变量所占据的空间在函数被调用完后会自动释放</li>
<li>引用类型：slice，map，chan和值类型对应的指针。变量存储的是一个地址（或者理解为指针），指针指向内存中真正存储数据的首地址。内存通常在堆上分配，通过GC回收</li>
<li><strong>注意：</strong> 对于引用类型的变量，我们不仅要声明变量，更重要的是，我们得手动为它分配空间</li>
</ul>
<ol>
<li>new该方法的参数要求传入一个类型，而不是一个值，它会申请一个该类型大小的内存空间，并会初始化为对应的零值，返回指向该内存空间的一个指针。new只用于分配内存，返回一个指向地址的<strong>指针</strong>。它为每个新类型分配一片内存，初始化为0且返回类型*T的内存地址，它相当于&amp;T{}</li>
<li>make也是用于内存分配，但是和new不同，只用来引用对象slice、map和channel的内存创建，它返回的类型就是类型本身，而不是它们的指针类型。make只可用于<strong>slice</strong>，<strong>map</strong>，<strong>channel</strong>的初始化，返回的是<strong>引用</strong></li>
</ol>
<h4 id="38-Go的defer原理是什么"><a href="#38-Go的defer原理是什么" class="headerlink" title="38. Go的defer原理是什么"></a><font color=DarkOrange>38. Go的defer原理是什么</font></h4><p>defer意为延迟，在 golang 中用于延迟执行一个函数。它可以帮助我们处理容易忽略的问题，如资源释放、连接关闭等。但在实际使用过程中，有一些需要注意的地方：</p>
<ul>
<li>若函数中有多个 defer，其执行顺序为 先进后出，可以理解为栈</li>
<li>return 会做什么？Go 的函数返回值是通过堆栈返回的，return 语句不是原子操作，而是被拆成了两步<ul>
<li>给返回值赋值 (rval)</li>
<li>调用 defer 表达式</li>
<li>返回给调用函数(ret)</li>
</ul>
</li>
<li>若 defer 表达式有返回值，将会被丢弃。在实际开发中，defer 的使用经常伴随着闭包与匿名函数的使用</li>
</ul>
<h4 id="39-Go的select可以用于什么"><a href="#39-Go的select可以用于什么" class="headerlink" title="39. Go的select可以用于什么"></a><font color=DarkOrange>39. Go的select可以用于什么</font></h4><p>Golang 的 select 机制可以理解为是在语言层面实现了和 select, poll, epoll 相似的功能：监听多个描述符的读&#x2F;写等事件，一旦某个描述符就绪（一般是读或者写事件发生了），就能够将发生的事件通知给关心的应用程序去处理该事件。 golang 的 select 机制是，监听多个channel，每一个 case 是一个事件，可以是读事件也可以是写事件，随机选择一个执行，可以设置default，它的作用是：当监听的多个事件都阻塞住会执行default的逻辑</p>
<p>使用select case ,ok实现goroutine的优雅退出</p>
<ul>
<li>使用for-range退出</li>
<li>使用select case ,ok退出</li>
<li>使用退出通道退出</li>
</ul>
<h4 id="40-Go值接收者和指针接收者的区别"><a href="#40-Go值接收者和指针接收者的区别" class="headerlink" title="40. Go值接收者和指针接收者的区别"></a><font color=DarkOrange>40. Go值接收者和指针接收者的区别</font></h4><p>Go中的方法能给用户自定义的类型添加新的行为。它和函数的区别在于方法有一个接收者，给一个函数添加一个接收者，那么它就变成了方法。接收者可以是值接收者，也可以是指针接收者</p>
<p>在调用方法的时候，值类型既可以调用值接收者的方法，也可以调用指针接收者的方法；指针类型既可以调用指针接收者的方法，也可以调用值接收者的方法。也就是说，不管方法的接收者是什么类型，该类型的值和指针都可以调用，不必严格符合接收者的类型</p>
<table>
<thead>
<tr>
<th align="left">函数和方法</th>
<th align="left">值接收者</th>
<th align="left">指针接收者</th>
</tr>
</thead>
<tbody><tr>
<td align="left">值类型调用者</td>
<td align="left">方法会使用调用者的一个副本，类似于“传值”</td>
<td align="left">使用值的引用来调用方法，上例中，p1.GetAge() 实际上是 (&amp;p1).GetAge()</td>
</tr>
<tr>
<td align="left">指针类型调用者</td>
<td align="left">指针被解引用为值，上例中，p2.GetAge()实际上是 (*p1).GetAge()</td>
<td align="left">实际上也是“传值”，方法里的操作会影响到调用者，类似于指针传参，拷贝了一份指针</td>
</tr>
</tbody></table>
<p>如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法</p>
<p>如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身</p>
<p>通常我们使用指针作为方法的接收者的理由：</p>
<ul>
<li>使用指针方法能够修改接收者指向的值。</li>
<li>可以避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效</li>
</ul>
<p>因而，我们是使用值接收者还是指针接收者，不是由该方法是否修改了调用者（也就是接收者）来决定，而是应该基于该类型的本质</p>
<h4 id="41-Go中两个Nil可能不相等吗"><a href="#41-Go中两个Nil可能不相等吗" class="headerlink" title="41. Go中两个Nil可能不相等吗"></a><font color=DarkOrange>41. Go中两个Nil可能不相等吗</font></h4><p>Go中两个Nil可能不相等</p>
<p>接口(interface) 是对非接口值(例如指针，struct等)的封装，内部实现包含 2 个字段，类型 T 和 值 V。一个接口等于 nil，当且仅当 T 和 V 处于 unset 状态（T&#x3D;nil，V is unset）。两个接口值比较时，会先比较 T，再比较 V。接口值与非接口值比较时，会先将非接口值尝试转换为接口值，再比较</p>
<h4 id="42-Golang垃圾回收算法"><a href="#42-Golang垃圾回收算法" class="headerlink" title="42. Golang垃圾回收算法"></a><font color=DarkOrange>42. Golang垃圾回收算法</font></h4><p>Golang1.5版本后，采取的是“非分代的、非移动的、并发的、三色的”标记清除垃圾回收算法</p>
<p>垃圾回收算法分类：</p>
<ul>
<li>引用计数</li>
<li>标记-清除</li>
<li>分代回收</li>
</ul>
<p>golang的垃圾回收是基于标记清扫算法，这种算法需要进行 STW（stop the world)，这个过程就会导致程序是卡顿的，频繁的 GC 会严重影响程序性能，golang在此基础上进行了改进，通过三色标记清扫法与写屏障来减少STW的时间</p>
<p>gc的过程一共分为四个阶段：</p>
<ol>
<li>栈扫描（开始时STW） 所有对象最开始都是白色</li>
<li>从 root 开始找到所有可达对象，标记为灰色，放入待处理队列</li>
<li>遍历灰色对象队列，将其引用对象标记为灰色放入待处理队列，自身标记为黑色</li>
<li>清除（并发） 循环步骤3直到灰色队列为空为止，此时所有引用对象都被标记为黑色，所有不可达的对象依然为白色，白色的就是需要进行回收的对象</li>
</ol>
<p>三色标记法相对于普通标记清扫，减少了STW时间. 这主要得益于标记过程是 “on-the-fly” 的，在标记过程中是不需要STW的，它与程序是并发执行的，这就大大缩短了STW的时间</p>
<p>写屏障：</p>
<ul>
<li>当标记和程序是并发执行的，这就会造成一个问题. 在标记过程中，有新的引用产生，可能会导致误清扫</li>
<li>清扫开始前，标记为黑色的对象引用了一个新申请的对象，它肯定是白色的，而黑色对象不会被再次扫描，那么这个白色对象无法被扫描变成灰色、黑色，它就会最终被清扫，而实际它不应该被清扫</li>
<li>golang采用了写屏障，其作用就是为了避免这类误清扫问题. 写屏障即在内存写操作前，维护一个约束，从而确保清扫开始前，黑色的对象不能引用白色对象</li>
</ul>
<h4 id="43-GC的触发条件"><a href="#43-GC的触发条件" class="headerlink" title="43. GC的触发条件"></a><font color=DarkOrange>43. GC的触发条件</font></h4><ul>
<li>主动触发(手动触发)，通过调用<code>runtime.GC</code> 来触发<code>GC</code>，此调用阻塞式地等待当前<code>GC</code>运行完毕</li>
<li>被动触发，分为两种方式：<ul>
<li>使用系统监控，当超过两分钟没有产生任何<code>GC</code>时，强制触发 <code>GC</code></li>
<li>使用步调（Pacing）算法，其核心思想是控制内存增长的比例，当前内存分配达到一定比例则触发</li>
</ul>
</li>
</ul>
<h4 id="44-Go中的http包的实现原理"><a href="#44-Go中的http包的实现原理" class="headerlink" title="44. Go中的http包的实现原理"></a><font color=DarkOrange>44. Go中的http包的实现原理</font></h4><p>Golang中http包中处理 HTTP 请求主要跟两个东西相关：ServeMux 和 Handler</p>
<p>ServeMux 本质上是一个 HTTP 请求路由器（或者叫多路复用器，Multiplexor）。它把收到的请求与一组预先定义的 URL 路径列表做对比，然后在匹配到路径的时候调用关联的处理器（Handler）</p>
<p>处理器（Handler）负责输出HTTP响应的头和正文。任何满足了http.Handler接口的对象都可作为一个处理器。通俗的说，对象只要有个如下签名的ServeHTTP方法即可</p>
<p>Go 语言的 HTTP 包自带了几个函数用作常用处理器，比如<code>FileServer</code>，<code>NotFoundHandler</code> 和 <code>RedirectHandler</code></p>
<h4 id="45-Go中的defer函数使用下面的两种情况下结果是什么"><a href="#45-Go中的defer函数使用下面的两种情况下结果是什么" class="headerlink" title="45. Go中的defer函数使用下面的两种情况下结果是什么"></a><font color=DarkOrange>45. Go中的defer函数使用下面的两种情况下结果是什么</font></h4><p>无</p>
<hr>
<h4 id="1-Go项目性能测试、压测"><a href="#1-Go项目性能测试、压测" class="headerlink" title="1. Go项目性能测试、压测"></a><font color=DarkOrange>1. Go项目性能测试、压测</font></h4><ol>
<li>单元测试，以<code>Test</code>开头，在需要测试的包路径内执行<code>go test</code>对该包进行测试</li>
<li>性能测试，以<code>Benchmark</code>开头，<code>go test</code>默认不会执行压力测试函数，需要通过指定参数<code>-test.bench</code>来运行压力测试函数，<code>-test.bench</code>后跟正则表达式，如：<code>go -test.bench=&quot;.*&quot;</code>表示执行所有的压力测试函数</li>
<li>测试覆盖率，<code>cover</code>工具，<code>go test -coverprofile=cover.out</code>，在测试文件目录下运行并统计测试覆盖率</li>
<li>性能分析，<code>pprof</code>进行性能分析</li>
<li>使用<code>Jmeter</code>做<code>Web</code>性能测试</li>
</ol>
<p>API性能测试指标，主要有3个：</p>
<ol>
<li>并发数（<code>Concurrent</code>），是指某个时间范围内，同时正在使用系统的用户数</li>
<li>每秒查询数（<code>QPS</code>），是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，<code>QPS</code>&#x3D;并发数&#x2F;平均请求响应时间，在说<code>QPS</code>时需要指明多少并发数下的<code>QPS</code>，因为不同并发数下<code>QPS</code>是不同的</li>
<li>请求响应时间（<code>TTLB</code>），是从客户端发出请求到得到响应的整个时间</li>
</ol>
<hr>
<h4 id="2-下面2个函数分别输出什么结果"><a href="#2-下面2个函数分别输出什么结果" class="headerlink" title="2. 下面2个函数分别输出什么结果"></a><font color=DarkOrange>2. 下面2个函数分别输出什么结果</font></h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> (a <span class="type">int</span>) &#123;</span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		a += <span class="number">1</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 函数的返回值是(a int)</span></span><br><span class="line">	<span class="comment">// return语句不是原子操作，1.给返回值赋值，2.调用defer表达式，3.返回给调用函数</span></span><br><span class="line">	<span class="comment">// defer遵循先进后出，return时，先把100赋值给a，然后a执行了defer func()+1操作</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	a := <span class="number">1</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		a += <span class="number">1</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 函数返回的是int类型的数，没指定返回的一定是a，所以直接返回return后面的数字</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(A()) <span class="comment">// 101</span></span><br><span class="line">	<span class="built_in">println</span>(B()) <span class="comment">// 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h82o60shgaj312i0x2wn7.jpg" alt="image.png" style="zoom:55%;" /></div>

<h4 id="3-Go面向对象"><a href="#3-Go面向对象" class="headerlink" title="3. Go面向对象"></a><font color=DarkOrange>3. Go面向对象</font></h4><p>面向对象的三大基本特性：<strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong></p>
<ul>
<li>封装<ul>
<li>面向对象中的 “封装” 指的是可以隐藏对象的内部属性和实现细节，仅对外提供公开接口调用，这样子用户就不需要关注你内部是怎么实现的</li>
<li>在 Go 语言中的属性访问权限，通过首字母大小写来控制：<ul>
<li>首字母大写，代表是公共的，可被外部访问的</li>
<li>首字母小写，代表是私有的，不可以被外部访问</li>
</ul>
</li>
</ul>
</li>
<li>继承<ul>
<li>面向对象中的 “继承” 指的是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为</li>
<li>继承是编译时特征，在<code>struct</code>内加入所需要继承的类即可</li>
</ul>
</li>
<li>多态<ul>
<li>面向对象中的 “多态” 指的同一个行为具有多种不同表现形式或形态的能力，具体是指一个类实例（对象）的相同方法在不同情形有不同表现形式</li>
<li>多态也使得不同内部结构的对象可以共享相同的外部接口，也就是都是一套外部模板，内部实际是什么，只要符合规格就可以</li>
<li>多态是运行时特征，在 Go 语言中，多态是通过接口<code>interface</code>来实现的，类型和接口是松耦合的，某个类型的实例可以赋给它所实现的任意接口类型的变量</li>
</ul>
</li>
</ul>
<h4 id="4-Go编写HTTP服务器"><a href="#4-Go编写HTTP服务器" class="headerlink" title="4. Go编写HTTP服务器"></a><font color=DarkOrange>4. Go编写HTTP服务器</font></h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, HelloHandler)</span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;:8000&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行代码之后，在浏览器中打开<code>localhost:8000</code>就可以看到<code>Hello World</code>。这段代码先利用<code>http.HandleFunc</code>在根路由<code>/</code>上注册了一个<code>HelloHandler</code>，然后利用<code>http.ListenAndServe</code>启动服务器并监听本地的 8000 端口。当有请求过来时，则根据路由执行对应的<code>handler</code>函数</p>
<p>参考链接：<a href="https://cloud.tencent.com/developer/article/1584872">点击跳转</a></p>
<h4 id="5-Gin示例"><a href="#5-Gin示例" class="headerlink" title="5. Gin示例"></a><font color=DarkOrange>5. Gin示例</font></h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个默认的路由引擎</span></span><br><span class="line">	r := gin.Default()</span><br><span class="line">	<span class="comment">// GET：请求方式；/hello：请求的路径</span></span><br><span class="line">	<span class="comment">// 当客户端以GET方法请求/hello路径时，会执行后面的匿名函数</span></span><br><span class="line">	r.GET(<span class="string">&quot;api/v1/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// c.JSON：返回JSON格式的数据</span></span><br><span class="line">		c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// 启动HTTP服务，默认在0.0.0.0:8080启动服务</span></span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-TX代码分析"><a href="#6-TX代码分析" class="headerlink" title="6. TX代码分析"></a><font color=DarkOrange>6. TX代码分析</font></h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*student)</span><br><span class="line">	stus := []student&#123;</span><br><span class="line">		&#123;name: <span class="string">&quot;张三&quot;</span>, age: <span class="number">18</span>&#125;, &#123;name: <span class="string">&quot;李四&quot;</span>, age: <span class="number">23</span>&#125;, &#123;name: <span class="string">&quot;王五&quot;</span>, age: <span class="number">26</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, stu := <span class="keyword">range</span> stus &#123;</span><br><span class="line">		m[stu.name] = &amp;stu</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		fmt.Println(k, <span class="string">&quot;=&gt;&quot;</span>, v.name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码创建了一个结构体类型 <code>student</code>，包含两个字段 <code>name</code> 和 <code>age</code>。然后在 <code>main</code> 函数中，创建了一个空的映射 <code>m</code>，并且创建了一个切片 <code>stus</code>，其中包含了三个 <code>student</code> 类型的值</p>
<p>接下来的循环将 <code>stus</code> 中的每个元素的指针存储到映射 <code>m</code> 的键值对中，键是 <code>student</code> 的 <code>name</code> 字段，值是 <code>student</code> 的指针</p>
<p>然而，由于 Go 语言中的循环变量是重用的，因此每次迭代时，变量 <code>stu</code> 的地址都是相同的，也就是指向同一个 <code>student</code> 对象的地址。因此，无论循环的键值对如何分配，最终映射 <code>m</code> 中的每个键值对都将包含指向 <code>stus</code> 切片中最后一个元素的指针</p>
<p>最后，代码打印出了映射 <code>m</code> 的内容，并遍历了映射 <code>m</code> 的每个键值对，并输出每个键和对应值的 <code>name</code> 字段。由于每个键值对的值都是指向 <code>stus</code> 切片中最后一个元素的指针，因此在输出时，它们都将显示为最后一个元素的 <code>name</code> 字段。因此，输出将为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">张三 =&gt; 王五</span><br><span class="line">李四 =&gt; 王五</span><br><span class="line">王五 =&gt; 王五</span><br></pre></td></tr></table></figure>

<p>为了修复这个问题，可以在循环中使用 <code>stu</code> 的副本来解决。修改后的代码如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*student)</span><br><span class="line">	stus := []student&#123;</span><br><span class="line">		&#123;name: <span class="string">&quot;张三&quot;</span>, age: <span class="number">18</span>&#125;, &#123;name: <span class="string">&quot;李四&quot;</span>, age: <span class="number">23</span>&#125;, &#123;name: <span class="string">&quot;王五&quot;</span>, age: <span class="number">26</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> stus &#123;</span><br><span class="line">		stu := &amp;stus[i] <span class="comment">// 使用stu的副本</span></span><br><span class="line">		m[stu.name] = stu</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		fmt.Println(k, <span class="string">&quot;=&gt;&quot;</span>, v.name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">张三 =&gt; 张三</span><br><span class="line">李四 =&gt; 李四</span><br><span class="line">王五 =&gt; 王五</span><br></pre></td></tr></table></figure>

<h4 id="7-goroutine-chan交替打印ping-x2F-pong"><a href="#7-goroutine-chan交替打印ping-x2F-pong" class="headerlink" title="7. goroutine+chan交替打印ping&#x2F;pong"></a><font color=DarkOrange>7. goroutine+chan交替打印ping&#x2F;pong</font></h4><p>题目：用两goroutine+chan实现ping&#x2F;pong 的交替输出。一个 goroutine print ping，一个goroutine print Pong</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	pingChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">	pongChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// goroutine to print &quot;ping&quot;</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			&lt;-pingChan</span><br><span class="line">			fmt.Println(<span class="string">&quot;ping&quot;</span>)</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">			pongChan &lt;- <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// goroutine to print &quot;pong&quot;</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			&lt;-pongChan</span><br><span class="line">			fmt.Println(<span class="string">&quot;pong&quot;</span>)</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">			pingChan &lt;- <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// start the ping-pong game</span></span><br><span class="line">	pingChan &lt;- <span class="literal">true</span></span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建了两个通道 <code>pingChan</code> 和 <code>pongChan</code>。然后我们创建了两个匿名的goroutine，一个用于打印”ping”，另一个用于打印”pong”。这两个goroutine都使用无限循环，不断等待在通道上的信号。当接收到信号后，它们会打印相应的字符串，然后通过另一个通道发送信号，使另一个goroutine开始工作。最后，我们通过向 <code>pingChan</code> 发送一个初始信号来启动整个游戏。由于这是一个无限循环，我们使用 <code>select&#123;&#125;</code> 来阻止程序退出</p>
<h4 id="8-多协程统计10000内的素数"><a href="#8-多协程统计10000内的素数" class="headerlink" title="8. 多协程统计10000内的素数"></a><font color=DarkOrange>8. 多协程统计10000内的素数</font></h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 要检查的最大数</span></span><br><span class="line">	n := <span class="number">10000</span></span><br><span class="line">	<span class="comment">// 创建一个有缓冲的通道，用于存储要检查的数字</span></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, n)</span><br><span class="line">	<span class="comment">// 创建一个无缓冲的通道，用于存储每个goroutine计算的素数个数</span></span><br><span class="line">	res := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向通道中发送2到10000之间的所有整数</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		ch &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 关闭通道</span></span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建10个goroutine并行检查数字是否是素数</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">// 计数器，用于统计当前goroutine检查出的素数个数</span></span><br><span class="line">			cnt := <span class="number">0</span></span><br><span class="line">			<span class="comment">// 不断从通道中读取数字，直到通道关闭</span></span><br><span class="line">			<span class="keyword">for</span> num := <span class="keyword">range</span> ch &#123;</span><br><span class="line">				<span class="comment">// 检查数字是否是素数</span></span><br><span class="line">				<span class="keyword">if</span> isPrime(num) &#123;</span><br><span class="line">					cnt++</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 将计数器的值发送到res通道中</span></span><br><span class="line">			res &lt;- cnt</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 统计所有goroutine计算出的素数个数之和</span></span><br><span class="line">	total := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		total += &lt;-res</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印总素数个数</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Total prime numbers:&quot;</span>, total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个数字是否是素数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPrime</span><span class="params">(num <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> num &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">2</span>; i*i &lt;= num; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> num%i == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码输出：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Total prime numbers: 1229</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们使用一个有缓冲的通道 <code>ch</code> 来存储要检查的数字。我们向这个通道发送2到10000之间的所有整数。然后，我们使用10个goroutine并行读取通道中的数字，并使用 <code>isPrime</code> 函数检查它们是否是素数。如果是素数，我们就将计数器 <code>cnt</code> 加1。每个goroutine都在处理完通道中的数字后，将计数器 <code>cnt</code> 的值发送到 <code>res</code> 通道中</p>
<p>最后，我们在主goroutine中读取 <code>res</code> 通道中的所有值，将它们相加，并打印总素数的数量</p>
<p><strong>注意：</strong>这个例子中使用了一个固定的数字10来指定使用的goroutine数量，这不一定是最优的值，实际的最优值可能因系统配置和其它因素而异。如果要优化性能，可以尝试不同的goroutine数量，并找到最快的方式来计算素数</p>
<hr>
<p>知乎Golang面试题总结链接：<a href="https://zhuanlan.zhihu.com/p/471490292">点击跳转</a></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><font color=DarkOrange>总结</font></h4><p>Go面试复习应该有所侧重，关注切片，通道，异常处理，Goroutine，GMP模型，字符串高效拼接，指针，反射，接口，sync。对于比较难懂的部分，GMP模型和GC和内存管理，应该主动去看<strong>源码</strong>，然后慢慢理解。业务代码写多了，自然就有理解了</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis面试题</title>
    <url>/2022/10/28/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>Redis面试常见问题汇总</p>
<h4 id="1-Redis的数据结构及使用场景"><a href="#1-Redis的数据结构及使用场景" class="headerlink" title="1. Redis的数据结构及使用场景"></a><font color=DarkOrange>1. Redis的数据结构及使用场景</font></h4><ul>
<li><p>String字符串</p>
<p>字符串类型是 Redis 最基础的数据结构，首先键都是字符串类型，而且 其他几种数据结构都是在字符串类型基础上构建的，我们常使用的 set key value 命令就是字符串。常用在缓存、计数、共享Session、限速等</p>
</li>
</ul>
<hr>
<ul>
<li><p>Hash哈希</p>
<p>在Redis中，哈希类型是指键值本身又是一个键值对结构，哈希可以用来存放用户信息，比如实现购物车</p>
</li>
</ul>
<hr>
<ul>
<li><p>List列表（双向链表）</p>
<p>列表（list）类型是用来存储多个有序的字符串。可以做简单的消息队列的功能</p>
</li>
</ul>
<hr>
<ul>
<li><p>Set集合</p>
<p>集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一 样的是，集合中不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素。利用 Set 的交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能</p>
</li>
</ul>
<hr>
<ul>
<li><p>Sorted Set有序集合（跳表实现）</p>
<p>Sorted Set 多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。可以做排行榜应用，取 TOP N 操作</p>
</li>
</ul>
<h4 id="2-Redis持久化的几种方式"><a href="#2-Redis持久化的几种方式" class="headerlink" title="2. Redis持久化的几种方式"></a><font color=DarkOrange>2. Redis持久化的几种方式</font></h4><p>Redis为了保证效率，数据缓存在了内存中，但是会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中，以保证数据的持久化。Redis的持久化策略有两种：</p>
<ul>
<li><strong>RDB：</strong> 快照形式是直接把内存中的数据保存到一个dump的文件中，定时保存，保存策略<ul>
<li>当Redis需要做持久化时，Redis会fork一个子进程，子进程将数据写到磁盘上一个临时RDB文件中。当子进程完成写临时文件后，将原来的RDB替换掉</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>AOF：</strong> 把所有的对Redis的服务器进行修改的命令都存到一个文件里，命令的集合<ul>
<li>使用AOF做持久化，每一个写命令都通过write函数追加到<code>appendonly.aof</code>中</li>
<li>aof的默认策略是每秒钟fsync一次，在这种配置下，就算发生故障停机，也最多丢失一秒钟的数据</li>
<li>缺点是对于相同的数据集来说，AOF的文件体积通常要大于RDB文件的体积。根据所使用的fsync策略，AOF的速度可能会慢于RDB</li>
</ul>
</li>
</ul>
<p>Redis默认是快照RDB的持久化方式。对于主从同步来说，主从刚刚连接的时候，进行全量同步（RDB），全同步结束后，进行增量同步(AOF)</p>
<h4 id="3-Redis的LRU具体实现"><a href="#3-Redis的LRU具体实现" class="headerlink" title="3. Redis的LRU具体实现"></a><font color=DarkOrange>3. Redis的LRU具体实现</font></h4><ul>
<li>传统的LRU是使用栈的形式，每次都将最新使用的移入栈顶，但是用栈的形式会导致执行<code>select *</code>的时候大量非热点数据占领头部数据，所以需要改进</li>
<li>Redis每次按key获取一个值的时候，都会更新value中的lru字段为当前秒级别的时间戳。Redis初始的实现算法很简单，随机从dict中取出五个key，淘汰一个lru字段值最小的</li>
<li>在3.0的时候，又改进了一版算法，首先第一次随机选取的key都会放入一个pool中(pool的大小为16)，pool中的key是按lru大小顺序排列的</li>
<li>接下来每次随机选取的keylru值必须小于pool中最小的lru才会继续放入，直到将pool放满。放满之后，每次如果有新的key需要放入，需要将pool中lru最大的一个key取出。淘汰的时候，直接从pool中选取一个lru最小的值然后将其淘汰</li>
</ul>
<h4 id="4-单线程的Redis为什么快"><a href="#4-单线程的Redis为什么快" class="headerlink" title="4. 单线程的Redis为什么快"></a><font color=DarkOrange>4. 单线程的Redis为什么快</font></h4><ul>
<li>纯内存操作</li>
<li>单线程操作，避免了频繁的上下文切换</li>
<li>合理高效的数据结构</li>
<li>采用了非阻塞I&#x2F;O多路复用机制</li>
</ul>
<h4 id="5-Redis的数据过期策略"><a href="#5-Redis的数据过期策略" class="headerlink" title="5. Redis的数据过期策略"></a><font color=DarkOrange>5. Redis的数据过期策略</font></h4><p>Redis 中数据过期策略采用<strong>定期删除</strong>和<strong>惰性删除</strong>策略：</p>
<ul>
<li>定期删除策略<ul>
<li>Redis 启用一个定时器定时监视所有的 key，判断key是否过期，过期的话就删除</li>
<li>这种策略可以保证过期的 key 最终都会被删除，但是也存在严重的缺点：每次都遍历内存中所有的数据，非常消耗 CPU资源，并且当 key 已过期，但是定时器还处于未唤起状态，这段时间内 key 仍然可以用</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>惰性删除策略<ul>
<li>在获取 key 时，先判断 key 是否过期，如果过期则删除</li>
<li>这种方式存在一个缺点：如果这个 key一直未被使用，那么它一直在内存中，其实它已经过期了，会浪费大量的空间</li>
</ul>
</li>
</ul>
<p>这两种策略天然的互补，结合起来之后，定时删除策略就发生了一些改变，不在是每次扫描全部的 key 了，而是随机抽取一部分 key 进行检查，这样就降低了对 CPU 资源的损耗，惰性删除策略互补了为检查到的key，基本上满足了所有要求</p>
<p>但是有时候就是那么的巧，既没有被定时器抽取到，又没有被使用，这些数据又如何从内存中消失？这个时候就需要用到了，内存淘汰机制</p>
<h5 id="5-1-内存淘汰机制"><a href="#5-1-内存淘汰机制" class="headerlink" title="5.1 内存淘汰机制"></a><font color=DarkOrange>5.1 内存淘汰机制</font></h5><ul>
<li>当内存不足以容纳新写入数据时，新写入操作会报错。（Redis 默认策略）</li>
<li>当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。（LRU推荐使用）</li>
<li>当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key</li>
<li>当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用</li>
<li>当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key</li>
<li>当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除</li>
</ul>
<h4 id="6-如何解决Redis缓存雪崩问题"><a href="#6-如何解决Redis缓存雪崩问题" class="headerlink" title="6. 如何解决Redis缓存雪崩问题"></a><font color=DarkOrange>6. 如何解决Redis缓存雪崩问题</font></h4><ul>
<li>使用 Redis 高可用架构：使用 Redis 集群来保证 Redis 服务不会挂掉</li>
<li>缓存时间不一致，给缓存的失效时间，加上一个随机值，避免集体失效</li>
<li>限流降级策略：有一定的备案，比如个性推荐服务不可用了，换成热点数据推荐服务</li>
</ul>
<h4 id="7-如何解决Redis缓存穿透问题"><a href="#7-如何解决Redis缓存穿透问题" class="headerlink" title="7. 如何解决Redis缓存穿透问题"></a><font color=DarkOrange>7. 如何解决Redis缓存穿透问题</font></h4><ul>
<li>在接口层做校验</li>
<li>存null值（缓存击穿加锁）</li>
<li>布隆过滤器拦截：将所有可能的查询key 先映射到布隆过滤器中，查询时先判断key是否存在布隆过滤器中，存在才继续向下执行，如果不存在，则直接返回<br>布隆过滤器将值进行多次哈希bit存储，布隆过滤器说某个元素在，可能会被误判。布隆过滤器说某个元素不在，那么一定不在</li>
</ul>
<h4 id="8-Redis并发竞争key如何解决"><a href="#8-Redis并发竞争key如何解决" class="headerlink" title="8. Redis并发竞争key如何解决"></a><font color=DarkOrange>8. Redis并发竞争key如何解决</font></h4><ul>
<li>可以利用分布式锁和时间戳来解决</li>
<li>利用消息队列解决</li>
</ul>
<h4 id="9-Redis的主从模式和哨兵模式和集群模式区别"><a href="#9-Redis的主从模式和哨兵模式和集群模式区别" class="headerlink" title="9. Redis的主从模式和哨兵模式和集群模式区别"></a><font color=DarkOrange>9. Redis的主从模式和哨兵模式和集群模式区别</font></h4><p>Redis集群方式共有三种：<strong>主从模式</strong>，<strong>哨兵模式</strong>，<strong>集群(cluster)模式</strong></p>
<ul>
<li><p>主从模式</p>
<p>主从模式是三种集群方式里最简单的。它主要是基于Redis的主从复制特性架构的。通常我们会设置一个主节点，N个从节点；默认情况下，主节点负责处理使用者的IO操作，而从节点则会对主节点的数据进行备份，并且也会对外提供读操作的处理。主要的特点如下：</p>
<ul>
<li>主从模式下，当某一节点损坏时，因为其会将数据备份到其它Redis实例上，这样做在很大程度上可以恢复丢失的数据</li>
<li>主从模式下，可以保证负载均衡.</li>
<li>主从模式下，主节点和从节点是读写分离的。使用者不仅可以从主节点上读取数据，还可以很方便的从从节点上读取到数据，这在一定程度上缓解了主机的压力</li>
</ul>
<p>从节点也是能够支持写入数据的，只不过从从节点写入的数据不会同步到主节点以及其它的从节点下。从以上，我们不难看出Redis在主从模式下，必须保证主节点不会宕机——一旦主节点宕机，其它节点不会竞争称为主节点，此时，Redis将丧失写的能力。这点在生产环境中，是致命的</p>
</li>
</ul>
<hr>
<ul>
<li><p>哨兵模式</p>
<p>哨兵模式是基于主从模式做的一定变化，它能够为Redis提供了高可用性</p>
<p>在实际生产中，服务器难免不会遇到一些突发状况：服务器宕机，停电，硬件损坏等。这些情况一旦发生，其后果往往是不可估量的</p>
<p>而哨兵模式在一定程度上能够帮我们规避掉这些意外导致的灾难性后果。其实，哨兵模式的核心还是主从复制</p>
<p>只不过相对于主从模式在主节点宕机导致不可写的情况下，多了一个竞选机制——从所有的从节点竞选出新的主节点。竞选机制的实现，是依赖于在系统中启动一个sentinel进程。sentinel特点：</p>
<ul>
<li>监控：它会监听主服务器和从服务器之间是否在正常工作</li>
<li>通知：它能够通过API告诉系统管理员或者程序，集群中某个实例出了问题。</li>
<li>故障转移：它在主节点出了问题的情况下，会在所有的从节点中竞选出一个节点，并将其作为新的主节点。</li>
<li>提供主服务器地址：它还能够向使用者提供当前主节点的地址。这在故障转移后，使用者不用做任何修改就可以知道当前主节点地址</li>
</ul>
<p>sentinel，也可以集群，部署多个哨兵，sentinel可以通过发布与订阅来自动发现Redis集群上的其它sentinel。sentinel在发现其它sentinel进程后，会将其放入一个列表中，这个列表存储了所有已被发现的sentinel</p>
<p>集群中的所有sentinel不会并发着去对同一个主节点进行故障转移。故障转移只会从第一个sentinel开始，当第一个故障转移失败后，才会尝试下一个</p>
<p>当选择一个从节点作为新的主节点后，故障转移即成功了(而不会等到所有的从节点配置了新的主节点后)。这过程中，如果重启了旧的主节点，那么就会出现无主节点的情况，这种情况下，只能重启集群</p>
<p>当竞选出新的主节点后，被选为新的主节点的从节点的配置信息会被sentinel改写为旧的主节点的配置信息。完成改写后，再将新主节点的配置广播给所有的从节点</p>
</li>
</ul>
<hr>
<ul>
<li><p>集群模式</p>
<p>Redis 集群是一个提供在多个Redis间节点间共享数据的程序集， 其中Redis集群分为主节点和从节点。主节点用于处理槽，而从节点用于复制某个主节点，并在被复制的主节点下线时，代替下线的主节点继续处理命令请求</p>
<p>Redis集群并不支持处理多个keys的命令，因为这需要在不同的节点间移动数据，从而达不到像Redis那样的性能，在高负载的情况下可能会导致不可预料的错误</p>
<p>Redis 集群通过分区来提供一定程度的可用性，在实际环境中当某个节点宕机或者不可达的情况下继续处理命令. Redis 集群的优势：自动分割数据到不同的节点上</p>
<p>整个集群的部分节点失败或者不可达的情况下能够继续处理命令</p>
<p>Redis集群的数据分片 Redis 集群没有使用一致性hash， 而是引入了哈希槽的概念</p>
<p>Redis 集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽</p>
</li>
</ul>
<h4 id="10-单机、主从、哨兵、集群模式优缺点"><a href="#10-单机、主从、哨兵、集群模式优缺点" class="headerlink" title="10. 单机、主从、哨兵、集群模式优缺点"></a><font color=DarkOrange>10. 单机、主从、哨兵、集群模式优缺点</font></h4><h5 id="10-1-单机模式"><a href="#10-1-单机模式" class="headerlink" title="10.1 单机模式"></a><font color=DarkOrange>10.1 单机模式</font></h5><p>Redis 单副本，采用单个 Redis 节点部署架构，没有备用节点实时同步数据，不提供数据持久化和备份策略，适用于数据可靠性要求不高的纯缓存业务场景</p>
<p><strong>优点：</strong></p>
<ul>
<li>架构简单，部署方便</li>
<li>高性价比：缓存使用时无需备用节点(单实例可用性可以用 supervisor 或 crontab 保证)，当然为了满足业务的高可用性，也可以牺牲一个备用节点，但同时刻只有一个实例对外提供服务</li>
<li>高性能</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>不保证数据的可靠性</li>
<li>在缓存使用，进程重启后，数据丢失，即使有备用的节点解决高可用性，但是仍然不能解决缓存预热问题，因此不适用于数据可靠性要求高的业务</li>
<li>高性能受限于单核 CPU 的处理能力(Redis 是单线程机制)，CPU 为主要瓶颈，所以适合操作命令简单，排序、计算较少的场景。也可以考虑用 Memcached 替代</li>
</ul>
<h5 id="10-2-主从模式"><a href="#10-2-主从模式" class="headerlink" title="10.2 主从模式"></a><font color=DarkOrange>10.2 主从模式</font></h5><p>主（master）和 从（slave）部署在不同的服务器上，当主节点服务器写入数据时会同步到从节点的服务器上，一般主节点负责写入数据，从节点负责读取数据</p>
<blockquote>
<p><strong>从节点设置只读属性，而主节点没有只写属性，因此，主节点可读可以写</strong></p>
</blockquote>
<p><strong>优点：</strong></p>
<ul>
<li><p>读写分离，提高效率</p>
<p>主节点负责写操作，从节点负责读操作；如果写少读多场景，配置多个从节点的话，效率非常高</p>
</li>
<li><p>数据热备份，提供多个副本</p>
<p>从节点宕机，影响较小</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>主节点故障，集群则无法进行工作，可用性比较低，从节点升主节点需要人工手动干预</p>
<p>因为只有主节点能进行写操作，一旦主节点宕机，整个服务就无法使用。当然此时从节点仍可以进行读操作，但是对于整个服务流程来说，是无法使用的</p>
</li>
<li><p>Master的写的压力难以降低</p>
<p>如果写操作比较多，那么只有一个主节点的话，无法分担压力</p>
</li>
<li><p>主节点存储能力受到单击限制</p>
<p>主节点只能有一个，因此单节点内存大小不会太大，因此存储数据量受限</p>
</li>
<li><p>主从数据同步，可能产生部分的性能影响甚至同步风暴</p>
<p>风暴问题，对于任何集群分布式来说都存在，要合理分布节点</p>
</li>
</ul>
<h5 id="10-3-哨兵模式"><a href="#10-3-哨兵模式" class="headerlink" title="10.3 哨兵模式"></a><font color=DarkOrange>10.3 哨兵模式</font></h5><p>为了解决这两个问题，在2.8版本之后redis正式提供了sentinel架构</p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8evssatocj30i30bwq48.jpg" alt="image.png" style="zoom:67%;" /></div>

<p>在redis3.0以前的版本要实现集群一般是借助哨兵sentinel工具来监控master节点的状态</p>
<p>如果master节点异常，则会做主从切换，将某一台slave作为master，哨兵的配置略微复杂，并且性能和高可用性等各方面表现一般</p>
<p><strong>优点：</strong></p>
<ul>
<li>对节点进行监控，来完成自动的故障发现与转移</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>特别是在主从切换的瞬间存在访问瞬断的情况，等待时间比较长，至少十来秒不可用</li>
<li>哨兵模式只有一个主节点对外提供服务，没法支持很高的并发</li>
<li>单个主节点内存也不宜设置得过大，否则会导致持久化文件过大，影响数据恢复或主从同步的效率</li>
</ul>
<p><strong>与主从相比，哨兵仅解决了手动切换主从节点问题，至于其他的问题，基本上仍然存在</strong></p>
<p><strong>哨兵的主要问题还是由于中心架构，仅存在一个master节点引起的，写的效率太低</strong></p>
<h5 id="10-4-集群模式"><a href="#10-4-集群模式" class="headerlink" title="10.4 集群模式"></a><font color=DarkOrange>10.4 集群模式</font></h5><p>Redis Cluster 是 3.0 版后推出的 Redis 分布式集群解决方案，主要解决 Redis 分布式方面的需求，比如，当遇到单机内存，并发和流量等瓶颈的时候，Redis Cluster 能起到很好的负载均衡的目的</p>
<p>Redis Cluster 集群节点<font color=Red><strong>最小配置 6 个节点以上(3 主 3 从)</strong></font>，其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。Redis Cluster 采用虚拟槽分区，所有的键根据哈希函数映射到 0～16383 个整数槽内，每个节点负责维护一部分槽以及槽所印映射的键值数据</p>
<blockquote>
<p>注意：集群模式下 从节点不提供读写，与主从模式不一样。 总结一下经验，分布式 场景下：集群模式一般从节点不参与读写，仅作为备用节点。而主从一般都要负责读或写，都要参与具体的工作</p>
</blockquote>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8evydq8vhj30fk0dfdk7.jpg" alt="image.png" style="zoom:80%;" /></div>

<p> <strong>优点：</strong></p>
<ul>
<li><p>无中心架构</p>
<p>即有多个master节点，不像哨兵模式下仅有一个。这样写的压力就可以分散了；并且存储量也可以扩展了，因为多个主节点都可以存储一部分数据，总量要远大于单主节点架构</p>
</li>
<li><p>数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布</p>
</li>
<li><p>可扩展性：可线性扩展到 1000 多个节点，<code>节点可动态添加或删除</code></p>
</li>
<li><p>高可用性：部分节点不可用时，集群仍可用。通过增加 Slave 做 standby 数据副本，能够 实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave 到 Master 的角色提升</p>
</li>
</ul>
<blockquote>
<p>当然，如果某个槽归属的小群内都不可用时，整个服务仍然是不可用的！通过cluster-require-full-coverageyes 控制该特性， 默认yes 即需要集群完整，方可对外提供服务，设置为no ，其他的小集群仍然可以对外提供服务</p>
</blockquote>
<p><strong>缺点：</strong></p>
<ul>
<li>如果主节点A和它的从节点A1都宕机了，那么该集群就无法再提供服务了</li>
</ul>
<h4 id="11-Redis事物的了解CheckAndSet操作实现乐观锁"><a href="#11-Redis事物的了解CheckAndSet操作实现乐观锁" class="headerlink" title="11. Redis事物的了解CheckAndSet操作实现乐观锁"></a><font color=DarkOrange>11. Redis事物的了解CheckAndSet操作实现乐观锁</font></h4><p>和众多其它数据库一样，Redis作为NoSQL数据库也同样提供了事务机制。在Redis中，<code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code>，<code>WATCH</code>这四个命令是我们实现事务的基石。相信对有关系型数据库开发经验的开发者而言这一概念并不陌生，即便如此，我们还是会简要的列出 Redis中事务的实现特征 ：</p>
<ul>
<li>在事务中的所有命令都将会被串行化的顺序执行，事务执行期间，Redis不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行</li>
<li>和关系型数据库中的事务相比，在Redis事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行</li>
<li>我们可以通过MULTI命令开启一个事务，有关系型数据库开发经验的人可以将其理解为”BEGIN TRANSACTION”语句。在该语句之后执行的命令都将被视为事务之内的操作，最后我们可以通过执行<code>EXEC</code>，<code>DISCARD</code>命令来提交，回滚该事务内的所有操作。这两个Redis命令可被视为等同于关系型数据库中的COMMIT&#x2F;ROLLBACK语句</li>
<li>在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行</li>
<li>当使用<code>Append-Only</code>模式时，Redis会通过调用系统函数write将该事务内的所有写操作在本次调用中全部写入磁盘。然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。Redis服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用Redis工具包中提供的<code>redis-check-aof</code>工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了</li>
</ul>
<h4 id="12-Redis有序集合zset底层怎么实现的"><a href="#12-Redis有序集合zset底层怎么实现的" class="headerlink" title="12. Redis有序集合zset底层怎么实现的"></a><font color=DarkOrange>12. Redis有序集合zset底层怎么实现的</font></h4><ul>
<li>跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表</li>
<li>跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找</li>
<li>跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能</li>
</ul>
<hr>
<ul>
<li>跳表是可以实现二分查找的有序链表</li>
<li>每个元素插入时随机生成它的level</li>
<li>最低层包含所有的元素</li>
<li>如果一个元素出现在level(x)，那么它肯定出现在x以下的level中</li>
<li>每个索引节点包含两个指针，一个向下，一个向右</li>
<li>跳表查询、插入、删除的时间复杂度为O(log n)，与平衡二叉树接近</li>
</ul>
<hr>
<h5 id="12-1-为什么Redis选择使用跳表而不是红黑树来实现有序集合？-O-logN"><a href="#12-1-为什么Redis选择使用跳表而不是红黑树来实现有序集合？-O-logN" class="headerlink" title="12.1 为什么Redis选择使用跳表而不是红黑树来实现有序集合？(O(logN))"></a><font color=DarkOrange>12.1 为什么Redis选择使用跳表而不是红黑树来实现有序集合？(O(logN))</font></h5><p>首先，我们来分析下Redis的有序集合支持的操作：</p>
<ul>
<li>插入元素</li>
<li>删除元素</li>
<li>查找元素</li>
<li>有序输出所有元素</li>
<li>查找区间内所有元素</li>
</ul>
<p>其中，前4项红黑树都可以完成，且时间复杂度与跳表一致。但是，最后一项，红黑树的效率就没有跳表高了。在跳表中，要查找区间的元素，我们只要定位到两个区间端点在最低层级的位置，然后按顺序遍历元素就可以了，非常高效</p>
<p>而红黑树只能定位到端点后，再从首位置开始每次都要查找后继节点，相对来说是比较耗时的。此外，跳表实现起来很容易且易读，红黑树实现起来相对困难，所以Redis选择使用跳表来实现有序集合</p>
<h4 id="13-跳表的查询过程是怎么样的，查询和插入的时间复杂度"><a href="#13-跳表的查询过程是怎么样的，查询和插入的时间复杂度" class="headerlink" title="13. 跳表的查询过程是怎么样的，查询和插入的时间复杂度"></a><font color=DarkOrange>13. 跳表的查询过程是怎么样的，查询和插入的时间复杂度</font></h4><p>先从第一层查找，不满足就下沉到第二层找，因为每一层都是有序的，写入和插入的时间复杂度都是O(logN)</p>
<hr>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生00-什么是云原生</title>
    <url>/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F00-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%91%E5%8E%9F%E7%94%9F/</url>
    <content><![CDATA[<h4 id="1-什么是云原生"><a href="#1-什么是云原生" class="headerlink" title="1. 什么是云原生"></a><font color=DarkOrange>1. 什么是云原生</font></h4><ul>
<li><p>在包括公有云、私有云、混合云等动态环境中构建和运行规模化应用的能力</p>
</li>
<li><p>云原生是一种思想，是技术、企业管理方法的集合</p>
<ul>
<li>技术层面<ul>
<li>应用程序从设计之初就为在云上运行而做好准备</li>
<li>云平台基于自动化体系</li>
</ul>
</li>
<li>流程层面<ul>
<li>基于 DevOps，CI&#x2F;CD</li>
</ul>
</li>
</ul>
</li>
<li><p>基于多种手段</p>
<ul>
<li>应用容器化封装</li>
<li>服务网格</li>
<li>不可变基础架构</li>
<li>声明式 API</li>
</ul>
</li>
<li><p>云原生的意义</p>
<ul>
<li>提升系统的适应性、可管理性、可观察性</li>
<li>使工程师能以最小成本进行频繁和可预测的系统变更</li>
<li>提升速度和效率，助力业务成长，缩短 I2M（Idea to Market）</li>
</ul>
</li>
</ul>
<h4 id="2-云原生核心项目概览"><a href="#2-云原生核心项目概览" class="headerlink" title="2. 云原生核心项目概览"></a><font color=DarkOrange>2. 云原生核心项目概览</font></h4><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8akra0wvmj30yk0qgdvy.jpg" alt="image.png" style="zoom:50%;" /></div>

<h4 id="3-kube-proxy-是干啥用的"><a href="#3-kube-proxy-是干啥用的" class="headerlink" title="3. kube-proxy 是干啥用的"></a><font color=DarkOrange>3. kube-proxy 是干啥用的</font></h4><h5 id="3-1-官方文档"><a href="#3-1-官方文档" class="headerlink" title="3.1 官方文档"></a><font color=DarkOrange>3.1 官方文档</font></h5><p>官方文档：<a href="https://kubernetes.io/docs/concepts/overview/components/">点击跳转</a></p>
<p>kube-proxy uses the operating system packet filtering layer if there is one and it’s available. Otherwise, kube-proxy forwards the traffic itself.</p>
<h5 id="3-2-看看前人是怎么解读的"><a href="#3-2-看看前人是怎么解读的" class="headerlink" title="3.2 看看前人是怎么解读的"></a><font color=DarkOrange>3.2 看看前人是怎么解读的</font></h5><p>搜中文文档，知乎，CSDN，简书都有比较高质量的文章，可以多看一些文档，并理解不同人 的理解差异</p>
<p>知乎：<a href="https://zhuanlan.zhihu.com/p/337806843">点击跳转</a></p>
<p>中文世界Kubernetes非常活跃，不少文档质量超过英文。但中文搬运转载问题比较严重，需要自己甄别</p>
<h5 id="3-3-找关键知识点"><a href="#3-3-找关键知识点" class="headerlink" title="3.3 找关键知识点"></a><font color=DarkOrange>3.3 找关键知识点</font></h5><ul>
<li>先对大概的框架有认识</li>
<li>kube-proxy 监听 API server 中 资源对象的变化情况，包括以下三种：<ul>
<li>service</li>
<li>endpoint&#x2F;endpointslices</li>
<li>node</li>
</ul>
</li>
<li>目前 Kube-proxy 支持4中代理模式：<ul>
<li>userspace</li>
<li>iptables</li>
<li>ipvs</li>
<li>kernelspace（windows）</li>
</ul>
</li>
</ul>
<h5 id="3-4-由点到面稍稍展开一下"><a href="#3-4-由点到面稍稍展开一下" class="headerlink" title="3.4 由点到面稍稍展开一下"></a><font color=DarkOrange>3.4 由点到面稍稍展开一下</font></h5><p>由浅入深的理解，成为专家</p>
<ul>
<li>入门：可以使用，知道怎么用，大概做了什么</li>
<li>初级：粗略理解配置方法</li>
<li>高级：理解不同模式的差异，理解为什么要有多种模式，理解配置细节</li>
<li>专家级：理解完整的内核协议栈处理数据包的流程，能够举一反三</li>
</ul>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8akygl1nyj31qi0fe46c.jpg" alt="image.png" style="zoom:67%;" /></div>

<h4 id="4-如何学习云原生技术"><a href="#4-如何学习云原生技术" class="headerlink" title="4. 如何学习云原生技术"></a><font color=DarkOrange>4. 如何学习云原生技术</font></h4><ul>
<li><p>代码驱动</p>
<ul>
<li>掌握 Go 语言编程能力</li>
</ul>
</li>
<li><p>从点到面</p>
<ul>
<li>cgroup、namespace</li>
<li>网络协议栈</li>
<li>文件系统</li>
</ul>
</li>
<li><p>抓住核心掌控全局</p>
<ul>
<li>深入理解 Kubernetes<ul>
<li>API 定义</li>
<li>控制器模式</li>
<li>核心组件</li>
</ul>
</li>
</ul>
</li>
<li><p>大规模生产化</p>
<ul>
<li>多集群</li>
<li>服务网格和多网格</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>云原生</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生02-编写Go程序</title>
    <url>/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F02-%E7%BC%96%E5%86%99Go%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>Go语言进阶知识整理</p>
<h4 id="1-线程加锁"><a href="#1-线程加锁" class="headerlink" title="1. 线程加锁"></a><font color=DarkOrange>1. 线程加锁</font></h4><h5 id="1-1-锁"><a href="#1-1-锁" class="headerlink" title="1.1 锁"></a><font color=DarkOrange>1.1 锁</font></h5><ul>
<li>Go 语言不仅仅提供基于 CSP 的通讯模型，也支持基于共享内存的多线程数据访问</li>
<li>Sync 包提供了锁的基本原语</li>
<li>sync.Mutex 互斥锁<ul>
<li>Lock()加锁，Unlock 解锁</li>
</ul>
</li>
<li>sync.RWMutex 读写分离锁<ul>
<li>不限制并发读，只限制并发写和并发读写</li>
</ul>
</li>
<li>sync.WaitGroup<ul>
<li>等待一组 goroutine 返回</li>
</ul>
</li>
<li>sync.Once<ul>
<li>保证某段代码只执行一次</li>
</ul>
</li>
<li>sync.Cond<ul>
<li>让一组 goroutine 在满足特定条件时被唤醒</li>
</ul>
</li>
</ul>
<h5 id="1-2-Mutex示例"><a href="#1-2-Mutex示例" class="headerlink" title="1.2 Mutex示例"></a><font color=DarkOrange>1.2 Mutex示例</font></h5><p>Kubernetes 中的 informer factory</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Start initializes all requested informers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *sharedInformerFactory)</span></span> Start(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) &#123;</span><br><span class="line">  f.lock.Lock()</span><br><span class="line">  <span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line">  <span class="keyword">for</span> informerType, informer := <span class="keyword">range</span> f.informers &#123;</span><br><span class="line">    <span class="keyword">if</span> !f.startedInformers[informerType] &#123;</span><br><span class="line">      <span class="keyword">go</span> informer.Run(stopCh)</span><br><span class="line">      f.startedInformers[informerType] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-3-WaitGroup示例"><a href="#1-3-WaitGroup示例" class="headerlink" title="1.3 WaitGroup示例"></a><font color=DarkOrange>1.3 WaitGroup示例</font></h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CreateBatch create a batch of pods. All pods are created before waiting.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *PodClient)</span></span> CreateBatch(pods []*v1.Pod) []*v1.Pod &#123;</span><br><span class="line">  ps := <span class="built_in">make</span>([]*v1.Pod, <span class="built_in">len</span>(pods))</span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  <span class="keyword">for</span> i, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>, pod *v1.Pod)</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> wg.Done()</span><br><span class="line">      <span class="keyword">defer</span> GinkgoRecover()</span><br><span class="line">      ps[i] = c.CreateSync(pod)</span><br><span class="line">    &#125;(i, pod)</span><br><span class="line">  &#125;</span><br><span class="line">  wg.Wait()</span><br><span class="line">  <span class="keyword">return</span> ps</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-4-Cond示例"><a href="#1-4-Cond示例" class="headerlink" title="1.4 Cond示例"></a><font color=DarkOrange>1.4 Cond示例</font></h5><p>Kubernetes 中的队列，标准的生产者消费者模式</p>
<p>cond: sync.NewCond(&amp;sync.Mutex{})</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Add marks item as needing processing.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span></span> Add(item <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">  q.cond.L.Lock()</span><br><span class="line">  <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">  <span class="keyword">if</span> q.shuttingDown &#123;</span><br><span class="line">  	<span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> q.dirty.has(item) &#123;</span><br><span class="line">  	<span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  q.metrics.add(item)</span><br><span class="line">  q.dirty.insert(item)</span><br><span class="line">  <span class="keyword">if</span> q.processing.has(item) &#123;</span><br><span class="line">  	<span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  q.queue = <span class="built_in">append</span>(q.queue, item)</span><br><span class="line">  q.cond.Signal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get blocks until it can return an item to be processed. If shutdown = true,</span></span><br><span class="line"><span class="comment">// the caller should end their goroutine. You must call Done with item when you</span></span><br><span class="line"><span class="comment">// have finished processing it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span></span> Get() (item <span class="keyword">interface</span>&#123;&#125;, shutdown <span class="type">bool</span>) &#123;</span><br><span class="line">  q.cond.L.Lock()</span><br><span class="line">  <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">len</span>(q.queue) == <span class="number">0</span> &amp;&amp; !q.shuttingDown &#123;</span><br><span class="line">  	q.cond.Wait()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(q.queue) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// We must be shutting down.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  item, q.queue = q.queue[<span class="number">0</span>], q.queue[<span class="number">1</span>:]</span><br><span class="line">  q.metrics.get(item)</span><br><span class="line">  q.processing.insert(item)</span><br><span class="line">  q.dirty.<span class="built_in">delete</span>(item)</span><br><span class="line">  <span class="keyword">return</span> item, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-线程调度"><a href="#2-线程调度" class="headerlink" title="2. 线程调度"></a><font color=DarkOrange>2. 线程调度</font></h4><h5 id="2-1-深入理解Go语言线程调度"><a href="#2-1-深入理解Go语言线程调度" class="headerlink" title="2.1 深入理解Go语言线程调度"></a><font color=DarkOrange>2.1 深入理解Go语言线程调度</font></h5><ul>
<li>进程：资源分配的基本单位</li>
<li>线程：调度的基本单位</li>
<li>无论是线程还是进程，在 linux 中都以 task_struct 描述，从内核角度看，与进程无本质区别</li>
<li>Glibc 中的 pthread 库提供 NPTL（Native POSIX Threading Library）支持</li>
</ul>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d2s6imj8j31b60gutem.jpg" alt="image.png" style="zoom:50%;" /></div>

<h5 id="2-2-Linux进程的内存使用"><a href="#2-2-Linux进程的内存使用" class="headerlink" title="2.2 Linux进程的内存使用"></a><font color=DarkOrange>2.2 Linux进程的内存使用</font></h5><p><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d2tl546nj31n40o27fy.jpg" alt="image.png"></p>
<h5 id="2-3-CPU对内存的访问"><a href="#2-3-CPU对内存的访问" class="headerlink" title="2.3 CPU对内存的访问"></a><font color=DarkOrange>2.3 CPU对内存的访问</font></h5><ul>
<li>CPU 上有个 Memory Management Unit（MMU） 单元</li>
<li>CPU 把虚拟地址给 MMU，MMU 去物理内存中查询页表，得到实际的物理地址</li>
<li>CPU 维护一份缓存 Translation Lookaside Buffer（TLB），缓存虚拟地址和物理地址的映射关系</li>
</ul>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d2uw9hhqj31cy0jm40u.jpg" alt="image.png" style="zoom:50%;" /></div>

<h5 id="2-4-进程切换开销"><a href="#2-4-进程切换开销" class="headerlink" title="2.4 进程切换开销"></a><font color=DarkOrange>2.4 进程切换开销</font></h5><ul>
<li>直接开销<ul>
<li>切换页表全局目录（PGD）</li>
<li>切换内核态堆栈</li>
<li>切换硬件上下文（进程恢复前，必须装入寄存器的数据统称为硬件上下文）</li>
<li>刷新 TLB</li>
<li>系统调度器的代码执行</li>
</ul>
</li>
<li>间接开销<ul>
<li>CPU 缓存失效导致的进程需要到内存直接访问的 IO 操作变多</li>
</ul>
</li>
</ul>
<h5 id="2-5-线程切换开销"><a href="#2-5-线程切换开销" class="headerlink" title="2.5 线程切换开销"></a><font color=DarkOrange>2.5 线程切换开销</font></h5><ul>
<li>线程本质上只是一批共享资源的进程，线程切换本质上依然需要内核进行进程切换</li>
<li>一组线程因为共享内存资源，因此一个进程的所有线程共享虚拟地址空间，线程切换相比进程 切换，主要节省了虚拟地址空间的切换</li>
</ul>
<h5 id="2-6-用户线程"><a href="#2-6-用户线程" class="headerlink" title="2.6 用户线程"></a><font color=DarkOrange>2.6 用户线程</font></h5><p>无需内核帮助，应用程序在用户空间创建的可执行单元，创建销毁完全在用户态完成</p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d2zvpsctj31e80lon5k.jpg" alt="image.png" style="zoom:50%;" /></div>

<h5 id="2-7-Goroutine"><a href="#2-7-Goroutine" class="headerlink" title="2.7 Goroutine"></a><font color=DarkOrange>2.7 Goroutine</font></h5><p>Go 语言基于 GMP 模型实现用户态线程</p>
<ul>
<li>G：表示 goroutine，每个 goroutine 都有自己的栈空间，定时器， 初始化的栈空间在 2k 左右，空间会随着需求增长</li>
<li>M：抽象化代表内核线程，记录内核线程栈信息，当 goroutine 调度 到线程时，使用该 goroutine 自己的栈信息</li>
<li>P：代表调度器，负责调度 goroutine，维护一个本地 goroutine 队 列，M 从 P 上获得 goroutine 并执行，同时还负责部分内存的管理</li>
</ul>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d31hrzzjj30g608mwfr.jpg" alt="image.png" style="zoom:40%;" /></div>

<h5 id="2-8-GMP模型细节"><a href="#2-8-GMP模型细节" class="headerlink" title="2.8 GMP模型细节"></a><font color=DarkOrange>2.8 GMP模型细节</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d32u86bpj31ke0r8naq.jpg" alt="image.png" style="zoom:67%;" /></div>

<h5 id="2-9-G所处的位置"><a href="#2-9-G所处的位置" class="headerlink" title="2.9 G所处的位置"></a><font color=DarkOrange>2.9 G所处的位置</font></h5><ul>
<li>进程都有一个全局的 G 队列</li>
<li>每个 P 拥有自己的本地执行队列</li>
<li>有不在运行队列中的 G<ul>
<li>处于 channel 阻塞态的 G 被放在 sudog</li>
<li>脱离 P 绑定在 M 上的 G，如系统调用</li>
<li>为了复用，执行结束进入 P 的 gFree 列表中的 G</li>
</ul>
</li>
</ul>
<h5 id="2-10-Goroutine创建过程"><a href="#2-10-Goroutine创建过程" class="headerlink" title="2.10 Goroutine创建过程"></a><font color=DarkOrange>2.10 Goroutine创建过程</font></h5><ul>
<li>获取或者创建新的 Goroutine 结构体<ul>
<li>从处理器的 gFree 列表中查找空闲的 Goroutine</li>
<li>如果不存在空闲的 Goroutine，会通过 runtime.malg 创建一个栈大小足够的新结构体</li>
</ul>
</li>
<li>将函数传入的参数移到 Goroutine 的栈上</li>
<li>更新 Goroutine 调度相关的属性，更新状态为_Grunnable</li>
<li>返回的 Goroutine 会存储到全局变量 allgs 中</li>
</ul>
<h5 id="2-11-将Goroutine放到运行队列上"><a href="#2-11-将Goroutine放到运行队列上" class="headerlink" title="2.11 将Goroutine放到运行队列上"></a><font color=DarkOrange>2.11 将Goroutine放到运行队列上</font></h5><ul>
<li>Goroutine 设置到处理器的 runnext 作为下一个处理器执行的任务</li>
<li>当处理器的本地运行队列已经没有剩余空间时，就会把本地队列中的一部分 Goroutine 和待加入的 Goroutine通过 runtime.runqputslow 添加到调度器持有的全局运行队列上</li>
</ul>
<h5 id="2-12-调度器行为"><a href="#2-12-调度器行为" class="headerlink" title="2.12 调度器行为"></a><font color=DarkOrange>2.12 调度器行为</font></h5><ul>
<li>为了保证公平，当全局运行队列中有待执行的 Goroutine 时，通过 schedtick 保证有一定 几率会从全局的运行队列中查找对应的 Goroutine</li>
<li>从处理器本地的运行队列中查找待执行的 Goroutine</li>
<li>如果前两种方法都没有找到 Goroutine，会通过 runtime.findrunnable 进行阻塞地查找 Goroutine<ul>
<li>从本地运行队列、全局运行队列中查找</li>
<li>从网络轮询器中查找是否有 Goroutine 等待运行</li>
<li>通过 runtime.runqsteal 尝试从其他随机的处理器中窃取待运行的 Goroutine</li>
</ul>
</li>
</ul>
<h4 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3. 内存管理"></a><font color=DarkOrange>3. 内存管理</font></h4><h5 id="3-1-堆内存管理"><a href="#3-1-堆内存管理" class="headerlink" title="3.1 堆内存管理"></a><font color=DarkOrange>3.1 堆内存管理</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d372j1f5j31jw0isdn7.jpg" alt="image.png" style="zoom:50%;" /></div>

<ul>
<li>初始化连续内存块作为堆</li>
<li>有内存申请的时候，Allocator 从堆内存的未分配区域分割小内存块</li>
<li>用链表将已分配内存连接起来</li>
<li>需要信息描述每个内存块的元数据：大小，是否使用，下一个内存块的地址等</li>
</ul>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d38gftrpj316007uabs.jpg" alt="image.png" style="zoom:50%;" /></div>

<h5 id="3-2-TCMalloc"><a href="#3-2-TCMalloc" class="headerlink" title="3.2 TCMalloc"></a><font color=DarkOrange>3.2 TCMalloc</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d39qtrfpj31k00nu7fm.jpg" alt="image.png" style="zoom:67%;" /></div>

<ul>
<li><p>page:内存页，一块 8K 大小的内存空间。Go 与操作系统之间的内存申请和释放，都是以 page 为单位的</p>
</li>
<li><p>span: 内存块，一个或多个连续的 page 组成一个 span </p>
</li>
<li><p>sizeclass : 空间规格，每个 span 都带有一个 sizeclass ，标记着该 span 中的 page 应该如何 使用</p>
</li>
<li><p>object : 对象，用来存储一个变量数据内存空间，一个 span 在初始化时，会被切割成一堆等大 的 object ；假设 object 的大小是 16B ，span 大小是 8K ，那么就会把 span 中的 page 就会 被初始化 8K &#x2F; 16B &#x3D; 512 个 object 。所谓内存分配，就是分配一个 object 出去</p>
</li>
<li><p>对象大小定义</p>
<ul>
<li>小对象大小：0~256KB</li>
<li>中对象大小：256KB~1MB</li>
<li>大对象大小：&gt;1MB</li>
</ul>
</li>
<li><p>小对象的分配流程</p>
<ul>
<li>ThreadCache -&gt; CentralCache -&gt; HeapPage，大部分时候，ThreadCache 缓存都是足够的，不需要去访问 CentralCache 和 HeapPage，无系统调用配合无锁分配，分配效率是非常高的</li>
</ul>
</li>
<li><p>中对象分配流程</p>
<ul>
<li>直接在 PageHeap 中选择适当的大小即可，128 Page 的 Span 所保存的最大内存就是 1MB</li>
</ul>
</li>
<li><p>大对象分配流程</p>
<ul>
<li>从 large span set 选择合适数量的页面组成 span，用来存储数据</li>
</ul>
</li>
</ul>
<h5 id="3-3-Go语言内存分配"><a href="#3-3-Go语言内存分配" class="headerlink" title="3.3 Go语言内存分配"></a><font color=DarkOrange>3.3 Go语言内存分配</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d3d17knjj31kq0ni499.jpg" alt="image.png" style="zoom:67%;" /></div>

<ul>
<li><p>mcache：小对象的内存分配直接走</p>
<ul>
<li>size class 从 1 到 66，每个 class 两个 span</li>
<li>Span 大小是 8KB，按 span class 大小切分</li>
</ul>
</li>
<li><p>mcentral</p>
<ul>
<li>Span 内的所有内存块都被占用时，没有剩余空间继续分配对象，mcache 会向 mcentral 申请1个span，mcache 拿到 span 后继续分配对象</li>
<li>当 mcentral 向 mcache 提供 span 时，如果没有符合条件的 span，mcentral 会向 mheap 申请span</li>
</ul>
</li>
<li><p>mheap</p>
<ul>
<li>当 mheap 没有足够的内存时，mheap 会向 OS 申请内存</li>
<li>Mheap 把 Span 组织成了树结构，而不是链表</li>
<li>然后把 Span 分配到 heapArena 进行管理，它包含地址映射和 span 是否包含指针等位图<ul>
<li>为了更高效的分配、回收和再利用内存</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="3-4-内存回收"><a href="#3-4-内存回收" class="headerlink" title="3.4 内存回收"></a><font color=DarkOrange>3.4 内存回收</font></h5><ul>
<li>引用计数（Python，PHP，Swift）<ul>
<li>对每一个对象维护一个引用计数，当引用该对象的对象被销毁的时候，引用计数减 1，当引用计数为 0 的时候，回 收该对象</li>
<li>优点：对象可以很快的被回收，不会出现内存耗尽或达到某个阀值时才回收</li>
<li>缺点：不能很好的处理循环引用，而且实时维护引用计数，有也一定的代价</li>
</ul>
</li>
<li>标记-清除（Golang）<ul>
<li>从根变量开始遍历所有引用的对象，引用的对象标记为”被引用”，没有被标记的进行回收</li>
<li>优点：解决引用计数的缺点</li>
<li>缺点：需要 STW（stop the word），即要暂停程序运行</li>
</ul>
</li>
<li>分代收集（Java）<ul>
<li>按照生命周期进行划分不同的代空间，生命周期长的放入老年代，短的放入新生代，新生代的回收频率高于老年 代的频率</li>
</ul>
</li>
</ul>
<h5 id="3-5-mspan"><a href="#3-5-mspan" class="headerlink" title="3.5 mspan"></a><font color=DarkOrange>3.5 mspan</font></h5><ul>
<li>allocBits<ul>
<li>记录了每块内存分配的情况</li>
</ul>
</li>
<li>gcmarkBits<ul>
<li>记录了每块内存的引用情况，标记阶段对每块内存进行标记，有对象引用的内存标记为1，没有的标 记为 0</li>
</ul>
</li>
<li>这两个位图的数据结构是完全一致的，标记结束则进行内存回收，回收的时候，将 allocBits 指 向 gcmarkBits，标记过的则存在，未进行标记的则进行回收</li>
</ul>
<h5 id="3-6-GC工作流程"><a href="#3-6-GC工作流程" class="headerlink" title="3.6 GC工作流程"></a><font color=DarkOrange>3.6 GC工作流程</font></h5><p>Golang GC 的大部分处理是和用户代码并行的</p>
<ul>
<li>Mark：<ul>
<li>Mark Prepare: 初始化 GC 任务，包括开启写屏障 (write barrier) 和辅助 GC(mutator assist)，统计root对象的任 务数量等。这个过程需要STW</li>
<li>GC Drains: 扫描所有 root 对象，包括全局指针和 goroutine(G) 栈上的指针（扫描对应 G 栈时需停止该 G)，将其 加入标记队列(灰色队列)，并循环处理灰色队列的对象，直到灰色队列为空。该过程后台并行执行</li>
</ul>
</li>
<li>Mark Termination：完成标记工作，重新扫描(re-scan)全局指针和栈。因为 Mark 和用户程序是并行的，所以在 Mark 过 程中可能会有新的对象分配和指针赋值，这个时候就需要通过写屏障（write barrier）记录下来，re-scan 再检查一下，这 个过程也是会 STW 的</li>
<li>Sweep：按照标记结果回收所有的白色对象，该过程后台并行执行</li>
<li>Sweep Termination：对未清扫的 span 进行清扫, 只有上一轮的 GC 的清扫工作完成才可以开始新一轮的 GC</li>
</ul>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d3k484cmj31ci0ikwn9.jpg" alt="image.png" style="zoom:67%;" /></div>

<h5 id="3-7-三色标记"><a href="#3-7-三色标记" class="headerlink" title="3.7 三色标记"></a><font color=DarkOrange>3.7 三色标记</font></h5><ul>
<li>GC 开始时，认为所有 object 都是 白色，即垃圾</li>
<li>从 root 区开始遍历，被触达的 object 置成 灰色</li>
<li>遍历所有灰色 object，将他们内部的引用变量置成 灰色，自身置成 黑色</li>
<li>循环第 3 步，直到没有灰色 object 了，只剩下了黑白两种，白色的都是垃圾</li>
<li>对于黑色 object，如果在标记期间发生了写操作，写屏障会在真正赋值前将新对象标记为 灰色</li>
<li>标记过程中，mallocgc 新分配的 object，会先被标记成 黑色 再返回</li>
</ul>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d3lpvwr3j31bw0940tw.jpg" alt="image.png" style="zoom:50%;" /></div>

<h5 id="3-8-垃圾回收触发机制"><a href="#3-8-垃圾回收触发机制" class="headerlink" title="3.8 垃圾回收触发机制"></a><font color=DarkOrange>3.8 垃圾回收触发机制</font></h5><ul>
<li>内存分配量达到阀值触发 GC<ul>
<li>每次内存分配时都会检查当前内存分配量是否已达到阀值，如果达到阀值则立即启动 GC</li>
<li>阀值 &#x3D; 上次 GC 内存分配量 * 内存增长率</li>
<li>内存增长率由环境变量 GOGC 控制，默认为 100，即每当内存扩大一倍时启动 GC</li>
</ul>
</li>
<li>定期触发 GC<ul>
<li>默认情况下，最长 2 分钟触发一次 GC，这个间隔在 src&#x2F;runtime&#x2F;proc.go:forcegcperiod 变量中 被声明</li>
</ul>
</li>
<li>手动触发<ul>
<li>程序代码中也可以使用 runtime.GC()来手动触发 GC。这主要用于 GC 性能测试和统计</li>
</ul>
</li>
</ul>
<h4 id="4-包引用与依赖管理"><a href="#4-包引用与依赖管理" class="headerlink" title="4. 包引用与依赖管理"></a><font color=DarkOrange>4. 包引用与依赖管理</font></h4><h5 id="4-1-Go-语言依赖管理的演进"><a href="#4-1-Go-语言依赖管理的演进" class="headerlink" title="4.1 Go 语言依赖管理的演进"></a><font color=DarkOrange>4.1 Go 语言依赖管理的演进</font></h5><ul>
<li>回顾 GOPATH<ul>
<li>通过环境变量设置系统级的 Go 语言类库目录</li>
<li>GOPATH 的问题？<ul>
<li>不同项目可能依赖不同版本</li>
<li>代码被 clone 以后需要设置 GOPATH 才能编译</li>
</ul>
</li>
</ul>
</li>
<li>vendor<ul>
<li>自 1.6 版本，支持 vendor 目录，在每个 Go 语言项目中，创建一个名叫 vendor 的目录，并将依赖拷贝至该目录</li>
<li>Go 语言项目会自动将 vendor 目录作为自身的项目依赖路径</li>
<li>好处？<ul>
<li>每个项目的 vendor目录是独立的，可以灵活的选择版本</li>
<li>Vendor 目录与源代码一起 check in 到 github，其他人 checkout 以后可直接编译</li>
<li>无需在编译期间下载依赖包，所有依赖都已经与源代码保存在一起</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="4-2-vendor管理工具"><a href="#4-2-vendor管理工具" class="headerlink" title="4.2 vendor管理工具"></a><font color=DarkOrange>4.2 vendor管理工具</font></h5><p>通过声明式配置，实现 vendor 管理的自动化</p>
<ul>
<li>在早期，Go 语言无自带依赖管理工具，社区方案鱼龙混杂比较出名的包括<ul>
<li>Godeps, Glide</li>
</ul>
</li>
<li>Go 语言随后发布了自带的依赖管理工具 Gopkg</li>
<li>很快用新的工具 gomod 替换掉了 gopkg<ul>
<li>切换 mod 开启模式：export GO111MODULE&#x3D;on&#x2F;off&#x2F;auto</li>
<li>Go mod 相比之前的工具更灵活易用，以基本统一了 Go 语言依赖管理</li>
</ul>
</li>
</ul>
<h5 id="4-3-Go-mod使用"><a href="#4-3-Go-mod使用" class="headerlink" title="4.3 Go mod使用"></a><font color=DarkOrange>4.3 Go mod使用</font></h5><ul>
<li>创建项目</li>
<li>初始化 Go 模块<ul>
<li><code>go mod init</code></li>
</ul>
</li>
<li>下载依赖包<ul>
<li><code>go mod download</code>（下载的依赖包在$GOPATH&#x2F;pkg，如果没有设置 GOPATH，则下载在项目根目录&#x2F;pkg）</li>
<li>在源代码中使用某个依赖包，如 github.com&#x2F;emicklei&#x2F;go-restful</li>
</ul>
</li>
<li>添加缺少的依赖并为依赖包瘦身<ul>
<li><code>go mod tidy</code></li>
</ul>
</li>
<li>把 Go 依赖模块添加到 vendor 目录<ul>
<li><code>go mod vendor</code></li>
</ul>
</li>
</ul>
<p>配置细节会被保存在项目根目录的 go.mod 中</p>
<p>可在 require 或者 replacement 中指定版本</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">module k8s.io/apiserver</span><br><span class="line"><span class="keyword">go</span> <span class="number">1.13</span></span><br><span class="line">require (</span><br><span class="line">  github.com/evanphx/json-patch v4<span class="number">.9</span><span class="number">.0</span>+incompatible</span><br><span class="line">  github.com/<span class="keyword">go</span>-openapi/jsonreference v0<span class="number">.19</span><span class="number">.3</span> <span class="comment">// indirect</span></span><br><span class="line">  github.com/<span class="keyword">go</span>-openapi/spec v0<span class="number">.19</span><span class="number">.3</span></span><br><span class="line">  github.com/gogo/protobuf v1<span class="number">.3</span><span class="number">.2</span></span><br><span class="line">  github.com/google/<span class="keyword">go</span>-cmp v0<span class="number">.3</span><span class="number">.0</span></span><br><span class="line">  github.com/google/gofuzz v1<span class="number">.1</span><span class="number">.0</span></span><br><span class="line">  k8s.io/apimachinery v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20210518100737</span><span class="number">-44</span>f1264f7b6b</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">replace (</span><br><span class="line">  golang.org/x/crypto =&gt; golang.org/x/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200220183623</span>-bac4c82f6975</span><br><span class="line">  golang.org/x/text =&gt; golang.org/x/text v0<span class="number">.3</span><span class="number">.2</span></span><br><span class="line">  k8s.io/api =&gt; k8s.io/api v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20210518101910</span><span class="number">-53468e23</span>a787</span><br><span class="line">  k8s.io/apimachinery =&gt; k8s.io/apimachinery v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20210518100737</span><span class="number">-44</span>f1264f7b6b</span><br><span class="line">  k8s.io/client-<span class="keyword">go</span> =&gt; k8s.io/client-<span class="keyword">go</span> v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20210518104342</span>-fa3acefe68f3</span><br><span class="line">  k8s.io/component-base =&gt; k8s.io/component-base v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20210518111421</span><span class="number">-67</span>c12a31a26a</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h5 id="4-4-GOPROXY和GOPRIVATE"><a href="#4-4-GOPROXY和GOPRIVATE" class="headerlink" title="4.4 GOPROXY和GOPRIVATE"></a><font color=DarkOrange>4.4 GOPROXY和GOPRIVATE</font></h5><ul>
<li>GOPROXY<ul>
<li>为拉取 Go 依赖设置代理<ul>
<li><code>export GOPROXY=https://goproxy.cn</code></li>
</ul>
</li>
</ul>
</li>
<li>在设置 GOPROXY 以后，默认所有依赖拉取都需要经过 proxy 连接 git repo，拉取代码，并做 checksum 校验</li>
<li>某些私有代码仓库是 goproxy.cn 无法连接的，因此需要设置 GOPRIVATE 来声明私有代码仓库</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">GOPRIVATE=*.corp.example.com</span><br><span class="line">GOPROXY=proxy.example.com</span><br><span class="line">GONOPROXY=myrepo.corp.example.com</span><br></pre></td></tr></table></figure>

<h4 id="5-Makefile"><a href="#5-Makefile" class="headerlink" title="5. Makefile"></a><font color=DarkOrange>5. Makefile</font></h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">root:</span><br><span class="line">	export ROOT=github.com/cncamp/golang;</span><br><span class="line">.PHONY: root</span><br><span class="line">release:</span><br><span class="line">  echo <span class="string">&quot;building httpserver binary&quot;</span></span><br><span class="line">  mkdir -p bin/amd64</span><br><span class="line">  CGO_ENABLED=<span class="number">0</span> GOOS=linux GOARCH=amd64 <span class="keyword">go</span> build -o bin/amd64 .</span><br><span class="line">.PHONY: release</span><br></pre></td></tr></table></figure>

<h4 id="6-动手编写一个HTTP-Server"><a href="#6-动手编写一个HTTP-Server" class="headerlink" title="6. 动手编写一个HTTP Server"></a><font color=DarkOrange>6. 动手编写一个HTTP Server</font></h4><h5 id="6-1-理解net-http包"><a href="#6-1-理解net-http包" class="headerlink" title="6.1 理解net.http包"></a><font color=DarkOrange>6.1 理解net.http包</font></h5><ul>
<li><p>注册 handle 处理函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">&quot;/healthz&quot;</span>, healthz)</span><br><span class="line"><span class="comment">//Use the default DefaultServeMux.</span></span><br><span class="line">ListenAndService</span><br><span class="line">err := http.ListenAndServe(<span class="string">&quot;:80&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义 handle 处理函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">healthz</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	io.WriteString(w, <span class="string">&quot;ok&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="6-2-阻塞IO模型"><a href="#6-2-阻塞IO模型" class="headerlink" title="6.2 阻塞IO模型"></a><font color=DarkOrange>6.2 阻塞IO模型</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d3y19ws9j31by0lin5s.jpg" alt="image.png" style="zoom:50%;" /></div>

<h5 id="6-3-非阻塞IO模型"><a href="#6-3-非阻塞IO模型" class="headerlink" title="6.3 非阻塞IO模型"></a><font color=DarkOrange>6.3 非阻塞IO模型</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d4695nkmj31dg0lmtjd.jpg" alt="image.png" style="zoom:50%;" /></div>

<h5 id="6-4-IO多路复用"><a href="#6-4-IO多路复用" class="headerlink" title="6.4 IO多路复用"></a><font color=DarkOrange>6.4 IO多路复用</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d477ndpqj31f20lo142.jpg" alt="image.png" style="zoom:50%;" /></div>

<h5 id="6-5-异步IO"><a href="#6-5-异步IO" class="headerlink" title="6.5 异步IO"></a><font color=DarkOrange>6.5 异步IO</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d4805ht4j318m0lmaif.jpg" alt="image.png" style="zoom:50%;" /></div>

<h5 id="6-6-Linux-epoll"><a href="#6-6-Linux-epoll" class="headerlink" title="6.6 Linux epoll"></a><font color=DarkOrange>6.6 Linux epoll</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d48xagndj31nm0tsqd5.jpg" alt="image.png" style="zoom:50%;" /></div>

<h5 id="6-7-Go-语言高性能httpserver的实现细节"><a href="#6-7-Go-语言高性能httpserver的实现细节" class="headerlink" title="6.7 Go 语言高性能httpserver的实现细节"></a><font color=DarkOrange>6.7 Go 语言高性能httpserver的实现细节</font></h5><p>Go 语言将协程与 fd 资源绑定</p>
<ul>
<li>一个 socket fd 与一个协程绑定</li>
<li>当 socket fd 未就绪时，将对应协程设置为 Gwaiting 状态，将 CPU 时间片让给其他协程</li>
<li>Go 语言 runtime 调度器进行调度唤醒协程时，检查 fd 是否就绪，如果就绪则将协程置为 Grunnable 并加入执行队列</li>
<li>协程被调度后处理 fd 数据</li>
</ul>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8d4aae3tyj30vk0d60x7.jpg" alt="image.png" style="zoom:50%;" /></div>

<h4 id="7-调试"><a href="#7-调试" class="headerlink" title="7. 调试"></a><font color=DarkOrange>7. 调试</font></h4><h5 id="7-1-debug"><a href="#7-1-debug" class="headerlink" title="7.1 debug"></a><font color=DarkOrange>7.1 debug</font></h5><ul>
<li>gdb：<ul>
<li>Gccgo 原生支持 gdb，因此可以用 gdb 调试 Go 语言代码，但 dlv 对 Go 语言 debug 的支持比 gdb 更好</li>
<li>Gdb 对 Go 语言的栈管理，多线程支持等方面做的不够好，调试代码时可能有错乱现象</li>
</ul>
</li>
<li>dlv：<ul>
<li>Go 语言的专有 debugger</li>
</ul>
</li>
</ul>
<h5 id="7-2-dlv的配置"><a href="#7-2-dlv的配置" class="headerlink" title="7.2 dlv的配置"></a><font color=DarkOrange>7.2 dlv的配置</font></h5><ul>
<li>配置<ul>
<li>在 vscode 中配置 dlb</li>
<li>菜单：View -&gt; Command Palette</li>
<li>选择 Go : Install&#x2F;Update Tools，选择安装</li>
<li>安装完后，从改入口列表中可以看到 dlv 和 dlv-dap 已经安装好</li>
</ul>
</li>
<li>Debug 方法<ul>
<li>在代码中设置断点</li>
<li>菜单中选择 Run -&gt; Start Debugging 即可进入调试</li>
</ul>
</li>
</ul>
<h5 id="7-3-更多debug方法"><a href="#7-3-更多debug方法" class="headerlink" title="7.3 更多debug方法"></a><font color=DarkOrange>7.3 更多debug方法</font></h5><ul>
<li>添加日志<ul>
<li>在关键代码分支中加入日志</li>
<li>基于fmt包将日志输出到标准输出 stdout：<code>fmt.Println()</code></li>
<li>fmt 无日志重定向，无日志分级</li>
</ul>
</li>
<li>即与日志框架将日志输出到对应的 appender<ul>
<li>比如可利用 glog 进行日志输出<ul>
<li>可配置 appender，将标准输出转至文件</li>
<li>支持多级日志输出，可修改配置调整日志等级</li>
<li>自带时间戳和代码行，方便调试</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="7-4-Glog使用方法示例"><a href="#7-4-Glog使用方法示例" class="headerlink" title="7.4 Glog使用方法示例"></a><font color=DarkOrange>7.4 Glog使用方法示例</font></h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/golang/glog&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Set(<span class="string">&quot;v&quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line">  glog.V(<span class="number">2</span>).Info(<span class="string">&quot;Starting http server...&quot;</span>)</span><br><span class="line">  mux := http.NewServeMux()</span><br><span class="line">  mux.HandleFunc(<span class="string">&quot;/&quot;</span>, rootHandler)</span><br><span class="line">  err := http.ListenAndServe(<span class="string">&quot;:80&quot;</span>, mux)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  	log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-5-性能分析（Performance-Profiling）"><a href="#7-5-性能分析（Performance-Profiling）" class="headerlink" title="7.5 性能分析（Performance Profiling）"></a><font color=DarkOrange>7.5 性能分析（Performance Profiling）</font></h5><p>CPU Profiling: 在代码中添加 CPUProfile 代码，runtime&#x2F;pprof 包提供支持</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cpuprofile = flag.String(<span class="string">&quot;cpuprofile&quot;</span>, <span class="string">&quot;&quot;</span> , <span class="string">&quot;write cpu profile to file&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Parse()</span><br><span class="line">  <span class="keyword">if</span> *cpuprofile != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    f, err := os.Create(*cpuprofile)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    	log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    pprof.StartCPUProfile(f)</span><br><span class="line">    <span class="keyword">defer</span> pprof.StopCPUProfile()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析 CPU 瓶颈</strong></p>
<ul>
<li><p>运行 cpuprofilie 代码后，会在 &#x2F;tmp&#x2F;cpuprofile 中记录 cpu 使用时间</p>
</li>
<li><p>运行 go tool pprof &#x2F;tmp&#x2F;cpuprofile 进入分析模式</p>
</li>
<li><p>运行 top10 查看 top 10线程，显示 30ms 花费在 main.main</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">30</span>ms, <span class="number">100</span>% of <span class="number">30</span>ms total</span><br><span class="line">flat flat% sum% cum cum%</span><br><span class="line"><span class="number">30</span>ms <span class="number">100</span>% <span class="number">100</span>% <span class="number">30</span>ms <span class="number">100</span>% main.main</span><br><span class="line"><span class="number">0</span> <span class="number">0</span>% <span class="number">100</span>% <span class="number">30</span>ms <span class="number">100</span>% runtime.main</span><br></pre></td></tr></table></figure>
</li>
<li><p>(pprof) list main.main 显示 30 毫秒都花费在循环上</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Total: <span class="number">30</span>ms</span><br><span class="line"><span class="number">30</span>ms <span class="number">30</span>ms (flat, cum) <span class="number">100</span>% of Total</span><br><span class="line"><span class="number">20</span>ms <span class="number">20</span>ms <span class="number">21</span>: <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++ &#123;</span><br><span class="line"><span class="number">10</span>ms <span class="number">10</span>ms <span class="number">22</span>: result += I</span><br></pre></td></tr></table></figure>
</li>
<li><p>可执行 web 命令生成 svg 文件，在通过浏览器打开 svg 文件查看图形化分析结果</p>
</li>
</ul>
<p><strong>其他可用 profiling 工具分析的问题</strong></p>
<ul>
<li>CPU profile<ul>
<li>程序的 CPU 使用情况，每 100 毫秒采集一次 CPU 使用情况</li>
</ul>
</li>
<li>Memory Profile<ul>
<li>程序的内存使用情况</li>
</ul>
</li>
<li>Block Profiling<ul>
<li>非运行态的 goroutine 细节，分析和查找死锁</li>
</ul>
</li>
<li>Goroutine Profiling<ul>
<li>所有 goroutines 的细节状态，有哪些 goroutine，它们的调用关系是怎样的</li>
</ul>
</li>
</ul>
<p><strong>针对 http 服务的 pprof</strong></p>
<ul>
<li><p>net&#x2F;http&#x2F;pprof 包提供支持</p>
</li>
<li><p>如果采用默认 mux handle，则只需 import _ “net&#x2F;http&#x2F;pprof”</p>
</li>
<li><p>如果采用自定义 mux handle，则需要注册 pprof handler</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startHTTP</span><span class="params">(addr <span class="type">string</span>, s *tnetd.Server)</span></span> &#123;</span><br><span class="line">  mux := http.NewServeMux()</span><br><span class="line">  mux.HandleFunc(“/debug/pprof/”, pprof.Index)</span><br><span class="line">  mux.HandleFunc(“/debug/pprof/profile”, pprof.Profile)</span><br><span class="line">  mux.HandleFunc(“/debug/pprof/symbol”, pprof.Symbol)</span><br><span class="line">  mux.HandleFunc(“/debug/pprof/trace”, pprof.Trace)</span><br><span class="line">  server := &amp;http.Server&#123;</span><br><span class="line">    Addr: addr,</span><br><span class="line">    Handler: mux,</span><br><span class="line">  &#125;</span><br><span class="line">  server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>分析 go profiling 结果</strong></p>
<p>在运行了开启 pprof 的服务器以后，可以通过访问对应的 URL 获得 profile 结果</p>
<ul>
<li>allocs: A sampling of all past memory allocations</li>
<li>block: Stack traces that led to blocking on synchronization primitives</li>
<li>cmdline: The command line invocation of the current program</li>
<li>goroutine: Stack traces of all current goroutines</li>
<li>heap: A sampling of memory allocations of live objects. You can specify the gc GET parameter to run GC before taking the heap sample</li>
</ul>
<p><strong>分析 go profiling 结果</strong></p>
<ul>
<li>mutex: Stack traces of holders of contended mutexes</li>
<li>profile: CPU profile. You can specify the duration in the seconds GET parameter. After you get the profile file, use the go tool pprof command to investigate the profile</li>
<li>threadcreate: Stack traces that led to the creation of new OS threads</li>
<li>trace: A trace of execution of the current program. You can specify the duration in the seconds GET parameter. After you get the trace file, use the go tool trace command to investigate the trace</li>
</ul>
<p><strong>结果分析示例</strong></p>
<ul>
<li>分析 goroutine 运行情况<ul>
<li><code>curl localhost/debug/pprof/goroutine?debug=2</code></li>
</ul>
</li>
<li>分析堆内存使用情况<ul>
<li><code>curl localhost/debug/pprof/heap?debug=2</code></li>
</ul>
</li>
</ul>
<h4 id="8-Kubernetes中常用代码解读"><a href="#8-Kubernetes中常用代码解读" class="headerlink" title="8. Kubernetes中常用代码解读"></a><font color=DarkOrange>8. Kubernetes中常用代码解读</font></h4><p>Rate Limit Queue</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ItemExponentialFailureRateLimiter)</span></span> When(item <span class="keyword">interface</span>&#123;&#125;) time.Duration &#123;</span><br><span class="line">  r.failuresLock.Lock()</span><br><span class="line">  <span class="keyword">defer</span> r.failuresLock.Unlock()</span><br><span class="line">  </span><br><span class="line">  exp := r.failures[item]</span><br><span class="line">  r.failures[item] = r.failures[item] + <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// The backoff is capped such that ‘calculated’ value never overflows.</span></span><br><span class="line">  backoff := <span class="type">float64</span>(r.baseDelay.Nanoseconds()) * math.Pow(<span class="number">2</span>, <span class="type">float64</span>(exp))</span><br><span class="line">  <span class="keyword">if</span> backoff &gt; math.MaxInt64 &#123;</span><br><span class="line">  	<span class="keyword">return</span> r.maxDelay</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  calculated := time.Duration(backoff)</span><br><span class="line">  <span class="keyword">if</span> calculated &gt; r.maxDelay &#123;</span><br><span class="line">  	<span class="keyword">return</span> r.maxDelay</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> calculated</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-Kubernetes日常运维中的代码调试场景"><a href="#9-Kubernetes日常运维中的代码调试场景" class="headerlink" title="9. Kubernetes日常运维中的代码调试场景"></a><font color=DarkOrange>9. Kubernetes日常运维中的代码调试场景</font></h4><h5 id="9-1-案例1：空指针"><a href="#9-1-案例1：空指针" class="headerlink" title="9.1 案例1：空指针"></a><font color=DarkOrange>9.1 案例1：空指针</font></h5><ul>
<li><p>问题描述</p>
<p>Kubenetes 调度器在调度有外挂存储需求的 pod 的时候，在获取节点信息失败 时会异常退出</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">panic</span>: runtime <span class="type">error</span>: invalid memory address or <span class="literal">nil</span> pointer dereference [signal SIGSEGV: segmentation violation code=<span class="number">0x1</span> addr=<span class="number">0x0</span> pc=<span class="number">0x105e283</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>根因分析</p>
<p>nil pointe 是 Go 语言中最常出现的一类错误，也最容易判断，通常在 call stack 中就会告诉 你哪行代码有问题</p>
<p>在调度器 csi.go 中的如下代码，当 node 为 nil 的时候，对 node 的引用 node.Name 就会 引发空指针</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">node := nodeInfo.Node()</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> framework.NewStatus(framework.Error, fmt.Sprintf(<span class="string">&quot;nodenot found: %s&quot;</span>, node.Name))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决办法</p>
<p>当指针为空时，不要继续引用</p>
<p>GitHub参考地址：<a href="https://github.com/kubernetes/kubernetes/pull/102229">点击跳转</a></p>
</li>
</ul>
<h5 id="9-2-案例2：Map-的读写冲突"><a href="#9-2-案例2：Map-的读写冲突" class="headerlink" title="9.2 案例2：Map 的读写冲突"></a><font color=DarkOrange>9.2 案例2：Map 的读写冲突</font></h5><ul>
<li><p>问题描述</p>
<p>程序在遍历 Kubernetes 对象的 Annotation 时异常退出</p>
</li>
<li><p>根因分析</p>
<p>Kubernetes 对象中 Label 和 Annotation 是 map[string]string</p>
<p>经常有代码需要修改这两个 Map</p>
<p>同时可能有其他线程 for…range 遍历</p>
</li>
<li><p>解决方法</p>
<ul>
<li>用 sync.RWMutex 加锁</li>
<li>使用线程安全 Map，比如 sync.Map{}</li>
</ul>
</li>
</ul>
<h5 id="9-3-案例3：kube-proxy消耗10个CPU"><a href="#9-3-案例3：kube-proxy消耗10个CPU" class="headerlink" title="9.3 案例3：kube-proxy消耗10个CPU"></a><font color=DarkOrange>9.3 案例3：kube-proxy消耗10个CPU</font></h5><ul>
<li><p>问题描述</p>
<p>客户汇报问题，kube-proxy 消耗了主机 10 个 CPU</p>
</li>
<li><p>根因分析</p>
<ul>
<li><p>登录问题机器，执行 top 命令查看 cpu 消耗，可以看到 kube-proxy 的 cpu 消耗和 pid 信息</p>
</li>
<li><p>对 kube-proxy 进程运行 System profiling tool，发现 10 个 CPU 中，超过 60% 的 CPU 都在做垃圾回收，这说明 GC 需要回收的对象太多了， 说明程序创建了大量可回收对象</p>
</li>
<li><p><code>perf top –p</code> </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Overhead Shared Obj Symbol</span><br><span class="line"><span class="number">26.48</span>% kube-proxy [.] runtime.gcDrain</span><br><span class="line"><span class="number">13.86</span>% kube-proxy [.] runtime.greyobject</span><br><span class="line"><span class="number">10.71</span>% kube-proxy [.] runtime.(*lfstack).pop</span><br><span class="line"><span class="number">10.04</span>% kube-proxy [.] runtime.scanobject</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 pprof 分析内存占用情况，<code>curl 127.0.0.1:10249/debug/pprof/heap?debug=2</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="number">245760</span> [<span class="number">301102</span>: <span class="number">73998827520</span>] @ <span class="number">0x11ddcda</span> <span class="number">0x11f306e</span> <span class="number">0x11f35f5</span> <span class="number">0x11fbdce</span> <span class="number">0x1204a8a</span> <span class="number">0x114ed76</span></span><br><span class="line"><span class="number">0x114eacb</span> <span class="number">0x11</span></span><br><span class="line"># &lt;font color=DarkOrange&gt;<span class="number">0x11ddcd9</span>&lt;/font&gt;</span><br><span class="line">k8s.io/kubernetes/vendor/github.com/vishvananda/netlink.(*Handle).RouteListFiltered+<span class="number">0x679</span></span><br><span class="line"># &lt;font color=DarkOrange&gt;<span class="number">0x11f306d</span> k8s.io/kubernetes/pkg/proxy/ipvs.(*netlinkHandle).GetLocalAddresses+<span class="number">0xed</span>&lt;/font&gt;</span><br><span class="line"># &lt;font color=DarkOrange&gt;<span class="number">0x11f35f4</span> k8s.io/kubernetes/pkg/proxy/ipvs.(*realIPGetter).NodeIPs+<span class="number">0x64</span>&lt;/font&gt;</span><br><span class="line"># &lt;font color=DarkOrange&gt;<span class="number">0x11fbdcd</span> k8s.io/kubernetes/pkg/proxy/ipvs.(*Proxier).syncProxyRules+<span class="number">0x47dd</span>&lt;/font&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>heap dump 分析</p>
<ul>
<li>GetLocalAddresses 函数调用创建了 301102 个对象，占用内存 73998827520</li>
<li>如此多的对象被创建，显然会导致 kube-proxy 进程忙于 GC，占用大量 CPU</li>
<li>对照代码分析 GetLocalAddresses 的实现，发现该函数的主要目的是获取节点本机 IP 地址，获取的方法是通过 ip route 命令获得当前节点所有 local 路由信息并转换成 go struct 并过滤掉 ipvs0网口上的路由信息</li>
<li><code>ip route show table local type local proto kernel</code></li>
<li>因为集群规模较大，该命令返回 5000 条左右记录，因此每次函数调用都会有数万个对象被生成</li>
<li>而 kube-proxy 在处理每一个服务的时候都会调用该方法，因为集群有数千个服务，因此，kube-proxy在反复调用该函数创建大量临时对象</li>
</ul>
</li>
<li><p>修复方法</p>
<p>函数调用提取到循环外</p>
<p>GitHub参考地址：<a href="https://github.com/kubernetes/kubernetes/pull/79444">点击跳转</a></p>
</li>
</ul>
<h5 id="9-4-案例4：线程池耗尽"><a href="#9-4-案例4：线程池耗尽" class="headerlink" title="9.4 案例4：线程池耗尽"></a><font color=DarkOrange>9.4 案例4：线程池耗尽</font></h5><ul>
<li><p>问题描述</p>
<p>在 Kubernetes 中有一个控制器，叫做 endpoint controller，该控制器符合生产者消费者模式，默认有5 个 worker 线程作为消费者。该消费者在处理请求时，可能调用的 LBaaS 的 API 更新负载均衡配置。我们 发现该控制器会时不时不工作，具体表现为，该做的配置变更没发生，相关日志也不打印了</p>
</li>
<li><p>根因分析</p>
<p>通过 pprof 打印出该进程的所有 go routine 信息，发现 worker 线程都卡在 http 请求调用处</p>
<p>当worker线程调用 LBaaS API 时，底层是 net&#x2F;http 包调用，而客户端在发起连接请求时，未设置客户端 超时时间。这导致当出现某些网络异常时，客户端会永远处于等待状态</p>
</li>
<li><p>解决方法</p>
<p>修改代码加入客户端超时控制</p>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>云原生</tag>
      </tags>
  </entry>
  <entry>
    <title>Python面试题</title>
    <url>/2023/03/01/Python%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>Python常见面试题分享，涵盖了常见的Python面试八股文</p>
<h4 id="Python语言特点"><a href="#Python语言特点" class="headerlink" title="Python语言特点"></a><font color=DarkOrange>Python语言特点</font></h4><ol>
<li>易学易用：Python语法简单明了，易于学习和上手，代码可读性强，使得开发效率高。</li>
<li>面向对象：Python支持面向对象编程（OOP），包括封装、继承、多态等OOP特性，可以更方便地组织代码和抽象问题。</li>
<li>解释型：Python是解释型语言，不需要编译过程，直接运行源代码，这使得开发和调试变得更加容易</li>
<li>动态类型：Python是动态类型语言，不需要声明变量类型，可以根据需要动态改变变量类型，使得代码更加灵活。</li>
<li>跨平台：Python可以在各种操作系统上运行，包括Windows、Linux、Mac OS等，具有很强的跨平台性。</li>
<li>强大的标准库：Python标准库提供了大量的模块和函数，涵盖了网络编程、GUI编程、多线程编程、正则表达式等各种方面，开发者可以直接使用标准库来完成常见的任务，不需要从零开始编写</li>
<li>第三方库丰富：Python拥有众多的第三方库和框架，如NumPy、Pandas、Django等，可以快速实现各种功能，提高开发效率</li>
<li>可扩展性：Python可以通过C&#x2F;C++扩展模块来提高性能，还可以与其他语言进行混合编程。</li>
<li>开放源代码：Python是一种开放源代码语言，拥有大量的贡献者和用户社区，可以获得免费的开发工具和技术支持</li>
</ol>
<h4 id="1-Python的数据类型有哪些"><a href="#1-Python的数据类型有哪些" class="headerlink" title="1. Python的数据类型有哪些"></a><font color=DarkOrange>1. Python的数据类型有哪些</font></h4><ol>
<li>数字（number）：整数、浮点数和复数</li>
<li>字符串（string）：由字符组成的序列</li>
<li>列表（list）：由一组有序的值组成的序列，可修改</li>
<li>元组（tuple）：由一组有序的值组成的序列，不可修改</li>
<li>集合（set）：由一组唯一的、无序的值组成</li>
<li>字典（dict）：由一组键-值对组成的映射表</li>
<li>布尔值（bool）：表示True或False的值</li>
<li>空值（None）：表示没有值的对象，用None表示</li>
</ol>
<h4 id="2-Python可变与不可变数据类型的区别"><a href="#2-Python可变与不可变数据类型的区别" class="headerlink" title="2. Python可变与不可变数据类型的区别"></a><font color=DarkOrange>2. Python可变与不可变数据类型的区别</font></h4><ul>
<li>可变类型：可以修改其内容的数据类型，包括列表、集合和字典等。修改这些类型的值时，会直接在原始对象上进行修改，而不是创建一个新对象。例如，当向一个列表中添加一个元素时，列表的长度会发生变化，但其身份标识不会改变</li>
<li>不可变类型：一旦创建就不能更改其内容的数据类型，包括整数、浮点数、布尔值、元组和字符串等。如果对这些类型进行修改，将会创建一个新对象。例如，当对一个字符串进行切片或拼接时，会创建一个新的字符串对象</li>
</ul>
<p><strong>注意：</strong>可变类型的修改操作是原地修改，不可变类型的修改操作是创建一个新对象并返回</p>
<h4 id="3-Python列表和元组的区别"><a href="#3-Python列表和元组的区别" class="headerlink" title="3. Python列表和元组的区别"></a><font color=DarkOrange>3. Python列表和元组的区别</font></h4><ol>
<li>可变性：列表是可变的，可以在原地添加、删除或修改元素，而元组是不可变的，无法在原地进行修改操作。</li>
<li>语法：列表使用方括号 [] 来表示，元素之间用逗号分隔；元组使用圆括号 () 来表示，元素之间也用逗号分隔。如果元组只包含一个元素，需要在该元素后面添加一个逗号来表示它是一个元组而不是一个普通的值。</li>
<li>性能：元组相对于列表来说，在创建、遍历和访问元素时具有更高的性能，因为元组的结构是不可变的，因此在创建后不需要再进行修改，不会出现额外的开销</li>
<li>用途：列表通常用于需要添加、删除或修改元素的场景，如缓存数据、维护计数器、记录用户输入等；而元组通常用于存储一些固定的、不可变的数据，如坐标点、日期、时间等</li>
</ol>
<h4 id="4-Python列表的基本操作"><a href="#4-Python列表的基本操作" class="headerlink" title="4. Python列表的基本操作"></a><font color=DarkOrange>4. Python列表的基本操作</font></h4><ol>
<li>创建列表：使用方括号 [] 将一组元素括起来即可创建一个列表，例如：<code>a = [1, 2, 3, 4, 5]</code></li>
<li>索引和切片：可以使用索引和切片操作来访问列表中的元素，例如：<code>a[0]</code> 返回列表中的第一个元素，<code>a[1:3]</code> 返回列表中第二个到第四个元素。</li>
<li>修改元素：可以通过索引来修改列表中的元素，例如：<code>a[0] = 0</code> 将列表中的第一个元素修改为0</li>
<li>添加元素：可以使用 <code>append()</code> 方法向列表末尾添加一个元素，使用 <code>insert()</code> 方法在指定位置插入一个元素，例如：<code>a.append(6)</code>，<code>a.insert(0, 0)</code></li>
<li>删除元素：可以使用 <code>del</code> 语句、<code>remove()</code> 方法或 <code>pop()</code> 方法来删除列表中的元素，例如：<code>del a[0]</code> 删除列表中的第一个元素，<code>a.remove(3)</code> 删除列表中值为3的元素，<code>a.pop()</code> 删除并返回列表中的最后一个元素。</li>
<li>合并列表：可以使用 <code>+</code> 运算符将两个列表合并成一个新列表，例如：<code>a + [6, 7, 8]</code></li>
<li>复制列表：可以使用切片或 <code>copy()</code> 方法来复制一个列表，例如：<code>b = a[:]</code> 或 <code>b = a.copy()</code></li>
<li>获取列表长度：可以使用 <code>len()</code> 函数来获取列表的长度，例如：<code>len(a)</code> 返回列表 a 中元素的个数</li>
</ol>
<h4 id="5-Python中的列表推导式"><a href="#5-Python中的列表推导式" class="headerlink" title="5. Python中的列表推导式"></a><font color=DarkOrange>5. Python中的列表推导式</font></h4><p>Python中的列表推导式（List Comprehension）是一种简洁而强大的语法，可以快速地创建一个新的列表，语法形式为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[expression <span class="keyword">for</span> item <span class="keyword">in</span> iterable <span class="keyword">if</span> condition]</span><br></pre></td></tr></table></figure>

<p>其中，<code>expression</code> 是一个表达式，用于计算新列表中每个元素的值；<code>item</code> 是 iterable（可迭代对象）中的一个元素；<code>if condition</code> 是一个可选的条件语句，用于过滤 iterable 中的元素。</p>
<p>举个例子，假设我们需要创建一个列表，其中包含从 0 到 9 的所有偶数的平方，可以使用列表推导式来实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>上述代码首先使用 <code>range(10)</code> 函数生成一个从 0 到 9 的整数序列，然后通过 <code>if</code> 语句过滤出其中的偶数，最后对每个偶数进行平方运算并添加到新列表中。因此，<code>squares</code> 列表的值为 <code>[0, 4, 16, 36, 64]</code></p>
<p>除了基本形式外，列表推导式还支持嵌套、多个 <code>for</code> 循环和多个 <code>if</code> 条件语句的组合，可以根据需要进行组合和使用，以满足不同的需求。列表推导式具有简洁、高效和易读的特点</p>
<h4 id="6-Python删除list里的重复元素有几种方法"><a href="#6-Python删除list里的重复元素有几种方法" class="headerlink" title="6. Python删除list里的重复元素有几种方法"></a><font color=DarkOrange>6. Python删除list里的重复元素有几种方法</font></h4><ol>
<li><p>使用 set() 函数去重：将列表转换为 set 集合，再将其转换为列表即可，但是这种方法会改变列表元素的顺序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">lst = <span class="built_in">list</span>(<span class="built_in">set</span>(lst))</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># 输出 [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用列表推导式去重：利用列表推导式，遍历原列表，将不重复的元素添加到新列表中，缺点是需要额外的空间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">new_lst = []</span><br><span class="line">[new_lst.append(i) <span class="keyword">for</span> i <span class="keyword">in</span> lst <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> new_lst]</span><br><span class="line"><span class="built_in">print</span>(new_lst)  <span class="comment"># 输出 [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 for 循环去重：利用 for 循环遍历原列表，将不重复的元素添加到新列表中，这种方法比较简单但速度较慢</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">new_lst = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lst:</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> new_lst:</span><br><span class="line">        new_lst.append(i)</span><br><span class="line"><span class="built_in">print</span>(new_lst)  <span class="comment"># 输出 [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用字典的 fromkeys() 方法去重：利用字典的键不能重复的特性，将列表中的元素作为字典的键，再将字典的键转换为列表即可，但是这种方法也会改变列表元素的顺序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">lst = <span class="built_in">list</span>(<span class="built_in">dict</span>.fromkeys(lst))</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># 输出 [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>注意：</strong>这些方法各有优缺点，可以根据实际情况选择使用，常见的方法有 set() 函数和列表推导式，因为它们简单、直观且效率高</p>
<h4 id="7-Python类型转换"><a href="#7-Python类型转换" class="headerlink" title="7. Python类型转换"></a><font color=DarkOrange>7. Python类型转换</font></h4><ol>
<li><code>int(x)</code>：将 x 转换为一个整数。如果 x 无法转换为整数，则会抛出 ValueError 异常</li>
<li><code>float(x)</code>：将 x 转换为一个浮点数。如果 x 无法转换为浮点数，则会抛出 ValueError 异常。</li>
<li><code>str(x)</code>：将 x 转换为一个字符串。如果 x 无法转换为字符串，则会抛出 TypeError 异常</li>
<li><code>bool(x)</code>：将 x 转换为一个布尔值。如果 x 为假值（如空字符串、0、False），则返回 False，否则返回 True。</li>
<li><code>list(x)</code>：将 x 转换为一个列表。如果 x 不可迭代或没有实现 <strong>iter</strong> 方法，则会抛出 TypeError 异常</li>
<li><code>tuple(x)</code>：将 x 转换为一个元组。如果 x 不可迭代或没有实现 <strong>iter</strong> 方法，则会抛出 TypeError 异常</li>
<li><code>set(x)</code>：将 x 转换为一个集合。如果 x 不可迭代或没有实现 <strong>iter</strong> 方法，则会抛出 TypeError 异常。</li>
<li><code>dict(x)</code>：将 x 转换为一个字典。如果 x 不是映射类型（如字典或实现了 <strong>getitem</strong> 方法的类），则会抛出 TypeError 异常</li>
</ol>
<p><strong>注意：</strong>类型转换时可能会出现异常，因此在进行类型转换时需要注意错误处理，避免程序崩溃。同时，Python 中还有其他一些类型转换函数，如 <code>complex()</code> 用于将字符串或数字转换为复数、<code>bytes()</code> 用于将字符串或整数转换为字节串等，可以根据需要进行使用</p>
<h4 id="8-Python字典以及基本操作"><a href="#8-Python字典以及基本操作" class="headerlink" title="8. Python字典以及基本操作"></a><font color=DarkOrange>8. Python字典以及基本操作</font></h4><p>Python 中的字典是一种无序的可变集合，它包含键和对应的值。字典中的键必须是不可变的类型，例如整数、字符串、元组等，而值可以是任何类型</p>
<ol>
<li><p>创建字典：可以使用花括号 {} 或 dict() 函数来创建一个空字典，或者使用键值对的方式来初始化一个字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建空字典</span></span><br><span class="line">my_dict = &#123;&#125;</span><br><span class="line">my_dict = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化字典</span></span><br><span class="line">my_dict = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;</span><br><span class="line">my_dict = <span class="built_in">dict</span>(name=<span class="string">&#x27;Alice&#x27;</span>, age=<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加或更新键值对：可以使用赋值运算符或 <code>update()</code> 方法来添加或更新字典中的键值对</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加键值对</span></span><br><span class="line">my_dict[<span class="string">&#x27;gender&#x27;</span>] = <span class="string">&#x27;female&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新键值对</span></span><br><span class="line">my_dict[<span class="string">&#x27;age&#x27;</span>] = <span class="number">21</span></span><br><span class="line">my_dict.update(&#123;<span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;female&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">21</span>&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除键值对：可以使用 <code>del</code> 关键字或 <code>pop()</code> 方法来删除字典中的键值对</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除键值对</span></span><br><span class="line"><span class="keyword">del</span> my_dict[<span class="string">&#x27;gender&#x27;</span>]</span><br><span class="line">my_dict.pop(<span class="string">&#x27;age&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问键值对：可以使用键来访问字典中的值，如果键不存在则会抛出 <code>KeyError</code> 异常。可以使用 <code>get()</code> 方法来避免这种情况，并返回一个默认值（默认为 <code>None</code>）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 访问键值对</span></span><br><span class="line">name = my_dict[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">age = my_dict.get(<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line">gender = my_dict.get(<span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;unknown&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历字典：可以使用 <code>for</code> 循环来遍历字典的键或值，或者使用 <code>items()</code> 方法来遍历键值对</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 遍历键</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> my_dict:</span><br><span class="line">    <span class="built_in">print</span>(key)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历值</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> my_dict.values():</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历键值对</span></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> my_dict.items():</span><br><span class="line">    <span class="built_in">print</span>(key, value)</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他方法：字典还提供了一些其他常用的方法，例如 <code>keys()</code> 方法用于获取所有键的视图，<code>values()</code> 方法用于获取所有值的视图，<code>clear()</code> 方法用于清空字典等</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取键的视图</span></span><br><span class="line">keys = my_dict.keys()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取值的视图</span></span><br><span class="line">values = my_dict.values()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空字典</span></span><br><span class="line">my_dict.clear()</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>注意：</strong>字典是一种无序的数据结构，因此不能通过下标来访问字典中的元素，而是需要使用键来访问相应的值。另外，字典中的键必须是唯一的，如果有多个相同的键，则后面的键值对会覆盖前面的</p>
<h4 id="9-Python中的list和dict是怎么实现的"><a href="#9-Python中的list和dict是怎么实现的" class="headerlink" title="9. Python中的list和dict是怎么实现的"></a><font color=DarkOrange>9. Python中的list和dict是怎么实现的</font></h4><ol>
<li>列表的实现方式：Python 中的列表是一种动态数组，它实际上是一个由一系列连续的内存块组成的结构。每个元素都存储在内存中的一个单独的位置，通过索引可以直接访问相应位置的元素。当列表的长度发生变化时，Python 会重新分配一块更大或更小的内存空间来存储新的元素，然后将原来的元素拷贝到新的内存空间中。由于这种实现方式需要频繁地分配和拷贝内存，因此当列表较大时会带来一定的性能开销。</li>
<li>字典：Python 中的字典采用了一种哈希表的实现方式，它通过将键映射到内存地址来实现快速的键值查找。具体来说，字典实际上是一个由哈希桶组成的数组，每个哈希桶中存储着一条链表，链表中的每个节点都包含了一个键值对。当插入一个新的键值对时，Python 会根据键的哈希值将其插入到对应的哈希桶中，如果发现冲突则会将新的节点插入到链表的末尾。当查找一个键值对时，Python 首先计算键的哈希值，然后在相应的哈希桶中查找对应的链表，最后在链表中遍历查找相应的节点。由于哈希表的查找操作复杂度为 O(1)，因此字典在查找键值对时具有很高的效率。当字典中的键值对数量变化时，Python 会根据需要动态调整哈希表的大小，以保证哈希桶的装载因子在一个合理的范围内</li>
</ol>
<p><strong>注意：</strong>列表和字典的实现方式不仅影响它们的性能，还影响了它们的特性和用法。例如，由于列表是一种连续的内存结构，因此可以使用切片和排序等操作来修改和排序列表中的元素；而由于字典是一种哈希表结构，因此它不支持切片和排序等操作，但支持键值查找和更新等操作</p>
<h4 id="10-Python字符串格式化的几种方式"><a href="#10-Python字符串格式化的几种方式" class="headerlink" title="10. Python字符串格式化的几种方式"></a><font color=DarkOrange>10. Python字符串格式化的几种方式</font></h4><ol>
<li><p>使用 % 运算符：可以使用 % 运算符将变量插入到字符串中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;Alice&quot;</span></span><br><span class="line">age = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My name is %s and I am %d years old.&quot;</span> % (name, age))</span><br></pre></td></tr></table></figure>

<p>输出结果为：<code>My name is Alice and I am 20 years old.</code></p>
</li>
<li><p>使用 format() 方法：可以使用 format() 方法将变量插入到字符串中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;Bob&quot;</span></span><br><span class="line">age = <span class="number">25</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My name is &#123;&#125; and I am &#123;&#125; years old.&quot;</span>.<span class="built_in">format</span>(name, age))</span><br></pre></td></tr></table></figure>

<p>输出结果为：<code>My name is Bob and I am 25 years old.</code></p>
</li>
<li><p>使用 f-string：可以使用 f-string 将变量插入到字符串中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;Charlie&quot;</span></span><br><span class="line">age = <span class="number">30</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;My name is <span class="subst">&#123;name&#125;</span> and I am <span class="subst">&#123;age&#125;</span> years old.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>输出结果为：<code>My name is Charlie and I am 30 years old.</code></p>
</li>
<li><p>使用模板字符串：可以使用模板字符串来格式化字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> Template</span><br><span class="line"></span><br><span class="line">name = <span class="string">&quot;Dave&quot;</span></span><br><span class="line">age = <span class="number">35</span></span><br><span class="line"></span><br><span class="line">template = Template(<span class="string">&quot;My name is $name and I am $age years old.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(template.substitute(name=name, age=age))</span><br></pre></td></tr></table></figure>

<p>输出结果为：<code>My name is Dave and I am 35 years old.</code></p>
</li>
</ol>
<h4 id="11-Python中-args和-kwargs"><a href="#11-Python中-args和-kwargs" class="headerlink" title="11. Python中*args和**kwargs"></a><font color=DarkOrange>11. Python中*args和**kwargs</font></h4><p>Python 中，<code>*args</code> 和 <code>**kwargs</code> 用于在函数定义时接受任意数量的参数，<strong>只能放在参数的最后位置</strong></p>
<ol>
<li><p><code>*args</code>：<code>*args</code> 表示接受任意数量的位置参数（Positional Arguments），这些参数将被作为元组传递给函数。具体来说，当函数定义时使用 <code>*args</code> 时，它可以接受任意数量的位置参数，这些参数将被打包成一个元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        <span class="built_in">print</span>(arg)</span><br><span class="line"></span><br><span class="line">my_func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment"># 输出结果为：1 2 3</span></span><br><span class="line">my_func(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>)  <span class="comment"># 输出结果为：a b c d</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，函数 <code>my_func()</code> 使用了 <code>*args</code>，它可以接受任意数量的位置参数，并将它们打包成一个元组。在函数内部，我们可以使用 <code>for</code> 循环遍历元组中的每个元素</p>
</li>
<li><p><code>**kwargs</code>：<code>**kwargs</code> 表示接受任意数量的关键字参数（Keyword Arguments），这些参数将被作为字典传递给函数。具体来说，当函数定义时使用 <code>**kwargs</code> 时，它可以接受任意数量的关键字参数，这些参数将被打包成一个字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>(<span class="params">**kwargs</span>):</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;key&#125;</span> = <span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">my_func(name=<span class="string">&quot;Alice&quot;</span>, age=<span class="number">20</span>)  <span class="comment"># 输出结果为：name = Alice, age = 20</span></span><br><span class="line">my_func(country=<span class="string">&quot;USA&quot;</span>, city=<span class="string">&quot;New York&quot;</span>, language=<span class="string">&quot;English&quot;</span>)  <span class="comment"># 输出结果为：country = USA, city = New York, language = English</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，函数 <code>my_func()</code> 使用了 <code>**kwargs</code>，它可以接受任意数量的关键字参数，并将它们打包成一个字典。在函数内部，我们可以使用字典的 <code>items()</code> 方法遍历字典中的每个键值对</p>
</li>
<li><p>除了在函数定义时使用 <code>*args</code> 和 <code>**kwargs</code> 外，它们还可以在函数调用时使用。当在函数调用时使用 <code>*args</code> 和 <code>**kwargs</code> 时，它们的作用是将一个序列或字典拆包成多个参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;a = <span class="subst">&#123;a&#125;</span>, b = <span class="subst">&#123;b&#125;</span>, c = <span class="subst">&#123;c&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">my_func(*args)  <span class="comment"># 等价于 my_func(1, 2, 3)</span></span><br><span class="line"></span><br><span class="line">kwargs = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>, <span class="string">&quot;c&quot;</span>: <span class="number">3</span>&#125;</span><br><span class="line">my_func(**kwargs)  <span class="comment"># 等价于 my_func(a=1, b=2, c=3)</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们首先定义了一个函数 <code>my_func()</code>，它接受三个位置参数。然后，我们定义了一个元组 <code>args</code> 和一个字典 <code>kwargs</code>，分别包含三个元素和三个键值对</p>
</li>
</ol>
<h4 id="12-Python中深拷贝和浅拷贝的区别"><a href="#12-Python中深拷贝和浅拷贝的区别" class="headerlink" title="12. Python中深拷贝和浅拷贝的区别"></a><font color=DarkOrange>12. Python中深拷贝和浅拷贝的区别</font></h4><p>Python 中的拷贝操作分为浅拷贝（Shallow Copy）和深拷贝（Deep Copy），它们的主要区别在于复制后的对象是否共享内存</p>
<ol>
<li><p>浅拷贝：指创建一个新的对象，但是这个新对象只是原始对象的一个副本，它们共享相同的内存地址。也就是说，当我们修改其中一个对象时，另一个对象也会被修改。在 Python 中，可以使用 <code>copy()</code> 方法或切片操作来进行浅拷贝</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 浅拷贝示例</span></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">list2 = list1.copy()  <span class="comment"># 浅拷贝</span></span><br><span class="line">list1[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">list1[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">300</span></span><br><span class="line"><span class="built_in">print</span>(list1)  <span class="comment"># [100, 2, [300, 4]]</span></span><br><span class="line"><span class="built_in">print</span>(list2)  <span class="comment"># [1, 2, [300, 4]]</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们创建了一个包含三个元素的列表 <code>list1</code>，其中第三个元素是一个嵌套列表。然后，我们对 <code>list1</code> 进行了浅拷贝，得到了一个新的列表 <code>list2</code>。接着，我们修改了 <code>list1</code> 的第一个元素和第三个元素的第一个元素，然后打印出了 <code>list1</code> 和 <code>list2</code>。可以看到，虽然 <code>list1</code> 和 <code>list2</code> 是不同的对象，但是它们共享了第三个元素的内存地址，所以修改其中一个对象的值也会影响另一个对象的值</p>
</li>
<li><p>深拷贝：指创建一个新的对象，并且递归地复制它所包含的所有对象。也就是说，当我们修改其中一个对象时，另一个对象不会受到影响。在 Python 中，可以使用 <code>copy.deepcopy()</code> 方法进行深拷贝</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 深拷贝示例</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">list2 = copy.deepcopy(list1)  <span class="comment"># 深拷贝</span></span><br><span class="line">list1[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">list1[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">300</span></span><br><span class="line"><span class="built_in">print</span>(list1)  <span class="comment"># [100, 2, [300, 4]]</span></span><br><span class="line"><span class="built_in">print</span>(list2)  <span class="comment"># [1, 2, [3, 4]]</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们使用 <code>copy.deepcopy()</code> 方法对 <code>list1</code> 进行了深拷贝，得到了一个新的列表 <code>list2</code>。然后，我们修改了 <code>list1</code> 的第一个元素和第三个元素的第一个元素，然后打印出了 <code>list1</code> 和 <code>list2</code>。可以看到，虽然 <code>list1</code> 和 <code>list2</code> 是不同的对象，并且它们不共享任何内存地址，所以修改其中一个对象的值不会影响另一个对象的值</p>
</li>
</ol>
<h4 id="13-Python中的单引号和双引号的区别"><a href="#13-Python中的单引号和双引号的区别" class="headerlink" title="13. Python中的单引号和双引号的区别"></a><font color=DarkOrange>13. Python中的单引号和双引号的区别</font></h4><p>单引号和双引号都可以用来表示字符串，它们的主要区别在于字符串中是否包含了引号本身</p>
<p>单引号用来表示包含双引号的字符串，双引号用来表示包含单引号的字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用单引号表示包含双引号的字符串</span></span><br><span class="line">str1 = <span class="string">&#x27;I said, &quot;Hello!&quot;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(str1)  <span class="comment"># I said, &quot;Hello!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用双引号表示包含单引号的字符串</span></span><br><span class="line">str2 = <span class="string">&quot;It&#x27;s a beautiful day.&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str2)  <span class="comment"># It&#x27;s a beautiful day.</span></span><br></pre></td></tr></table></figure>

<p>在 Python 中，还有一种特殊的字符串格式，称为三引号（Triple quotes）。它可以用来表示包含多行文本的字符串，不需要在每行文本中使用转义字符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用三引号表示多行字符串</span></span><br><span class="line">str3 = <span class="string">&#x27;&#x27;&#x27;Hello,</span></span><br><span class="line"><span class="string">           world!</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(str3)</span><br><span class="line"><span class="comment"># Hello,</span></span><br><span class="line"><span class="comment">#            world!</span></span><br></pre></td></tr></table></figure>

<p>上面的示例中，我们使用三引号来表示包含多行文本的字符串，这样可以避免在每行文本中使用转义字符，使代码更加简洁易读</p>
<h4 id="14-Python中append、insert和extend的区别"><a href="#14-Python中append、insert和extend的区别" class="headerlink" title="14. Python中append、insert和extend的区别"></a><font color=DarkOrange>14. Python中append、insert和extend的区别</font></h4><p>在 Python 中，<code>append()</code>、<code>insert()</code> 和 <code>extend()</code> 都是用来向列表（list）中添加元素的方法</p>
<ol>
<li><p><code>append</code>: 在列表末尾添加一个元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">lst.append(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>insert</code>: 在指定位置插入一个元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">lst.insert(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [1, 4, 2, 3]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>extend</code>: 将一个列表的所有元素添加到另一个列表的末尾</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">lst2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">lst1.extend(lst2)</span><br><span class="line"><span class="built_in">print</span>(lst1)  <span class="comment"># [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="15-Python中break、continue、pass是什么"><a href="#15-Python中break、continue、pass是什么" class="headerlink" title="15. Python中break、continue、pass是什么"></a><font color=DarkOrange>15. Python中break、continue、pass是什么</font></h4><p>在 Python 中，<code>break</code>、<code>continue</code> 和 <code>pass</code> 都是控制语句，用于控制循环的执行流程</p>
<ul>
<li><code>break</code> 语句用于终止循环，并跳出循环体。当循环条件不成立或者执行 <code>break</code> 语句时，循环会立即停止执行。</li>
<li><code>continue</code> 语句用于跳过当前循环中的某些语句，直接进入下一次循环的判断。当 <code>continue</code> 语句执行时，循环体中后续的语句都不会执行，而是直接跳到下一次循环的判断</li>
<li><code>pass</code> 语句用于占位，表示一个空语句。当需要在代码中添加一个空语句，但是又不能让 Python 报错时，就可以使用 <code>pass</code> 语句</li>
</ul>
<h4 id="16-Python中的remove、del和pop"><a href="#16-Python中的remove、del和pop" class="headerlink" title="16. Python中的remove、del和pop"></a><font color=DarkOrange>16. Python中的remove、del和pop</font></h4><p>在 Python 中，<code>remove</code>、<code>del</code> 和 <code>pop</code> 都是用来删除列表元素的方法</p>
<ol>
<li><p><code>remove</code> ：列表的内置函数，用于删除列表中指定的元素。如果列表中有多个相同的元素，它只会删除第一个匹配项，如果元素不存在则会抛出 <code>ValueError</code> 异常。如果要删除所有匹配项，可以使用循环或列表推导式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">lst.remove(<span class="number">3</span>)  <span class="comment"># 从列表中删除元素 3</span></span><br><span class="line"><span class="built_in">print</span>(lst)     <span class="comment"># [1, 2, 4, 5]</span></span><br><span class="line">lst.remove(<span class="number">6</span>)  <span class="comment"># 抛出 ValueError 异常，因为元素 6 不存在于列表中</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>del</code> ：Python的关键字，用于删除列表中指定位置的元素。它可以删除单个元素，也可以删除切片。如果删除的是切片，则删除的是切片中的所有元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">del</span> lst[<span class="number">2</span>]   <span class="comment"># 从列表中删除索引为 2 的元素，即元素 3</span></span><br><span class="line"><span class="built_in">print</span>(lst)   <span class="comment"># [1, 2, 4, 5]</span></span><br><span class="line"><span class="keyword">del</span> lst[<span class="number">10</span>]  <span class="comment"># 抛出 IndexError 异常，因为索引 10 超出了列表的长度</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>pop</code> ：列表的内置函数，用于删除列表中指定位置的元素并返回该元素。如果没有指定位置，则默认删除最后一个元素。如果要删除的位置不存在，则会引发IndexError异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">x = lst.pop(<span class="number">2</span>)  <span class="comment"># 删除索引为 2 的元素，即元素 3，并将其赋值给变量 x</span></span><br><span class="line"><span class="built_in">print</span>(x)        <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(lst)      <span class="comment"># [1, 2, 4, 5]</span></span><br><span class="line">x = lst.pop()   <span class="comment"># 删除最后一个元素，即元素 5，并将其赋值给变量 x</span></span><br><span class="line"><span class="built_in">print</span>(x)        <span class="comment"># 5</span></span><br><span class="line"><span class="built_in">print</span>(lst)      <span class="comment"># [1, 2, 4]</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>注意：</strong>如果需要删除列表中所有元素，可以使用 <code>lst.clear()</code> 方法</p>
<h4 id="17-Python中-x3D-x3D-和is的区别"><a href="#17-Python中-x3D-x3D-和is的区别" class="headerlink" title="17. Python中&#x3D;&#x3D;和is的区别"></a><font color=DarkOrange>17. Python中&#x3D;&#x3D;和is的区别</font></h4><ol>
<li><code>==</code> 运算符用于比较两个对象的值是否相等，它会比较对象的内容而不是它们的身份标识（内存地址）</li>
<li><code>is</code> 运算符用于比较两个对象的内存地址是否相等，也就是它们是否指向内存中的同一块地址</li>
</ol>
<h4 id="18-Python中-x3D-和is-not的区别"><a href="#18-Python中-x3D-和is-not的区别" class="headerlink" title="18. Python中!&#x3D;和is not的区别"></a><font color=DarkOrange>18. Python中!&#x3D;和is not的区别</font></h4><ol>
<li><code>!=</code> 运算符用于比较两个对象的值是否不相等，它与 <code>==</code> 运算符的作用相反</li>
<li><code>is not</code> 运算符用于比较两个对象的内存地址是否不相等，它与 <code>is</code> 运算符的作用相反</li>
</ol>
<h4 id="19-Python中iterables和iterators的区别"><a href="#19-Python中iterables和iterators的区别" class="headerlink" title="19. Python中iterables和iterators的区别"></a><font color=DarkOrange>19. Python中iterables和iterators的区别</font></h4><ol>
<li>Iterables（可迭代对象）是指那些可以被迭代的对象，例如列表、元组、字典等。这些对象可以通过 <code>for</code> 循环进行迭代，或者使用 <code>iter()</code> 函数将其转换为一个迭代器对象。</li>
<li>Iterators（迭代器）是指那些实现了 <code>__iter__()</code> 和 <code>__next__()</code> 方法的对象。<code>__iter__()</code> 方法返回迭代器对象自身，而 <code>__next__()</code> 方法返回下一个迭代值。迭代器可以用于访问集合中的元素，并且只能向前移动，一旦到达末尾就不能再次迭代</li>
</ol>
<p>因此，iterables 是一类对象，它们可以被迭代；而 iterators 是一类对象，它们是可迭代对象的具体实现，可以用于遍历可迭代对象中的元素。可以使用 <code>iter()</code> 函数将 iterables 转换为 iterators</p>
<p><strong>注意：</strong>只有实现了 <code>__iter__()</code> 方法的对象才是可迭代对象，而实现了 <code>__next__()</code> 方法的对象才是迭代器。如果一个对象既可以通过 <code>iter()</code> 函数转换为迭代器，又可以通过 <code>__iter__()</code> 方法返回迭代器对象自身，那么它就是一个迭代器</p>
<h4 id="20-Python解释器种类以及特点"><a href="#20-Python解释器种类以及特点" class="headerlink" title="20. Python解释器种类以及特点"></a><font color=DarkOrange>20. Python解释器种类以及特点</font></h4><ol>
<li>CPython：CPython 是 Python 官方实现，使用 C 语言编写。它是最常用的 Python 解释器，也是默认的解释器。CPython 的特点是运行速度较快，支持多种操作系统和平台，可以调用 C&#x2F;C++ 库，但占用资源较多。</li>
<li>Jython：Jython 是一种基于 Java 平台的 Python 解释器，它将 Python 代码转换为 Java 字节码执行。Jython 的特点是具有与 Java 平台相关的优点，例如垃圾回收、多线程等，但速度较慢，不支持一些 Python 特性和 C&#x2F;C++ 库。</li>
<li>IronPython：IronPython 是一种基于 .NET 平台的 Python 解释器，它将 Python 代码转换为 .NET 代码执行。IronPython 的特点是具有与 .NET 平台相关的优点，例如可重用性、可扩展性等，但速度较慢，不支持一些 Python 特性和 C&#x2F;C++ 库</li>
<li>PyPy：PyPy 是一种基于 Python 实现的解释器，它使用了即时编译技术，可以使 Python 代码的执行速度比 CPython 快 5-10 倍。PyPy 的特点是速度快，支持多种操作系统和平台，但不支持一些 Python 特性和 C&#x2F;C++ 库。</li>
<li>MicroPython：MicroPython 是一种专为嵌入式系统开发的 Python 解释器，它可以在资源受限的系统中运行 Python 代码。MicroPython 的特点是占用资源少、运行速度较快、支持硬件编程和网络编程等</li>
</ol>
<h4 id="21-Python面向对象三大特性"><a href="#21-Python面向对象三大特性" class="headerlink" title="21. Python面向对象三大特性"></a><font color=DarkOrange>21. Python面向对象三大特性</font></h4><ol>
<li><p>封装：封装是将数据和行为封装在一个单元中，通过接口来控制外部对内部的访问。Python 中的封装通过类的定义实现，将数据和方法定义在类中，并通过访问控制符号（public、private、protected）来控制访问权限</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.__age = age  <span class="comment"># 私有属性，外部无法直接访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;My name is &#123;0&#125;, and I&#x27;m &#123;1&#125; years old.&quot;</span>.<span class="built_in">format</span>(self.name, self.__age))</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(p.name)  <span class="comment"># 可以访问公有属性 name</span></span><br><span class="line"><span class="built_in">print</span>(p.__age)  <span class="comment"># 无法直接访问私有属性 __age，会抛出 AttributeError 异常</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>继承：继承是指一个类可以从另一个类中继承属性和方法，从而实现代码的复用和扩展。Python 中的继承通过在类定义中指定父类实现，子类可以继承父类的属性和方法，并可以在此基础上添加自己的属性和方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Woof!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Meow!&quot;</span>)</span><br><span class="line"></span><br><span class="line">dog = Dog(<span class="string">&quot;Rufus&quot;</span>)</span><br><span class="line">cat = Cat(<span class="string">&quot;Fluffy&quot;</span>)</span><br><span class="line">dog.speak()  <span class="comment"># 输出 &quot;Woof!&quot;</span></span><br><span class="line">cat.speak()  <span class="comment"># 输出 &quot;Meow!&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多态：多态是指同一种操作或函数可以有多种不同的实现方式，提高了代码的灵活性和可扩展性。Python 中的多态通过继承和方法重写实现，子类可以重写父类的方法，从而实现不同的行为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>(<span class="title class_ inherited__">Shape</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Draw a circle.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span>(<span class="title class_ inherited__">Shape</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Draw a square.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span>(<span class="title class_ inherited__">Shape</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Draw a triangle.&quot;</span>)</span><br><span class="line"></span><br><span class="line">shapes = [Circle(), Square(), Triangle()]</span><br><span class="line"><span class="keyword">for</span> shape <span class="keyword">in</span> shapes:</span><br><span class="line">    shape.draw()  <span class="comment"># 多态，根据不同的对象调用不同的实现方式</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="22-Python多重继承"><a href="#22-Python多重继承" class="headerlink" title="22. Python多重继承"></a><font color=DarkOrange>22. Python多重继承</font></h4><p>Python多重继承是指一个类可以同时继承多个父类的特性。在Python中，多重继承可以通过在类定义时在括号内列出多个父类来实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method_a</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method_b</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;B&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(A, B):  <span class="comment"># 多重继承</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method_c</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;C&quot;</span>)</span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line">c.method_a()  <span class="comment"># 输出 &quot;A&quot;</span></span><br><span class="line">c.method_b()  <span class="comment"># 输出 &quot;B&quot;</span></span><br><span class="line">c.method_c()  <span class="comment"># 输出 &quot;C&quot;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>方法解析顺序（MRO）：当一个类继承多个父类时，Python会按照一定的顺序来查找方法，这个顺序被称为方法解析顺序（MRO），MRO的计算方式是通过C3算法来实现的</li>
<li>调用父类方法：当一个类继承多个父类时，如果这些父类中有同名的方法，Python会按照MRO的顺序来调用这些方法。如果需要调用指定父类的方法，可以使用super()函数来实现。</li>
<li>Diamond继承问题：当一个类继承多个父类时，如果这些父类之间存在继承关系，就会出现Diamond继承问题，这个问题可以通过使用抽象基类（ABC）来解决</li>
</ol>
<p><strong>注意：</strong>多重继承也可能会导致一些问题，例如父类中有同名方法或属性时，可能会产生歧义；还可能会增加代码的复杂性和维护难度。因此，在使用多重继承时，需要谨慎设计和管理类的层次结构</p>
<h4 id="23-Python变量、函数、类的命名规则"><a href="#23-Python变量、函数、类的命名规则" class="headerlink" title="23. Python变量、函数、类的命名规则"></a><font color=DarkOrange>23. Python变量、函数、类的命名规则</font></h4><ol>
<li>只能包含字母、数字和下划线，不能以数字开头；</li>
<li>不允许使用 Python 的关键字和保留字，如 if、while、class、def 等</li>
<li>变量和函数名使用小写字母，多个单词用下划线连接，如 my_var、my_function</li>
<li>类名使用大写字母开头，多个单词使用驼峰命名法，如 MyClass、MyClassExample；</li>
<li>前导下划线表示私有属性或方法，双前导下划线表示强制私有，后续加上类名的前导下划线表示受保护的属性或方法，如 my_var、my_var、MyClass_my_var</li>
</ol>
<h4 id="4-Python中迭代器和生成器"><a href="#4-Python中迭代器和生成器" class="headerlink" title="4. Python中迭代器和生成器"></a><font color=DarkOrange>4. Python中迭代器和生成器</font></h4><ol>
<li><p>迭代器：是一种访问集合元素的方式，迭代器对象从集合的第一个元素开始访问，直到所有元素被访问完毕。迭代器只能往前不会后退，而且在迭代过程中无法修改集合元素</p>
<p>Python中的迭代器有两个基本的方法：iter() 和 next()</p>
<ul>
<li>iter(object[, sentinel]) 函数用来生成迭代器，object 是可迭代对象，sentinel 是可选的，如果传递了第二个参数，则参数 object 必须是一个可调用的对象（如函数），此时，iter 创建了一个迭代器对象，每次调用这个迭代器对象的 <code>__next__()</code> 方法时，都会调用 object</li>
<li>next(iterator[, default]) 函数用来获取迭代器的下一个元素，如果迭代器已经到了最后一个元素，再次调用 next() 函数会抛出 StopIteration 异常，default 是可选的，如果迭代器已经到了最后一个元素，返回 default 值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 迭代器示例</span></span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">my_iterator = <span class="built_in">iter</span>(my_list)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_iterator))  <span class="comment"># 输出 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_iterator))  <span class="comment"># 输出 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_iterator))  <span class="comment"># 输出 3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生成器：是一种特殊的迭代器，它是通过函数来实现的，生成器函数在执行时会生成一个生成器对象，生成器对象是一个可迭代对象，每次调用生成器对象的 <code>__next__()</code> 方法时，都会执行生成器函数中的代码，直到遇到 yield 语句，yield 语句会返回一个值，并暂停生成器函数的执行，下次调用 <code>__next__()</code> 方法时，生成器函数会从 yield 语句暂停的位置继续执行</p>
<p>Python中的生成器有两种实现方式：生成器函数和生成器表达式</p>
<p>生成器函数是通过 def 关键字定义的函数，函数中包含 yield 语句，生成器函数在执行时会生成一个生成器对象</p>
<p>生成器可以帮助我们节省内存，因为生成器每次只会返回一个值，而不会一次性将所有值都存储在内存中。另外，生成器还可以用于实现协程等高级特性，提高代码的灵活性和可维护性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成器示例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_generator</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> my_generator():</span><br><span class="line">    <span class="built_in">print</span>(value)  <span class="comment"># 输出 1, 2, 3</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="25-Python中猴子补丁是什么"><a href="#25-Python中猴子补丁是什么" class="headerlink" title="25. Python中猴子补丁是什么"></a><font color=DarkOrange>25. Python中猴子补丁是什么</font></h4><p>猴子补丁是指在运行时动态修改类或模块的行为的技术。它允许在程序运行时更改代码，而不需要修改原始源代码。这种技术通常用于在测试或调试期间临时修改代码，或者在第三方库中添加或修改功能。使用猴子补丁时需要注意，它可能会导致代码的不稳定性和难以维护性，因此应该谨慎使用</p>
<h4 id="6-Python中的垃圾回收机制"><a href="#6-Python中的垃圾回收机制" class="headerlink" title="6. Python中的垃圾回收机制"></a><font color=DarkOrange>6. Python中的垃圾回收机制</font></h4><p>Python中的垃圾回收机制使用引用计数技术和垃圾回收器两种技术来实现。引用计数是一种轻量级的内存管理机制，当一个对象的引用计数变为0时，Python会立即回收它的内存。垃圾回收器是一种更高级别的机制，它会跟踪对象之间的引用，并回收不再使用的对象</p>
<p>Python中的垃圾回收器有两种实现方式：分代垃圾回收和循环垃圾回收。分代垃圾回收机制将对象根据其生命周期分成三代：0代、1代和2代。当一个对象经历了多次垃圾回收，其代数就会逐渐增加。Python垃圾回收器会根据代数来选择合适的回收策略</p>
<p>循环垃圾回收机制则会跟踪对象之间的引用关系，找到不再使用的对象，并将它们回收。这种机制需要更多的计算资源，因此只在必要时才会使用</p>
<h4 id="7-Python中的lambda表达式"><a href="#7-Python中的lambda表达式" class="headerlink" title="7. Python中的lambda表达式"></a><font color=DarkOrange>7. Python中的lambda表达式</font></h4><p>Lambda表达式是一种匿名函数，它可以在Python中快速定义简单的函数。它通常由一个单独的表达式组成，该表达式在调用时返回结果。Lambda表达式的语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> arguments: expression</span><br></pre></td></tr></table></figure>

<p>其中，arguments是函数的参数，可以是任意数量的参数，用逗号分隔。expression是函数的返回值，通常是一个简单的表达式。</p>
<p>Lambda表达式通常用于需要一个简单函数的地方，例如在map()、filter()和reduce()等函数中。它们也可以用于定义回调函数和排序函数等</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个lambda表达式</span></span><br><span class="line">lambda_func = <span class="keyword">lambda</span> x, y: x + y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用lambda函数</span></span><br><span class="line">result = lambda_func(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出 7</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>虽然lambda表达式可以用来定义小型函数，但是如果函数体过于复杂，建议使用普通的函数定义语法，以提高代码可读性和可维护性</p>
<h4 id="28-Python中的反射"><a href="#28-Python中的反射" class="headerlink" title="28. Python中的反射"></a><font color=DarkOrange>28. Python中的反射</font></h4><p>Python中的反射是一种动态访问和修改对象属性和方法的机制，可以通过字符串的方式来访问对象的属性和方法。在Python中，每个对象都有一些基本的属性和方法，而反射机制可以通过这些属性和方法来实现动态访问和修改。</p>
<p>反射机制主要通过内置函数<code>getattr()</code>、<code>setattr()</code>、<code>hasattr()</code>和<code>delattr()</code>来实现。具体来说，这些函数的作用如下：</p>
<ul>
<li><code>getattr(object, name[, default])</code>: 获取对象的属性值。如果属性不存在，则会抛出AttributeError异常，或者返回default参数指定的默认值（如果提供了该参数）。</li>
<li><code>setattr(object, name, value)</code>: 设置对象的属性值。如果属性不存在，则会创建一个新属性</li>
<li><code>hasattr(object, name)</code>: 检查对象是否有指定的属性。如果对象有该属性，返回True，否则返回False。</li>
<li><code>delattr(object, name)</code>: 删除对象的指定属性。</li>
</ul>
<p>通过这些函数，可以实现访问、修改、创建和删除对象的属性和方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.x = <span class="number">10</span></span><br><span class="line">        self.y = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, a, b</span>):</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用getattr获取对象属性</span></span><br><span class="line">x = <span class="built_in">getattr</span>(obj, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 输出10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用setattr设置对象属性</span></span><br><span class="line"><span class="built_in">setattr</span>(obj, <span class="string">&#x27;y&#x27;</span>, <span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(obj.y)  <span class="comment"># 输出30</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用hasattr检查对象属性是否存在</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(obj, <span class="string">&#x27;z&#x27;</span>))  <span class="comment"># 输出False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用delattr删除对象属性</span></span><br><span class="line"><span class="built_in">delattr</span>(obj, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(obj.__dict__)  <span class="comment"># 输出 &#123;&#x27;y&#x27;: 30&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>反射机制可以让代码更加灵活，但同时也会增加代码的复杂性和运行开销，因此在实际使用中需要谨慎使用</p>
<h4 id="29-Python中的-new-和-init-的区别"><a href="#29-Python中的-new-和-init-的区别" class="headerlink" title="29. Python中的__new__和__init__的区别"></a><font color=DarkOrange>29. Python中的<code>__new__</code>和<code>__init__</code>的区别</font></h4><p>在Python中，每个类都有两个特殊方法<code>__new__()</code>和<code>__init__()</code>。这两个方法都是用来创建类实例的，但是它们的作用不同。</p>
<p><code>__new__()</code>方法是一个类方法，用于创建并返回一个新的类实例。它通常被用来控制对象的创建过程，可以在对象实例化之前做一些自定义的操作，比如修改对象的属性、改变对象的类型等。<code>__new__()</code>方法的返回值是一个对象实例，这个实例会传递给<code>__init__()</code>方法作为第一个参数self。</p>
<p><code>__init__()</code>方法是一个实例方法，用于初始化一个已经存在的对象实例。它通常被用来对对象的属性进行初始化和赋值。<code>__init__()</code>方法没有返回值，它只是对self进行修改，因为self已经被创建了并传递给这个方法了。</p>
<p>需要注意的是，<code>__new__()</code>方法是在<code>__init__()</code>方法之前调用的，所以在<code>__init__()</code>方法中可以使用<code>self</code>对象已经存在的属性，但是不能修改这些属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;__new__ called&#x27;</span>)</span><br><span class="line">        instance = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">        instance.name = <span class="string">&#x27;MyClass&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, age</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;__init__ called&#x27;</span>)</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">obj = MyClass(<span class="number">18</span>)</span><br><span class="line"><span class="built_in">print</span>(obj.name)  <span class="comment"># 输出 MyClass</span></span><br><span class="line"><span class="built_in">print</span>(obj.age)  <span class="comment"># 输出 18</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>__new__()</code>方法被重写，创建了一个新的对象实例，并将<code>name</code>属性设置为<code>MyClass</code>，最后将实例返回给<code>__init__()</code>方法。<code>__init__()</code>方法接收到这个实例之后，对它进行了初始化，将<code>age</code>属性赋值为传入的参数18</p>
<h4 id="30-Python闭包"><a href="#30-Python闭包" class="headerlink" title="30. Python闭包"></a><font color=DarkOrange>30. Python闭包</font></h4><p>Python闭包是指在函数内部定义的函数，该函数可以访问外部函数的变量和参数，并且可以在外部函数返回后继续访问这些变量和参数。闭包可以用来实现一些高级的编程技巧，例如装饰器和函数工厂</p>
<p>在Python中，闭包是通过函数对象和函数属性来实现的。当一个函数定义在另一个函数内部时，它就可以访问外部函数的变量和参数。这些变量和参数被称为自由变量和自由参数。当外部函数返回时，闭包函数仍然可以访问这些自由变量和自由参数，因为它们被保存在闭包函数的函数对象中。这使得闭包函数可以在外部函数返回后继续执行，并且可以访问外部函数的状态</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer_func</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner_func</span>(<span class="params">y</span>):</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    <span class="keyword">return</span> inner_func</span><br><span class="line"></span><br><span class="line">closure = outer_func(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(closure(<span class="number">5</span>))  <span class="comment"># 输出 15</span></span><br><span class="line"><span class="built_in">print</span>(closure(<span class="number">10</span>))  <span class="comment"># 输出 20</span></span><br></pre></td></tr></table></figure>

<h4 id="31-Python元类"><a href="#31-Python元类" class="headerlink" title="31. Python元类"></a><font color=DarkOrange>31. Python元类</font></h4><p>Python中的元类是用于创建类的类。元类允许我们控制类的创建过程，可以在类被创建之前或之后修改类。元类是一种高级的Python编程技巧，通常用于框架和库的开发中，比如Django、Flask、Tornado等。</p>
<p>元类可以用来实现单例模式、注册表、插件系统等功能。在Python中，所有的类都是由type类创建的，因此type类是Python中的默认元类</p>
<h4 id="32-Python中的GIL"><a href="#32-Python中的GIL" class="headerlink" title="32. Python中的GIL"></a><font color=DarkOrange>32. Python中的GIL</font></h4><p>GIL（Global Interpreter Lock）是Python解释器中的一个特性，它是一种锁机制，用于保证在同一时刻只有一个线程可以执行Python字节码。这个锁是解释器级别的锁，也称为全局锁。在多线程环境下，GIL会导致线程无法真正并行执行，因为只有一个线程可以拥有GIL</p>
<p>GIL的存在是因为CPython解释器的内存管理不是线程安全的，当多个线程同时访问和修改Python对象的引用计数时，可能会出现竞争条件和数据一致性问题。因此，为了避免这些问题，CPython引入了GIL来限制同一时刻只有一个线程可以执行Python字节码。</p>
<p>GIL的存在会影响Python多线程程序的性能，因为多线程程序无法真正利用多核CPU的性能优势。在CPU密集型任务中，GIL会成为瓶颈，导致多线程程序的运行时间比单线程程序更长。但在I&#x2F;O密集型任务中，GIL的影响较小，因为线程在等待I&#x2F;O操作完成时，GIL会被释放，其他线程就可以执行Python字节码。</p>
<p>为了避免GIL的影响，可以使用多进程代替多线程，因为多个进程之间是相互独立的，各自拥有自己的解释器和GIL，可以真正并行执行。也可以使用其他语言编写CPU密集型任务的模块，然后在Python程序中调用这些模块，避免GIL的影响。另外，Python还提供了一些并发编程库和工具，如multiprocessing、concurrent.futures、asyncio等，可以在一定程度上缓解GIL的影响</p>
<h4 id="33-Python类和对象的区别"><a href="#33-Python类和对象的区别" class="headerlink" title="33. Python类和对象的区别"></a><font color=DarkOrange>33. Python类和对象的区别</font></h4><p>在Python中，类是一种数据类型，用于定义对象的属性和方法。对象是类的实例，也就是类的具体化。类是对象的抽象，而对象是类的具体实现。类是一种模板或者蓝图，用于创建对象。</p>
<p>具体来说，Python中的类是由属性和方法组成的，属性是类的变量，用于存储对象的状态，方法是类的函数，用于定义对象的行为。类可以看作是一种特殊的字典，类的属性和方法都保存在类的命名空间中。类属性是所有实例共享的，而实例属性是每个实例独有的。</p>
<p>对象是类的实例，是根据类创建的具体实体，每个对象都有自己的状态和行为。对象包含属性和方法，属性是对象的变量，用于存储对象的状态，方法是对象的函数，用于定义对象的行为。对象是在程序运行时创建的，每个对象都是独立的，有自己的属性和方法</p>
<p>在Python中，类和对象的关系可以用以下表格来描述：</p>
<table>
<thead>
<tr>
<th>类</th>
<th>对象</th>
</tr>
</thead>
<tbody><tr>
<td>模板</td>
<td>具体实体</td>
</tr>
<tr>
<td>定义</td>
<td>创建</td>
</tr>
<tr>
<td>属性和方法</td>
<td>属性和方法</td>
</tr>
<tr>
<td>类变量</td>
<td>实例变量</td>
</tr>
<tr>
<td>类方法</td>
<td>实例方法</td>
</tr>
<tr>
<td>类属性</td>
<td>实例属性</td>
</tr>
<tr>
<td>继承</td>
<td>实例化</td>
</tr>
</tbody></table>
<p><strong>总的来说，类是一种抽象的概念，对象是类的实例化，是具体的实体。类描述了对象的属性和方法，而对象则是类的具体实现</strong></p>
<h4 id="34-Python中的self的作用"><a href="#34-Python中的self的作用" class="headerlink" title="34. Python中的self的作用"></a><font color=DarkOrange>34. Python中的self的作用</font></h4><p>在Python中，self是一个约定俗成的命名方式，用于表示类实例对象本身。self作为第一个参数出现在类的方法中，它表示对类实例对象本身的引用。</p>
<p>当一个类的方法被调用时，它会自动传入类实例对象本身作为第一个参数，通常使用self作为参数名。这样，在方法内部就可以使用self来引用对象本身，从而访问对象的属性和调用对象的方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say_hello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello, my name is&quot;</span>, self.name, <span class="string">&quot;and I am&quot;</span>, self.age, <span class="string">&quot;years old.&quot;</span>)</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&quot;John&quot;</span>, <span class="number">30</span>)</span><br><span class="line">p.say_hello()  <span class="comment"># 输出：Hello, my name is John and I am 30 years old.</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>__init__</code>方法和<code>say_hello</code>方法都有一个<code>self</code>参数，它们用于引用类实例对象本身。在<code>__init__</code>方法中，使用<code>self</code>来初始化类实例对象的属性；在<code>say_hello</code>方法中，使用<code>self</code>来引用对象的属性和方法，从而输出对象的信息</p>
<p><strong>注意：</strong><code>self</code>不是Python的关键字，可以使用其他名称代替，但是约定俗成的做法是使用<code>self</code>。另外，<code>self</code>只在类的方法中出现，而在类的其他地方，如属性和方法的定义中，不需要使用<code>self</code></p>
<h4 id="35-Python2和Python3的区别"><a href="#35-Python2和Python3的区别" class="headerlink" title="35. Python2和Python3的区别"></a><font color=DarkOrange>35. Python2和Python3的区别</font></h4><ol>
<li>语法：Python3对语言的语法进行了一些改进，如print函数变成了print()函数，除法运算符变成了真正的浮点除法符号<code>/</code>，新增了非本地变量声明<code>nonlocal</code>等</li>
<li>编码：Python3默认采用UTF-8编码，而Python2采用的是ASCII编码。</li>
<li>兼容性：Python3不兼容Python2的代码，而Python2中的大多数代码可以在Python3中运行，但是需要进行一些修改</li>
<li>标准库：Python3的标准库中增加了一些新模块，如asyncio、enum、ipaddress等，同时还更新了一些模块，如pickle、tkinter等。</li>
<li>Unicode字符串：在Python3中，字符串是默认采用Unicode编码，而在Python2中，字符串采用的是ASCII编码。</li>
<li>整数除法：在Python2中，两个整数相除得到的是整数结果，而在Python3中，两个整数相除得到的是浮点数结果</li>
<li>range函数：在Python2中，range函数返回的是一个列表，而在Python3中，range函数返回的是一个可迭代对象</li>
<li>异常处理：在Python3中，异常处理语句需要使用as关键字来接收异常对象。</li>
<li>print函数：在Python2中，print语句可以不用括号，而在Python3中，print函数必须要用括号。</li>
</ol>
<h4 id="36-Python如何提高运行效率"><a href="#36-Python如何提高运行效率" class="headerlink" title="36. Python如何提高运行效率"></a><font color=DarkOrange>36. Python如何提高运行效率</font></h4><ol>
<li>使用算法和数据结构：在编写Python代码时，使用高效的算法和数据结构可以大大提高代码的运行效率。例如，在需要对大量数据进行排序时，使用快速排序算法比使用冒泡排序算法更加高效。</li>
<li>使用生成器：生成器是Python中的一种特殊类型的函数，可以逐个生成值，而不是一次生成所有值。使用生成器可以避免在内存中生成大量数据，从而提高运行效率。</li>
<li>使用列表推导式和生成器表达式：列表推导式和生成器表达式可以在一行代码中生成列表或生成器。它们通常比使用循环和条件语句生成列表或生成器更加高效</li>
<li>使用Cython或Numba等工具：Cython是一种将Python代码转换为C代码的工具，可以提高Python代码的运行效率。Numba是一种Python库，可以使用JIT（即时编译）技术将Python代码转换为机器码，从而提高代码的运行速度。</li>
<li>使用并行编程：Python提供了一些模块，如multiprocessing和concurrent.futures等，可以使用多进程或多线程并行执行代码，从而提高运行效率。</li>
<li>避免使用循环：在Python中，循环的执行效率较低，应尽量避免使用循环。可以使用NumPy等库中的矩阵运算等高效操作来替代循环</li>
<li>避免使用全局变量：在Python中，全局变量的访问速度较慢，应尽量避免使用全局变量，而使用局部变量来代替。</li>
</ol>
<h4 id="37-Python异常处理"><a href="#37-Python异常处理" class="headerlink" title="37. Python异常处理"></a><font color=DarkOrange>37. Python异常处理</font></h4><ol>
<li><p>异常处理是什么？<br>异常处理是指在程序运行过程中，当出现错误或异常时，程序能够捕获并处理这些异常，从而保证程序的正常运行。</p>
</li>
<li><p>Python中的异常类型有哪些？<br>Python中有很多内置的异常类型，比如NameError、TypeError、ValueError等等，还可以自定义异常类型。</p>
</li>
<li><p>如何捕获异常？<br>在Python中，可以使用try-except语句来捕获异常。try语句块中放置可能会出现异常的代码，如果出现异常，则会跳转到except语句块中进行处理</p>
</li>
<li><p>如何处理异常？<br>在except语句块中可以对异常进行处理，比如输出错误信息、记录日志、重新抛出异常等等。</p>
</li>
<li><p>finally语句的作用是什么？<br>finally语句块中的代码无论是否出现异常都会被执行，通常用于释放资源等操作。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 可能会出现异常的代码块</span></span><br><span class="line"><span class="keyword">except</span> ExceptionType:</span><br><span class="line">    <span class="comment"># 处理异常的代码块</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 最终执行的代码块</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>try</code>：表示要执行的代码块，这里是可能会出现异常的代码块</li>
<li><code>except</code>：表示当try语句块中出现指定类型的异常时，执行该语句块；</li>
<li><code>ExceptionType</code>：指定要处理的异常类型；</li>
<li><code>finally</code>：不管try语句块中是否有异常都会执行的代码块</li>
</ul>
<p>除了使用<code>except</code>语句来处理异常，还可以使用<code>else</code>语句块，当没有异常出现时，执行<code>else</code>语句块中的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 可能会出现异常的代码块</span></span><br><span class="line"><span class="keyword">except</span> ExceptionType:</span><br><span class="line">    <span class="comment"># 处理异常的代码块</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 没有异常时执行的代码块</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 最终执行的代码块</span></span><br></pre></td></tr></table></figure>

<h4 id="38-Python中的标准异常类"><a href="#38-Python中的标准异常类" class="headerlink" title="38. Python中的标准异常类"></a><font color=DarkOrange>38. Python中的标准异常类</font></h4><table>
<thead>
<tr>
<th>异常类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>Exception</code></td>
<td>所有标准异常类的基类</td>
</tr>
<tr>
<td><code>AssertionError</code></td>
<td>断言语句失败时引发</td>
</tr>
<tr>
<td><code>AttributeError</code></td>
<td>对象没有这个属性</td>
</tr>
<tr>
<td><code>EOFError</code></td>
<td>没有输入，输入流结束</td>
</tr>
<tr>
<td><code>FileNotFoundError</code></td>
<td>请求的文件或目录未找到</td>
</tr>
<tr>
<td><code>ImportError</code></td>
<td>导入模块或包失败</td>
</tr>
<tr>
<td><code>IndexError</code></td>
<td>序列中没有此索引（index）</td>
</tr>
<tr>
<td><code>KeyError</code></td>
<td>映射中没有这个键</td>
</tr>
<tr>
<td><code>KeyboardInterrupt</code></td>
<td>用户中断执行（通常是输入^C）</td>
</tr>
<tr>
<td><code>MemoryError</code></td>
<td>操作耗尽内存</td>
</tr>
<tr>
<td><code>NameError</code></td>
<td>未声明&#x2F;初始化对象（没有属性）</td>
</tr>
<tr>
<td><code>NotImplementedError</code></td>
<td>尚未实现的方法或函数</td>
</tr>
<tr>
<td><code>OSError</code></td>
<td>操作系统错误</td>
</tr>
<tr>
<td><code>OverflowError</code></td>
<td>数字运算超出最大限制</td>
</tr>
<tr>
<td><code>RecursionError</code></td>
<td>递归调用超出最大限制</td>
</tr>
<tr>
<td><code>RuntimeError</code></td>
<td>一般的运行时错误</td>
</tr>
<tr>
<td><code>StopIteration</code></td>
<td>迭代器没有更多的值</td>
</tr>
<tr>
<td><code>SyntaxError</code></td>
<td>Python 语法错误</td>
</tr>
<tr>
<td><code>IndentationError</code></td>
<td>缩进错误</td>
</tr>
<tr>
<td><code>TabError</code></td>
<td>Tab和空格混用</td>
</tr>
<tr>
<td><code>SystemError</code></td>
<td>一般的解释器系统错误</td>
</tr>
<tr>
<td><code>SystemExit</code></td>
<td>Python 解释器请求退出</td>
</tr>
<tr>
<td><code>TypeError</code></td>
<td>对类型无效的操作</td>
</tr>
<tr>
<td><code>UnboundLocalError</code></td>
<td>访问未初始化的本地变量</td>
</tr>
<tr>
<td><code>UnicodeError</code></td>
<td>Unicode 相关的错误</td>
</tr>
<tr>
<td><code>ValueError</code></td>
<td>传递给函数的参数类型不正确，或者值不合法</td>
</tr>
<tr>
<td><code>ZeroDivisionError</code></td>
<td>除数为零</td>
</tr>
</tbody></table>
<hr>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生01-Go语言特性</title>
    <url>/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F01-Go%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>Go语言基础知识整理</p>
<h4 id="1-为什么需要另Go语言"><a href="#1-为什么需要另Go语言" class="headerlink" title="1. 为什么需要另Go语言"></a><font color=DarkOrange>1. 为什么需要另Go语言</font></h4><ul>
<li>其他编程语言的弊端<ul>
<li>硬件发展速度远远超过软件</li>
<li>C 语言等原生语言缺乏好的依赖管理 (依赖头文件）</li>
<li>Java 和 C++ 等语言过于笨重</li>
<li>系统语言对垃圾回收和并行计算等基础功能缺乏支持</li>
<li>对多核计算机缺乏支持</li>
</ul>
</li>
<li>Go 语言是一个可以编译高效，支持高并发的，面向垃圾回收的全新语言<ul>
<li>秒级完成大型程序的单节点编译</li>
<li>依赖管理清晰</li>
<li>不支持继承，程序员无需花费精力定义不同类型之间的关系</li>
<li>支持垃圾回收，支持并发执行，支持多线程通讯</li>
<li>对多核计算机支持友好</li>
</ul>
</li>
</ul>
<h5 id="1-1-Go-语言不支持的特性"><a href="#1-1-Go-语言不支持的特性" class="headerlink" title="1.1 Go 语言不支持的特性"></a><font color=DarkOrange>1.1 Go 语言不支持的特性</font></h5><ul>
<li>不支持函数重载和操作符重载</li>
<li>为了避免在 C&#x2F;C++ 开发中的一些 Bug 和混乱，不支持隐式转换</li>
<li>支持接口抽象，不支持继承</li>
<li>不支持动态加载代码</li>
<li>不支持动态链接库</li>
<li>通过 recover 和 panic 来替代异常机制</li>
<li>不支持断言</li>
<li>不支持静态变量</li>
</ul>
<h5 id="1-2-Go-语言特性衍生来源"><a href="#1-2-Go-语言特性衍生来源" class="headerlink" title="1.2 Go 语言特性衍生来源"></a><font color=DarkOrange>1.2 Go 语言特性衍生来源</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8aliy8674j31ey0pc11z.jpg" alt="image.png" style="zoom:45%;" /></div>

<h4 id="2-Go-语言编译环境设置"><a href="#2-Go-语言编译环境设置" class="headerlink" title="2. Go 语言编译环境设置"></a><font color=DarkOrange>2. Go 语言编译环境设置</font></h4><h5 id="2-1-下载-Go"><a href="#2-1-下载-Go" class="headerlink" title="2.1 下载 Go"></a><font color=DarkOrange>2.1 下载 Go</font></h5><ul>
<li>Go 安装文件以及源代码<ul>
<li>链接：<a href="https://golang.google.cn/dl/">点击跳转</a></li>
</ul>
</li>
<li>下载对应平台的二进制文件并安装</li>
<li>环境变量<ul>
<li>GOROOT<ul>
<li>go的安装目录</li>
</ul>
</li>
<li>GOPATH<ul>
<li>src：存放源代码</li>
<li>pkg：存放依赖包</li>
<li>bin：存放可执行文件</li>
</ul>
</li>
<li>其他常用变量<ul>
<li>GOOS，GOARCH，GOPROXY</li>
<li>国内用户建议设置 goproxy：<code>export GOPROXY=https://goproxy.cn</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2-2-IDE-设置（VS-Code）"><a href="#2-2-IDE-设置（VS-Code）" class="headerlink" title="2.2 IDE 设置（VS Code）"></a><font color=DarkOrange>2.2 IDE 设置（VS Code）</font></h5><ul>
<li>下载并安装 Visual Studio Code<ul>
<li>VSCode：<a href="https://code.visualstudio.com/download">点击跳转</a></li>
</ul>
</li>
<li>安装 Go 语言插件<ul>
<li>插件：<a href="https://marketplace.visualstudio.com/items?itemName=golang.go">点击跳转</a></li>
</ul>
</li>
<li>其他可选项<ul>
<li>Intellj goland，收费软件，<a href="https://www.jetbrains.com/go/download/#section=mac">点击跳转</a></li>
<li>vim，sublime等</li>
</ul>
</li>
</ul>
<h5 id="2-3-一些基本命令"><a href="#2-3-一些基本命令" class="headerlink" title="2.3 一些基本命令"></a><font color=DarkOrange>2.3 一些基本命令</font></h5><table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>bug</td>
<td>start a bug report</td>
</tr>
<tr>
<td>build</td>
<td>compile packages and dependencies</td>
</tr>
<tr>
<td>clean</td>
<td>remove object files and cached files</td>
</tr>
<tr>
<td>doc</td>
<td>show documentation for package or symbol</td>
</tr>
<tr>
<td>env</td>
<td>print Go environment information</td>
</tr>
<tr>
<td>fix</td>
<td>update packages to use new APIs</td>
</tr>
<tr>
<td>fmt</td>
<td>gofmt (reformat) package sources</td>
</tr>
<tr>
<td>generate</td>
<td>generate Go files by processing source</td>
</tr>
<tr>
<td>get</td>
<td>add dependencies to current module and install them</td>
</tr>
<tr>
<td>install</td>
<td>compile and install packages and dependencies</td>
</tr>
<tr>
<td>list</td>
<td>list packages or modules</td>
</tr>
<tr>
<td>mod</td>
<td>module maintenance</td>
</tr>
<tr>
<td>run</td>
<td>compile and run Go program</td>
</tr>
<tr>
<td>test</td>
<td>test packages</td>
</tr>
<tr>
<td>tool</td>
<td>run specified go tool</td>
</tr>
<tr>
<td>version</td>
<td>print Go version</td>
</tr>
<tr>
<td>vet</td>
<td>report likely mistakes in packages</td>
</tr>
</tbody></table>
<h5 id="2-4-Go-build"><a href="#2-4-Go-build" class="headerlink" title="2.4 Go build"></a><font color=DarkOrange>2.4 Go build</font></h5><ul>
<li>Go 语言不支持动态链接，因此编译时会将所有依赖编译进同一个二进制文件</li>
<li>指定输出目录<ul>
<li>go build –o bin&#x2F;mybinary</li>
</ul>
</li>
<li>常用环境变量设置编译操作系统和 CPU 架构<ul>
<li>GOOS&#x3D;linux GOARCH&#x3D;amd64 go build</li>
</ul>
</li>
<li>全支持列表<ul>
<li>$GOROOT&#x2F;src&#x2F;go&#x2F;build&#x2F;syslist.go</li>
</ul>
</li>
</ul>
<h5 id="2-6-Go-test"><a href="#2-6-Go-test" class="headerlink" title="2.6 Go test"></a><font color=DarkOrange>2.6 Go test</font></h5><p>Go 语言原生自带测试</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestIncrease</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	t.Log(<span class="string">&quot;Start testing&quot;</span>)</span><br><span class="line">	increase(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>go test .&#x2F;… -v 运行测试</p>
<p>go test 命令扫描所有*_test.go为结尾的文件，惯例是将测试代码与正式代码放在同目录， 如 foo.go 的测试代码一般写在 foo_test.go</p>
<h5 id="2-7-Go-vet"><a href="#2-7-Go-vet" class="headerlink" title="2.7 Go vet"></a><font color=DarkOrange>2.7 Go vet</font></h5><p>代码静态检查，发现可能的 bug 或者可疑的构造</p>
<ul>
<li><p>Print-format 错误，检查类型不匹配的print</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str := “hello world!”</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, str)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Boolean 错误，检查一直为 true、false 或者冗余的表达式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(i != <span class="number">0</span> || i != <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Range 循环，比如如下代码主协程会先退出，go routine无法被执行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">words := []<span class="type">string</span>&#123;<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, word := <span class="keyword">range</span> words &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(word)</span><br><span class="line">  &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Unreachable的代码，如 return 之后的代码</p>
</li>
<li><p>其他错误，比如变量自赋值，error 检查滞后等</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">res, err := http.Get(<span class="string">&quot;https://www.spreadsheetdb.io/&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> res.Body.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="2-8-代码版本控制"><a href="#2-8-代码版本控制" class="headerlink" title="2.8 代码版本控制"></a><font color=DarkOrange>2.8 代码版本控制</font></h5><ul>
<li>下载并安装 Git Command Line<ul>
<li>Git，<a href="https://git-scm.com/downloads">点击跳转</a></li>
</ul>
</li>
<li>Github<ul>
<li>代码仓库</li>
</ul>
</li>
<li>创建代码目录<ul>
<li>mkdir –p $GOPATH&#x2F;src&#x2F;github.com&#x2F;cncamp</li>
<li>cd $GOPATH&#x2F;src&#x2F;github.com&#x2F;cncamp</li>
</ul>
</li>
<li>代码下载</li>
<li>修改代码</li>
<li>上传代码<ul>
<li>git add filename</li>
<li>git commit –m ‘change logs’</li>
<li>git push</li>
</ul>
</li>
</ul>
<h5 id="2-9-Golang-playground"><a href="#2-9-Golang-playground" class="headerlink" title="2.9 Golang playground"></a><font color=DarkOrange>2.9 Golang playground</font></h5><ul>
<li>官方 playground，<a href="https://play.golang.org/">点击跳转</a></li>
<li><strong>推荐：</strong> 国内可直接访问的 playground，<a href="https://goplay.tools/">点击跳转</a></li>
</ul>
<p>可直接编写和运行 Go 语言程序</p>
<h4 id="3-控制结构"><a href="#3-控制结构" class="headerlink" title="3. 控制结构"></a><font color=DarkOrange>3. 控制结构</font></h4><h5 id="3-1-if"><a href="#3-1-if" class="headerlink" title="3.1 if"></a><font color=DarkOrange>3.1 if</font></h5><ul>
<li><p>基本形式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1 &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> condition2 &#123;</span><br><span class="line">  <span class="comment">// do something else</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// catch-all or default</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>if 的简短语句</p>
<ul>
<li>for 一样， if 语句可以在条件表达式前执行一个简单的语句</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> v := x - <span class="number">100</span>; v &lt; <span class="number">0</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="3-2-switch"><a href="#3-2-switch" class="headerlink" title="3.2 switch"></a><font color=DarkOrange>3.2 switch</font></h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> var1 &#123;</span><br><span class="line">  <span class="keyword">case</span> val1: <span class="comment">//空分支</span></span><br><span class="line">  <span class="keyword">case</span> val2:</span><br><span class="line">  	<span class="keyword">fallthrough</span> <span class="comment">//执行case3中的f()</span></span><br><span class="line">  <span class="keyword">case</span> val3:</span><br><span class="line">  	f()</span><br><span class="line">  <span class="keyword">default</span>: <span class="comment">//默认分支</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-for"><a href="#3-3-for" class="headerlink" title="3.3 for"></a><font color=DarkOrange>3.3 for</font></h5><p>Go 只有一种循环结构：for 循环</p>
<ul>
<li><p>计入计数器的循环</p>
<ul>
<li>for 初始化语句; 条件语句; 修饰语句 {}</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">	sum += i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化语句和后置语句是可选的，此场景与 while 等价（Go 语言不支持 while）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>; &#123;</span><br><span class="line">	sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>无限循环</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> condition1 &#123;</span><br><span class="line">  	<span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="3-4-for-range"><a href="#3-4-for-range" class="headerlink" title="3.4 for-range"></a><font color=DarkOrange>3.4 for-range</font></h5><p>遍历数组，切片，字符串，Map 等</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> index, char := <span class="keyword">range</span> myString &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> MyMap &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> MyArray &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>需要注意：如果 for range 遍历指针数组，则 value 取出的指 针地址为原指针地址的拷贝</strong></p>
<h4 id="4-Go-语言常用数据结构"><a href="#4-Go-语言常用数据结构" class="headerlink" title="4. Go 语言常用数据结构"></a><font color=DarkOrange>4. Go 语言常用数据结构</font></h4><h5 id="4-1-变量与常量"><a href="#4-1-变量与常量" class="headerlink" title="4.1 变量与常量"></a><font color=DarkOrange>4.1 变量与常量</font></h5><ul>
<li>常量<ul>
<li>const identifier type</li>
</ul>
</li>
<li>变量<ul>
<li>var identifier type</li>
</ul>
</li>
</ul>
<h5 id="4-2-变量定义"><a href="#4-2-变量定义" class="headerlink" title="4.2 变量定义"></a><font color=DarkOrange>4.2 变量定义</font></h5><ul>
<li>变量<ul>
<li>var 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后</li>
<li>var c, python, java bool</li>
</ul>
</li>
<li>变量的初始化<ul>
<li>变量声明可以包含初始值，每个变量对应一个</li>
<li>如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型</li>
<li>var i, j int &#x3D; 1, 2</li>
</ul>
</li>
<li>短变量声明<ul>
<li>在函数中，简洁赋值语句 :&#x3D; 可在类型明确的地方代替 var 声明</li>
<li>函数外的每个语句都必须以关键字开始（var, func 等等），<strong>因此 :&#x3D; 结构不能在函数外使用</strong></li>
<li>c, python, java :&#x3D; true, false, “no!”</li>
</ul>
</li>
</ul>
<h5 id="4-3-类型转换与推导"><a href="#4-3-类型转换与推导" class="headerlink" title="4.3 类型转换与推导"></a><font color=DarkOrange>4.3 类型转换与推导</font></h5><ul>
<li>类型转换<ul>
<li>表达式 T(v) 将值 v 转换为类型 T<ul>
<li>一些关于数值的转换：<ul>
<li>var i int &#x3D; 42</li>
<li>var f float64 &#x3D; float64(i) </li>
<li>var u uint &#x3D; uint(f)</li>
</ul>
</li>
<li>或者，更加简单的形式：<ul>
<li>i :&#x3D; 42 </li>
<li>f :&#x3D; float64(i)</li>
<li>u :&#x3D; uint(f)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>类型推导<ul>
<li>在声明一个变量而不指定其类型时（即使用不带类型的 :&#x3D; 语法或 var &#x3D; 表达式语法），变量的类型由右值推导得出<ul>
<li>var i int </li>
<li>j :&#x3D; i &#x2F;&#x2F; j 也是一个 int</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="4-4-数组"><a href="#4-4-数组" class="headerlink" title="4.4 数组"></a><font color=DarkOrange>4.4 数组</font></h5><ul>
<li>相同类型且长度固定连续内存片段</li>
<li>以编号访问每个元素</li>
<li>定义方法<ul>
<li>var identifier [len]type</li>
</ul>
</li>
<li>示例<ul>
<li>myArray :&#x3D; [3]int{1,2,3}</li>
</ul>
</li>
</ul>
<h5 id="4-5-切片-slice"><a href="#4-5-切片-slice" class="headerlink" title="4.5 切片(slice)"></a><font color=DarkOrange>4.5 切片(slice)</font></h5><ul>
<li><p>切片是对数组一个连续片段的引用</p>
</li>
<li><p>数组定义中不指定长度即为切片</p>
<ul>
<li>var identifier []type</li>
</ul>
</li>
<li><p>切片在未初始化之前默认为nil， 长度为0</p>
</li>
<li><p>常用方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  myArray := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">  mySlice := myArray[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">  fmt.Printf(<span class="string">&quot;mySlice %+v\n&quot;</span>, mySlice)</span><br><span class="line">  fullSlice := myArray[:]</span><br><span class="line">  remove3rdItem := deleteItem(fullSlice, <span class="number">2</span>)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;remove3rdItem %+v\n&quot;</span>, remove3rdItem)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteItem</span><span class="params">(slice []<span class="type">int</span>, index <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">append</span>(slice[:index], slice[index+<span class="number">1</span>:]...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="4-6-make和new"><a href="#4-6-make和new" class="headerlink" title="4.6 make和new"></a><font color=DarkOrange>4.6 make和new</font></h5><ul>
<li><p>new 返回指针地址</p>
</li>
<li><p>make 返回第一个元素，可预设内存空间，避免未来的内存拷贝</p>
</li>
<li><p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mySlice1 := <span class="built_in">new</span>([]<span class="type">int</span>)</span><br><span class="line">mySlice2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">mySlice3 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">mySlice4 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8au3yhk17j30rc08c0wm.jpg" alt="image.png" style="zoom: 50%;" /></li>
</ul>
<h5 id="4-7-关于切片的常见问题"><a href="#4-7-关于切片的常见问题" class="headerlink" title="4.7 关于切片的常见问题"></a><font color=DarkOrange>4.7 关于切片的常见问题</font></h5><ul>
<li><p>切片是连续内存并且可以动态扩展，由此引发的问题？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := []<span class="type">int</span></span><br><span class="line">b := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">c := a</span><br><span class="line">a = <span class="built_in">append</span>(b, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改切片的值？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mySlice := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> mySlice &#123;</span><br><span class="line">	value *= <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;mySlice %+v\n&quot;</span>, mySlice)</span><br><span class="line"><span class="keyword">for</span> index, _ := <span class="keyword">range</span> mySlice &#123;</span><br><span class="line">	mySlice[index] *= <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;mySlice %+v\n&quot;</span>, mySlice)</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="4-8-Map"><a href="#4-8-Map" class="headerlink" title="4.8 Map"></a><font color=DarkOrange>4.8 Map</font></h5><ul>
<li><p>声明方法</p>
<ul>
<li>var map1 map[keytype]valuetype</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">myMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">10</span>)</span><br><span class="line">myMap[<span class="string">&quot;a&quot;</span>] = <span class="string">&quot;b&quot;</span></span><br><span class="line">myFuncMap := <span class="keyword">map</span>[<span class="type">string</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span>&#123;</span><br><span class="line">	<span class="string">&quot;funcA&quot;</span>: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(myFuncMap)</span><br><span class="line">f := myFuncMap[<span class="string">&quot;funcA&quot;</span>]</span><br><span class="line">fmt.Println(f())</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="4-9-访问-Map-元素"><a href="#4-9-访问-Map-元素" class="headerlink" title="4.9 访问 Map 元素"></a><font color=DarkOrange>4.9 访问 Map 元素</font></h5><ul>
<li><p>按 Key 取值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value, exists := myMap[<span class="string">&quot;a&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> exists &#123;</span><br><span class="line">	<span class="built_in">println</span>(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历 Map</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> myMap &#123;</span><br><span class="line">	<span class="built_in">println</span>(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="4-10-结构体和指针"><a href="#4-10-结构体和指针" class="headerlink" title="4.10 结构体和指针"></a><font color=DarkOrange>4.10 结构体和指针</font></h5><ul>
<li>通过 type … struct 关键字自定义结构体</li>
<li>Go 语言支持指针，但不支持指针运算<ul>
<li>指针变量的值为内存地址</li>
<li>未赋值的指针为 nil</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyType <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMyType</span><span class="params">(t *MyType)</span></span>&#123;</span><br><span class="line">	<span class="built_in">println</span>(t.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  t := MyType&#123;Name: <span class="string">&quot;test&quot;</span>&#125;</span><br><span class="line">  printMyType(&amp;t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-11-结构体标签"><a href="#4-11-结构体标签" class="headerlink" title="4.11 结构体标签"></a><font color=DarkOrange>4.11 结构体标签</font></h5><ul>
<li>结构体中的字段除了有名字和类型外，还可以有一个可选的标签（tag）</li>
<li>使用场景：Kubernetes APIServer 对所有资源的定义都用 Json tag 和 protoBuff tag<ul>
<li>NodeName string <code>json:&quot;nodeName,omitempty&quot; protobuf:&quot;bytes,10,opt,name=nodeName&quot;</code></li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyType <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  mt := MyType&#123;Name: <span class="string">&quot;test&quot;</span>&#125;</span><br><span class="line">  myType := reflect.TypeOf(mt)</span><br><span class="line">  name := myType.Field(<span class="number">0</span>)</span><br><span class="line">  tag := name.Tag.Get(<span class="string">&quot;json&quot;</span>)</span><br><span class="line">  <span class="built_in">println</span>(tag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-12-类型别名"><a href="#4-12-类型别名" class="headerlink" title="4.12 类型别名"></a><font color=DarkOrange>4.12 类型别名</font></h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Service Type string describes ingress methods for a service</span></span><br><span class="line"><span class="keyword">type</span> ServiceType <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  <span class="comment">// ServiceTypeClusterIP means a service will only be accessible inside the</span></span><br><span class="line">  <span class="comment">// cluster, via the ClusterIP.</span></span><br><span class="line">  ServiceTypeClusterIP ServiceType = <span class="string">&quot;ClusterIP&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ServiceTypeNodePort means a service will be exposed on one port of</span></span><br><span class="line">  <span class="comment">// every node, in addition to &#x27;ClusterIP&#x27; type.</span></span><br><span class="line">  ServiceTypeNodePort ServiceType = <span class="string">&quot;NodePort&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ServiceTypeLoadBalancer means a service will be exposed via an</span></span><br><span class="line">  <span class="comment">// external load balancer (if the cloud provider supports it), in addition</span></span><br><span class="line">  <span class="comment">// to &#x27;NodePort&#x27; type.</span></span><br><span class="line">  ServiceTypeLoadBalancer ServiceType = <span class="string">&quot;LoadBalancer&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ServiceTypeExternalName means a service consists of only a reference to</span></span><br><span class="line">  <span class="comment">// an external name that kubedns or equivalent will return as a CNAME</span></span><br><span class="line">  <span class="comment">// record, with no exposing or proxying of any pods involved.</span></span><br><span class="line">  ServiceTypeExternalName ServiceType = <span class="string">&quot;ExternalName&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="5-Go-语言函数调用"><a href="#5-Go-语言函数调用" class="headerlink" title="5. Go 语言函数调用"></a><font color=DarkOrange>5. Go 语言函数调用</font></h4><h5 id="5-1-main函数"><a href="#5-1-main函数" class="headerlink" title="5.1 main函数"></a><font color=DarkOrange>5.1 main函数</font></h5><ul>
<li>每个 Go 语言程序都应该有个 main package</li>
<li>Main package 里的 main 函数是 Go 语言程序入口</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  args := os.Args</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;Do not accept any argument&quot;</span>)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-2-参数解析"><a href="#5-2-参数解析" class="headerlink" title="5.2 参数解析"></a><font color=DarkOrange>5.2 参数解析</font></h5><ul>
<li>请注意 main 函数与其他语言不同，没有类似 java 的 []string args 参数</li>
<li>Go 语言如何传入参数呢？<ul>
<li>方法1：<ul>
<li>fmt.Println(“os args is:”, os.Args)</li>
</ul>
</li>
<li>方法2：<ul>
<li>name :&#x3D; flag.String(“name”, “world”, “specify the name you want to say hi”)</li>
<li>flag.Parse()</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="5-3-init函数"><a href="#5-3-init函数" class="headerlink" title="5.3 init函数"></a><font color=DarkOrange>5.3 init函数</font></h5><ul>
<li>init 函数：会在包初始化时运行</li>
<li>谨慎使用 init 函数<ul>
<li>当多个依赖项目引用统一项目，且被引用项目的初始化在 init 中完成，并且不可重复运行时，会导 致启动错误</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myVariable = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	myVariable = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-4-返回值"><a href="#5-4-返回值" class="headerlink" title="5.4 返回值"></a><font color=DarkOrange>5.4 返回值</font></h5><ul>
<li>多值返回<ul>
<li>函数可以返回任意数量的返回值</li>
</ul>
</li>
<li>命名返回值<ul>
<li>Go 的返回值可被命名，它们会被视作定义在函数顶部的变量</li>
<li>返回值的名称应当具有一定的意义，它可以作为文档使用</li>
<li>没有参数的 return 语句返回已命名的返回值。也就是直接返回</li>
</ul>
</li>
<li>调用者忽略部分返回值<ul>
<li>result, _ &#x3D; strconv.Atoi(origStr)</li>
</ul>
</li>
</ul>
<h5 id="5-5-传递变长参数"><a href="#5-5-传递变长参数" class="headerlink" title="5.5 传递变长参数"></a><font color=DarkOrange>5.5 传递变长参数</font></h5><p>Go 语言中的可变长参数允许调用方传递任意多个相同类型的参数</p>
<ul>
<li><p>函数定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(slice []Type, elems ...Type)</span></span> []Type</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">myArray := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">myArray = <span class="built_in">append</span>(myArray, <span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="5-6-内置函数"><a href="#5-6-内置函数" class="headerlink" title="5.6 内置函数"></a><font color=DarkOrange>5.6 内置函数</font></h5><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>close</td>
<td>管道关闭</td>
</tr>
<tr>
<td>len, cap</td>
<td>返回数组、切片，Map 的长度或容量</td>
</tr>
<tr>
<td>new, make</td>
<td>内存分配</td>
</tr>
<tr>
<td>copy, append</td>
<td>操作切片</td>
</tr>
<tr>
<td>panic, recover</td>
<td>错误处理</td>
</tr>
<tr>
<td>print, println</td>
<td>打印</td>
</tr>
<tr>
<td>complex, real, imag</td>
<td>操作复数</td>
</tr>
</tbody></table>
<h5 id="5-7-回调函数-Callback"><a href="#5-7-回调函数-Callback" class="headerlink" title="5.7 回调函数(Callback)"></a><font color=DarkOrange>5.7 回调函数(Callback)</font></h5><p>函数作为参数传入其它函数，并在其他函数内部调用执行</p>
<ul>
<li>strings.IndexFunc(line, unicode.IsSpace)</li>
<li>Kubernetes controller的leaderelection</li>
</ul>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  DoOperation(<span class="number">1</span>, increase)</span><br><span class="line">  DoOperation(<span class="number">1</span>, decrease)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increase</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(“increase result is:”, a+b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoOperation</span><span class="params">(y <span class="type">int</span>, f <span class="keyword">func</span>(<span class="type">int</span>, <span class="type">int</span>)</span></span>) &#123;</span><br><span class="line">	f(y, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decrease</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;decrease result is:&quot;</span>, a-b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-8-闭包"><a href="#5-8-闭包" class="headerlink" title="5.8 闭包"></a><font color=DarkOrange>5.8 闭包</font></h5><p>匿名函数</p>
<ul>
<li><p>不能独立存在</p>
</li>
<li><p>可以赋值给其他变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x:= <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以直接调用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(x,y <span class="type">int</span>)</span></span>&#123;<span class="built_in">println</span>(x+y)&#125;(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>可作为函数返回值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">()</span></span> (<span class="function"><span class="keyword">func</span><span class="params">(b <span class="type">int</span>)</span></span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用场景</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">  	<span class="built_in">println</span>(“recovered in FuncX”)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="5-9-方法"><a href="#5-9-方法" class="headerlink" title="5.9 方法"></a><font color=DarkOrange>5.9 方法</font></h5><ul>
<li><p>方法：作用在接收者上的函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">• <span class="function"><span class="keyword">func</span> <span class="params">(recv receiver_type)</span></span> methodName(parameter_list) (return_value_list)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用场景</p>
<ul>
<li>很多场景下，函数需要的上下文可以保存在receiver属性中，通过定义 receiver 的方法，该方法可以直接 访问 receiver 属性，减少参数传递需求</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StartTLS starts TLS on a server from NewUnstartedServer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> StartTLS() &#123;</span><br><span class="line">  <span class="keyword">if</span> s.URL != “” &#123;</span><br><span class="line">  	<span class="built_in">panic</span>(“Server already started”)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.client == <span class="literal">nil</span> &#123;</span><br><span class="line">  	s.client = &amp;http.Client&#123;Transport: &amp;http.Transport&#123;&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="5-10-传值还是传指针"><a href="#5-10-传值还是传指针" class="headerlink" title="5.10 传值还是传指针"></a><font color=DarkOrange>5.10 传值还是传指针</font></h5><ul>
<li>Go 语言只有一种规则-传值</li>
<li>函数内修改参数的值不会影响函数外原始变量的值</li>
<li>可以传递指针参数将变量地址传递给调用函数，Go 语言会复制该指针作为函数内的地址，但指向同一地址</li>
</ul>
<p><strong>思考：当我们写代码的时候，函数的参数传递应该用struct 还是pointer？</strong></p>
<h5 id="5-11-接口"><a href="#5-11-接口" class="headerlink" title="5.11 接口"></a><font color=DarkOrange>5.11 接口</font></h5><ul>
<li><p>接口定义一组方法集合</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IF <span class="keyword">interface</span> &#123;</span><br><span class="line">	Method1(param_list) return_type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>适用场景：Kubernetes 中有大量的接口抽象和多种实现</p>
</li>
<li><p>Struct 无需显示声明实现 interface，只需直接实现方法</p>
</li>
<li><p>Struct 除实现 interface 定义的接口外，还可以有额外的方法</p>
</li>
<li><p>一个类型可实现多个接口（Go 语言的多重继承）</p>
</li>
<li><p>Go 语言中接口不接受属性定义</p>
</li>
<li><p>接口可以嵌套其他接口</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IF <span class="keyword">interface</span> &#123;</span><br><span class="line">	getName() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">	firstName, lastName <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> getName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> h.firstName + <span class="string">&quot;,&quot;</span> + h.lastName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">	factory, model <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Car)</span></span> getName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.factory + <span class="string">&quot;-&quot;</span> + c.model</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  interfaces := []IF&#123;&#125;</span><br><span class="line">  h := <span class="built_in">new</span>(Human)</span><br><span class="line">  h.firstName = <span class="string">&quot;first&quot;</span></span><br><span class="line">  h.lastName = <span class="string">&quot;last&quot;</span></span><br><span class="line">  interfaces = <span class="built_in">append</span>(interfaces, h)</span><br><span class="line">  c := <span class="built_in">new</span>(Car)</span><br><span class="line">  c.factory = <span class="string">&quot;benz&quot;</span></span><br><span class="line">  c.model = <span class="string">&quot;s&quot;</span></span><br><span class="line">  interfaces = <span class="built_in">append</span>(interfaces, c)</span><br><span class="line">  <span class="keyword">for</span> _, f := <span class="keyword">range</span> interfaces &#123;</span><br><span class="line">  	fmt.Println(f.getName())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>Interface 是可能为 nil 的，所以针对 interface 的使用一定要预 先判空，否则会引起程序 crash(nil panic)</li>
<li>Struct 初始化意味着空间分配，对 struct 的引用不会出现空指针</li>
</ul>
<h5 id="5-12-反射机制"><a href="#5-12-反射机制" class="headerlink" title="5.12 反射机制"></a><font color=DarkOrange>5.12 反射机制</font></h5><ul>
<li>reflect.TypeOf ()返回被检查对象的类型</li>
<li>reflect.ValueOf()返回被检查对象的值</li>
</ul>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">myMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">10</span>)</span><br><span class="line">myMap[<span class="string">&quot;a&quot;</span>] = <span class="string">&quot;b&quot;</span></span><br><span class="line">t := reflect.TypeOf(myMap)</span><br><span class="line">fmt.Println(<span class="string">&quot;type:&quot;</span>, t)</span><br><span class="line">v := reflect.ValueOf(myMap)</span><br><span class="line">fmt.Println(<span class="string">&quot;value:&quot;</span>, v)</span><br></pre></td></tr></table></figure>

<h5 id="5-13-基于struct的反射"><a href="#5-13-基于struct的反射" class="headerlink" title="5.13 基于struct的反射"></a><font color=DarkOrange>5.13 基于struct的反射</font></h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// struct</span></span><br><span class="line">myStruct := T&#123;A: <span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line">v1 := reflect.ValueOf(myStruct)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v1.NumField(); i++ &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Field %d: %v\n&quot;</span>, i, v1.Field(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v1.NumMethod(); i++ &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Method %d: %v\n&quot;</span>, i, v1.Method(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要注意 receive 是 struct 还是指针</span></span><br><span class="line">result := v1.Method(<span class="number">0</span>).Call(<span class="literal">nil</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;result:&quot;</span>, result)</span><br></pre></td></tr></table></figure>

<h5 id="5-14-Go语言中的面向对象编程"><a href="#5-14-Go语言中的面向对象编程" class="headerlink" title="5.14 Go语言中的面向对象编程"></a><font color=DarkOrange>5.14 Go语言中的面向对象编程</font></h5><ul>
<li>可见性控制<ul>
<li>public - 常量、变量、类型、接口、结构、函数等的名称大写</li>
<li>private - 非大写就只能在包内使用</li>
</ul>
</li>
<li>继承<ul>
<li>通过组合实现，内嵌一个或多个 struct</li>
</ul>
</li>
<li>多态<ul>
<li>通过接口实现，通过接口定义方法集，编写多套实现</li>
</ul>
</li>
</ul>
<h5 id="5-15-json编解码"><a href="#5-15-json编解码" class="headerlink" title="5.15 json编解码"></a><font color=DarkOrange>5.15 json编解码</font></h5><ul>
<li><p>Unmarshal: 从 string 转换至 struct</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unmarshal2Struct</span><span class="params">(humanStr <span class="type">string</span>)</span></span>Human &#123;</span><br><span class="line">  h := Human&#123;&#125;</span><br><span class="line">  err := json.Unmarshal([]<span class="type">byte</span>(humanStr), &amp;h)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  	<span class="built_in">println</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Marshal: 从 struct 转换至 string</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">marshal2JsonString</span><span class="params">(h Human)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  h.Age = <span class="number">30</span></span><br><span class="line">  updatedBytes, err := json.Marshal(&amp;h)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  	<span class="built_in">println</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">string</span>(updatedBytes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>json 包使用 map[string]interface{} 和 []interface{} 类型保存任意对象</p>
</li>
<li><p>可通过如下逻辑解析任意 json</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">err := json.Unmarshal([]<span class="type">byte</span>(humanStr), &amp;obj)</span><br><span class="line">objMap, ok := obj.(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> objMap &#123;</span><br><span class="line">  <span class="keyword">switch</span> value := v.(<span class="keyword">type</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">  	fmt.Printf(<span class="string">&quot;type of %s is string, value is %v\n&quot;</span>, k, value)</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line">  	fmt.Printf(<span class="string">&quot;type of %s is interface&#123;&#125;, value is %v\n&quot;</span>, k, value)</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  	fmt.Printf(<span class="string">&quot;type of %s is wrong, value is %v\n&quot;</span>, k, value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-常用语法"><a href="#6-常用语法" class="headerlink" title="6. 常用语法"></a><font color=DarkOrange>6. 常用语法</font></h4><h5 id="6-1-错误处理"><a href="#6-1-错误处理" class="headerlink" title="6.1 错误处理"></a><font color=DarkOrange>6.1 错误处理</font></h5><ul>
<li><p>Go 语言无内置 exceptio 机制，只提供 error 接口供定义错误</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">	Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可通过 errors.New 或 fmt.Errorf 创建新的 error</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> errNotFound <span class="type">error</span> = errors.New(<span class="string">&quot;NotFound&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>通常应用程序对 error 的处理大部分是判断 error 是否为 nil</p>
</li>
</ul>
<p>如需将 error 归类，通常交给应用程序自定义，比如 kubernetes 自定义了与 apiserver 交互的不同类型错误</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StatusError <span class="keyword">struct</span> &#123;</span><br><span class="line">	ErrStatus metav1.Status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ <span class="type">error</span> = &amp;StatusError&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error implements the Error interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *StatusError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> e.ErrStatus.Message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-2-defer"><a href="#6-2-defer" class="headerlink" title="6.2 defer"></a><font color=DarkOrange>6.2 defer</font></h5><ul>
<li>函数返回之前执行某个语句或函数</li>
<li>常见的 defer 使用场景：记得关闭你打开的资源<ul>
<li>defer file.Close()</li>
<li>defer mu.Unlock()</li>
<li>defer println(“”)</li>
</ul>
</li>
</ul>
<h5 id="6-3-panic和recover"><a href="#6-3-panic和recover" class="headerlink" title="6.3 panic和recover"></a><font color=DarkOrange>6.3 panic和recover</font></h5><ul>
<li>panic: 可在系统出现不可恢复错误时主动调用 panic, panic 会使当前线程直接 crash</li>
<li>defer: 保证执行并把控制权交还给接收到 panic 的函数调用者</li>
<li>recover: 函数从 panic 或 错误场景中恢复</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;defer func is called&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  	fmt.Println(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;a panic is triggered&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="7-多线程"><a href="#7-多线程" class="headerlink" title="7. 多线程"></a><font color=DarkOrange>7. 多线程</font></h4><h5 id="7-1-并发和并行"><a href="#7-1-并发和并行" class="headerlink" title="7.1 并发和并行"></a><font color=DarkOrange>7.1 并发和并行</font></h5><ul>
<li><p>并发（concurrency）</p>
<ul>
<li>两个或多个事件在同一时间间隔发生</li>
</ul>
<img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8bzcerzeej30zw02yjsm.jpg" alt="image.png" style="zoom: 50%;" />
</li>
<li><p>并行（parallellism）</p>
<ul>
<li>两个或者多个事件在同一时刻发生</li>
</ul>
<img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8bzd7setzj30zu0aadh9.jpg" alt="image.png" style="zoom: 50%;" /></li>
</ul>
<h5 id="7-2-协程"><a href="#7-2-协程" class="headerlink" title="7.2 协程"></a><font color=DarkOrange>7.2 协程</font></h5><ul>
<li>进程<ul>
<li>分配系统资源（CPU 时间、内存等）基本单位</li>
<li>有独立的内存空间，切换开销大</li>
</ul>
</li>
<li>线程<ul>
<li>进程的一个执行流，是 CPU 调度并能独立运行的的基本单位</li>
<li>同一进程中的多线程共享内存空间，线程切换代价小</li>
<li>多线程通信方便</li>
<li>从内核层面来看线程其实也是一种特殊的进程，它跟父进程共享了打开的文件和文件系统信息，共<br>享了地址空间和信号处理函数</li>
</ul>
</li>
<li>协程<ul>
<li>Go 语言中的轻量级线程实现</li>
<li>Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，当遇到长时间执行<br>或者进行系统调用时，会主动把当前 goroutine 的 CPU (P) 转让出去，让其他 goroutine 能被调度<br>并执行，也就是 Golang 从语言层面支持了协程</li>
</ul>
</li>
</ul>
<h5 id="7-3-CSP"><a href="#7-3-CSP" class="headerlink" title="7.3 CSP"></a><font color=DarkOrange>7.3 CSP</font></h5><ul>
<li><p>CSP</p>
<ul>
<li>描述两个独立的并发实体通过共享的通讯 channel 进行通信的并发模型</li>
</ul>
</li>
<li><p>Go 协程 goroutine</p>
<ul>
<li>是一种轻量线程，它不是操作系统的线程，而是将一个操作系统线程分段使用，通过调度器实现协<br>作式调度</li>
<li>是一种绿色线程，微线程，它与 Coroutine 协程也有区别，能够在发现堵塞后启动新的微线程</li>
</ul>
</li>
<li><p>通道 channel</p>
<ul>
<li>类似 Unix 的 Pipe，用于协程之间通讯和同步</li>
<li>协程之间虽然解耦，但是它们和 Channel 有着耦合</li>
</ul>
</li>
</ul>
<h5 id="7-4-线程和协程的差异"><a href="#7-4-线程和协程的差异" class="headerlink" title="7.4 线程和协程的差异"></a><font color=DarkOrange>7.4 线程和协程的差异</font></h5><ul>
<li><p>每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少</p>
<ul>
<li>goroutine：2KB</li>
<li>线程：8MB</li>
</ul>
</li>
<li><p>线程&#x2F;goroutine 切换开销方面，goroutine 远比线程小</p>
<ul>
<li>线程：涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP…等寄存器的刷新</li>
<li>goroutine：只有三个寄存器的值修改 - PC &#x2F; SP &#x2F; DX</li>
</ul>
</li>
<li><p>GOMAXPROCS</p>
<ul>
<li>控制并行线程数量</li>
</ul>
</li>
<li><p>启动新协程：go functionName()</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">go</span> fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="7-5-channel-多线程通信"><a href="#7-5-channel-多线程通信" class="headerlink" title="7.5 channel-多线程通信"></a><font color=DarkOrange>7.5 channel-多线程通信</font></h5><ul>
<li>Channel 是多个协程之间通讯的管道<ul>
<li>一端发送数据，一端接收数据</li>
<li>同一时间只有一个协程可以访问数据，无共享内存模式可能出现的内存竞争</li>
<li>协调协程的执行顺序</li>
</ul>
</li>
<li>声明方式<ul>
<li><code>var identifier chan datatype</code></li>
<li>操作符&lt;-</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;hello from goroutine&quot;</span>)</span><br><span class="line">  ch &lt;- <span class="number">0</span> <span class="comment">//数据写入Channel</span></span><br><span class="line">&#125;()</span><br><span class="line">i := &lt;-ch<span class="comment">//从Channel中取数据并赋值</span></span><br></pre></td></tr></table></figure>

<h5 id="7-6-通道缓冲"><a href="#7-6-通道缓冲" class="headerlink" title="7.6 通道缓冲"></a><font color=DarkOrange>7.6 通道缓冲</font></h5><ul>
<li>基于 Channel 的通信是同步的</li>
<li>当缓冲区满时，数据的发送是阻塞的</li>
<li>通过 make 关键字创建通道时可定义缓冲区容量，默认缓冲区容量为 0</li>
</ul>
<h5 id="7-7-遍历通道缓冲区"><a href="#7-7-遍历通道缓冲区" class="headerlink" title="7.7 遍历通道缓冲区"></a><font color=DarkOrange>7.7 遍历通道缓冲区</font></h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    n := rand.Intn(<span class="number">10</span>) <span class="comment">// n will be between 0 and 10</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;putting: &quot;</span>, n)</span><br><span class="line">    ch &lt;- n</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">close</span>(ch)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;hello from main&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;receiving: &quot;</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-8-单向通道"><a href="#7-8-单向通道" class="headerlink" title="7.8 单向通道"></a><font color=DarkOrange>7.8 单向通道</font></h5><ul>
<li><p>只发送通道</p>
<ul>
<li><code>var sendOnly chan&lt;- int</code></li>
</ul>
</li>
<li><p>只接收通道</p>
<ul>
<li><code>var readOnly &lt;-chan int</code></li>
</ul>
</li>
<li><p>Istio webhook controller</p>
<ul>
<li><code>func (w *WebhookCertPatcher) runWebhookController(stopChan &lt;-chan struct&#123;&#125;) &#123;&#125;</code></li>
</ul>
</li>
<li><p>如何用: 双向通道转换</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> prod(c)</span><br><span class="line"><span class="keyword">go</span> consume(c)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prod</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> &#123; ch &lt;- <span class="number">1</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123; &lt;-ch &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="7-9-关闭通道"><a href="#7-9-关闭通道" class="headerlink" title="7.9 关闭通道"></a><font color=DarkOrange>7.9 关闭通道</font></h5><ul>
<li>通道无需每次关闭</li>
<li>关闭的作用是告诉接收者该通道再无新数据发送</li>
<li>只有发送方需要关闭通道</li>
</ul>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(ch)</span><br><span class="line"><span class="keyword">if</span> v, notClosed := &lt;-ch; notClosed &#123;</span><br><span class="line">	fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-10-select"><a href="#7-10-select" class="headerlink" title="7.10 select"></a><font color=DarkOrange>7.10 select</font></h5><ul>
<li>当多个协程同时运行时，可通过 select 轮询多个通道<ul>
<li>如果所有通道都阻塞则等待，如定义了 default 则执行 default</li>
<li>如多个通道就绪则随机选择</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v:= &lt;- ch1:</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">case</span> v:= &lt;- ch2:</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-11-定时器timer"><a href="#7-11-定时器timer" class="headerlink" title="7.11 定时器timer"></a><font color=DarkOrange>7.11 定时器timer</font></h5><ul>
<li>time.Ticker 以指定的时间间隔重复的向通道 C 发送时间值</li>
<li>使用场景<ul>
<li>为协程设定超时时间</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">timer := time.NewTimer(time.Second)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="comment">// check normal channel</span></span><br><span class="line">  <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">  	fmt.Println(<span class="string">&quot;received from ch&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">  	fmt.Println(<span class="string">&quot;timeout waiting from channel ch&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-12-上下文context"><a href="#7-12-上下文context" class="headerlink" title="7.12 上下文context"></a><font color=DarkOrange>7.12 上下文context</font></h5><ul>
<li><p>超时、取消操作或者一些异常情况，往往需要进行抢占操作或者中断后续操作</p>
</li>
<li><p>Context 是设置截止日期、同步信号，传递请求相关值的结构体</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">Err() <span class="type">error</span></span><br><span class="line">Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用法</p>
<ul>
<li>context.Background</li>
<li>context.TODO</li>
<li>context.WithDeadline</li>
<li>context.WithValue</li>
<li>context.WithCancel</li>
</ul>
</li>
</ul>
<h5 id="7-13-如何停止一个子协程"><a href="#7-13-如何停止一个子协程" class="headerlink" title="7.13 如何停止一个子协程"></a><font color=DarkOrange>7.13 如何停止一个子协程</font></h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-done:</span><br><span class="line">    	fmt.Println(<span class="string">&quot;done channel is triggerred, exit child go routine&quot;</span>)</span><br><span class="line">    	<span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">close</span>(done)</span><br></pre></td></tr></table></figure>

<h5 id="7-14-基于context停止子协程"><a href="#7-14-基于context停止子协程" class="headerlink" title="7.14 基于context停止子协程"></a><font color=DarkOrange>7.14 基于context停止子协程</font></h5><p>Context 是 Go 语言对 go routine 和 timer 的封装</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"><span class="keyword">go</span> process(ctx, <span class="number">100</span>*time.Millisecond)</span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line">fmt.Println(<span class="string">&quot;main:&quot;</span>, ctx.Err())</span><br></pre></td></tr></table></figure>



<hr>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>云原生</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生03-Docker核心技术</title>
    <url>/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F03-Docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<p>待完成。。。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>云原生</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生04-Kubernetes架构原则和对象设计</title>
    <url>/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F04-Kubernetes%E6%9E%B6%E6%9E%84%E5%8E%9F%E5%88%99%E5%92%8C%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>待完成。。。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>云原生</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL、MongoDB、PostgreSQL面试题</title>
    <url>/2022/10/28/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>数据库常见面试题、八股文</p>
<h3 id="MySQL面试题"><a href="#MySQL面试题" class="headerlink" title="MySQL面试题"></a><font color=DarkOrange>MySQL面试题</font></h3><h4 id="1-Mysql索引用的是什么算法"><a href="#1-Mysql索引用的是什么算法" class="headerlink" title="1. Mysql索引用的是什么算法"></a><font color=DarkOrange>1. Mysql索引用的是什么算法</font></h4><ul>
<li>Mysql索引选用的是B+树，平衡二叉树的高度太高，查找可能需要较多的磁盘IO。B树索引占用内存较高(非叶子节点存储数据)</li>
<li>B+树，主要是查询效率高，O(logN)，可以充分利用磁盘预读的特性，多叉树，深度小，叶子结点有序且存储数据</li>
</ul>
<h4 id="2-Mysql事务的基本要素"><a href="#2-Mysql事务的基本要素" class="headerlink" title="2. Mysql事务的基本要素"></a><font color=DarkOrange>2. Mysql事务的基本要素</font></h4><ul>
<li>原子性：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行</li>
<li>一致性：事务开始前和结束后，数据库的完整性约束没有被破坏</li>
<li>隔离性：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰</li>
<li>持久性：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚</li>
</ul>
<h4 id="3-Mysql的存储引擎"><a href="#3-Mysql的存储引擎" class="headerlink" title="3. Mysql的存储引擎"></a><font color=DarkOrange>3. Mysql的存储引擎</font></h4><ul>
<li>InnoDB存储引擎<ul>
<li>InnoDB存储引擎支持事务，其设计目标主要面向在线事务处理（OLTP）的应用</li>
<li>其特点是行锁设计，支持外键，并支持非锁定锁，即默认读取操作不会产生锁。从Mysql5.5.8版本开始，InnoDB存储引擎是默认的存储引擎</li>
</ul>
</li>
<li>MyISAM存储引擎<ul>
<li>MyISAM存储引擎不支持事务、表锁设计，支持全文索引，主要面向一些OLAP数据库应用</li>
<li>InnoDB的数据文件本身就是主索引文件，而MyISAM的主索引和数据是分开的</li>
</ul>
</li>
<li>NDB存储引擎<ul>
<li>NDB存储引擎是一个集群存储引擎，其结构是share nothing的集群架构，能提供更高的可用性</li>
<li>NDB的特点是数据全部放在内存中（从MySQL 5.1版本开始，可以将非索引数据放在磁盘上），因此主键查找的速度极快，并且通过添加NDB数据存储节点可以线性地提高数据库性能，是高可用、高性能的集群系统</li>
<li>NDB存储引擎的连接操作是在MySQL数据库层完成的，而不是在存储引擎层完成的。这意味着，复杂的连接操作需要巨大的网络开销，因此查询速度很慢。如果解决了这个问题，NDB存储引擎的市场应该是非常巨大的</li>
</ul>
</li>
<li>Memory存储引擎<ul>
<li>Memory存储引擎（之前称HEAP存储引擎）将表中的数据存放在内存中，如果数据库重启或发生崩溃，表中的数据都将消失</li>
<li>它非常适合用于存储临时数据的临时表，以及数据仓库中的纬度表。Memory存储引擎默认使用哈希索引，而不是我们熟悉的B+树索引</li>
<li>虽然Memory存储引擎速度非常快，但在使用上还是有一定的限制。比如，只支持表锁，并发性能较差，并且不支持TEXT和BLOB列类型。最重要的是，存储变长字段时是按照定常字段的方式进行的，因此会浪费内存</li>
</ul>
</li>
<li>Archive存储引擎<ul>
<li>Archive存储引擎只支持INSERT和SELECT操作，从MySQL 5.1开始支持索引</li>
<li>Archive存储引擎使用zlib算法将数据行（row）进行压缩后存储，压缩比一般可达1∶10。正如其名字所示，Archive存储引擎非常适合存储归档数据，如日志信息</li>
<li>Archive存储引擎使用行锁来实现高并发的插入操作，但是其本身并不是事务安全的存储引擎，其设计目标主要是提供高速的插入和压缩功能</li>
</ul>
</li>
<li>Maria存储引擎<ul>
<li>Maria存储引擎是新开发的引擎，设计目标主要是用来取代原有的MyISAM存储引擎，从而成为MySQL的默认存储引擎。它可以看做是MyISAM的后续版本</li>
<li>Maria存储引擎的特点是：支持缓存数据和索引文件，应用了行锁设计，提供了MVCC功能，支持事务和非事务安全的选项，以及更好的BLOB字符类型的处理性能</li>
</ul>
</li>
</ul>
<h4 id="4-Mysql事务隔离级别"><a href="#4-Mysql事务隔离级别" class="headerlink" title="4. Mysql事务隔离级别"></a><font color=DarkOrange>4. Mysql事务隔离级别</font></h4><p>Mysql有四种事务隔离级别，默认的是可重复读</p>
<table>
<thead>
<tr>
<th align="left">事务隔离级别</th>
<th align="left">脏读</th>
<th align="left">不可重复读</th>
<th align="left">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="left">读未提交</td>
<td align="left">是</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">读已提交</td>
<td align="left">否</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">可重复读</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">串行</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">否</td>
</tr>
</tbody></table>
<ul>
<li><p>读未提交(Read uncommitted)</p>
<p>一个事务可以读取另一个未提交事务的数据，最低级别，任何情况都无法保证</p>
<ul>
<li>所有事务都可以看到其他未提交事务的执行结果</li>
<li>本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少</li>
<li>该级别引发的问题是——脏读(Dirty Read)：读取到了未提交的数据</li>
</ul>
</li>
<li><p>读已提交(Read committed)</p>
<p>一个事务要等另一个事务提交后才能读取数据，可避免脏读的发生</p>
<ul>
<li>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）</li>
<li>它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变</li>
<li>这种隔离级别出现的问题是——不可重复读(Nonrepeatable Read)，不可重复读意味着我们在同一个事务中执行完全相同的select语句时可能看到不一样的结果</li>
</ul>
<p>导致这种情况的原因可能有：</p>
<ul>
<li>有一个交叉的事务有新的commit，导致了数据的改变</li>
<li>一个数据库被多个实例操作时，同一事务的其他实例在该实例处理其间可能会有新的commit</li>
</ul>
</li>
<li><p>可重复读(Repeatable read)</p>
<p>就是在开始读取数据（事务开启）时，不再允许修改操作，可避免脏读、不可重复读的发生</p>
<ul>
<li>这是MySQL的默认事务隔离级别</li>
<li>它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行</li>
<li>此级别可能出现的问题——幻读(Phantom Read)：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行</li>
<li>InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了该问题.InnoDB采用MVCC来支持高并发，实现了四个标准隔离级别。默认基本是可重复读，并且提供间隙锁（next-key locks）策略防止幻读出现</li>
</ul>
</li>
<li><p>串行(Serializable)</p>
<p>串行(Serializable)，是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。Mysql的默认隔离级别是Repeatable read</p>
<ul>
<li>这是最高的隔离级别</li>
<li>它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁</li>
<li>在这个级别，可能导致大量的超时现象和锁竞争</li>
</ul>
</li>
</ul>
<h4 id="5-Mysql高可用方案有哪些"><a href="#5-Mysql高可用方案有哪些" class="headerlink" title="5. Mysql高可用方案有哪些"></a><font color=DarkOrange>5. Mysql高可用方案有哪些</font></h4><ul>
<li>主从复制方案<ul>
<li>这是MySQL自身提供的一种高可用解决方案，数据同步方法采用的是<code>MySQL replication</code>技术。<code>MySQL replication</code>就是从服务器到主服务器拉取二进制日志文件，然后再将日志文件解析成相应的SQL在从服务器上重新执行一遍主服务器的操作，通过这种方式保证数据的一致性</li>
<li>为了达到更高的可用性，在实际的应用环境中，一般都是采用<code>MySQL replication</code>技术配合高可用集群软件<code>keepalived</code>来实现自动<code>failover</code>，这种方式可以实现95.000%的SLA</li>
</ul>
</li>
<li>MMM&#x2F;MHA高可用方案<ul>
<li>MMM提供了MySQL主主复制配置的监控、故障转移和管理的一套可伸缩的脚本套件。在MMM高可用方案中，典型的应用是双主多从架构，通过MySQL replication技术可以实现两个服务器互为主从，且在任何时候只有一个节点可以被写入，避免了多点写入的数据冲突</li>
<li>同时，当可写的主节点故障时，MMM套件可以立刻监控到，然后将服务自动切换到另一个主节点，继续提供服务，从而实现MySQL的高可用</li>
</ul>
</li>
<li>Heartbeat&#x2F;SAN高可用方案<ul>
<li>在这个方案中，处理failover的方式是高可用集群软件Heartbeat，它监控和管理各个节点间连接的网络，并监控集群服务，当节点出现故障或者服务不可用时，自动在其他节点启动集群服务</li>
<li>在数据共享方面，通过SAN（Storage Area Network）存储来共享数据，这种方案可以实现99.990%的SLA</li>
</ul>
</li>
<li>Heartbeat&#x2F;DRBD高可用方案<ul>
<li>这个方案处理failover的方式上依旧采用Heartbeat，不同的是，在数据共享方面，采用了基于块级别的数据同步软件DRBD来实现</li>
<li>DRBD是一个用软件实现的、无共享的、服务器之间镜像块设备内容的存储复制解决方案。和SAN网络不同，它并不共享存储，而是通过服务器之间的网络复制数据</li>
</ul>
</li>
<li>NDB CLUSTER高可用方案<ul>
<li>国内用NDB集群的公司非常少，貌似有些银行有用。NDB集群不需要依赖第三方组件，全部都使用官方组件，能保证数据的一致性，某个数据节点挂掉，其他数据节点依然可以提供服务，管理节点需要做冗余以防挂掉</li>
<li>缺点是：管理和配置都很复杂，而且某些SQL语句例如join语句需要避免</li>
</ul>
</li>
</ul>
<h4 id="6-Mysql中utf8和utf8mb4区别"><a href="#6-Mysql中utf8和utf8mb4区别" class="headerlink" title="6. Mysql中utf8和utf8mb4区别"></a><font color=DarkOrange>6. Mysql中utf8和utf8mb4区别</font></h4><ul>
<li>MySQL在5.5.3之后增加了这个utf8mb4的编码，mb4就是most bytes 4的意思，专门用来兼容四字节的unicode。好在utf8mb4是utf8的超集，除了将编码改为utf8mb4外不需要做其他转换。当然，为了节省空间，一般情况下使用utf8也就可以了</li>
<li>Mysql支持的utf8编码最大字符长度为3字节，如果遇到4字节的宽字符就会插入异常了。三个字节的UTF-8最大能编码的Unicode字符是0xffff，也就是Unicode中的基本多文种平面(BMP)。任何不在基本多文本平面的Unicode字符，都无法使用Mysql的utf8字符集存储</li>
<li>包括 Emoji 表情(Emoji是一种特殊的Unicode编码，常见于ios和android手机上)，和很多不常用的汉字，以及任何新增的Unicode字符等等</li>
<li>Mysql中保存4字节长度的UTF-8字符，需要使用utf8mb4字符集，但只有5.5.3版本以后的才支持(查看版本： select version();)。因此呢，为了获取更好的兼容性，应该总是使用utf8mb4而非utf8</li>
<li>对于CHAR类型数据，utf8mb4会多消耗一些空间，根据Mysql官方建议，使用VARCHAR替代CHAR</li>
</ul>
<h4 id="7-Mysql中乐观锁和悲观锁区别"><a href="#7-Mysql中乐观锁和悲观锁区别" class="headerlink" title="7. Mysql中乐观锁和悲观锁区别"></a><font color=DarkOrange>7. Mysql中乐观锁和悲观锁区别</font></h4><ul>
<li><p>悲观锁(Pessimistic Lock)</p>
<ul>
<li>悲观锁顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁</li>
<li>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁</li>
</ul>
</li>
<li><p>乐观锁(Optimistic Lock)</p>
<ul>
<li>乐观锁顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制</li>
<li>乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于<code>write_condition</code>机制的其实都是提供的乐观锁</li>
<li>乐观锁的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好</li>
</ul>
</li>
<li><p>两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适</p>
</li>
</ul>
<h4 id="8-Mysql索引主要是哪些"><a href="#8-Mysql索引主要是哪些" class="headerlink" title="8. Mysql索引主要是哪些"></a><font color=DarkOrange>8. Mysql索引主要是哪些</font></h4><p>索引的目的在于提高查询效率</p>
<ul>
<li>UNIQUE(唯一索引)：不可以出现相同的值，可以有NULL值</li>
<li>INDEX(普通索引)：允许出现相同的索引内容</li>
<li>PROMARY KEY(主键索引)：不允许出现相同的值</li>
<li>fulltext index(全文索引)：可以针对值中的某个单词，但效率确实不敢恭维</li>
<li>组合索引：实质上是将多个字段建到一个索引里，列值的组合必须唯一</li>
</ul>
<hr>
<h5 id="8-1-索引的缺点"><a href="#8-1-索引的缺点" class="headerlink" title="8.1 索引的缺点"></a><font color=DarkOrange>8.1 索引的缺点</font></h5><ul>
<li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT，UPDATE和DELETE。因为更新表时，mysql不仅要保存数据，还要保存一下索引文件</li>
<li>建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在要给大表上建了多种组合索引，索引文件会膨胀很宽， 索引只是提高效率的一个方式，如果mysql有大数据量的表，就要花时间研究建立最优的索引，或优化查询语句</li>
</ul>
<hr>
<h5 id="8-2-索引使用技巧"><a href="#8-2-索引使用技巧" class="headerlink" title="8.2 索引使用技巧"></a><font color=DarkOrange>8.2 索引使用技巧</font></h5><ul>
<li><strong>索引不会包含有NULL的列：</strong> 只要列中包含有NULL值，都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此符合索引就是无效的</li>
<li><strong>使用短索引：</strong> 对串列进行索引，如果可以就应该指定一个前缀长度。例如，如果有一个char（255）的列，如果在前10个或20个字符内，多数值是唯一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I&#x2F;O操作</li>
<li><strong>索引列排序：</strong>mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作，尽量不要包含多个列的排序，如果需要最好给这些列建复合索引</li>
<li><strong>like语句操作：</strong>一般情况下不鼓励使用like操作，如果非使用不可，注意正确的使用方式。<code>like ‘%aaa%’</code>不会使用索引，而<code>like ‘aaa%’</code>可以使用索引</li>
<li>不要在列上进行运算</li>
<li>不使用<code>NOT IN</code> 、<code>&lt;&gt;</code>、<code>！=</code>操作，但<code>&lt;</code>，<code>&lt;=</code>，<code>=</code>，<code>&gt;</code>，<code>&gt;=</code>，BETWEEN，IN是可以用到索引的</li>
<li>索引要建立在经常进行select操作的字段上。这是因为，如果这些列很少用到，那么有无索引并不能明显改变查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求</li>
<li>索引要建立在值比较唯一的字段上。</li>
<li>对于那些定义为text、image和bit数据类型的列不应该增加索引。因为这些列的数据量要么相当大，要么取值很少</li>
<li>在where和join中出现的列需要建立索引。</li>
<li>where的查询条件里有不等号(where column !&#x3D; …)，mysql将无法使用索引。</li>
<li>如果where字句的查询条件里使用了函数(如：where DAY(column)&#x3D;…)，mysql将无法使用索引</li>
<li>在join操作中(需要从多个数据表提取数据时)，mysql只有在主键和外键的数据类型相同时才能使用索引，否则及时建立了索引也不会使用</li>
</ul>
<hr>
<h5 id="8-3-组合索引的作用"><a href="#8-3-组合索引的作用" class="headerlink" title="8.3 组合索引的作用"></a><font color=DarkOrange>8.3 组合索引的作用</font></h5><ul>
<li>减少开销<ul>
<li>建一个组合索引(col1，col2，col3)，实际相当于建了(col1)，(col1，col2)，(col1，col2，col3)三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用组合索引会大大的减少开销</li>
</ul>
</li>
<li>覆盖索引<ul>
<li>通常指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖</li>
<li>对组合索引(col1，col2，col3)，如果有如下的<code>sql: select col1，col2，col3 from test where col1=1 and col2=2</code></li>
<li>那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一</li>
</ul>
</li>
<li>效率高<ul>
<li>索引列越多，通过索引筛选出的数据越快</li>
</ul>
</li>
</ul>
<h4 id="9-Mysql联合索引最左匹配原则"><a href="#9-Mysql联合索引最左匹配原则" class="headerlink" title="9. Mysql联合索引最左匹配原则"></a><font color=DarkOrange>9. Mysql联合索引最左匹配原则</font></h4><ul>
<li>在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先<ul>
<li>在检索数据时从联合索引的最左边开始匹配，Mysql会一直向右匹配直到遇到范围查询（<code>&gt;、&lt;、between、like</code>）就停止匹配了</li>
<li>就比如 <code>a=3 and b=4 and c&gt;5 and d=6</code>如果建立(abcd)顺序的索引，d就用不到索引了，如果建立(abdc)的索引则都可以用到索引，其中abd的顺序可以任意调整，因为查询优化器会重新编排（即使是c&gt;5 and b&#x3D;4 and d&#x3D;6 and a&#x3D;3也会全部用到 abdc索引 ）</li>
</ul>
</li>
<li><code>=</code>和<code>in</code>可以乱序，比如<code>a=1 and b=2 and c=3</code> 建立(abc)索引可以任意顺序，mysql查询优化器会优化顺序<ul>
<li>这里需要注意下，比如abc索引 那么只要查询条件有a即可用到abc索引（如abc ab ac a），没有a就用不到</li>
<li>最左前缀匹配成因：Mysql是创建复合索引的规则是根据索引最左边的字段进行排序，在第一个字段排序的基础上再进行第二个字段排序，类似于order by col1，col2… 所以第一个字段是绝对有序的 第二个字段就是无序的了，所以Mysql强调最左前缀匹配</li>
</ul>
</li>
</ul>
<h4 id="10-聚簇索引和非聚簇索引区别"><a href="#10-聚簇索引和非聚簇索引区别" class="headerlink" title="10. 聚簇索引和非聚簇索引区别"></a><font color=DarkOrange>10. 聚簇索引和非聚簇索引区别</font></h4><ul>
<li>聚簇索引与非聚簇索引的区别是：叶子节点是否存放一整行记录</li>
<li>InnoDB 主键使用的是聚簇索引，MyISAM 不管是主键索引，还是二级索引使用的都是非聚簇索引</li>
<li>对于聚簇索引表来说（左图），表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值。使用的是B+树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)</li>
<li>对于非聚簇索引表来说（右图），表数据和索引是分成两部分存储的，主键索引和二级索引存储上没有任何区别。使用的是B+树作为索引的存储结构，所有的节点都是索引，叶子节点存储的是索引+索引对应的记录的数据</li>
<li>因此，聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针</li>
</ul>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7lczbhkshj318611ik0y.jpg" alt="image.png" style="zoom: 20%;" /></div>

<h4 id="11-如何查询一个字段是否命中了索引"><a href="#11-如何查询一个字段是否命中了索引" class="headerlink" title="11. 如何查询一个字段是否命中了索引"></a><font color=DarkOrange>11. 如何查询一个字段是否命中了索引</font></h4><ul>
<li>通过explain sql可看下SQL是否走了索引，很快对比出来 </li>
<li>当一个sql中索引字段为int类型时，例如搜索条件<code>where num=&quot;111&quot;</code>与<code>where num=111</code>都可以使用该字段的索引。当一个中索引字段为varchar类型时，例如搜索条件<code>where num=&quot;111&quot;</code>可以使用索引，<code>where num=111</code>不可以使用索引</li>
</ul>
<h4 id="12-Mysql不走索引的情况"><a href="#12-Mysql不走索引的情况" class="headerlink" title="12. Mysql不走索引的情况"></a><font color=DarkOrange>12. Mysql不走索引的情况</font></h4><ol>
<li>查询条件使用函数或表达式：如果在查询条件中使用函数或表达式，MySQL 无法使用索引进行优化，例如<code>WHERE YEAR(date) = 2022</code></li>
<li>查询条件使用了 LIKE 语句：如果在查询条件中使用了 LIKE 语句并且模式以通配符开头，例如<code>WHERE name LIKE &#39;%xxx&#39;</code></li>
<li>查询条件使用了 OR：如果查询条件使用了 OR，例如<code>WHERE a = 1 OR b = 2</code>，MySQL 无法同时使用多个索引，OR操作有至少一个字段没有索引</li>
<li>查询条件对列进行了运算或类型转换：如果在查询条件中对列进行了运算或类型转换，例如<code>WHERE CONCAT(firstname, lastname) = &#39;xxx&#39;</code></li>
<li>查询条件中使用了 NULL 值：如果在查询条件中使用了 NULL 值，例如<code>WHERE name IS NULL</code></li>
<li>查询的数据量很大：如果查询的数据量很大，超过了索引的选择性，MySQL可能会选择全表扫描而不是使用索引</li>
</ol>
<h4 id="13-Mysql中的MVCC是什么"><a href="#13-Mysql中的MVCC是什么" class="headerlink" title="13. Mysql中的MVCC是什么"></a><font color=DarkOrange>13. Mysql中的MVCC是什么</font></h4><p>数据库并发控制——锁:Multiversion (version) concurrency control (MCC or MVCC) 多版本并发控制 ，它是数据库管理系统一种常见的并发控制</p>
<p>并发控制常用的是锁，当线程要对一个共享资源进行操作的时候，加锁是一种非常简单粗暴的方法(事务开始时给 DQL 加读锁，给 DML 加写锁)，这种锁是一种 悲观 的实现方式，也就是说这会给其他事务造成堵塞，从而影响数据库性能</p>
<p>其中在数据库中最常见的就是悲观锁和乐观锁：</p>
<ul>
<li>悲观锁：当一个线程需要对共享资源进行操作的时候，首先对共享资源进行加锁，当该线程持有该资源的锁的时候，其他线程对该资源进行操作的时候会被阻塞.</li>
<li>乐观锁：当一个线程需要对一个共享资源进行操作的时候，不对它进行加锁，而是在操作完成之后进行判断。比如乐观锁会通过一个版本号控制，如果操作完成后通过版本号进行判断在该线程操作过程中是否有其他线程已经对该共享资源进行操作了，如果有则通知操作失败，如果没有则操作成功，当然除了版本号还有CAS，如果不了解的可以去学习一下，这里不做过多涉及</li>
</ul>
<p>MVCC的两种读形式：</p>
<ul>
<li>快照读：读取的只是当前事务的可见版本，不用加锁。而你只要记住 简单的 <code>select</code>操作就是快照读(select * from table where id &#x3D; xxx)</li>
<li>当前读：读取的是当前版本，比如 特殊的读操作，更新&#x2F;插入&#x2F;删除操作</li>
</ul>
<p>MVCC的实现原理：</p>
<p>MVCC 使用了“三个隐藏字段”来实现版本并发控制，MySQL在创建建表的时候 innoDB 创建的真正的三个隐藏列吧</p>
<table>
<thead>
<tr>
<th align="left">RowID</th>
<th align="left">DB_TRX_ID</th>
<th align="left">DB_ROLL_PTR</th>
<th align="left">id</th>
<th align="left">name</th>
<th align="left">password</th>
</tr>
</thead>
<tbody><tr>
<td align="left">自动创建的id</td>
<td align="left">事务id</td>
<td align="left">回滚指针</td>
<td align="left">id</td>
<td align="left">name</td>
<td align="left">password</td>
</tr>
</tbody></table>
<ul>
<li>RowID：隐藏的自增ID，当建表没有指定主键，InnoDB会使用该RowID创建一个聚簇索引</li>
<li>DB_TRX_ID：最近修改（更新&#x2F;删除&#x2F;插入）该记录的事务ID</li>
<li>DB_ROLL_PTR：回滚指针，指向这条记录的上一个版本</li>
</ul>
<p>其实还有一个删除的flag字段，用来判断该行记录是否已经被删除。而 MVCC 使用的是其中的 事务字段，回滚指针字段，是否删除字段</p>
<h4 id="14-Mvcc和Redolog和Undolog以及Binlog有什么不同"><a href="#14-Mvcc和Redolog和Undolog以及Binlog有什么不同" class="headerlink" title="14. Mvcc和Redolog和Undolog以及Binlog有什么不同"></a><font color=DarkOrange>14. Mvcc和Redolog和Undolog以及Binlog有什么不同</font></h4><ul>
<li>Mvcc<ul>
<li>MVCC多版本并发控制是MySQL中基于乐观锁理论实现隔离级别的方式，用于读已提交和可重复读取隔离级别的实现</li>
<li>在MySQL中，会在表中每一条数据后面添加两个字段，最近修改该行数据的事务ID，指向该行（undolog表中）回滚段的指针</li>
<li>Read View判断行的可见性，创建一个新事务时，copy一份当前系统中的活跃事务列表。意思是，当前不应该被本事务看到的其他事务id列表</li>
</ul>
</li>
<li>UndoLog<ul>
<li>UndoLog也就是我们常说的回滚日志文件 主要用于事务中执行失败，进行回滚，以及MVCC中对于数据历史版本的查看</li>
<li>由引擎层的InnoDB引擎实现，是逻辑日志，记录数据修改被修改前的值，比如”把id&#x3D;’B’ 修改为id &#x3D; ‘B2’ ，那么undo日志就会用来存放id &#x3D;’B’的记录”</li>
<li>当一条数据需要更新前，会先把修改前的记录存储在undolog中，如果这个修改出现异常，则会使用undo日志来实现回滚操作，保证事务的一致性</li>
<li>当事务提交之后，undo log并不能立马被删除，而是会被放到待清理链表中，待判断没有事物用到该版本的信息时才可以清理相应undolog。它保存了事务发生之前的数据的一个版本，用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读</li>
</ul>
</li>
<li>Redolog<ul>
<li>Redolog是重做日志文件是记录数据修改之后的值，用于持久化到磁盘中</li>
<li>Redolog包括两部分：一：是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二：是磁盘上的重做日志文件(redo log file)，该部分日志是持久的</li>
<li>由引擎层的InnoDB引擎实现，是物理日志，记录的是物理数据页修改的信息，比如“某个数据页上内容发生了哪些改动”。当一条数据需要更新时，InnoDB会先将数据更新，然后记录redoLog 在内存中，然后找个时间将redoLog的操作执行到磁盘上的文件上</li>
<li>不管是否提交成功我都记录，你要是回滚了，那我连回滚的修改也记录。它确保了事务的持久性</li>
</ul>
</li>
<li>Binlog<ul>
<li>Binlog由Mysql的Server层实现，是逻辑日志，记录的是sql语句的原始逻辑，比如”把id&#x3D;’B’ 修改为id &#x3D; ‘B2’</li>
<li>Binlog会写入指定大小的物理文件中，是追加写入的，当前文件写满则会创建新的文件写入</li>
<li>产生:事务提交的时候，一次性将事务中的sql语句，按照一定的格式记录到binlog中</li>
<li>用于复制和恢复在主从复制中，从库利用主库上的binlog进行重播(执行日志中记录的修改逻辑)，实现主从同步。业务数据不一致或者错了，用binlog恢复</li>
</ul>
</li>
</ul>
<h4 id="15-Mysql读写分离以及主从同步"><a href="#15-Mysql读写分离以及主从同步" class="headerlink" title="15. Mysql读写分离以及主从同步"></a><font color=DarkOrange>15. Mysql读写分离以及主从同步</font></h4><ul>
<li>原理：主库将变更写binlog日志，然后从库连接到主库后，从库有一个IO线程，将主库的binlog日志拷贝到自己本地，写入一个中继日志中，接着从库中有一个sql线程会从中继日志读取binlog，然后执行binlog日志中的内容，也就是在自己本地再执行一遍sql，这样就可以保证自己跟主库的数据一致</li>
<li>问题：这里有很重要一点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行操作，在从库上会串行化执行，由于从库从主库拷贝日志以及串行化执行sql特点，在高并发情况下，从库数据一定比主库慢一点，是有延时的，所以经常出现，刚写入主库的数据可能读不到了，要过几十毫秒，甚至几百毫秒才能读取到。还有一个问题，如果突然主库宕机了，然后恰巧数据还没有同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。所以mysql实际上有两个机制，一个是半同步复制，用来解决主库数据丢失问题，一个是并行复制，用来解决主从同步延时问题</li>
<li>半同步复制：semi-sync复制，指的就是主库写入binlog日志后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的relay log之后，接着会返回一个ack给主库，主库接收到至少一个从库ack之后才会认为写完成</li>
<li>并发复制：指的是从库开启多个线程，并行读取relay log中不同库的日志，然后并行重放不同库的日志，这样库级别的并行。（将主库分库也可缓解延迟问题）</li>
</ul>
<h4 id="16-InnoDB的关键特性"><a href="#16-InnoDB的关键特性" class="headerlink" title="16. InnoDB的关键特性"></a><font color=DarkOrange>16. InnoDB的关键特性</font></h4><ul>
<li>插入缓冲：对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个Insert Buffer对象中。然后再以一定的频率和情况进行Insert Buffer和辅助索引页子节点的merge（合并）操作，这时通常能将多个插入合并到一个操作中（因为在一个索引页中），这就大大提高了对于非聚集索引插入的性能</li>
<li>两次写：两次写带给InnoDB存储引擎的是数据页的可靠性，有经验的DBA也许会想，如果发生写失效，可以通过重做日志进行恢复。这是一个办法。但是必须清楚地认识到，如果这个页本身已经发生了损坏（物理到page页的物理日志成功页内逻辑日志失败），再对其进行重做是没有意义的。这就是说，在应用（apply）重做日志前，用户需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做。在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是会通过memcpy函数将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，这就是doublewrite</li>
<li>自适应哈希索引：InnoDB存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引</li>
<li>异步IO：为了提高磁盘操作性能，当前的数据库系统都采用异步IO（AIO）的方式来处理磁盘操作。AIO的另一个优势是可以进行IO Merge操作，也就是将多个IO合并为1个IO，这样可以提高IOPS的性能</li>
<li>刷新邻接页：当刷新一个脏页时，InnoDB存储引擎会检测该页所在区（extent）的所有页，如果是脏页，那么一起进行刷新。这样做的好处显而易见，通过AIO可以将多个IO写入操作合并为一个IO操作，故该工作机制在传统机械磁盘下有着显著的优势</li>
</ul>
<h4 id="17-Mysql如何保证一致性和持久性"><a href="#17-Mysql如何保证一致性和持久性" class="headerlink" title="17. Mysql如何保证一致性和持久性"></a><font color=DarkOrange>17. Mysql如何保证一致性和持久性</font></h4><ul>
<li>Mysql为了保证<code>ACID</code>中的一致性和持久性，使用了WAL(<code>Write-Ahead Logging</code>，先写日志再写磁盘)。<code>Redo log</code>就是一种WAL的应用</li>
<li>当数据库忽然掉电，再重新启动时，Mysql可以通过<code>Redo log</code>还原数据。也就是说，每次事务提交时，不用同步刷新磁盘数据文件，只需要同步刷新<code>Redo log</code>就足够了</li>
</ul>
<h4 id="18-为什么选择B-树作为索引结构"><a href="#18-为什么选择B-树作为索引结构" class="headerlink" title="18. 为什么选择B+树作为索引结构"></a><font color=DarkOrange>18. 为什么选择B+树作为索引结构</font></h4><ul>
<li>Hash索引：Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描</li>
<li>二叉查找树：解决了排序的基本问题，但是由于无法保证平衡，可能退化为链表</li>
<li>平衡二叉树：通过旋转解决了平衡的问题，但是旋转操作效率太低</li>
<li>红黑树：通过舍弃严格的平衡和引入红黑节点，解决了AVL旋转效率过低的问题，但是在磁盘等场景下，树仍然太高，IO次数太多</li>
<li>B+树：在B树的基础上，将非叶节点改造为不存储数据纯索引节点，进一步降低了树的高度；此外将叶节点使用指针连接成链表，范围查询更加高效。此外，B+树，主要是查询效率高，O(logN)，可以充分利用磁盘预读的特性，多叉树，深度小，叶子结点有序且存储数据</li>
</ul>
<h4 id="19-InnoDB的行锁模式"><a href="#19-InnoDB的行锁模式" class="headerlink" title="19. InnoDB的行锁模式"></a><font color=DarkOrange>19. InnoDB的行锁模式</font></h4><ul>
<li>共享锁(S)：用法lock in share mode，又称读锁，允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁<ul>
<li>若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改</li>
</ul>
</li>
<li>排他锁(X)：用法for update，又称写锁，允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁<ul>
<li>若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。在没有索引的情况下，InnoDB只能使用表锁</li>
</ul>
</li>
</ul>
<h4 id="20-哈希-hash-比树-tree-更快，索引结构为什么要设计成树型"><a href="#20-哈希-hash-比树-tree-更快，索引结构为什么要设计成树型" class="headerlink" title="20. 哈希(hash)比树(tree)更快，索引结构为什么要设计成树型"></a><font color=DarkOrange>20. 哈希(hash)比树(tree)更快，索引结构为什么要设计成树型</font></h4><p>加速查找速度的数据结构，常见的有两类：</p>
<ul>
<li>哈希，例如HashMap，查询&#x2F;插入&#x2F;修改&#x2F;删除的平均时间复杂度都是O(1)</li>
<li>树，例如平衡二叉搜索树，查询&#x2F;插入&#x2F;修改&#x2F;删除的平均时间复杂度都是O(lg(n))</li>
</ul>
<p>哈希只能满足等值查询，不满足范围和大小查询，其次哈希不可以排序。Mysql是用等值查询，用树的话，等值查询只需要顺序遍历即可。但是对于排序查询的sql需求：分组：<code>group by</code> ，排序：<code>order by</code> ，比较：<code>&lt;、&gt;</code>等，哈希型的索引，时间复杂度会退化为O(n)，而树型的“有序”特性，依然能够保持O(log(n)) 的高效率</p>
<h4 id="21-为什么索引的key长度不能太长"><a href="#21-为什么索引的key长度不能太长" class="headerlink" title="21. 为什么索引的key长度不能太长"></a><font color=DarkOrange>21. 为什么索引的key长度不能太长</font></h4><p>key 太长会导致一个页当中能够存放的 key 的数目变少，间接导致索引树的页数目变多，索引层次增加，从而影响整体查询变更的效率</p>
<h4 id="22-Mysql的数据如何恢复到任意时间点"><a href="#22-Mysql的数据如何恢复到任意时间点" class="headerlink" title="22. Mysql的数据如何恢复到任意时间点"></a><font color=DarkOrange>22. Mysql的数据如何恢复到任意时间点</font></h4><p>恢复到任意时间点以定时的做全量备份，以及备份增量的 binlog 日志为前提。恢复到任意时间点首先将全量备份恢复之后，再此基础上回放增加的 binlog 直至指定的时间点</p>
<h4 id="23-Mysql为什么加了索引可以加快查询"><a href="#23-Mysql为什么加了索引可以加快查询" class="headerlink" title="23. Mysql为什么加了索引可以加快查询"></a><font color=DarkOrange>23. Mysql为什么加了索引可以加快查询</font></h4><p>在数据十分庞大的时候，索引可以大大加快查询的速度，这是因为使用索引后可以不用扫描全表来定位某行的数据，而是先通过索引表找到该行数据对应的物理地址然后访问相应的数据</p>
<ul>
<li>优势：可以快速检索，减少I&#x2F;O次数，加快检索速度；根据索引分组和排序，可以加快分组和排序</li>
<li>劣势：索引本身也是表，因此会占用存储空间，一般来说，索引表占用的空间的数据表的1.5倍；索引表的维护和创建需要时间成本，这个成本随着数据量增大而增大；构建索引会降低数据表的修改操作（删除，添加，修改）的效率，因为在修改数据表的同时还需要修改索引表</li>
</ul>
<h4 id="24-Explain命令有什么用"><a href="#24-Explain命令有什么用" class="headerlink" title="24. Explain命令有什么用"></a><font color=DarkOrange>24. Explain命令有什么用</font></h4><p>在开发的过程中，我们有时会用<strong>慢查询</strong>去记录一些执行时间比较久的Sql语句，找出这些Sql语句并不意味着完事了，这个时候我们就需要用到explain这个命令来查看一个这些Sql语句的执行计划，查看该Sql语句有没有使用上了索引，有没有做全表扫描，这些都可以通过explain命令来查看</p>
<p>expain出来的信息有10列，分别是<code>id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">- <span class="built_in">id</span>：select选择标识符</span><br><span class="line">- select_type：表示查询的类型</span><br><span class="line">- table：输出结果集的表</span><br><span class="line">- partitions：匹配的分区</span><br><span class="line">- <span class="built_in">type</span>：表示表的连接类型</span><br><span class="line">- possible_keys：表示查询时，可能使用的索引</span><br><span class="line">- key：表示实际使用的索引</span><br><span class="line">- key_len：索引字段的长度</span><br><span class="line">- ref：列与索引的比较</span><br><span class="line">- rows：扫描出的行数(估算的行数)</span><br><span class="line">- filtered：按表条件过滤的行百分比</span><br><span class="line">- Extra：执行情况的描述和说明</span><br></pre></td></tr></table></figure>

<ul>
<li><p>id：select选择标识符</p>
<p>id是Sql执行的顺序的标识，Sql从大到小的执行</p>
<ul>
<li>id相同时，执行顺序由上至下</li>
<li>如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li>
<li>id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行</li>
</ul>
</li>
<li><p>select_type：表示查询的类型</p>
<p>查询中每个select子句的类型</p>
<ul>
<li>SIMPLE(简单SELECT，不使用UNION或子查询等)</li>
<li>PRIMARY(查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)</li>
<li>UNION(UNION中的第二个或后面的SELECT语句)</li>
<li>DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)</li>
<li>UNION RESULT(UNION的结果)</li>
<li>SUBQUERY(子查询中的第一个SELECT)</li>
<li>DEPENDENT SUBQUERY(子查询中的第一个SELECT，取决于外面的查询)</li>
<li>DERIVED(派生表的SELECT，FROM子句的子查询)</li>
<li>UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)</li>
</ul>
</li>
<li><p>table：输出结果集的表</p>
<ul>
<li>table显示这一行的数据是关于哪张表的，有时不是真实的表名字，看到的是derivedx</li>
</ul>
</li>
<li><p>partitions：匹配的分区</p>
</li>
<li><p>type：表示表的连接类型</p>
<p>type表示Mysql在表中找到所需行的方式，又称“访问类型”。常用的类型有： ALL， index， range， ref， eq_ref， const， system， NULL（从左到右，性能从差到好）</p>
<ul>
<li>ALL：Full Table Scan， Mysql将遍历全表以找到匹配的行</li>
<li>index：Full Index Scan，index与ALL区别为index类型只遍历索引树</li>
<li>range：只检索给定范围的行，使用一个索引来选择行</li>
<li>ref：表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</li>
<li>eq_ref：类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件</li>
<li>const、system：当Mysql对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，Mysql就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system</li>
<li>NULL：Mysql在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成</li>
</ul>
</li>
<li><p>possible_keys：表示查询时，可能使用的索引</p>
<ul>
<li>possible_keys指出Mysql能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用</li>
<li>该列完全独立于<code>EXPLAIN</code>输出所示的表的次序。这意味着在<code>possible_keys</code>中的某些键实际上不能按生成的表次序使用</li>
<li>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询</li>
</ul>
</li>
<li><p>key：表示实际使用的索引</p>
<ul>
<li>key列显示MySql实际决定使用的键（索引）</li>
<li>如果没有选择索引，键是NULL。要想强制Mysql使用或忽视<code>possible_keys</code>列中的索引，在查询中使用<code>FORCE INDEX、USE INDEX</code>或者<code>IGNORE INDEX</code></li>
</ul>
</li>
<li><p>key_len：索引字段的长度</p>
<ul>
<li>key_len表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）不损失精确性的情况下，长度越短越好</li>
</ul>
</li>
<li><p>ref：列与索引的比较</p>
<ul>
<li>ref表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</li>
</ul>
</li>
<li><p>rows：扫描出的行数(估算的行数)</p>
<ul>
<li>rows表示Mysql根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</li>
</ul>
</li>
<li><p>filtered：按表条件过滤的行百分比</p>
</li>
<li><p>Extra：执行情况的描述和说明</p>
<p>该列包含Mysql解决查询的详细信息，有以下几种情况：</p>
<ul>
<li>Using where：列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤</li>
<li>Using temporary：表示Mysql需要使用临时表来存储结果集，常见于排序和分组查询</li>
<li>Using filesort：Mysql中无法利用索引完成的排序操作称为“文件排序”</li>
<li>Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能</li>
<li>Impossible where：这个值强调了where语句会导致没有符合条件的行</li>
<li>Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行</li>
</ul>
</li>
</ul>
<h4 id="25-MySQL优化"><a href="#25-MySQL优化" class="headerlink" title="25. MySQL优化"></a><font color=DarkOrange>25. MySQL优化</font></h4><ol>
<li>优化查询语句：使用索引、避免全表扫描、合理使用 JOIN 语句、避免使用子查询等方式可以提高查询性能</li>
<li>优化表结构：选择合适的数据类型、避免使用过多的 NULL 值、避免使用过多的索引等方式可以提高表的读写效率</li>
<li>优化服务器配置：调整缓存大小、调整线程数、调整网络连接等可以提高 MySQL 的性能</li>
<li>使用缓存：使用 MySQL 自带的缓存机制或者使用外部缓存工具，如Redis等，可以提高读取效率</li>
<li>定期维护：定期备份、优化表、清理无用数据、修复数据等操作可以保持数据库的健康运行状态</li>
<li>使用连接池：连接池可以避免频繁地建立和关闭数据库连接，提高数据库连接的效率</li>
<li>合理分布数据：将数据分布在多个物理磁盘上，可以避免磁盘的瓶颈，提高数据访问的效率</li>
<li>避免使用外部函数：外部函数通常比 MySQL 自带的函数慢很多，可以避免使用外部函数来提高 MySQL 的性能</li>
<li>使用慢查询日志：使用慢查询日志可以帮助发现查询语句的性能瓶颈，及时进行优化</li>
<li>读写分离：通过将读操作和写操作分开处理，提高系统的性能和可靠性</li>
</ol>
<h5 id="25-1-优化查询语句"><a href="#25-1-优化查询语句" class="headerlink" title="25.1 优化查询语句"></a><font color=DarkOrange>25.1 优化查询语句</font></h5><ol>
<li><p><font color=deeppink>使用索引：确保查询涉及的列都有合适的索引</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> indexed_column <span class="operator">=</span> <span class="string">&#x27;value&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><font color=deeppink>避免使用SELECT * ：只选择需要的列，避免不必要的数据传输</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2 <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> column3 <span class="operator">=</span> <span class="string">&#x27;value&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><font color=deeppink>使用JOIN时，避免在被连接的表上使用函数或表达式</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> table1.column1, table2.column2 <span class="keyword">FROM</span> table1 <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1.column1 <span class="operator">=</span> CONCAT(<span class="string">&#x27;prefix&#x27;</span>, table2.column2);</span><br></pre></td></tr></table></figure>
</li>
<li><p><font color=deeppink>避免使用子查询：使用 JOIN 或者其他更好的方式重构查询</font></p>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1 <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> column2 <span class="operator">=</span> (<span class="keyword">SELECT</span> column3 <span class="keyword">FROM</span> table2 <span class="keyword">WHERE</span> column4 <span class="operator">=</span> <span class="string">&#x27;value&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>改为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t1.column1 <span class="keyword">FROM</span> <span class="keyword">table</span> t1 <span class="keyword">JOIN</span> table2 t2 <span class="keyword">ON</span> t1.column2 <span class="operator">=</span> t2.column3 <span class="keyword">WHERE</span> t2.column4 <span class="operator">=</span> <span class="string">&#x27;value&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><font color=deeppink>使用EXPLAIN命令分析查询计划，以便确定查询是否使用了索引</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> indexed_column <span class="operator">=</span> <span class="string">&#x27;value&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><font color=deeppink>尽量减少使用OR和IN等操作符</font></p>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1 <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> column2 <span class="operator">=</span> <span class="string">&#x27;value&#x27;</span> <span class="keyword">OR</span> column3 <span class="operator">=</span> <span class="string">&#x27;value&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>改为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1 <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> column2 <span class="operator">=</span> <span class="string">&#x27;value&#x27;</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> column1 <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> column3 <span class="operator">=</span> <span class="string">&#x27;value&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><font color=deeppink>避免使用不必要的 GROUP BY 操作符</font></p>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1 <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> column2 <span class="operator">=</span> <span class="string">&#x27;value&#x27;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> column1;</span><br></pre></td></tr></table></figure>

<p>改为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> column1 <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> column2 <span class="operator">=</span> <span class="string">&#x27;value&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><font color=deeppink>对于大表，可以使用分区表进行优化</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">table</span> <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(column1) (<span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> LESS THAN (<span class="number">100</span>), <span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> LESS THAN (<span class="number">200</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p><font color=deeppink>对于大表，可以使用水平分片或垂直分片</font></p>
<p>水平分片可以根据时间或者ID等条件对表进行分割；垂直分片可以根据列的类型和频率进行划分</p>
</li>
<li><p><font color=deeppink>避免在查询中使用通配符（如%），它会使索引无效</font></p>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1 <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> column2 <span class="keyword">LIKE</span> <span class="string">&#x27;%value%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>改为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1 <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> column2 <span class="keyword">LIKE</span> <span class="string">&#x27;value%&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><font color=deeppink>使用合适的数据类型，例如使用整型而不是字符串型</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1 <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> column2 <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><font color=deeppink>在创建表时设置合适的数据类型和字段长度</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">table</span> (column1 <span class="type">INT</span>(<span class="number">10</span>), column2 <span class="type">VARCHAR</span>(<span class="number">50</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p><font color=deeppink>对于需要重复多次查询的数据，可以考虑使用缓存</font></p>
<p>使用Redis或Memcached等缓存技术，将查询结果缓存到内存中，以提高查询速度</p>
</li>
<li><p><font color=deeppink>如果查询有重复的子查询，可以使用公共表表达式（CTE）进行优化</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> subquery <span class="keyword">AS</span> (<span class="keyword">SELECT</span> column1 <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> column2 <span class="operator">=</span> <span class="string">&#x27;value&#x27;</span>) <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> subquery <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> subquery.column1 <span class="operator">=</span> table2.column3;</span><br></pre></td></tr></table></figure>
</li>
<li><p><font color=deeppink>避免在 WHERE 子句中对列进行函数计算</font></p>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1 <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(column2) <span class="operator">=</span> <span class="number">2023</span>;</span><br></pre></td></tr></table></figure>

<p>改为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1 <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> column2 <span class="operator">&gt;=</span> <span class="string">&#x27;2023-01-01&#x27;</span> <span class="keyword">AND</span> column2 <span class="operator">&lt;</span> <span class="string">&#x27;2024-01-01&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><font color=deeppink>避免使用 UNION：UNION 会将多个查询合并在一起，会增加查询的执行时间和资源消耗，应该尽量避免使用</font></p>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1 <span class="keyword">FROM</span> table1 <span class="keyword">WHERE</span> column2 <span class="operator">=</span> <span class="string">&#x27;value1&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> column1 <span class="keyword">FROM</span> table2 <span class="keyword">WHERE</span> column2 <span class="operator">=</span> <span class="string">&#x27;value2&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>改为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> table1.column1 <span class="keyword">FROM</span> table1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1.column2 <span class="operator">=</span> <span class="string">&#x27;value1&#x27;</span> <span class="keyword">AND</span> table2.column2 <span class="operator">=</span> <span class="string">&#x27;value2&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="25-2-优化表结构"><a href="#25-2-优化表结构" class="headerlink" title="25.2 优化表结构"></a><font color=DarkOrange>25.2 优化表结构</font></h5><ol>
<li>合理设计表结构：在设计表结构时，应该尽量避免冗余字段、过多的索引、过多的数据类型等问题。应该根据具体业务需求设计合理的表结构，避免无谓的字段和表关系</li>
<li>优化数据类型：在设计表结构时，应该根据数据类型的实际需求选择合适的数据类型。应该尽量避免使用过大或过小的数据类型，可以使用 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT 等整型数据类型来优化表结构，减少数据存储空间的占用</li>
<li>创建合适的索引：索引是提高查询性能的一个重要因素。在 WHERE、ORDER BY、GROUP BY、JOIN 等操作中经常用到的列应该加索引。可以使用 EXPLAIN 命令来查看查询执行计划，分析索引是否被正确地使用</li>
<li>分区表：对于大型数据表，可以使用分区表来将表分成多个小表，根据数据的范围或者其他条件来分区，提高查询效率</li>
<li>使用合适的存储引擎：MySQL 支持多种存储引擎，不同的存储引擎有不同的优缺点。可以根据实际情况选择合适的存储引擎来优化表结构。例如，InnoDB 存储引擎支持事务和行级锁，可以提高并发性能，MyISAM 存储引擎不支持事务但具有更高的查询速度</li>
<li>分离大字段：对于包含大字段（如 BLOB 或 TEXT）的表，可以考虑将这些字段独立出来，单独存储在一个表中，避免影响整个表的查询性能</li>
</ol>
<h5 id="25-3-优化服务器配置"><a href="#25-3-优化服务器配置" class="headerlink" title="25.3 优化服务器配置"></a><font color=DarkOrange>25.3 优化服务器配置</font></h5><ol>
<li>调整缓存设置：MySQL 有多种缓存设置，包括 key_buffer_size、query_cache_size、innodb_buffer_pool_size、sort_buffer_size 等。这些缓存可以缓存查询结果、表索引、数据行等。根据实际情况，可以调整缓存大小，以便让 MySQL 更好地使用内存，提高性能</li>
<li>调整线程设置：MySQL 中的线程池可以控制连接数，防止过多连接导致服务器负载过高。可以根据实际情况调整连接数的大小，避免因为连接数过多而导致的性能问题</li>
<li>调整存储引擎设置：MySQL 支持多种存储引擎，不同的存储引擎对性能和稳定性的影响是不同的。可以根据实际情况选择合适的存储引擎，并进行相应的配置优化</li>
<li>配置查询缓存：MySQL 中的查询缓存可以缓存查询结果，避免重复查询。可以根据实际情况调整查询缓存的大小和使用情况，以便让 MySQL 更好地使用缓存，提高性能</li>
<li>优化操作系统设置：MySQL 运行在操作系统之上，操作系统的设置也会影响 MySQL 的性能和稳定性。可以根据实际情况调整操作系统的内存、磁盘、网络等设置，以提高 MySQL 的性能和稳定性</li>
</ol>
<h5 id="25-4-使用缓存"><a href="#25-4-使用缓存" class="headerlink" title="25.4 使用缓存"></a><font color=DarkOrange>25.4 使用缓存</font></h5><ol>
<li>查询缓存：查询缓存可以缓存查询语句及其结果，如果再次执行相同的查询，就可以直接从缓存中获取结果，避免了重复查询数据库。开启查询缓存需要设置 query_cache_type&#x3D;1 和 query_cache_size，具体可以在 MySQL 配置文件中设置</li>
<li>表缓存：表缓存可以缓存表的定义，避免每次查询时都需要重新解析表结构。开启表缓存需要设置 table_definition_cache 和 table_open_cache，具体可以在 MySQL 配置文件中设置</li>
</ol>
<p>除了 MySQL 自带的缓存机制，还可以使用外部缓存工具，如 Memcached 和 Redis 等，将常用的数据缓存到内存中，以提高查询性能和响应速度。具体方法如下：</p>
<ol>
<li>安装和配置 Memcached 或 Redis 服务器，并在应用程序中使用相应的客户端库连接到服务器</li>
<li>在应用程序中定义需要缓存的数据，并设置过期时间等参数，然后将数据存储到 Memcached 或 Redis 服务器中</li>
<li>在查询数据时，首先检查缓存中是否有相应的数据，如果有，则直接从缓存中获取数据，避免了查询数据库的过程</li>
</ol>
<h5 id="25-5-定期维护"><a href="#25-5-定期维护" class="headerlink" title="25.5 定期维护"></a><font color=DarkOrange>25.5 定期维护</font></h5><ol>
<li>备份数据库：备份数据库是保证数据安全的重要手段，可以通过 MySQL 自带的备份工具或者第三方备份工具进行备份。建议定期备份数据库，并将备份文件存储在安全的位置</li>
<li>优化表结构：定期检查表结构是否存在冗余字段和索引，删除不必要的字段和索引，可以提高查询性能和减少存储空间占用</li>
<li>清理无用数据：对于一些已经过期或者不再使用的数据，应该定期进行清理，以避免数据量过大导致查询性能下降</li>
<li>重建索引：定期重建索引可以保证索引的完整性和准确性，避免出现索引失效等问题</li>
<li>优化查询语句：定期检查慢查询日志，找出一些性能较差的查询语句，并进行优化，以提高查询性能</li>
<li>检查服务器资源：定期检查服务器资源的使用情况，如 CPU、内存、磁盘空间等，如果资源使用率过高，可以考虑升级服务器硬件或者调整数据库配置，以提高性能和稳定性</li>
<li>更新 MySQL 版本：定期更新 MySQL 版本可以获取最新的功能和安全修复，避免已知的安全漏洞和性能问题</li>
</ol>
<h5 id="25-6-使用连接池"><a href="#25-6-使用连接池" class="headerlink" title="25.6 使用连接池"></a><font color=DarkOrange>25.6 使用连接池</font></h5><p>使用连接池可以有效地提高数据库访问性能和减少连接的创建和销毁开销。以下是使用连接池的一般步骤：</p>
<ol>
<li>导入连接池库：Java 中有许多第三方连接池库，如 c3p0、Druid、HikariCP 等，可以选择其中一个导入到项目中</li>
<li>配置连接池参数：在配置文件中设置连接池参数，如最大连接数、最小连接数、连接超时时间、空闲连接超时时间等参数</li>
<li>获取连接：在需要访问数据库时，从连接池中获取一个可用连接</li>
<li>执行 SQL：使用获取的连接执行 SQL 操作</li>
<li>释放连接：完成 SQL 操作后，将连接释放回连接池，以便其他线程使用</li>
</ol>
<p><strong>使用连接池时需要注意以下几点：</strong></p>
<ol>
<li>最大连接数：设置最大连接数时需要根据服务器硬件和应用负载情况进行调整，过高的最大连接数可能会导致服务器负载过高，而过低的最大连接数可能会导致连接池中的连接不足</li>
<li>连接超时时间：设置连接超时时间可以防止连接被长时间占用而无法释放，导致连接池中的连接耗尽</li>
<li>空闲连接超时时间：设置空闲连接超时时间可以定期清理空闲连接，避免连接池中的连接长时间闲置而浪费资源</li>
<li>异常处理：使用连接池时需要处理连接异常，如连接超时、数据库宕机等异常情况，避免应用程序崩溃</li>
</ol>
<h5 id="25-7-合理分布数据"><a href="#25-7-合理分布数据" class="headerlink" title="25.7 合理分布数据"></a><font color=DarkOrange>25.7 合理分布数据</font></h5><p>将数据分布在多个物理磁盘上，可以避免磁盘的瓶颈，提高数据访问的效率。MySQL 可以通过以下两种方式来实现数据的分布式存储：</p>
<ol>
<li><p>分区（Partitioning）：MySQL 提供了分区功能，可以将一个大的表分割成多个小的表，每个小表存储不同的数据，以便更好地控制数据的存储和访问</p>
<p>分区可以按照一定的规则（如按照时间、按照地区、按照数据类型等）将表分割成多个分区，每个分区存储不同的数据。分区可以根据需求选择不同的分区类型，如 RANGE、LIST、HASH 等，以实现数据的分布式存储</p>
<p>使用分区可以有效地避免磁盘的瓶颈，提高数据访问的效率。同时，也可以利用多个磁盘提高数据的可靠性，避免数据丢失。</p>
</li>
<li><p>垂直分割（Vertical Partitioning）：将一个大的表拆分成多个小的表，每个小表存储不同的列，以便更好地控制数据的存储和访问</p>
<p>垂直分割可以根据列的相关性将表拆分成多个小表，每个小表只包含相关的列，从而减少了数据的冗余，提高了数据的存储效率。同时，也可以利用多个磁盘提高数据的可靠性，避免数据丢</p>
</li>
</ol>
<h5 id="25-8-避免使用外部函数"><a href="#25-8-避免使用外部函数" class="headerlink" title="25.8 避免使用外部函数"></a><font color=DarkOrange>25.8 避免使用外部函数</font></h5><p>在 MySQL 中，可以通过避免使用外部函数来提高查询的效率。外部函数是指不属于 MySQL 内部函数库的函数，如自定义函数或其他程序库中的函数。由于外部函数需要调用外部程序或动态链接库，因此会增加额外的开销和延迟，从而降低查询的效率</p>
<p>以下是一些避免使用外部函数的方法：</p>
<ol>
<li>尽量使用 MySQL 内置函数：MySQL 内置函数已经被优化过，可以获得更好的性能。因此，尽量使用 MySQL 内置函数而不是外部函数，以提高查询的效率</li>
<li>使用存储过程和触发器：存储过程和触发器可以在 MySQL 中实现一些自定义的逻辑，避免使用外部函数。可以使用存储过程和触发器来代替一些复杂的查询，以提高查询的效率</li>
<li>将一些计算操作放到应用程序中完成：一些简单的计算操作，如字符串拼接、日期格式化等，可以在应用程序中完成，而不是在 MySQL 中使用外部函数。这样可以避免增加额外的开销和延迟，提高查询的效率</li>
<li>避免使用 UDF（User Defined Functions）：UDF 是 MySQL 中的自定义函数，虽然可以实现一些定制化的功能，但是也会增加额外的开销和延迟。因此，除非必要，应避免使用 UDF</li>
</ol>
<h5 id="25-9-使用慢查询日志"><a href="#25-9-使用慢查询日志" class="headerlink" title="25.9 使用慢查询日志"></a><font color=DarkOrange>25.9 使用慢查询日志</font></h5><p>MySQL 的慢查询日志是一种记录慢查询语句的机制，可以记录执行时间超过一定阈值的查询语句，以帮助开发人员和 DBA 找出慢查询的原因，并进行优化。下面是使用慢查询日志的步骤：</p>
<ol>
<li><p>启用慢查询日志：在 MySQL 配置文件中设置 slow_query_log 参数为 ON，设置 slow_query_log_file 参数为日志文件的路径。可以通过以下命令查看当前参数的值：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow_query%&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置慢查询阈值：通过设置 long_query_time 参数来确定查询执行时间的阈值，单位为秒。默认值为 10 秒，可以根据实际情况进行调整</p>
</li>
<li><p>查看慢查询日志：通过查看慢查询日志文件，可以找到执行时间超过阈值的查询语句。可以使用以下命令查看最近一段时间的慢查询日志：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldumpslow <span class="operator">-</span>s t <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slow.log</span><br></pre></td></tr></table></figure>

<p>该命令将会按照查询执行时间排序，以 t 表示时间为单位进行汇总</p>
</li>
<li><p>分析慢查询日志：通过分析慢查询日志，可以找到慢查询的原因，并进行优化。可以根据查询语句的执行时间、执行计划等信息，找到查询中存在的瓶颈，进行优化</p>
</li>
<li><p>关闭慢查询日志：在优化完慢查询后，可以将慢查询日志关闭，以避免对系统性能产生影响</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>注意：</strong>慢查询日志可能会对系统性能产生一定的影响，因此应该在优化完毕后及时关闭。同时，慢查询日志记录的是执行时间超过阈值的查询语句，而并不是所有查询语句，因此需要合理设置阈值，以避免记录过多的查询语句</p>
<h5 id="25-10-读写分离"><a href="#25-10-读写分离" class="headerlink" title="25.10 读写分离"></a><font color=DarkOrange>25.10 读写分离</font></h5><p>MySQL 实现读写分离可以将读操作和写操作分开处理，提高系统的性能和可靠性。具体实现方式如下：</p>
<ol>
<li>建立主从复制：将一个 MySQL 数据库作为主库，其他 MySQL 数据库作为从库，在主库上进行写操作，从库复制主库的数据，并提供读操作的服务</li>
<li>配置主库和从库：在主库和从库上配置相应的参数，以建立主从复制。主库需要开启 binlog，从库需要配置主库的 IP 地址和日志文件名等信息，以便从主库复制数据</li>
<li>配置读写分离：在应用服务器中配置读写分离的规则，使得应用程序在读取数据时连接从库，写入数据时连接主库。可以使用多种方式实现读写分离，如使用中间件、使用路由规则等</li>
<li>监控和管理：在实现读写分离后，需要对主从复制进行监控和管理。可以通过慢查询日志、系统监控工具等方式对数据库进行监控，及时发现并处理故障</li>
</ol>
<p><strong>注意：</strong>读写分离可以提高系统的性能和可靠性，但同时也可能会带来数据一致性的问题。因为从库的数据是通过复制主库的数据实现的，主从复制的延迟可能会导致从库中的数据与主库中的数据不一致。因此，在实现读写分离时，需要考虑数据一致性问题，采取相应的措施，如设置合理的复制延迟时间、使用全局锁等</p>
<h4 id="26-SQL注入"><a href="#26-SQL注入" class="headerlink" title="26. SQL注入"></a><font color=DarkOrange>26. SQL注入</font></h4><p>Sql注入攻击是通过将恶意的Sql查询或添加语句插入到应用的输入参数中，再在后台Sql服务器上解析执行进行的攻击，它目前黑客对数据库进行攻击的最常用手段之一。</p>
<p><strong>避免SQL注入：</strong></p>
<ul>
<li>参数校验，校验数据的类型，长度，特殊字符，数据库关键词等</li>
<li>代码层面防止SQL注入攻击的最佳方案是SQL预编译，尽量不写SQL原生语句，使用ORM</li>
<li>严格限制数据库权限</li>
<li>避免直接响应一些SQL异常信息，SQL发生异常后，自定义异常进行响应</li>
</ul>
<h4 id="27-MySQL、MongoDB、Redis、PostgreSQL区别，适用场景"><a href="#27-MySQL、MongoDB、Redis、PostgreSQL区别，适用场景" class="headerlink" title="27. MySQL、MongoDB、Redis、PostgreSQL区别，适用场景"></a><font color=DarkOrange>27. MySQL、MongoDB、Redis、PostgreSQL区别，适用场景</font></h4><h5 id="27-1-MySQL"><a href="#27-1-MySQL" class="headerlink" title="27.1 MySQL"></a><font color=DarkOrange>27.1 MySQL</font></h5><p>MySQL是一种关系型数据库管理系统，采用SQL语言进行操作，支持多种数据类型和事务处理。MySQL的应用场景非常广泛，尤其适用于需要处理大量结构化数据的应用程序。例如，金融数据、电子商务网站数据、在线预订系统和搜索引擎数据等。MySQL支持大多数主要操作系统，包括Linux、Windows和Mac OS X</p>
<h5 id="27-2-MongoDB"><a href="#27-2-MongoDB" class="headerlink" title="27.2 MongoDB"></a><font color=DarkOrange>27.2 MongoDB</font></h5><p>MongoDB是一种面向文档的数据库管理系统，适用于需要处理非结构化和半结构化数据的应用程序，例如日志、用户信息和地理位置数据等。MongoDB的数据模型非常灵活，能够轻松处理可变模式和复杂层次结构数据。MongoDB还提供了自动分片和自动故障转移等高级功能，使其非常适合大型分布式系统</p>
<h5 id="27-3-Redis"><a href="#27-3-Redis" class="headerlink" title="27.3 Redis"></a><font color=DarkOrange>27.3 Redis</font></h5><p>Redis是一种内存数据结构存储系统，支持各种数据结构，包括字符串、哈希、列表、集合和有序集合等。Redis的数据存储在内存中，因此速度非常快，但存储容量受限于可用内存大小。Redis的高性能和低延迟使其非常适合缓存和消息队列等应用场景。例如，网站缓存、会话存储、排行榜和实时数据分析等</p>
<h5 id="27-4-PostgreSQL"><a href="#27-4-PostgreSQL" class="headerlink" title="27.4 PostgreSQL"></a><font color=DarkOrange>27.4 PostgreSQL</font></h5><p>PostgreSQL是一种功能丰富的关系型数据库管理系统，提供了广泛的数据类型、完整的事务支持、高级的并发控制和复杂的查询优化功能。PostgreSQL适用于需要处理大量复杂数据的应用程序，例如地理信息系统、社交网络和日志分析等</p>
<p><strong>总结：</strong>MySQL适用于处理大量结构化数据，MongoDB适用于处理非结构化和半结构化数据，Redis适用于缓存和消息队列等应用场景，PostgreSQL适用于处理大量复杂数据的应用程序。当然，具体应该根据具体的应用场景和数据需求来选择最合适的数据库管理系统</p>
<h4 id="28-MongoDB为什么比MySQL快"><a href="#28-MongoDB为什么比MySQL快" class="headerlink" title="28. MongoDB为什么比MySQL快"></a><font color=DarkOrange>28. MongoDB为什么比MySQL快</font></h4><p>MongoDB和MySQL是两种不同类型的数据库，MongoDB是文档型数据库，而MySQL是关系型数据库</p>
<ol>
<li>数据模型的差异：MongoDB使用文档型数据库模型，其中数据被组织为类似于JSON的文档，而MySQL使用关系型数据库模型，其中数据被组织为表。由于文档数据库模型具有更好的数据局部性，因此在某些查询和更新方面可能比关系型数据库更快</li>
<li>索引和查询优化：MongoDB具有基于内存的查询优化器和多种类型的索引，例如哈希、文本和地理空间索引。这些功能使MongoDB在某些查询方面具有更高的性能</li>
<li>高可用性和可伸缩性：MongoDB具有内置的复制和分片功能，这使得它可以更好地扩展到大型分布式系统中，并且在可用性方面更加强大</li>
<li>没有外键和事务的支持：MongoDB不支持外键和事务，这使得它可以更快地执行操作，并且在某些情况下可以避免锁定操作</li>
</ol>
<p><strong>注意：</strong>性能不仅取决于数据库的类型，还取决于许多其他因素，例如服务器硬件、网络带宽和数据库配置等。因此，在比较两个不同类型的数据库时，必须仔细考虑不同方面的性能需求，并根据具体情况做出选择</p>
<hr>
<hr>
<h3 id="MongoDB面试题"><a href="#MongoDB面试题" class="headerlink" title="MongoDB面试题"></a><font color=DarkOrange>MongoDB面试题</font></h3><h4 id="1-什么是MongoDB？它与关系型数据库有什么不同之处"><a href="#1-什么是MongoDB？它与关系型数据库有什么不同之处" class="headerlink" title="1. 什么是MongoDB？它与关系型数据库有什么不同之处"></a><font color=DarkOrange>1. 什么是MongoDB？它与关系型数据库有什么不同之处</font></h4><p>MongoDB是一个开源的、面向文档的NoSQL数据库系统，采用了分布式文件存储的方式来存储数据。它是一款非常灵活和可扩展的数据库，具有高可用性、高性能和高扩展性，被广泛应用于Web、移动、物联网等应用场景</p>
<p>与关系型数据库相比，MongoDB有以下不同之处：</p>
<ol>
<li>数据模型：MongoDB采用文档数据模型，数据以文档的形式存储，而关系型数据库则采用表格模型，数据以行和列的形式存储</li>
<li>事务处理：MongoDB在早期版本中不支持事务处理，但在最新版本中已经支持了多文档的事务处理，而关系型数据库则一直支持事务处理</li>
<li>数据查询：MongoDB采用基于文档的查询语言，支持丰富的查询方式，包括嵌套查询、范围查询、正则表达式查询等，而关系型数据库则采用SQL查询语言</li>
<li>扩展性：MongoDB可以很容易地进行横向扩展，通过添加更多的节点来扩展系统性能，而关系型数据库则通常需要通过垂直扩展来提高性能，即增加更强大的硬件</li>
<li>存储结构：MongoDB采用BSON（二进制JSON）格式来存储数据，而关系型数据库则采用基于行的存储结构</li>
</ol>
<p><strong>总结：</strong>MongoDB的文档数据模型和分布式架构使得它更适合于处理大量结构化和非结构化的数据，特别是在大数据、实时应用等方面有着明显的优势</p>
<h4 id="2-如何在MongoDB中进行聚合操作"><a href="#2-如何在MongoDB中进行聚合操作" class="headerlink" title="2. 如何在MongoDB中进行聚合操作"></a><font color=DarkOrange>2. 如何在MongoDB中进行聚合操作</font></h4><p>在MongoDB中，聚合操作是指在一个或多个集合中执行多个操作，从而返回一个结果集合的过程。聚合操作可以用于数据分析和数据挖掘等领域，通常包括以下几个步骤：</p>
<ol>
<li>创建聚合管道：使用聚合管道可以将多个操作连接起来，构成聚合操作的流程。聚合管道是一个由多个阶段组成的数组，每个阶段表示一个操作</li>
<li>筛选数据：使用 $match 操作符可以筛选符合条件的文档</li>
<li>分组数据：使用 $group 操作符可以将数据按照指定的字段进行分组，并对每个组进行聚合操作</li>
<li>过滤数据：使用 $project 操作符可以筛选需要输出的字段，并对输出结果进行格式化</li>
<li>排序数据：使用 $sort 操作符可以对输出结果进行排序</li>
<li>聚合数据：使用 $sum、$avg、$min、$max、$count 等聚合操作符可以对分组后的数据进行聚合操作</li>
<li>输出结果：使用 $out 操作符将聚合结果保存到一个集合中，或者使用 $merge 操作符将聚合结果合并到一个已存在的集合中</li>
</ol>
<p>下面是一个简单的聚合操作示例，以 orders 集合为例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.orders.aggregate([</span><br><span class="line">   &#123; $<span class="keyword">match</span>: &#123; status: &quot;complete&quot; &#125; &#125;,</span><br><span class="line">   &#123; $<span class="keyword">group</span>: &#123; _id: &quot;$customer&quot;, total: &#123; $sum: &quot;$amount&quot; &#125; &#125; &#125;,</span><br><span class="line">   &#123; $sort: &#123; total: <span class="number">-1</span> &#125; &#125;,</span><br><span class="line">   &#123; $project: &#123; _id: <span class="number">0</span>, customer: &quot;$_id&quot;, total: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">   &#123; $<span class="keyword">out</span>: &quot;customer_total&quot; &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>这个聚合操作将 orders 集合中状态为“complete”的订单按照客户进行分组，并计算每个客户的订单总金额，然后按照总金额从高到低排序，只输出客户和总金额字段，并将结果保存到 customer_total 集合中</p>
<h4 id="3-MongoDB聚合优化"><a href="#3-MongoDB聚合优化" class="headerlink" title="3. MongoDB聚合优化"></a><font color=DarkOrange>3. MongoDB聚合优化</font></h4><p>聚合是一种强大的数据处理工具，可以用于处理大量的数据并生成复杂的结果。以下是一些MongoDB聚合优化的技巧：</p>
<ol>
<li>索引优化：使用适当的索引可以极大地提高聚合查询的性能。在聚合查询中，尤其是在需要使用 $match、$sort、$group 等聚合管道操作的时候，索引可以帮助 MongoDB 避免全集合扫描，提高查询效率</li>
<li>使用尽可能少的管道：在聚合查询中，每个管道操作都会创建一个临时的中间文档，这些中间文档会在管道操作之间传递。因此，使用尽可能少的管道可以减少中间文档的数量，从而提高查询效率</li>
<li>使用合适的数据类型：在聚合查询中，使用合适的数据类型可以减少数据的转换和处理，提高查询效率。例如，将字符串类型的字段转换为数字类型，可以加快比较和排序的速度</li>
<li>使用投影操作符：在聚合查询中，可以使用投影操作符将结果集缩小到仅包含需要的字段，从而减少文档的大小，提高查询效率</li>
<li>限制结果集大小：在聚合查询中，可以使用 $limit 操作符限制结果集大小，从而减少文档的数量，提高查询效率</li>
<li>使用聚合管道的优化操作符：在 MongoDB 中，有许多聚合管道操作符可以帮助优化聚合查询，例如 $lookup、$unwind、$project、$match、$sort、$group 等</li>
<li>使用复合索引：如果需要对多个字段进行聚合查询，可以使用复合索引来提高查询效率。复合索引可以在多个字段上创建索引，从而提高查询效率</li>
</ol>
<h4 id="4-什么是索引，如何在MongoDB中创建索引"><a href="#4-什么是索引，如何在MongoDB中创建索引" class="headerlink" title="4. 什么是索引，如何在MongoDB中创建索引"></a><font color=DarkOrange>4. 什么是索引，如何在MongoDB中创建索引</font></h4><p>在MongoDB中，索引是一种用于快速查找和排序文档的数据结构，可以提高查询性能和效率。MongoDB支持多种类型的索引，包括单字段索引、复合索引、地理空间索引等</p>
<p>创建索引可以通过 MongoDB shell 或驱动程序进行，具体步骤如下：</p>
<ol>
<li>选择要创建索引的集合：使用 <code>use</code> 命令选择要创建索引的数据库，然后使用 <code>db.collection</code> 命令选择要创建索引的集合</li>
<li>选择要创建索引的字段：使用 <code>createIndex</code> 命令指定要创建索引的字段，可以是单个字段或多个字段组合</li>
<li>配置索引选项：可以通过指定不同的选项来配置索引的行为，例如设置唯一索引、设置部分索引、设置文本索引等</li>
</ol>
<p>下面是一个创建单字段索引的示例，假设有一个名为 users 的集合，包含了用户的信息：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.users.createIndex(&#123; username: <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure>

<p>这个命令将为 users 集合的 username 字段创建一个升序的索引。在创建索引后，可以使用 <code>explain</code> 命令来查看查询执行计划，以确定查询是否使用了索引</p>
<p>除了单字段索引之外，还可以创建复合索引，用于按照多个字段进行排序和查询，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.users.createIndex(&#123; username: <span class="number">1</span>, age: <span class="number">-1</span> &#125;)</span><br></pre></td></tr></table></figure>

<p>这个命令将为 users 集合的 username 和 age 字段创建一个复合索引，其中 username 字段按升序排序，age 字段按降序排序。复合索引可以提高查询性能和效率，但也需要注意索引的大小和维护成本等问题</p>
<p><strong>总结：</strong>在 MongoDB 中创建索引可以提高查询性能和效率，但也需要根据实际情况选择适当的索引类型和配置选项，并进行维护和管理，以确保索引的有效性和可靠性</p>
<h4 id="5-如何在MongoDB中实现数据复制和故障转移"><a href="#5-如何在MongoDB中实现数据复制和故障转移" class="headerlink" title="5. 如何在MongoDB中实现数据复制和故障转移"></a><font color=DarkOrange>5. 如何在MongoDB中实现数据复制和故障转移</font></h4><p>在MongoDB中，数据复制和故障转移是通过复制集（Replica Set）来实现的。复制集是一组相互关联的 MongoDB 实例，其中包括一个主节点和一个或多个副本节点。主节点用于处理所有写操作，并将写入操作同步到所有副本节点中。副本节点用于处理读操作，并在主节点失效时自动接管主节点的角色，实现故障转移</p>
<p>要创建一个复制集，可以按照以下步骤进行：</p>
<ol>
<li>启动 MongoDB 实例：在每个要添加到复制集中的 MongoDB 实例上启动 MongoDB</li>
<li>配置 MongoDB 实例：对于每个 MongoDB 实例，可以配置其 <code>replication.replSetName</code> 属性来指定复制集的名称</li>
<li>初始化复制集：将其中一个 MongoDB 实例指定为主节点，然后将其他 MongoDB 实例添加为副本节点</li>
<li>监视复制集状态：可以使用 <code>rs.status()</code> 命令来监视复制集的状态，包括主节点和副本节点的状态、同步进度和故障转移情况等</li>
</ol>
<p>下面是一个创建一个名为 <code>myReplicaSet</code> 的复制集的示例：</p>
<ol>
<li><p>启动 MongoDB 实例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mongod <span class="comment">--replSet myReplicaSet --dbpath /data/db1 --port 27017</span></span><br><span class="line">mongod <span class="comment">--replSet myReplicaSet --dbpath /data/db2 --port 27018</span></span><br><span class="line">mongod <span class="comment">--replSet myReplicaSet --dbpath /data/db3 --port 27019</span></span><br></pre></td></tr></table></figure>

<p>这个命令将在三个不同的端口上启动三个 MongoDB 实例，并将它们分别配置为 <code>myReplicaSet</code> 复制集的成员</p>
</li>
<li><p>初始化复制集：</p>
<p>在其中一个 MongoDB 实例上启动 MongoDB shell，并执行以下命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">rs.initiate(&#123;</span><br><span class="line">   _id: &quot;myReplicaSet&quot;,</span><br><span class="line">   members: [</span><br><span class="line">      &#123; _id: <span class="number">0</span>, host: &quot;localhost:27017&quot; &#125;,</span><br><span class="line">      &#123; _id: <span class="number">1</span>, host: &quot;localhost:27018&quot; &#125;,</span><br><span class="line">      &#123; _id: <span class="number">2</span>, host: &quot;localhost:27019&quot; &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这个命令将初始化一个名为 <code>myReplicaSet</code> 的复制集，并将三个 MongoDB 实例分别配置为成员</p>
</li>
<li><p>监视复制集状态：</p>
<p>执行以下命令可以查看复制集的状态：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">rs.status()</span><br></pre></td></tr></table></figure>

<p>这个命令将显示复制集中每个成员的状态、同步进度和故障转移情况等信息</p>
</li>
</ol>
<h4 id="6-MongoDB如何处理数据的一致性"><a href="#6-MongoDB如何处理数据的一致性" class="headerlink" title="6. MongoDB如何处理数据的一致性"></a><font color=DarkOrange>6. MongoDB如何处理数据的一致性</font></h4><p>在MongoDB中，数据一致性是通过使用复制集（Replica Set）来保证的。复制集是一组相互关联的MongoDB实例，其中包括一个主节点和一个或多个副本节点。主节点用于处理所有写操作，并将写入操作同步到所有副本节点中。副本节点用于处理读操作，并在主节点失效时自动接管主节点的角色，实现故障转移</p>
<p>在MongoDB中，写操作会首先在主节点上执行，主节点会将写操作的结果同步到所有副本节点中，确保数据的一致性。当读操作发生时，客户端可以选择在主节点或副本节点上进行读取。如果在副本节点上进行读取，则副本节点会从主节点同步最新的数据，并提供客户端读取</p>
<p>在MongoDB中，如果主节点失效，副本节点会自动接管主节点的角色，并继续提供写操作和读操作服务。在这个过程中，MongoDB使用Raft算法来保证数据的一致性。Raft算法是一种分布式一致性算法，它可以确保数据的一致性，并在主节点失效时进行选举，选择新的主节点来继续提供服务</p>
<p>除了复制集外，MongoDB还提供了其他一些功能来处理数据的一致性，例如事务和读写关注点分离。通过使用事务，可以将多个操作组合在一起，以确保数据的原子性、一致性、隔离性和持久性。通过读写关注点分离，可以将读操作和写操作分别路由到不同的MongoDB实例上，以提高读写性能和减少写操作的锁竞争</p>
<p><strong>总结：</strong>在MongoDB中，通过复制集、事务和读写关注点分离等功能，可以确保数据的一致性和可靠性，提高数据库的可用性和可靠性</p>
<h4 id="7-MongoDB支持哪些数据模型？如何选择适当的数据模型"><a href="#7-MongoDB支持哪些数据模型？如何选择适当的数据模型" class="headerlink" title="7. MongoDB支持哪些数据模型？如何选择适当的数据模型"></a><font color=DarkOrange>7. MongoDB支持哪些数据模型？如何选择适当的数据模型</font></h4><p>MongoDB支持多种数据模型，包括关系型数据模型、文档数据模型和图形数据模型</p>
<p>关系型数据模型是传统的数据库模型，通过表格和行来表示数据，并使用SQL进行查询和操作。MongoDB支持使用SQL进行查询，但并不是主要的查询语言</p>
<p>文档数据模型是MongoDB的主要数据模型，它使用JSON格式表示数据，每个文档可以包含任意数量的字段和嵌套文档。文档数据模型非常适合表示复杂的、半结构化的数据，例如日志、产品目录和用户配置</p>
<p>图形数据模型是用于表示复杂关系的数据模型，它使用节点和边来表示数据，并提供了一些特殊的查询和操作语言。MongoDB支持图形数据模型，但这并不是它的主要特点</p>
<p>当选择数据模型时，需要考虑以下因素：</p>
<ol>
<li>数据的结构：如果数据有一个固定的结构，可以考虑使用关系型数据库。如果数据具有动态或半结构化的特性，可以考虑使用文档数据模型</li>
<li>数据的关系：如果数据包含多个表格或实体之间的关系，可以考虑使用关系型数据库。如果数据具有复杂的关系，例如一对多或多对多关系，可以考虑使用文档数据模型或图形数据模型</li>
<li>数据的可扩展性：如果需要处理大量数据或需要横向扩展，可以考虑使用文档数据模型或图形数据模型，因为它们支持自动分片和横向扩展</li>
<li>数据的查询和分析：如果需要高效地查询和分析数据，可以考虑使用文档数据模型或图形数据模型。因为它们支持索引和聚合操作</li>
</ol>
<p><strong>总结：</strong>MongoDB的文档数据模型非常适合表示动态或半结构化的数据，并具有很好的可扩展性和灵活性。在选择数据模型时，需要根据实际需求考虑不同的因素，并选择最适合的数据模型</p>
<h4 id="8-如何在MongoDB中进行备份和还原操作"><a href="#8-如何在MongoDB中进行备份和还原操作" class="headerlink" title="8. 如何在MongoDB中进行备份和还原操作"></a><font color=DarkOrange>8. 如何在MongoDB中进行备份和还原操作</font></h4><p>MongoDB中备份和还原数据可以通过mongodump和mongorestore工具来实现</p>
<p>备份数据：</p>
<ol>
<li>使用mongodump工具来备份数据。在终端输入以下命令：mongodump –host <hostname> –port <port> –db <database> –out <directory_path>。其中，hostname为MongoDB主机名或IP地址，port为MongoDB端口号，database为需要备份的数据库名称，directory_path为备份文件的目录</li>
<li>执行上述命令后，mongodump会将指定的数据库备份到指定的目录中。备份文件的格式为BSON格式，包含了指定数据库的所有数据和索引</li>
</ol>
<p>还原数据：</p>
<ol>
<li>使用mongorestore工具来还原数据。在终端输入以下命令：mongorestore –host <hostname> –port <port> –db <database> <directory_path>。其中，hostname为MongoDB主机名或IP地址，port为MongoDB端口号，database为需要还原的数据库名称，directory_path为备份文件的目录</li>
<li>执行上述命令后，mongorestore会将指定目录中的备份文件还原到指定的数据库中</li>
</ol>
<p><strong>注意：</strong>在进行备份和还原操作时，需要使用相同版本的MongoDB工具。此外，备份和还原操作可能会影响数据库的性能，因此需要在合适的时间进行操作，并确保备份文件的存储和管理安全可靠</p>
<h4 id="9-如何在MongoDB中实现数据分片"><a href="#9-如何在MongoDB中实现数据分片" class="headerlink" title="9. 如何在MongoDB中实现数据分片"></a><font color=DarkOrange>9. 如何在MongoDB中实现数据分片</font></h4><p>MongoDB使用数据分片来横向扩展数据存储能力，通过将数据分散到多个节点上，从而提高数据库的性能和可扩展性。以下是在MongoDB中实现数据分片的一般步骤：</p>
<ol>
<li>部署分片集群：首先需要部署一个分片集群，该集群由多个节点组成。一个分片集群通常包含3个配置节点、3个查询路由节点和多个数据分片节点</li>
<li>创建分片键：在MongoDB中，分片键用于确定数据如何被分片和分布到各个节点上。通常可以选择一个唯一或频繁查询的字段作为分片键。例如，在一个电子商务网站中，可以选择商品ID作为分片键，从而将同一商品的数据存储在同一个节点上</li>
<li>启用分片功能：在分片集群中启用分片功能，执行sh.enableSharding(dbname)命令，其中dbname是需要分片的数据库名称。这将启用分片功能，并为该数据库创建一个空的chunks集合</li>
<li>配置分片：执行sh.shardCollection命令来配置分片，将需要分片的集合和分片键传递给该命令。例如，执行sh.shardCollection(“testDB.testCollection”, { “shardingKey” : 1 })，将testDB数据库中的testCollection集合分片，并使用shardingKey字段作为分片键</li>
<li>向分片集群中添加节点：可以在分片集群中添加更多的节点，通过在节点中添加新的数据分片来扩展集群的存储能力。可以通过执行sh.addShard命令来添加新的节点</li>
<li>监控集群状态：可以使用sh.status命令来监视分片集群的状态，包括各个节点的负载情况和分片数据的分布情况</li>
</ol>
<p><strong>注意：</strong>数据分片是一项复杂的操作，需要考虑多个因素，包括数据量、查询负载、数据分布情况等。在实现数据分片之前，需要仔细评估和规划，确保分片集群能够满足业务需求，并具有良好的可扩展性和可靠性</p>
<h4 id="10-如何在MongoDB中进行事务处理"><a href="#10-如何在MongoDB中进行事务处理" class="headerlink" title="10. 如何在MongoDB中进行事务处理"></a><font color=DarkOrange>10. 如何在MongoDB中进行事务处理</font></h4><p>MongoDB从版本4.0开始支持多文档事务处理，提供了在多个文档之间执行原子操作的能力，从而确保数据的一致性和完整性。以下是在MongoDB中进行事务处理的一般步骤：</p>
<ol>
<li>启用事务功能：在MongoDB中启用事务功能，可以通过在会话级别打开事务，或者在集合级别打开事务。对于会话级别的事务，可以使用session.startTransaction()方法来启用事务。对于集合级别的事务，可以在执行任何涉及多个集合的操作之前，使用db.getCollection(collectionName).startSession()方法创建一个会话对象，并在该对象上调用session.startTransaction()方法来启用事务</li>
<li>执行事务操作：一旦启用了事务，可以在一个事务中执行多个操作，包括插入、更新、删除等操作。在MongoDB中，可以将多个操作放在一个事务中执行，如果其中一个操作失败，则整个事务将被回滚，所有操作都将被撤销</li>
<li>提交或回滚事务：一旦执行完所有操作，可以通过调用session.commitTransaction()方法来提交事务，或者调用session.abortTransaction()方法来回滚事务。提交事务将永久保存所有操作的结果，而回滚事务将撤销所有操作的结果</li>
</ol>
<p><strong>注意：</strong>MongoDB的事务处理功能在一些情况下可能会有性能上的损失，因此应该仔细评估业务需求，选择是否使用事务处理功能。另外，在使用事务处理功能时，还需要注意遵守MongoDB的事务处理规则和限制，例如，事务不能跨越分片，事务不能涉及多个数据库等</p>
<h4 id="11-MongoDB的数据存储格式是什么？它与JSON有什么不同之处"><a href="#11-MongoDB的数据存储格式是什么？它与JSON有什么不同之处" class="headerlink" title="11. MongoDB的数据存储格式是什么？它与JSON有什么不同之处"></a><font color=DarkOrange>11. MongoDB的数据存储格式是什么？它与JSON有什么不同之处</font></h4><p>MongoDB的数据存储格式是BSON（Binary JSON），它是一种二进制的JSON格式，由C++编写的BSON库将JSON对象序列化为二进制形式，从而提供了更高的效率和更好的可扩展性。BSON格式支持多种数据类型，包括字符串、数字、日期、布尔、数组、嵌套文档等，因此可以在MongoDB中存储非常灵活的数据结构</p>
<p>与JSON相比，BSON格式有以下不同之处：</p>
<ol>
<li>BSON是二进制格式，而JSON是文本格式。由于BSON是二进制格式，因此比JSON更加紧凑和高效，可以更快地进行序列化和反序列化操作。另外，BSON支持存储二进制数据、日期和时间等数据类型，而JSON不支持</li>
<li>BSON支持嵌套文档和数组。BSON格式支持嵌套文档和数组，因此可以更灵活地存储数据，而JSON只支持数组和键值对</li>
<li>BSON支持数据类型的扩展。BSON支持数据类型的扩展，因此可以在不破坏现有应用程序的情况下添加新的数据类型。而JSON是一种固定的数据格式，不支持扩展</li>
</ol>
<p><strong>总结：</strong>BSON是MongoDB专门为存储和检索数据而设计的二进制格式，相对于JSON来说更加高效、灵活和可扩展，因此可以更好地满足MongoDB的数据存储和查询需求</p>
<hr>
<hr>
<h3 id="PostgreSQL面试题"><a href="#PostgreSQL面试题" class="headerlink" title="PostgreSQL面试题"></a><font color=DarkOrange>PostgreSQL面试题</font></h3><h4 id="1-什么是PostgreSQL？请介绍它的特点和优势"><a href="#1-什么是PostgreSQL？请介绍它的特点和优势" class="headerlink" title="1. 什么是PostgreSQL？请介绍它的特点和优势"></a><font color=DarkOrange>1. 什么是PostgreSQL？请介绍它的特点和优势</font></h4><p>PostgreSQL是一种开源的关系型数据库管理系统（RDBMS），它支持大部分SQL标准，同时还提供了许多先进的功能和扩展性。以下是PostgreSQL的一些特点和优势：</p>
<ol>
<li>可扩展性：PostgreSQL可以在各种规模的应用程序中使用，从小型单用户应用程序到大型企业级数据库应用程序，支持高并发、高吞吐量和大数据量</li>
<li>可靠性：PostgreSQL具有高度的稳定性和可靠性，支持事务、崩溃恢复和备份等功能，以确保数据的完整性和持久性</li>
<li>安全性：PostgreSQL提供了高级的安全性和访问控制机制，包括强制访问控制和行级别安全性等功能，以保护敏感数据</li>
<li>可定制性：PostgreSQL具有可定制性高的特点，可以根据应用程序的需要添加或删除功能</li>
<li>支持多种数据类型：除了标准的数据类型之外，PostgreSQL还支持许多特定的数据类型，如几何数据、网络地址、JSON等</li>
<li>免费开源：PostgreSQL是一个免费的开源项目，任何人都可以自由使用、修改和分发它的代码</li>
<li>社区支持：PostgreSQL有一个庞大的社区支持，用户可以从社区中获取帮助、学习和分享知识</li>
</ol>
<h4 id="2-请解释一下PostgreSQL中的MVCC是什么"><a href="#2-请解释一下PostgreSQL中的MVCC是什么" class="headerlink" title="2. 请解释一下PostgreSQL中的MVCC是什么"></a><font color=DarkOrange>2. 请解释一下PostgreSQL中的MVCC是什么</font></h4><p>MVCC是PostgreSQL中的一种多版本并发控制技术，它可以实现高并发的事务处理，同时保证数据的一致性和完整性</p>
<p>在MVCC中，每个数据库事务在执行之前会获得一个唯一的事务ID，这个ID被称为XID。当一个事务更新数据时，PostgreSQL会将数据的旧版本存储在一个叫做Undo Buffer的地方，并在新版本的数据中记录对旧版本数据的修改。因此，在一个事务中，数据有多个版本存在，并且这些版本可以被同时访问和修改，而不会影响其他事务的操作</p>
<p>MVCC的核心思想是使用版本控制来管理事务的并发性，每个事务都看到自己的视图，因此可以避免锁的使用，减少锁等待的时间，提高并发性能。同时，由于每个事务看到的是一个一致性的数据视图，因此不会出现脏读、不可重复读等数据一致性问题</p>
<h4 id="3-什么是索引？PostgreSQL中有哪些类型的索引"><a href="#3-什么是索引？PostgreSQL中有哪些类型的索引" class="headerlink" title="3. 什么是索引？PostgreSQL中有哪些类型的索引"></a><font color=DarkOrange>3. 什么是索引？PostgreSQL中有哪些类型的索引</font></h4><p>索引是数据库中的一种数据结构，用于提高数据的检索速度。索引通常是在一列或多列上创建的，并按照一定的规则进行排序和存储，以支持快速的数据查找和访问。索引可以大大提高数据库查询的性能和效率</p>
<p>PostgreSQL中支持多种类型的索引，包括以下几种：</p>
<ol>
<li>B-tree索引：B-tree是一种常用的索引结构，可以用于支持等值、范围和模糊查询。在PostgreSQL中，B-tree索引是默认的索引类型</li>
<li>哈希索引：哈希索引是一种基于哈希表的索引结构，可以用于支持等值查询。在PostgreSQL中，哈希索引通常用于处理大型数据集的等值查询，因为哈希索引可以在O(1)的时间复杂度内进行查找</li>
<li>GiST索引：GiST（通用搜索树）索引是一种通用的索引结构，可以用于支持各种数据类型的查询，包括几何数据和全文搜索等</li>
<li>SP-GiST索引：SP-GiST（空间分割通用搜索树）索引是一种空间索引结构，用于支持空间数据类型的查询</li>
<li>GIN索引：GIN（通用倒排索引）索引是一种倒排索引结构，用于支持多值数据类型的查询，例如数组和JSON等</li>
<li>BRIN索引：BRIN（块范围索引）索引是一种块范围索引结构，用于支持大型数据集的范围查询。BRIN索引可以有效地减少磁盘空间的使用，并提高范围查询的性能</li>
</ol>
<p>除了以上几种索引类型，PostgreSQL还支持自定义索引类型，可以根据具体的应用场景进行自定义的索引设计和实现</p>
<h4 id="4-如何在PostgreSQL中备份和还原数据库"><a href="#4-如何在PostgreSQL中备份和还原数据库" class="headerlink" title="4. 如何在PostgreSQL中备份和还原数据库"></a><font color=DarkOrange>4. 如何在PostgreSQL中备份和还原数据库</font></h4><ol>
<li><p>使用pg_dump和pg_restore命令进行备份和还原：</p>
<ul>
<li><p>备份数据库：</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line">pg_dump -U username -h hostname -p port databasename &gt; backup.<span class="keyword">sql</span></span><br></pre></td></tr></table></figure>

<p>其中，username是数据库用户名，hostname是数据库服务器地址，port是数据库服务器端口号，databasename是需要备份的数据库名称，backup.sql是备份文件名</p>
</li>
<li><p>还原数据库：</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line">psql -U username -h hostname -p port -d databasename &lt; backup.<span class="keyword">sql</span></span><br></pre></td></tr></table></figure>

<p>其中，username是数据库用户名，hostname是数据库服务器地址，port是数据库服务器端口号，databasename是需要还原的数据库名称，backup.sql是备份文件名</p>
</li>
</ul>
</li>
<li><p>使用pg_basebackup和pg_receivexlog命令进行备份和还原：</p>
<ul>
<li><p>备份数据库：</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line">pg_basebackup -U username -h hostname -p port -D backup_directory -Ft -z -Xs -P</span><br></pre></td></tr></table></figure>

<p>其中，username是数据库用户名，hostname是数据库服务器地址，port是数据库服务器端口号，backup_directory是备份文件目录，-Ft选项表示使用tar格式进行备份，-z选项表示使用gzip进行压缩，-Xs选项表示备份时只备份WAL日志文件的切片，-P选项表示在屏幕上显示进度</p>
</li>
<li><p>还原数据库：</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line">pg_receivexlog -U username -h hostname -p port -D backup_directory -S slotname</span><br></pre></td></tr></table></figure>

<p>其中，username是数据库用户名，hostname是数据库服务器地址，port是数据库服务器端口号，backup_directory是备份文件目录，slotname是复制槽的名称</p>
</li>
</ul>
</li>
</ol>
<h4 id="5-PostgreSQL中的B-tree索引是如何工作的"><a href="#5-PostgreSQL中的B-tree索引是如何工作的" class="headerlink" title="5. PostgreSQL中的B-tree索引是如何工作的"></a><font color=DarkOrange>5. PostgreSQL中的B-tree索引是如何工作的</font></h4><p>PostgreSQL中，<strong>B-tree索引是默认的索引类型</strong>，在数据量较大时可以提供高效的查询性能。B-tree是一种自平衡的树形数据结构，可以用于快速的等值、范围和模糊查询。B-tree索引使用二叉树的结构，每个节点最多可以包含m个子节点，其中m称为B-tree的阶数。在PostgreSQL中，B-tree的默认阶数是4，可以通过修改参数进行调整</p>
<p>当创建一个B-tree索引时，PostgreSQL会在磁盘上创建一个B-tree数据结构，并将索引中的每个值存储在叶子节点上。每个非叶子节点都包含一组索引键，用于将索引值划分为更小的子集。在查询时，PostgreSQL会从根节点开始沿着B-tree逐级查找，直到找到匹配的叶子节点。由于B-tree的节点通常可以存储多个值，因此在一个节点上查找匹配值的时间复杂度是O(logm)，其中m是B-tree的阶数。因此，B-tree索引可以实现快速的数据检索和访问</p>
<p>B-tree索引还支持范围查询和模糊查询。对于范围查询，B-tree索引使用区间搜索技术，在索引键值之间的范围内搜索匹配的数据。对于模糊查询，B-tree索引使用通配符搜索技术，在索引键值中查找匹配的数据</p>
<h4 id="6-PostgreSQL中的锁是什么？有哪些类型的锁"><a href="#6-PostgreSQL中的锁是什么？有哪些类型的锁" class="headerlink" title="6. PostgreSQL中的锁是什么？有哪些类型的锁"></a><font color=DarkOrange>6. PostgreSQL中的锁是什么？有哪些类型的锁</font></h4><p>在PostgreSQL中，锁是一种用于管理并发访问的机制，可以确保多个会话之间的数据一致性和可靠性。PostgreSQL支持多种类型的锁，包括共享锁和排他锁等。下面是各种锁的类型及其用途：</p>
<ol>
<li>共享锁（Shared Lock）：也称为读锁。当一个会话获取共享锁时，其他会话仍然可以读取数据，但不能修改数据。共享锁适用于在并发访问情况下防止数据读取冲突</li>
<li>排他锁（Exclusive Lock）：也称为写锁。当一个会话获取排他锁时，其他会话既不能读取数据，也不能修改数据。排他锁适用于在并发访问情况下防止数据写入冲突</li>
<li>行级锁（Row-level Lock）：也称为记录锁或行锁。行级锁用于锁定特定的数据行，只有持有该行锁的会话才能对该行进行修改。行级锁适用于高并发情况下防止多个会话同时修改同一行数据</li>
<li>表级锁（Table-level Lock）：也称为全局锁。表级锁用于锁定整个数据表，只有持有该表级锁的会话才能对该表进行修改。表级锁适用于执行DDL语句或在某些特定场景下防止其他会话对表进行修改</li>
<li>页级锁（Page-level Lock）：也称为块锁或区锁。页级锁用于锁定特定的数据页，只有持有该页锁的会话才能对该页进行修改。页级锁适用于在高并发访问情况下防止多个会话同时修改同一数据页</li>
<li>记录锁（Tuple-level Lock）：也称为元组锁。记录锁用于锁定特定的数据记录，只有持有该记录锁的会话才能对该记录进行修改。记录锁是行级锁的一种实现方式</li>
<li>兼容锁（Compatible Lock）：也称为兼容性锁。当一个会话获取兼容锁时，其他会话可以读取该数据，但不能修改该数据。兼容锁适用于在读写混合访问情况下，防止读操作和写操作之间的冲突</li>
</ol>
<p>在PostgreSQL中，锁是由系统自动管理的，可以通过SQL命令和函数进行访问和管理。掌握锁的使用方法和技巧，可以帮助开发人员更好地处理并发访问和数据一致性问题</p>
<h4 id="7-如何在PostgreSQL中处理JSON数据类型"><a href="#7-如何在PostgreSQL中处理JSON数据类型" class="headerlink" title="7. 如何在PostgreSQL中处理JSON数据类型"></a><font color=DarkOrange>7. 如何在PostgreSQL中处理JSON数据类型</font></h4><ol>
<li><p>创建JSON类型列</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable (</span><br><span class="line">    id <span class="type">integer</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    data <span class="type">json</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入JSON数据</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mytable (id, data) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;&#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30&#125;&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询JSON数据</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> data-&gt;&gt;<span class="string">&#x27;name&#x27;</span> <span class="keyword">as</span> <span class="type">name</span>, data-&gt;&gt;<span class="string">&#x27;age&#x27;</span> <span class="keyword">as</span> age <span class="keyword">FROM</span> mytable <span class="keyword">WHERE</span> id = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>该语法使用<code>-&gt;&gt;</code>运算符从JSON列中提取指定的JSON属性</p>
</li>
<li><p>更新JSON数据</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> mytable <span class="keyword">SET data</span> = <span class="string">&#x27;&#123;&quot;name&quot;: &quot;Jack&quot;, &quot;age&quot;: 35&#125;&#x27;</span> <span class="keyword">WHERE</span> id = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除JSON数据</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> mytable <span class="keyword">WHERE</span> id = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>JSON函数</p>
<p>PostgreSQL提供了一些内置的JSON函数，可以帮助处理JSON数据。一些常用的JSON函数包括：</p>
<ul>
<li><code>json_object(text, ...)</code>: 创建一个JSON对象</li>
<li><code>json_array(...)</code>：创建一个JSON数组</li>
<li><code>json_extract_path(json, VARIADIC text[])</code>：从JSON数据中提取指定路径的JSON值</li>
<li><code>jsonb_exists(jsonb, VARIADIC text[])</code>：判断JSON数据是否包含指定路径的JSON值</li>
</ul>
</li>
<li><p>JSON索引</p>
<p>PostgreSQL还支持使用GIN索引来加速JSON数据的查询。可以使用以下语法在JSON列上创建GIN索引：</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_data <span class="keyword">ON</span> mytable <span class="keyword">USING</span> gin(data);</span><br></pre></td></tr></table></figure>

<p>该语法创建一个GIN索引，可以在JSON数据中快速查询指定的JSON属性</p>
</li>
</ol>
<h4 id="8-请介绍一下PostgreSQL中的继承"><a href="#8-请介绍一下PostgreSQL中的继承" class="headerlink" title="8. 请介绍一下PostgreSQL中的继承"></a><font color=DarkOrange>8. 请介绍一下PostgreSQL中的继承</font></h4><p>在PostgreSQL中，继承是一种用于实现表继承关系的机制。使用继承，可以创建一个父表并定义一组子表，子表会继承父表的所有列和约束。这种设计模式使得数据库表的设计更加灵活，可以避免数据冗余和代码重复</p>
<p>在继承关系中，父表被称为父级表或基表，子表被称为子级表或派生表。子表继承父表的所有属性，包括列、约束、索引和触发器。当在子表中插入一条记录时，这条记录会同时插入到父表中。同样，当在父表中更新一条记录时，所有子表中与该记录相关的数据也会相应更新</p>
<p>在继承关系中，还可以定义一些特殊的约束和属性，包括：</p>
<ol>
<li><p>NOT NULL约束：可以在父表中定义NOT NULL约束，这个约束会自动继承到所有子表中</p>
</li>
<li><p>CHECK约束：可以在父表中定义CHECK约束，这个约束同样会自动继承到所有子表中</p>
</li>
<li><p>父子表之间的关系：父子表之间的关系可以通过在子表中定义FOREIGN KEY约束实现。子表中的FOREIGN KEY约束必须引用父表的主键约束</p>
</li>
<li><p>查询子表数据：可以使用UNION ALL操作符将父表和所有子表的数据组合在一起，也可以单独查询父表或子表中的数据</p>
</li>
</ol>
<p><strong>注意：</strong>在使用继承关系时，父表和子表必须使用相同的表结构和数据类型，否则可能会导致查询错误或数据不一致。此外，继承关系还可能对查询性能产生影响，需要根据具体情况进行优化</p>
<h4 id="9-如何在PostgreSQL中进行数据复制和高可用性配置"><a href="#9-如何在PostgreSQL中进行数据复制和高可用性配置" class="headerlink" title="9. 如何在PostgreSQL中进行数据复制和高可用性配置"></a><font color=DarkOrange>9. 如何在PostgreSQL中进行数据复制和高可用性配置</font></h4><p>PostgreSQL提供了多种机制来进行数据复制和高可用性配置，下面介绍两种常用的方法：</p>
<ol>
<li><p>数据复制</p>
<p>PostgreSQL支持两种方式的数据复制：流复制和逻辑复制。流复制是将主数据库上的事务日志传输到备份服务器上，然后在备份服务器上重放这些日志以达到同步主从数据库的目的。逻辑复制则是将指定表的更改信息通过逻辑复制插件传输到备份服务器，然后在备份服务器上重新执行这些更改以达到同步主从数据库的目的。使用复制，可以实现数据的备份、读写分离、负载均衡等功能。</p>
</li>
<li><p>高可用性配置</p>
<p>PostgreSQL支持多种高可用性配置方法，包括：</p>
<ul>
<li>复制：通过流复制或逻辑复制实现主备切换，从而实现高可用性</li>
<li>Slony-I：基于触发器的复制机制，可以实现多节点的复制</li>
<li>Pgpool-II：支持连接池、查询路由、负载均衡和自动故障转移等功能，可以提高应用程序的可用性和性能</li>
<li>Patroni：一个高可用性集群管理工具，使用Zookeeper、etcd或Consul进行协调，支持主从切换、自动故障转移和复制监控等功能</li>
<li>Postgres-XL：一个分布式数据库系统，提供水平扩展和高可用性配置功能，支持全局表、多主复制和分片等功能</li>
</ul>
</li>
</ol>
<h4 id="10-如何在PostgreSQL中进行优化查询性能"><a href="#10-如何在PostgreSQL中进行优化查询性能" class="headerlink" title="10. 如何在PostgreSQL中进行优化查询性能"></a><font color=DarkOrange>10. 如何在PostgreSQL中进行优化查询性能</font></h4><ol>
<li>创建索引：创建合适的索引可以大幅提高查询性能。可以根据查询语句的条件字段创建相应的索引，例如使用B-tree索引来加速排序和范围查询，使用哈希索引来加速等值查询，使用全文索引来进行文本搜索等</li>
<li>避免全表扫描：尽量避免对整个表进行扫描，可以使用索引或者分区表来减少扫描范围</li>
<li>使用EXPLAIN分析查询计划：可以使用EXPLAIN命令来分析查询语句的执行计划，找出可能的瓶颈并进行优化</li>
<li>优化数据模型：合理设计数据模型可以减少查询时的连接操作和聚合计算，提高查询效率</li>
<li>合理设置参数：根据具体的硬件配置和应用场景，合理设置PostgreSQL的参数可以提高查询性能。例如shared_buffers、work_mem、maintenance_work_mem等参数</li>
<li>使用表分区：将大表按照一定的规则分成多个小表，可以提高查询效率，减少锁的竞争</li>
<li>使用连接池：连接池可以减少连接的创建和销毁，降低数据库的负载，提高应用程序的响应速度</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生05-Kubernetes控制平面组件：etcd</title>
    <url>/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F05-Kubernetes%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%BB%84%E4%BB%B6%EF%BC%9Aetcd/</url>
    <content><![CDATA[<p>待完成。。。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>云原生</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生06-Kubernetes控制平面组件：API Server</title>
    <url>/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F06-Kubernetes%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%BB%84%E4%BB%B6%EF%BC%9AAPI-Server/</url>
    <content><![CDATA[<p>待完成。。。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>云原生</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生07-Kubernetes控制平面组件：调度器和控制器</title>
    <url>/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F07-Kubernetes%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%BB%84%E4%BB%B6%EF%BC%9A%E8%B0%83%E5%BA%A6%E5%99%A8%E5%92%8C%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<p>待完成。。。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>云原生</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生08-Kubernetes控制平面组件：生命周期管理和服务发现</title>
    <url>/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F08-Kubernetes%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%BB%84%E4%BB%B6%EF%BC%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</url>
    <content><![CDATA[<p>待完成。。。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>云原生</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生09-生产化集群的管理</title>
    <url>/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F09-%E7%94%9F%E4%BA%A7%E5%8C%96%E9%9B%86%E7%BE%A4%E7%9A%84%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>待完成。。。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>云原生</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生10-Kubernetes的生产化运维</title>
    <url>/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F10-Kubernetes%E7%9A%84%E7%94%9F%E4%BA%A7%E5%8C%96%E8%BF%90%E7%BB%B4/</url>
    <content><![CDATA[<p>待完成。。。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>云原生</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生11-将应用迁移至Kubernetes平台</title>
    <url>/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F11-%E5%B0%86%E5%BA%94%E7%94%A8%E8%BF%81%E7%A7%BB%E8%87%B3Kubernetes%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<p>待完成。。。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>云原生</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生12-基于Istio的高级流量管理</title>
    <url>/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F12-%E5%9F%BA%E4%BA%8EIstio%E7%9A%84%E9%AB%98%E7%BA%A7%E6%B5%81%E9%87%8F%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>待完成。。。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>云原生</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生13-Kubernetes集群联邦和Istio多集群管理</title>
    <url>/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F13-Kubernetes%E9%9B%86%E7%BE%A4%E8%81%94%E9%82%A6%E5%92%8CIstio%E5%A4%9A%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>待完成。。。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>云原生</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生14-基于Kubernetes和Istio的安全保证</title>
    <url>/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F14-%E5%9F%BA%E4%BA%8EKubernetes%E5%92%8CIstio%E7%9A%84%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81/</url>
    <content><![CDATA[<p>待完成。。。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>云原生</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生15-微服务项目的开发和部署案例</title>
    <url>/2022/11/08/%E4%BA%91%E5%8E%9F%E7%94%9F15-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%BC%80%E5%8F%91%E5%92%8C%E9%83%A8%E7%BD%B2%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<p>待完成。。。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>云原生</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生训练营课程大纲</title>
    <url>/2022/11/06/%E4%BA%91%E5%8E%9F%E7%94%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E8%AF%BE%E7%A8%8B%E5%A4%A7%E7%BA%B2/</url>
    <content><![CDATA[<h4 id="第一部分：Go-语言基础"><a href="#第一部分：Go-语言基础" class="headerlink" title="第一部分：Go 语言基础"></a><font color=DarkOrange>第一部分：Go 语言基础</font></h4><h5 id="模块一：Go-语言特性"><a href="#模块一：Go-语言特性" class="headerlink" title="模块一：Go 语言特性"></a><font color=DarkOrange>模块一：Go 语言特性</font></h5><p><strong>教学目标：</strong></p>
<ol>
<li><p>理解 Go 语言基本语法</p>
</li>
<li><p>理解 Go 语言常用数据类型</p>
</li>
<li><p>理解 Go 语言常用小技巧</p>
</li>
<li><p>深入理解 Go 语言的多线程编程</p>
</li>
</ol>
<p><strong>针对的用户痛点：</strong></p>
<ol>
<li><p>云原生从业者因为未熟练掌握 Go 语言，在阅读 Docker、containerd、Kubernetes 代码时有困难</p>
</li>
<li><p>未熟练掌握 Go 语言，在需要编写云原生组件时无法高效率高质量交付</p>
</li>
</ol>
<p><strong>通过学习掌握的核心能力：</strong></p>
<ol>
<li><p>阅读 Go 语言代码的能力</p>
</li>
<li><p>用 Go 语言编写应用程序的基本能力</p>
</li>
<li><p>用 Go 语言编写一个 Kubernetes 中最常见的生产者消费者小程序</p>
</li>
</ol>
<p><strong>详细内容：</strong></p>
<ol>
<li><p>Go 语言编译环境设置</p>
</li>
<li><p>Go 语言常用数据结构</p>
</li>
<li><p>Go 语言函数调用，深入理解 Channel 并基于 Channel 编写一个生产者消费者程序</p>
</li>
</ol>
<hr>
<h5 id="模块二：使用-Go-语言编写一个小-Demo"><a href="#模块二：使用-Go-语言编写一个小-Demo" class="headerlink" title="模块二：使用 Go 语言编写一个小 Demo "></a><font color=DarkOrange>模块二：使用 Go 语言编写一个小 Demo </font></h5><p><strong>教学目标：</strong></p>
<ol>
<li><p>理解 Go 语言的调度原理</p>
</li>
<li><p>理解 Go 语言的内存管理</p>
</li>
<li><p>Go 语言依赖管理</p>
</li>
<li><p>Go 语言调试和问题分析 pprof</p>
</li>
</ol>
<p><strong>针对的用户痛点：</strong></p>
<ol>
<li><p>对 Goroutine 无深入理解，无法利用 Go 语言强大的并发能力</p>
</li>
<li><p>面对众多的 Go 语言项目包依赖管理工具无所适从，不知道该用哪一个工具</p>
</li>
<li><p>针对 Go 语言编写的程序，不知道如何调试</p>
</li>
</ol>
<p><strong>通过学习掌握的核心能力：</strong></p>
<ol>
<li><p>了解 Go 语言的高级话题，如线程调度原理，内存管理等，使得学员有能力编写高效程序</p>
</li>
<li><p>理解 Go 语言的依赖管理方法，以便能够正确地管理项目依赖</p>
</li>
<li><p>学会用 pprof 对应用运行时的调用栈、内存等进行分析</p>
</li>
<li><p>学会用 Go 语言编写一个简单的 HTTP 服务器供后续云原生应用使用</p>
</li>
</ol>
<p><strong>详细内容：</strong></p>
<ol>
<li><p>Goroutine 的调度</p>
</li>
<li><p>内存管理</p>
</li>
<li><p>学会用 Go 语言编写一个简单的 HTTP 服务器</p>
</li>
</ol>
<hr>
<h4 id="第二部分：云原生技术栈"><a href="#第二部分：云原生技术栈" class="headerlink" title="第二部分：云原生技术栈"></a><font color=DarkOrange>第二部分：云原生技术栈</font></h4><h5 id="模块三：Docker-核心技术"><a href="#模块三：Docker-核心技术" class="headerlink" title="模块三：Docker 核心技术"></a><font color=DarkOrange>模块三：Docker 核心技术</font></h5><p><strong>教学目标：</strong></p>
<ol>
<li><p>理解容器特性以及相比虚拟化技术所具备的优势</p>
</li>
<li><p>了解容器技术的实现细节：Namespace、cgroup、文件系统</p>
</li>
</ol>
<p><strong>针对的用户痛点：</strong></p>
<ol>
<li><p>分不清容器技术和虚拟化技术的差异，在做技术决策时没有理论支撑</p>
</li>
<li><p>因为不了解技术原理，排查容器问题时毫无头绪</p>
</li>
</ol>
<p><strong>通过学习掌握的核心能力：</strong></p>
<ol>
<li><p>了解 Namespace 技术的原理以及基于 Namespace 的问题排查方法</p>
</li>
<li><p>理解 cgroup 控制资源限额的方法，查看 cgroup 配置并临时调整 cgroup 配置</p>
</li>
<li><p>理解容器文件系统如何高效管理运行时和数据</p>
</li>
<li><p>理解容器网络，为进一步理解 Kubernetes 网络插件奠定基础</p>
</li>
<li><p>基于 Dockerfile 将应用程序打包成容器镜像</p>
</li>
</ol>
<p><strong>详细内容：</strong></p>
<ol>
<li><p>容器技术的本质以及技术优势，Namespace、cgroup、文件系统、网络连通</p>
</li>
<li><p>容器镜像与镜像仓库</p>
</li>
<li><p>将 Go 语言编写的 HTTP 服务器打包成容器镜像</p>
</li>
</ol>
<hr>
<h5 id="模块四：Kubernetes-架构原则和对象设计"><a href="#模块四：Kubernetes-架构原则和对象设计" class="headerlink" title="模块四：Kubernetes 架构原则和对象设计"></a><font color=DarkOrange>模块四：Kubernetes 架构原则和对象设计</font></h5><p><strong>教学目标：</strong></p>
<ol>
<li><p>理解 Kubenretes 架构原则</p>
</li>
<li><p>理解 Kubernetes 的对象设计与 API 定义</p>
</li>
<li><p>理解 Kubernetes 控制器模式与多组件联动机制</p>
</li>
</ol>
<p><strong>针对的用户痛点：</strong></p>
<ol>
<li><p>对 Kubernetes 有简单认知，但无法编写出高效的、符合云原生规范和最佳实践的组件</p>
</li>
<li><p>对组件和基本对象只有浅层次的理解，对 API 的统一性和差异性无深入理解</p>
</li>
<li><p>不了解 Kubernetes 的控制器原理，对 Kubernetes 控制面板组件如何运作无深入理解</p>
</li>
</ol>
<p><strong>通过学习掌握的核心能力：</strong></p>
<ol>
<li><p>动手搭建 Kubernetes 环境</p>
</li>
<li><p>理解 Kubernetes 架构原则</p>
</li>
<li><p>理解 Kubernetes API 定义的设计原则，理解 Kubernetes 对象中的重要属性</p>
</li>
<li><p>理解 Kubernetes 控制器的联动机制</p>
</li>
</ol>
<p><strong>详细内容：</strong></p>
<ol>
<li><p>环境搭建</p>
</li>
<li><p>Kubernetes 架构优势及架构原则</p>
</li>
<li><p>Kubernetes 核心组件</p>
</li>
<li><p>Kubernetes 对象设计与 API 定义</p>
</li>
<li><p>Kubernetes 控制器模式</p>
</li>
</ol>
<hr>
<h5 id="模块五：Kubernetes-控制平面组件：etcd"><a href="#模块五：Kubernetes-控制平面组件：etcd" class="headerlink" title="模块五：Kubernetes 控制平面组件：etcd"></a><font color=DarkOrange>模块五：Kubernetes 控制平面组件：etcd</font></h5><p><strong>教学目标：</strong></p>
<ol>
<li><p>深入理解 Kubernetes 的唯一数据存储组件 etcd</p>
</li>
<li><p>掌握构建生产系统中 etcd 集群的方法</p>
</li>
<li><p>熟悉 etcd 的优化管理，了解灾备方案</p>
</li>
</ol>
<p><strong>针对的用户痛点：</strong></p>
<ol>
<li><p>对 etcd 的实现机制不了解，不知道在生产化应用过程中可能遇到的问题</p>
</li>
<li><p>不知道应该如何构建生产系统中的 etcd 集群</p>
</li>
<li><p>不知道如何进行数据的备份和灾难恢复</p>
</li>
</ol>
<p><strong>通过学习掌握的核心能力：</strong></p>
<ol>
<li><p>理解 Raft 协议的工作机制和 etcd 的实现原理，针对 etcd 生产系统的配置优化以及数据灾备</p>
</li>
<li><p>深入理解 API Server 的实现机制，包括与企业认证系统整合、鉴权、准入插件的实现等等</p>
</li>
<li><p>深入理解 Kubernetes 的对象实现</p>
</li>
<li><p>如何构建高可用的 etcd 和 API Server 控制平面</p>
</li>
</ol>
<p><strong>详细内容：</strong></p>
<ol>
<li><p>深入理解 Kubernetes 的数据存储 etcd</p>
</li>
<li><p>了解 Raft 协议</p>
</li>
<li><p>生产系统中 etcd 的配置</p>
</li>
<li><p>etcd operator</p>
</li>
<li><p>etcd 的灾备方案</p>
</li>
<li><p>生产系统中常见问题解析</p>
</li>
</ol>
<hr>
<h5 id="模块六：Kubernetes-控制平面组件：API-Server"><a href="#模块六：Kubernetes-控制平面组件：API-Server" class="headerlink" title="模块六：Kubernetes 控制平面组件：API Server"></a><font color=DarkOrange>模块六：Kubernetes 控制平面组件：API Server</font></h5><p><strong>教学目标：</strong></p>
<ol>
<li><p>深入理解 Kubernetes API Server 的实现机制</p>
</li>
<li><p>掌握基于 API Server Webhook 的整合方案</p>
</li>
</ol>
<p><strong>针对的用户痛点：</strong></p>
<ol>
<li><p>缺乏对 Kubernetes 对象实现方法的理解</p>
</li>
<li><p>对 API Server 缺乏理解，不知道如何与企业认证系统整合，不会基于鉴权准入等机制打造多租户 Kubernetes 平台</p>
</li>
</ol>
<p><strong>通过学习掌握的核心能力：</strong></p>
<ol>
<li><p>理解 Kubernetes 对象设计的实现机制</p>
</li>
<li><p>理解 API Server 缓存的工作机制</p>
</li>
<li><p>掌握生产系统中 API Server 的常用配置</p>
</li>
<li><p>掌握 API Server 与企业生态系统的整合方法</p>
</li>
</ol>
<p><strong>详细内容：</strong></p>
<ol>
<li><p>深入理解 Kubernetes API Server</p>
</li>
<li><p>API Server 代码走读</p>
</li>
<li><p>理解 internalVersion、externalVersion 和 storageVersion</p>
</li>
<li><p>理解 conversion</p>
</li>
<li><p>基于 client-go 生成 Kubernetes 框架代码</p>
</li>
<li><p>理解 lister 和 informer 框架</p>
</li>
<li><p>理解 API Server 缓存</p>
</li>
<li><p>API Server 与企业生态系统的整合：认证接入、鉴权、准入控制</p>
</li>
<li><p>API Server 常用配置与常见问题解析</p>
</li>
</ol>
<hr>
<h5 id="模块七：Kubernetes-控制平面组件：调度器和控制器"><a href="#模块七：Kubernetes-控制平面组件：调度器和控制器" class="headerlink" title="模块七：Kubernetes 控制平面组件：调度器和控制器"></a><font color=DarkOrange>模块七：Kubernetes 控制平面组件：调度器和控制器</font></h5><p><strong>教学目标：</strong></p>
<ol>
<li><p>理解 Kubernetes 调度器原理以及常用调度插件</p>
</li>
<li><p>理解 Kubernetes 调度的常用技巧，利用亲和性与反亲和性进行调度</p>
</li>
<li><p>理解 Kubernetes 的常见控制器</p>
</li>
<li><p>深入理解 Kubelet 对 Pod 声明周期的管理</p>
</li>
</ol>
<p><strong>针对的用户痛点：</strong></p>
<ol>
<li><p>对 Kubernetes 调度器无深入理解，在 Pod 无法调度时，不知道如何排查问题</p>
</li>
<li><p>不会利用 Kubernetes 调度器实现应用的高效、高可用部署</p>
</li>
<li><p>对 Kubernetes 控制器缺乏全面认知</p>
</li>
<li><p>对 Kubernetes 如何管理 Pod 生命周期缺乏认知</p>
</li>
</ol>
<p><strong>通过学习掌握的核心能力：</strong></p>
<ol>
<li><p>排查调度故障，利用调度器实现应用的高可用部署</p>
</li>
<li><p>扩展对 Kubernetes 控制器的认知，理解更多的 Kubernetes 控制平面行为</p>
</li>
<li><p>深入理解 CRI、CNI 和 CSI</p>
</li>
</ol>
<p><strong>详细内容：</strong></p>
<ol>
<li><p>深入理解 Kubernetes 调度器</p>
</li>
<li><p>深入理解 Kubenretes 控制器</p>
</li>
<li><p>深入理解 Kubelet</p>
</li>
<li><p>如何运行你的 Pod（CRI、CNI、CSI）</p>
</li>
<li><p>Kubelet Pod 代码走读</p>
</li>
<li><p>containerd 代码走读</p>
</li>
<li><p>CNI 代码走读</p>
</li>
<li><p>全方位的 CSI 一站式解决方案：Rook</p>
</li>
</ol>
<hr>
<h5 id="模块八：Kubernetes-控制平面组件：生命周期管理和服务发现"><a href="#模块八：Kubernetes-控制平面组件：生命周期管理和服务发现" class="headerlink" title="模块八：Kubernetes 控制平面组件：生命周期管理和服务发现"></a><font color=DarkOrange>模块八：Kubernetes 控制平面组件：生命周期管理和服务发现</font></h5><p><strong>教学目标：</strong></p>
<ol>
<li><p>深入理解 Pod 的完整生命周期和就绪状态控制</p>
</li>
<li><p>深入理解 Pod 状态控制对应用可用性的影响</p>
</li>
<li><p>深入理解 Kubernetes 中的服务发现机制，包括负载均衡配置和域名服务</p>
</li>
</ol>
<p><strong>针对的用户痛点：</strong></p>
<ol>
<li><p>解决日常运维的困扰，比如，在 Pod 初始化或故障转移时或者版本发布时，如何不影响业务？</p>
</li>
<li><p>我发布的服务经常出现服务中断，是缺了什么配置吗？</p>
</li>
</ol>
<p><strong>通过学习掌握的核心能力：</strong></p>
<ol>
<li><p>理解 Pod 的完整生命周期，如何初始化、如何控制就绪状态、如何探活、如何优雅终止</p>
</li>
<li><p>如何发布服务，如何剔出异常实例</p>
</li>
</ol>
<p><strong>详细内容：</strong></p>
<ol>
<li><p>深入理解 Kubernetes 的服务实例对象 Pod：Pod 生命周期详解、健康探针、ReadinessGate</p>
</li>
<li><p>深入理解 Kube-Proxy：如何发布你的服务、代码走读、负载均衡配置</p>
</li>
<li><p>域名管理</p>
</li>
<li><p>基于 Ingress 以及 Service API 的入站流量管理</p>
</li>
</ol>
<hr>
<h5 id="模块九：生产化集群的管理"><a href="#模块九：生产化集群的管理" class="headerlink" title="模块九：生产化集群的管理"></a><font color=DarkOrange>模块九：生产化集群的管理</font></h5><p><strong>教学目标：</strong></p>
<ol>
<li><p>掌握生产化集群的搭建技术</p>
</li>
<li><p>掌握生产化集群持续运维过程中最重要的节点管理能力</p>
</li>
<li><p>如何在不影响业务的前提下完成 Kubernetes 升级</p>
</li>
</ol>
<p><strong>针对的用户痛点：</strong></p>
<ol>
<li><p>不知道如何快速构建本地集群供研发测试使用</p>
</li>
<li><p>未掌握构建生产化集群的方法，缺少对集群节点的管控，节点出现故障以后需要人为介入</p>
</li>
<li><p>如何实现生产化集群的管理，比如计算节点的监控与管理</p>
</li>
<li><p>不了解完成了集群搭建以后离生产化还有多远</p>
</li>
</ol>
<p><strong>通过学习掌握的核心能力：</strong></p>
<p>快速构建本地集群的能力</p>
<p>理解 Kubernetes 集群构建的原理，掌握搭建 Kubernetes 集群的能力</p>
<p>基于 Cluster API 完成生产化集群的构建和持续运维</p>
<p><strong>详细内容：</strong></p>
<ol>
<li><p>利用 kind 构建本地集群</p>
</li>
<li><p>利用 kubeadm 构建基于虚拟机的集群</p>
</li>
<li><p>利用 Cluster API 完成生产化集群的搭建</p>
</li>
<li><p>持续运维的考量：节点健康检查、Kubernetes 升级、主机操作系统升级</p>
</li>
</ol>
<hr>
<h5 id="模块十：Kubernetes-的生产化运维"><a href="#模块十：Kubernetes-的生产化运维" class="headerlink" title="模块十：Kubernetes 的生产化运维"></a><font color=DarkOrange>模块十：Kubernetes 的生产化运维</font></h5><p><strong>教学目标：</strong></p>
<ol>
<li><p>如何实现基于 Kubernetes 的 CI&#x2F;CD</p>
</li>
<li><p>如何实现生产化集群的监控</p>
</li>
</ol>
<p><strong>针对的用户痛点：</strong></p>
<ol>
<li><p>缺少企业统一的镜像仓库</p>
</li>
<li><p>镜像安全应该如何保证</p>
</li>
<li><p>企业缺少持续集成持续部署能力</p>
</li>
<li><p>缺少对整个集群的监控，希望实现无人值守</p>
</li>
</ol>
<p><strong>通过学习掌握的核心能力：</strong></p>
<ol>
<li><p>打造持续集成平台</p>
</li>
<li><p>基于自动化管理生产化集群</p>
</li>
<li><p>实现对集群控制面板以及重要应用的监控和告警</p>
</li>
</ol>
<p><strong>详细内容：</strong></p>
<ol>
<li><p>镜像仓库和容器镜像缓存</p>
</li>
<li><p>镜像扫描和镜像安全保证</p>
</li>
<li><p>基于 Kubernetes、Jenkins、Tekton 打造 CI&#x2F;CD Pipeline</p>
</li>
<li><p>集群监控：日志收集和分析，事件、指标和告警（Event、Metrics 和 Alert）</p>
</li>
</ol>
<hr>
<h5 id="模块十一：将应用迁移至-Kubernetes-平台"><a href="#模块十一：将应用迁移至-Kubernetes-平台" class="headerlink" title="模块十一：将应用迁移至 Kubernetes 平台"></a><font color=DarkOrange>模块十一：将应用迁移至 Kubernetes 平台</font></h5><p><strong>教学目标：</strong></p>
<ol>
<li><p>如何将无状态应用发布到 Kubernetes 平台</p>
</li>
<li><p>如何基于 Kubernetes 原生能力将有状态应用发布到 Kubernetes 平台</p>
</li>
<li><p>基于 Kubernetes 对象扩展，将更复杂的应用发布到 Kubernetes 平台</p>
</li>
</ol>
<p><strong>针对的用户痛点：</strong></p>
<ol>
<li><p>缺少将应用发布到 Kubernetes 平台上的理论指导</p>
</li>
<li><p>对于有状态应用，更不知道如何借助 Kubernetes 平台的优势进行处理</p>
</li>
</ol>
<p><strong>通过学习掌握的核心能力：</strong></p>
<ol>
<li><p>掌握 Kubernetes 提供的应用管理框架，包括有状态应用和无状态应用</p>
</li>
<li><p>掌握 Operator 模式，具备通过 Kubebuilder 构建自己的 CRD，并且基于 CRD 编写控制器的能力</p>
</li>
<li><p>利用 Kubebuilder 完成控制器的测试和发布</p>
</li>
<li><p>借助 Helm 完成复杂的应用模板管理</p>
</li>
</ol>
<p><strong>详细内容：</strong></p>
<ol>
<li><p>应用容器化</p>
</li>
<li><p>无状态应用移植到 Kubernetes 平台的考量</p>
</li>
<li><p>有状态应用移植到 Kubernetes 平台的考量</p>
</li>
<li><p>理解 Operator</p>
</li>
<li><p>借助 Kubebuilder 开发一个 Operator</p>
</li>
<li><p>借助 Helm 管理应用发布</p>
</li>
</ol>
<hr>
<h5 id="模块十二：基于-Istio-的高级流量管理"><a href="#模块十二：基于-Istio-的高级流量管理" class="headerlink" title="模块十二：基于 Istio 的高级流量管理"></a><font color=DarkOrange>模块十二：基于 Istio 的高级流量管理</font></h5><p><strong>教学目标：</strong></p>
<ol>
<li><p>理解基于 TCP&#x2F;UDP 协议的 Kubernetes Service 的局限性</p>
</li>
<li><p>理解 Kubernetes 入站流量管理的场景和原生方案</p>
</li>
<li><p>理解原生方案的局限性和社区的方向</p>
</li>
<li><p>深入理解 Envoy 的服务发现机制、线程模型以及扩展机制</p>
</li>
<li><p>理解如何基于 Istio 实现入站、出站流量管理以及服务网格管理</p>
</li>
</ol>
<p><strong>针对的用户痛点：</strong></p>
<ol>
<li><p>社区的 Ingress 对象无法毕业，为支持生产化应用，应该用什么方案提供入站流量支撑</p>
</li>
<li><p>Envoy 为什么变成了 Kubernetes 中七层代理的首选</p>
</li>
<li><p>社区爆火的 Istio 背后的技术驱动力是什么，我应该选 Istio 作为入站流量管理平面组件吗</p>
</li>
</ol>
<p><strong>通过学习掌握的核心能力：</strong></p>
<ol>
<li><p>深入理解 Envoy 的实现机制</p>
</li>
<li><p>深入理解 Istio 的实现机制，了解为什么 Istio 会成为服务网格的标准</p>
</li>
</ol>
<p><strong>详细内容：</strong></p>
<ol>
<li><p>入站流量管理 Ingress 和 Service API</p>
</li>
<li><p>Istio 和 Envoy</p>
</li>
<li><p>深入理解 Envoy：发现机制、线程模型、filter 机制、高级特性</p>
</li>
<li><p>深入理解 Isito：入站流量、出站流量、Service Mesh（服务网格）、Istio 服务发现代码走读</p>
</li>
<li><p>安全保证</p>
</li>
</ol>
<hr>
<h5 id="模块十三：Kubernetes-集群联邦和-Istio-多集群管理"><a href="#模块十三：Kubernetes-集群联邦和-Istio-多集群管理" class="headerlink" title="模块十三：Kubernetes 集群联邦和 Istio 多集群管理"></a><font color=DarkOrange>模块十三：Kubernetes 集群联邦和 Istio 多集群管理</font></h5><p><strong>教学目标：</strong></p>
<ol>
<li><p>如何通过集群联邦的统一控制平面管理多个集群</p>
</li>
<li><p>如何部署跨地域的高可用应用</p>
</li>
<li><p>如何通过 Istio 多集群方案管理跨集群的 Service Mesh（服务网格）</p>
</li>
</ol>
<p><strong>针对的用户痛点：</strong></p>
<ol>
<li><p>针对真正的生产化应用，跨地域部署是确保应用高可用的一个强需求，那么如何管理多个 Kubernetes 集群</p>
</li>
<li><p>针对跨集群部署的应用，如何确保其接入流量高可用，如何借助 Istio 实现这一目的</p>
</li>
</ol>
<p><strong>通过学习掌握的核心能力：</strong></p>
<ol>
<li><p>Kubernetes 集群联邦的实现原理和配置方法</p>
</li>
<li><p>Istio 多集群实现原理和配置方法</p>
</li>
</ol>
<p><strong>详细内容：</strong></p>
<ol>
<li><p>Kubernetes 集群联邦</p>
</li>
<li><p>基于集群联邦的跨地域高可用部署</p>
</li>
<li><p>基于 Istio 多集群的流量高可用方案</p>
</li>
</ol>
<hr>
<h5 id="模块十四：基于-Kubernetes-和-Istio-的安全保证"><a href="#模块十四：基于-Kubernetes-和-Istio-的安全保证" class="headerlink" title="模块十四：基于 Kubernetes 和 Istio 的安全保证"></a><font color=DarkOrange>模块十四：基于 Kubernetes 和 Istio 的安全保证</font></h5><p><strong>教学目标：</strong></p>
<ol>
<li><p>理解传统安全架构的挑战</p>
</li>
<li><p>掌握零信任架构的意义和机遇</p>
</li>
<li><p>掌握 Kubernetes 平台本身的安全保证手段</p>
</li>
<li><p>学习如何基于 Kubernetes 和 Istio 实现对应用的隔离和安全保证</p>
</li>
</ol>
<p><strong>针对的用户痛点：</strong></p>
<ol>
<li><p>如何确保 Kubernetes 平台的安全性</p>
</li>
<li><p>如何确保 Kubernetes 中数据保存的安全性</p>
</li>
<li><p>如何确保 Kubernetes 上运行应用的安全性</p>
</li>
</ol>
<p><strong>通过学习掌握的核心能力：</strong></p>
<ol>
<li><p>如何保证 etcd 中保存的数据安全性</p>
</li>
<li><p>如何保证 Kubernetes 控制面板的安全性</p>
</li>
<li><p>如何确保 API 网关的安全性</p>
</li>
<li><p>对应用进行安全隔离</p>
</li>
<li><p>如何基于零信任架构完成应用的认证和授权</p>
</li>
</ol>
<p><strong>详细内容：</strong></p>
<ol>
<li><p>理解 etcd 的加密方法</p>
</li>
<li><p>掌握 Kubernetes 控制面板的安全配置</p>
</li>
<li><p>掌握应用隔离的常规手段以及在 Kubernetes 中配置的方式</p>
</li>
<li><p>掌握 API 网关的安全配置</p>
</li>
<li><p>了解基于 Istio 的认证鉴权机制</p>
</li>
</ol>
<hr>
<h4 id="第三部分：云原生项目实战"><a href="#第三部分：云原生项目实战" class="headerlink" title="第三部分：云原生项目实战"></a><font color=DarkOrange>第三部分：云原生项目实战</font></h4><h5 id="模块十五：微服务项目的开发和部署案例"><a href="#模块十五：微服务项目的开发和部署案例" class="headerlink" title="模块十五：微服务项目的开发和部署案例"></a><font color=DarkOrange>模块十五：微服务项目的开发和部署案例</font></h5><p><strong>教学目标：</strong></p>
<p>完成一个复杂的异构的微服务系统在 Kubernetes 平台上的部署，以 Istio 的 Bookinfo 为例</p>
<p><strong>针对的用户痛点：</strong></p>
<ol>
<li><p>随着业务复杂度的增加，微服务的部署和运维变得越来越有挑战性，如何保证微服务应用部署的高性能是一个复杂问题</p>
</li>
<li><p>如何基于熔断、限流等手段保护核心业务</p>
</li>
<li><p>如何基于基础架构平台确保应用安全</p>
</li>
</ol>
<p><strong>通过学习掌握的核心能力：</strong></p>
<ol>
<li><p>基于微服务架构的复杂应用部署</p>
</li>
<li><p>熔断、限流、故障注入</p>
</li>
<li><p>应用的安全保证</p>
</li>
</ol>
<p><strong>详细内容：</strong></p>
<p>本模块是之前所有模块的综合复习模块，希望借助本模块完成基于 Kubernetes 框架下面微服务治理这一重要命题的回顾和总结</p>
<hr>
<h4 id="石墨文档"><a href="#石墨文档" class="headerlink" title="石墨文档"></a><font color=DarkOrange>石墨文档</font></h4><p>石墨文档的链接可能会更新，在此附上原地址链接</p>
<p>云原生训练营课程大纲：<a href="https://shimo.im/docs/6VdchtKxdjrCqDdY/read">点击跳转</a></p>
<p>云原生训练营实战项目：<a href="https://shimo.im/docs/RKAWV8xgZ7tKWXk8/read">点击跳转</a></p>
<hr>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>云原生</tag>
      </tags>
  </entry>
  <entry>
    <title>关于博客</title>
    <url>/2022/10/27/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容">
  <script id="hbeData" type="hbeData" data-hmacdigest="893d993856d8be9532b58bf0cba1fde1736be72bd16075cd08ff42841e392cdf">77cc46b16fd309e8f5b42a0dad109aa88a81e87c9c9da4bbe0e82fdb8f023502ed559dff2a350255747fddd08a8430d619a1d8915aa5a70618b8347f62ace0d26cbbb31748c0ff36b571d06c90a498ec588dcc721ea69c4517dffc906cc645307aa6b0e057e1cbb149f10f2016e208e069159ad5fc3661ec1e746de35a65c1991b8834898faaa2b07ceb03a18802c0af7d39225cd4f832d5353cf573eb75211ca9823f3c7a37d3450cd62cfa0a2c6f59f6f1b74158e7a053f5e7d371ad535f51e60d91628134033f1f4f4a82648bb6844612bd2d85051618facc28e4ec4ed76e84998ed4abde56af33ff52c305384555c99b7eb8e9b5a69187c61542dd3bdcce08029ad240d3ea93ae16ae58bcafe3be3885442470a2c56d0d0048beaaa89a2920a6c970d6e1b926b99c4cabf1fa3283d7aa6521ca239f45a8d9eeed0d463c17392f2944493bec04a2626dc4d2e15dfaec51c48d9feca197276b07a41992f5736c64715066fb7ab213b5d28ef6100e7d71439925ecb8df5c861c67c6cc2252f14f049c9d18f72a911331bae607a81f2b72c2954e04bf933846fe0408fec2ae891cc21aa14fac1ffa5953ec7faae2fe6246a8d9f00b27477e0daa30326ed41b3274c7953faef62ce74b862093d7243e6b52aabddde587bfc779cb704065d9269e7bc038921865a7f8f65ef41ab70fd009d1c71809518a8fbde5f247b80d2227934b0e85df392d87afed698dd0d6d766a327b99459cc03657362f43f2e8a9da68af335eda47e49e89a3fd78ae45cea194b2dac861d8b054ec202f9fe0c2f15011bd083475816f5fea18bec28f53b4648b21e33f0357df490b5a6deba7c80b3a696dde8e0b991f38f9f0e92795c976505b5862bc5393dd4556ed261b3350b69bfe76eca2481eb3a2900fe1eac4c1cd2dec19cc30c58465bbe670d77aa27d73071100706d993a6d60e7d4ba4ada865d9c5cb54e87e99a16c849f835b7c22a3bd1cb21bf27704951865f1a4b4c18dd7e1175ee41eef3d509dde2b1dc49b476f706a4f6904babe371c438e6347a5a7ebf0d55e6b782ed84394a933a4cad11ce26a8e5b1165e09e65dd97fe815548c5a1cc205e1733819a55a47ca43855941bb7d2c0ae616f8042c7c349c060dae92b716957a610aa8ffb73ef632671a1154ccc6635fd449f6c511954dac95158d44dd3cbf74df2fc7bf26a341ab576a9f7cf8b19cc7f5253575165bdfc5262762da9e9902235d9dc1111088ff811e97a720e14231b11c7234b37cd820b7cdc591abaaff756e3e8247319c3e43ea7d111679c5fb1aac81f301b7697947c74a7f4734c6fd9ce42410484616f3d1ba006d5095e8b3b2b57fe5b5cf98e229cf18d1145e36d922733158736a5a8a82f5f54f6a1fa9cebb2edd92f9600ac684bcbebc24a64f9f3fc3e0afa4699a8570e2f8ab781c6421b9b35fc31ce817c01880c7f121c8803334ed4dd4f245b400306bb4b7e4e1b3a1b6e9eaf70de9bbf38a3425751158851e57a1827531951b7b6e68aa806c66ad89a65d1bf9ab0a6aaae0147255634a9e9cf939620a8716dafab0a28b15e6b5615582ec4b169cf40f7a9c8a8d630fc1e9628fb81196536d60e9842c4339a916cf9dec8e9936d9febcade1c766209ae17bcb3d566f5040c6594794432f6b5e2fcd1f4ee78d6eac43f1ce0f3df3e8a9188e39d97c805e81470b0ed688e6ca5cb829f7268ad79147189ce03ad5d403c5e2b24225ef80bbee9bdda45c8e2678743aaf2cdf4a2a7b4bb2969f610c90c13497ba59d8ff9f1d8067a0529aa8cf29c8967037c900091219d3d85cb547f58a0796582e919b83e266a3cbcad6a21587e6e86accb64c6594639e67c9a99ab797d6680d8d203e1396b638e12ea99237347fbe98a7e29045ebbfa45db6422640655b6caa044a32738f9d47fd41aa4f740515654d5290f53488f76fc8eb12029240b8ada301d1b97573b6e1e35f21bbab09fc7e9862d8299de1e389b3c3ccdb6571ed2442901ff1ad03c552369db12790394e33a6c48a102c6e328465891812e8271de9608483c9f52b3d8abb6344d8896d84f9f8dcbdc1c0dfd9f5bb1db4752577779a9ffefed53b6fb209bdc5a72adfb27a06d85c6fb85c244ade0a568378682a7cbd428cf4d4bcd4d105889a395cfde7c2dda90d4441f45c61a59d6e1d7123d17eee53dd2588c285f103fa5a33b9aa6d2802bde7752cad8a39420ea5d42ed938ee9be1a07874e3374e0fb5262a77c37ef71cf8e97612c161a49589e02e41f3ce96812d0d79656c51e75f2fe37b240fdd5da11f5d076997712d15e69d9800d11158ee73c15c71aa3b4e1e2018ec3cb82ec3b3ea7414976b7ee6f0cb63e611ff598769751eb9bc87f5577c9cf3fb6105d3f3e621e47d9907c4217b815917889086f61439965c050bcf698eade42b9dc8e5b8a00cd827f8c82357909a6f90a76ca6eac78b3b54158515f7e5b549f2f71c07c656c8ed06212b126d224be26f7d59cee3d9287a17085a454b40d768d3283f35fadf0a1db4d6e7738b8e456456744bc9bff1d2a00d4386bfbf41de18157d4c7c35846540f31235457a423b6fdbed98ea9e283eb85768d15f339cbb25b5ef63bdee9ce0f426ce5fc993e2bd5d242d91e85edc336ac90fc61b4e23e1b6df52329567ae54a5e7cd3d7c2e23ad06e578f41e04d8ce1061ce1ae61e38279b4c8e3630ede90f576aaea1d607efcfd62d670273a7bf3bef4259fe874fdbf97fc5ead38be158727514398d05117820eb4417d5143ae79acfa10ca6e19f14dc4a7a068e545420b5bc2e4cbaec8cd04cd7f4e80c5b4536d3a122b03882734b0a0cb3fd992831c0975055eebe0d04f3966d8e877ae342e859c5c6485fd78b270165aad4d8790916bbf9e945701aad2ac8e177da020a29dcb5648916d7ac1e11724c52c93d7362251e5703c59bc7821238f5d95d613d06550aca516478d1459929359b4a8247c9ce7f6e3266f1e4a48ed6cbb44f95691cb30540de6e089819322f4c7db321a86b7614b21c86ca9c7530b1da883138350068fe206e0af94bf5bbe8de90c68790c6faefab63285d5736018f01dca52f7c4588d3bfb50a5e041dabc803f42c3bb948dece33a66ad89bebcee9bebab06a43c2a9ca253a3ad48e925f376517827873a25bc25beff005dcfef5833064f1d61e50d5c27ec303ff9ce17d5653dc6ae2fd56371028cbb3beb7baefbe39e7ebd3184bf7349ddd709133c1c0b124821fee7323074f5eb98da1918a1e35c0ba0577d327c88922c87c5a89a8d2eaa42f393eff9599c49e3f30697e4fb2e276f2aa1430afb112a5cb8787ac522e916befc550eaf5a3e6bc754ef57a98c0a7d88c5f2357cf88d1cd31a68a5de9ee443f4ac0bc27f69c5c8a7d14788e01f0595546d67735ae50c5ffb6cfbbbbe54b2b1b44a842015f030230858d7647937318ecd011813820fedb7541c1454c4d79b3df687eec435b44bfa531dbf3e9d251b64c6f8fc06a4e43e5ee3a6fe9deead93ae737fc02c0c987374809c6222066e0e13c7f3941f0af50f4a19af12534c752dd7710a457eb4e2cf00ab4c18e9bf142928aa400fa3c981cfa9044ad2c000fe06b75ef629d150d41327060d93014763a0f7eb29926012328d7456132e1f3eb619f433f62453f9ed4243763c95c440d32f877defd9503241018e7cb0004c7339bb1f6ab41f5d31d39c3b8fcbd400f2ae3896f5834b9f29979d6495eaf96bcb18d294415925049b7ee2192ed8ec3ce148db4bdab526287cc8e0c3372f5b74b67955d42cd999a773fd0fee1d2ff9eada7bc939564dab5d5e17e341bfb25ffdff152b42e5b8a61ba94048874a3a0b4d6700cbda4bc4e06bc4e304c7231f40702179313ab48e157cfcc8c303514edbc4588cb93d1bba8a1fc6d54d24358d320a8f7d0529c83d15c476bf82643c52d43369fcc3bd6eefc408da1407528eadac49c96cac6e6bb019c39c184093872028df9c4bdb425afe0aaa1c3eb338f1814434e986a1ae7333b4a32f9272f0b820a50e5aaaf36899daffce0de08b637fbba5838aca246213ea4ebae6d14a4cfc44578b66cdbd985c49224d8c3e9430c675015d3af7798d329c46ad570775fdb42363d93f15d758126040b2372e9776b7f0acef7cd554f9a664db319c3e3978c73c54e4fdbfd8b3a27b279c1033f3b69e7c7d160b3ddfa29786957ab382b0f7be5912f82e8a799ec3baf18f156c7d829ec1b7a029ccba12641addb7668ff79ce708b9ed58be4035aaea1186bb2c04a09c1d0925be3f88c12f0ad2db5bb85c058c593196353c25c68f02abb1887b006d22cc5e697121004ed71e034c5a0d17e79d8dc68211c52e5dc5a9262b9fdf19c604e53c3d38c3ac8bda430cf3c097238ebd57e1485c057f129bc4f2f855f286616aff20dd5ea6c2a79fbb88f4aef56b1dfefbcff5ddb585953e2b703c152b10bad2b5161b7ebc3793c9eefe307ee06bf7ac7af34b8bbf13975e02e2c0e9d02cb5d4b787ba8b0073a984beab237faf9d9f15a4174e655f595e383d528ea61c65980a2d2577ece44fc804944e3b5b9e40dcd25647937bc75f09cb463408bdd397de423e01d8469c697b4a10c7c2a81bf1c6dc3f1e0ffa9f9cc690dd5c36624d15428b89a28fd5e75f3d7559eb8cf5ea28c4e088b2a9954ec8eceeb2776859edbe68e8a76c5bc8b1c6692ef485bdbba955d1dbeba16023c3ab4c7d890f1a2a4531c238b8f45d7f6d9adc16107379a3238ceed1d61fc29091b4e72eee80caddf16683206ed4f0efa698f7575cba4ca6738ef2b192b5e24ee089bfb1842f648c10565bfc3a097cd0166332282d2aedafddceb840a44370eb39c644439122c1ce48223ccf05b63f9a19c02c3499a4602d694e5d92c90f27f0fe4541428eef063c8c4c79550b1892b170f724b65f265ace041094f518b7a6bd23d451f7faacc1f34165acf9890e82aeb101d1a3d6d10d3602e643df55904831739ea1cb5580d41dd637dbe4a462a2ed6be4cee0826cd17fb34c1f578b78842a2800f19cddb7b1ccfc7346971869ee1d6b9bf621316df336ac3f3f788427e138d9d118d94c0e7f8fe0efbe9f1c08d221a013e2dffd4e54697cd05330e6b74a6bea43495f13ed7590acdcff30bb713c24ad8ae7ae2fd33ebbcac161cb7e9ea29c6eb18471ae661852a15087a0bf0d0228fe18d340890c1acaadffb8de2e131fcaf900d3052917cb63ddd895903abefc251de245ecc146c922a06ff6041bb15a2608a3f83c41fa11e7761b0b82cec1b24079e87a4c924541d13becff8e16973f35e9ffbdb0549f833fb31267ee96ea1fa2620ee752de88179ea1b80052a6a595116783ac7c403ecdd76e70af8061cf4658bc6b7ab3f54e3dac5497ba5dcb373422392e742d6ed11b1dcda8a6aaf2a905b9c93168427a14e96f43354d3a58cf831765886338b996a5db8cb2a0ba7cd294e0f2103462583983aa2ae8ec96d4aa5214053461c2dd9c158e23bd729e50a7c5921df5b27704190c3fcf84fa839f54c3b5ef2479929c559e68fa507b3826e4b5cd50da49ba2f54ee0c6364825eb170f11bdee7a8f62a88ee811cb2f21969f9335c4e549d8e6bf863c2e85ea96b8dd266a0c5b3895b19475a832621beb22ec969186c4a172b96c091f8c9bd175a2141afc3ccd51eadadb84dca104e5b321e16b67cca4a59e63aec1b682b999c41a41cd886900179afd4b6fbf0dc2488cc2dae4ea0073e71f936a4b95750539052d920b2d4d9087aba177f1e5093a15616c55db83e3403e26c843799b15a717554691d17157fc9dd9233f767acad6a21ce40cd7acbdd3418d8260807b8ed58a3f7ec2e907b12400a5c6053671a1b93e11bd8f46a6ae8cd17be0c010f3ca320ef69cec29e91275545a36439d6a248ae90a5fb0f325ce942cc24188757f0ea9da82c2089d556201e15ed77a5216cc8342fa308f284439277f8fb9df92e861c144a06b8b98c724f5cf035fc587e0fbbe0785a2ea2aa217b5fb531387dce18dcfdce168a0541610e0b8a95b3b888910f362f1a96075da5c2b185a22e2b7b7f1e4aaf5b4add4ad938674359242d1c41c982dbbeccc199751e6322fe0eb9efea0f9eb460341d1f71d0fad07b9863cad599c44fa6b640966940edf61b1e84a572645a2d71af4bdde7271a8d1eb3370030ff67cdbe4dec0728fceb615ab26b847bfb5c98f2a9aa87bed06b0ed9d883c5db44c365512585a9650b4b933971ba3b21701aabd378a32d0e39c3ccc045aec2426124a81159467656b9e4f99ac152c133624f72be4596f70c7c53db9b564127b15f25e3e6babf03c457a5ceebb882b2145d65947fd04193801f54fb53d44b540b00d2aa38249610f11d3a9a83a78560a2b4284abaa7836234c0f438670bcc8c87ee7955a45587a137bb549acc6b6ea89ae3f3fae93f8ab8372de8cce243b5d39a5e01ebc0a3dc42e29cace7b4bdc18eeeaaa5635e039e910d3d9aef1519d06f7778b6aad51f0d3568050366a302d7f3a46b78ec83e2885369d859294bdf3fe3f26aa767fe001e20f81e0924eda27b271df0a1ea4fd1daf8186513fc0fa49f9ee51fd4ed29d9b6c4605c0619043f62a155c82809feabf771d663b4287ef9488307a00dd325271eaf3233585a1e9de80e163e1d917e88f9663c86455568e61895aed397d07012c21c55094f3ed35c289b9e7ba2586475e533537d39839a058c38d47f4d9ba766265a3315c25038725d381f589df05c02cb0c3251cff7ac196108a83ab13e5214fcbb928a4fd9a0f0fa68f81d53eb8e957fbe760174e9eb7ff62f3ba88767f6dbe87228b64590c43d9946deaa9f2eca5b28dbd8cb274083a0804e0e57372d8826e37fa9e59b742e758915849c98e961c1598d970545fc2280d5f6aa664f2a72ea566730bdd6ca3b2bcf352f890b634930a4a2281336db4fa46ccd4226c09b33875cd7cf7b38d9e13baf952dfc7118bf06acc28fd38e9819e8d548a7cef7d72b07f9ce8173337cf56de9916f46f14cadad57e9435690d117447afbfe10b42464d3aa4079347072172b3adbb03b6d17fc5847e30dd1c1c483ff5621bd501c4f5c4e053e23c9d4e5f94f8d5fcd2cf4a6434bbcf6131701a028f216f86fc57246b36ca813483f94667b166f02e53ec85e1b20127e92701a058ec501a71acb587cf2e399a8840b36a9b0b8126d2f9087328513a22824ea3112be4b3d0d3c60f4ec8ace4d2dff82704a3f65da235e4268ba33151821e6fc99a6959eef04939b4c01d6bb8f58e504264e783a9f3df1e955f03aac4422b85e68476a8eb0f0c217e2314f035710489130bb594e95cd139226a33221824595c37815bea2825327808b9e15383ae320794e9a71c60b918ae42a3e5a113864b245146b07fa6909318b0f3da6d8bb31805828a382c99f4067e9b7e1095479f11f217ed08b5c600b732e79964a7e08ea32af54c322e5b9849ab33aca810f1cc6656961e882a593ecfaee52321083fe5094f92e55d368d73aa6d32d8228acc7de460c9a1e5104ced2e3827cb2eb7ac82afe79f20ab9e0081181f4d76613e289be9b4fc5052dcf80ebb498d3e6129ebb364ff0583925ed0d477bce431925c68a8d6e13a172e963682ded05cfc408fe5c7594c33934b71cc3a19c6abffefc7ff5eff42346e0cafcac6dd23def26d97e60a63fc4173d7a7e44a2b8d7fec7782df40626c32796050ed75b80360943d3bffe8ff8137ede215782bfb58846d3e86c7018eebb029af408e662986572d72f493c4f0c43291b3e645b6100d5bf1fb163d413b9c9f66182d27e88629d9c4d07bcd9c17e11eef6fb360306d24d9179a2a3d7613c85f89fdcad1e7083e7094ebb625095255e0d1d0d016c2ddf196840017326b719dbdb3e3689b3f9baadd74b667a2326212bcd67c36eac6415290ad7cf99ff8cff776af90bb4c05efbe7ffcb821eb050ab4dc5f8793de0de3629ebd88827c216809af4edfcddc549448cf221ded16d563aaec0ee67d8ee119938550836f2cdce815b0548b51239d3d85216e8d3b4666307a83afc8c9b09d3a33c01b72b37758e7271f7687756085921aaf86d58c768039d8b6859d90c05d6121f87bcc5888a9d760d06a6b8b3c577a198d284a11f86e0dcf12aef47b313a955e86084ba5355fa9e75c5c9c875c3b44ab72f159976028e1231606678009523edb272ae46eeb1de5bdb84f0fc54981af1d372c93111d26e68821680242d302fc6bc1b3fb303ac53590812160c5de2ad6ec69f9d295b339e83af1af12a4f5c9d2661e73b9e9bc5ea807c4f00f27a1bca459e0725cad785460f3d1f9040b288000553d2cf59b12338a8a46cfa8fe9f29a11e208ab1adf9d23d0e1e1efe9f4e846621d4176ff65eb69567c86f663e7ca0aaf4b4f4aabfb9ad375a008fb309425a5ebb0551d724d8bd9ae18a00a509fec67a3410ad14f2d26ab949e3c2e1aaeb9e77f1296a55449dd1ad29150a4ea9fb91cdf7488a956bb049e9b8fe3c0b02592128600e29a8f78544ceb68871d65cfc70bc36d27426fa12c87df0f3577f5f6d351a05c77e4bbf84cea01bdc7409e0cce788922b4baf4cc0da93033b14876d0a4a6c73313dfdd1c6d06b3e370cc389507d767c86dd80887b0484ccbc00052585a23cce072673957bb159e5b1c4e918d92858c6ea53f8d963eec16a56780059ee17312fc32010791c24a7f985af4804676939838facc02f7885338e7ffbbf6ce88b2eab14bf7c7cb7526fcbfafeb52c9d77e9691881ccd8ac902830d36451fd4ff37ff1e90dea895f8512c3d9b1df0e00cf455e3e3d205f49a71ed8c6aa169a0841a806c8682f052051a81ef58e546eda28202fc5d09a52a5784882d4120632c8d833be7d3812dacf089d6c03b4c86bc6eb3ec7357fbc4845a005ebfcdf18682e5c97ac1debd4b5655e5e82b0e23c50eda36a5a91c3722807dab98ade7058de62b4d0e93fbaae001af3e8ee1622dd923a9886faed176fd3d82d403a14b230ffb07c06d93cee52182374766a0b7aecaa7d197cf5f49903ffa1573c3d1e9177c96d2db624f1f9f3a58c0dc3bab49421a457a637153acb23d71fe51bfa928671edf7fab9271da6f4ef26eb599c6890e9672575bdb3aa842bd814a35c5f6f906669223c53401ddaae7ea66b41fcc290483b41dc0a38cdee11c567db401b13a35558a8cd7a03df816488d7146a474ec6e41a5a5c938fd7339e686d36ae3d8521a8f99042b6e493acd44ca9f6264adaa7ab68380811d63b11698a0e2d41e4216b5ba91b0237771c6080c60956bccbbc4c42951d740934ad707c8b1e2cb47895d20c26570d37758fdade54ff105fa4d11af32ba0548d7f8bd8f438429720f4255ff8e1f6af35666923853695ef802a6b5ea394065e40f9c5787e9e57122f0fb640927daf62905e60cc16a8728cfc727d5a39a77d6ae36871b0a0be734c34a3face6af07c5d1e8f5b731f5be4c6ed5c90b28a82aa19b04a2b6b71be7b014610664f7d9b47595263591e89d03473a89479c913655ef9a7b5fb63267a3d2b6c63ebcc7e5690f535c0b4409f9cc7cc2401e2c0861e3530f492ee486783cf10d000479cb4c4baf56bf7b0d727632c0a3d1c040ec60f14987654deacbcef554c988fa34a3ff70f6c58069d9161180a92e38ba3c62a2eb0c5b659ae17afd267f6582dcf19d53b4d113d4d0f03f05f1f068d002fe26cb366188452663c00ca5a08f2deb64bd4c7b4060bc87562e00168c812b859bc7c35bf8a289d014d2cac7aea33fae89696c0aca98b8b8d4dbd7fc1fc41faa5881783ecfda3a1efd3e150812d8cd05be689a024933d98862df450b77ce230866cd5a4269eb79050d7ffe6f7e234720b13df70c9ba47c1da74fe0c8459994edf7ed794ad54cbbeaf47856ad596bd8c5eac200804d31505269c55c798baf5d7c99b03f39fa6c4bae3ba5e7960de4250a4811b12e7c4127c6e91de4d14221581353e3540e9c11e281537e4e5b0d007e150604c72a03e1b84d6e873fe13ae807772abf516e07778cbbb92dbcb96e5765981bd3cb454646dc9f4f22e2ed95571861b483351fe24a8e0ef35b927e71c3bedaee20803cddf4550f0524404df36ac588cefc695ae2316a0f7b218c255d5108571547a274373e92924ff3681564be0864d48391caa467e65aec258910e40c516755a5a290675b10c03ea0f451ef07913f33e7bd9dd0206aba7147dffe5b30c60ef221508f8ac3d569ab230549bb6f8abd867eca33f384a6938c63259e2a688285356d14261a2c7ba9ca204a08bd2a40bcb9620234cc10514a1195f159122e5aab773b394a6147948f31404f02dfeb87e594afe803d224f150df976d090d5bb4f00228a7c072b150ff9b881f117627c2c9dbf2ebc5e4de7cba45cf22b25f9d7d3fa6700cf01ae36750c53fbf6ae5e459e46c55725790e0e534606137c12d480f30dc9664055e200bdec019070df889add8b787a7b5eddfbccf2e2883130cb342915d87fec3517dc94b925ae0669832d4de3d74b49ba24e3bb2a5e6b0fbe91f4a9fec9798e3a66de30ba18c9ca5782ddc4c1af60ba2f4c9e7b3b4f7f6680b0527f477676a25e3ae6ea2d3cb280c486282d6ae53f66b42d9458761129662c1f806e3ad9b78b4778f9a5ff7e6c65b3f2ed809ed8c475947b7204cafdefbd87604aa3994ead2c3ae7d33950cd9898424076f66e987c178f4dbfa7402b91d402959c859e0f0059dd8b511b0912def363bcbf8befbeddae74b4d41683554e1fcacc5ba0af5be387247f9b00ac9814e5346933c53b4097382d49e2974868c9b13210154deddddc45af55c94656d547134b38e9f545ca6143965de3eadd1c792cd401508e0dfd4fddb38bd73eca9aa44d83f46957b4d5d1fe9dc396e6ab81809bb1f1b3b3e2c596f7f674ca1c10cd7806f181b223d586890dfcf0c8fb9f81a1c319b942bff42f531a20fc91f489a4a4ae0d803623b2c15a0f8b1af7ab588d1a9a6adbeed0a2cf6b98160cdf9401cf4899abf72fcca8267f7fe97663c18325443e0476837b2fc8879f40f70b5eb0dd762ccec7c8209dbf0595f98e1d5524c72bac4472a9f55664449485102fe7a0640990f4773401533063f6e407a918924a0ab874229ad722db99b57d1918b1b7c257d4aee3ce0cad0a53bf88d42536d824b9a8d2e9585f99337055545ba90c8ef6f0bbe6996c7456bc42edb59669a076732231981249eec0e5fee5a252a2f3033d8d69fd12f9a04ed7d62034c9c527eeaa0781e2425b225cb93ddb06cf2956fdebc3ef8056c79b12e21cd0e4d0f6308f7bebb8a740c52445ac18e039533153573ce91cea286dede6f0c892f7ad5417b2bd9c404d7425ca3426ce55d364458d3fa6de720902845458e9242bb388efa01d285323778de89723ad09f4550efaa6068d89d2cd73e8172e55f1f1de8d725b1a9b63289187c6482b3c7c23cd1a9e84a98d94913c86ca9da022ba822aaae0d3168be5cf6d8da980fddbf0c743bf274df64c901500aed73b957d84033b2f9fb323623eb60214449542f1b12476b23bc3e1f7f45b7d44d9458faa2fd3ea75996ada0c639f94ea9dab36700e60d61cf79b97e0b4beeeb25e3d86a04dbae8981094af4031e7758c230580174da67c8b3a34f3aa22abff42ad20a13707dcb47d84126de9c3c303578540bfd3b3927a8e25fd58e9b4a28169c4befb26d6771de87b7cb0c0185253f0ab4524d95427b3ff965077471842fd1831206781efb7290e74550e16cd796c99ab1699ddf909577ba357435410b817584e8b565ac844f63e1957304bc23d948e8f7c5f26d46d1b70a40df50fc2855788c8535cf68bc0fbc791a351c585f81c7be57b172937f917bd2b62c830b6d71a856cceb55d802eda24d48b43ca1edd7b0cd9b97e42fc02966c67b4ffd63675f07b56ee49b847856e92c4c4728864e7ef820854dd7987d4e6541689adbb1c2cc76972d663607846cc9eeb6143a3fb9805f153864a59283ef0c605c59ac17aec615c62c1f664ff1026730a8ee66602e4ec6d78b2804845ce0306c4f75f868cc5a533a2107e3d3fcf97ac4135abc9dd8685a194dcc402b4a7356c0f706048c30fc56a1f0fed22f5cb0ef8b4dfebcfdfcb08cae10bdd89f0fff1b1f0a08d43f2d1870bb576cd7ca829130d6d59b435c4bff5900f1bce3e02b316990626aae256b1b5b780355b8738c7ad00a1af0fa1e76c1ec6552f673302dc895db36e822f5598c3e4cf9cca1286680d564bff6fd930e3053d949af38158f46e40ab545f6eb9d8316c5675dbf0559d0fdc6cd5df26cab9300820c1f3164532da800ebdc53c0a89b591613b2f6fab920242959a3e22942e4e6d4a40b484dba1d41548d295488bc2b078401bcc365c635b383262de4e4c0020c3fdfaad2ed7584d08aa8e814f572070ba6adbc7007311ee1345558e40dee66bf704342290e99ceddad8881f878faeefb7833673444c6f7a9ceaeb52fed0f5c006e95daf24a1876ca592aea2ae479c840e27274cd753292d75ae054809bf2a5ce8c91b49d90b897f6b876af9bb0cdf7cba03771401e350989fb171c99a05a3857bc4c187e021f07e83bccc51946e84e2193f1321a1467423bce3ddb643182af39d39b8551f78e4bedcf808a414d3c23d87e63351f7eeafed44fe307d61c4521f6a3bfa88843d4eadf0b0d102dc5c3ebaddf7e4c5ab295bfba0a440ca4accde2a7aa03d6b18d6eb4ce637fc3d99af3038e1dacaae7fed2fc825a41e7366f9e3ddda8e9039f0dcc88e09cae8fa9eb14ecb5db2d457e20f19b5c9ccb3fe2d46f78cc86845b69b17392f299ab0980e76fc7a1b221577a43585c1a5a939a576254a5838d4ac3aad4948c4ca590d5721d146c960a4ec1a418ef1e5f61102754de256d7a163253d513277f481973d96087cef1765235469dee0ecb819525cffabe6010c756a9beb20fb96df8a4ada01f1787856089f15c0a8dce0aa6d3a132987d101caafc3f9fa29c8ccb1d7ca524abba00b5df31a982d294419c0c40fde5a01f499ec8d64eea89bc45446a50897db3f46b50de1cca50a5874575c19930da96c89bb10c4b5dff21590d9fa6a53d51fa8cf633ae7bee85ab36e45f6d6bf6228d52b59bf588706f3dbfa1f89685156736e66345c1ad08b763ec0991fab61a6d8a8852136e16b045ea86355729218f439a1d516520e0c847b9316773d2318ef20a737a7002a74e7b5098bfd92d875198463d6750286e98e4a4b8e4dbf3dab1b3fe5bfba696cc5af02b5f5b60bd2f203da3db1045f56806895b3996f20d8deb8d448b23cc939d03514df91c1afbe6c0e738061f9741a1a8f4ef99eff39f98feb9880cb7b84c77363b86f05927dd75787e9f7ef0421ced9c7f4b0da0b1731dc57797c21b4a1c43596825bddc825c63a3af8dd5d588f824db4baae576652671c3d42307ea9b2a209a29ec20da72671a6992714008091f65652670075b64554f26cf1605330162c935c2fbcb30224995cd29f8ab2f35f5477d153ad1b7a04a5c5b69df6d226a3684cf58391e4bd7b956535e4bee5bcc6f58493f38ca42d67e13df3776116815531c41f1b27c11f5ae98b7390f8ccef28c4e8bcb5909076a24eec16b121ebbddd7157bb447977bc086d47649bf15ebb169395cdad2cc9348d8ff48aa185d71c082557993713adba4698967ed3325628d3261cf0776281e334f6a5190e55fdf0db2081a2688f2e64b3903944504b21377e8b33e8c6a9076c8ee537a7bde14c651fe0e4a7ddf80c32e0b3e35d04d8b3b659e15a9c9d48b7fb49b57a13fe9bfd4ef41ac78e4520f8f432b4e8a2610cc79a0a77a2c32a260d8e1bca216f0e2ad63cfe6e14fad1b9ad503b6fdc07e392d6a536c94b1fefb5e9c395c2f23204f24a889e4d524252836f16e98d37fdd5a5f92a2782b01d3a42f2f35b2b903223673b707fab67a0ec5024cfbe998d5194d99ae4f399299e5f6aeebc083695d3a4f2e4fc37b46381395385b24fb9a2a66c09a569aecf1a5afe8721e0395304d69904cfcf67e8a0afcd9da5120ba6be2f7528d94dae02590ed9ebb8ac9f3c6a58093a4d26b2a21165e22ad6ac1629669d9c183cfdebf4d4eee89a0d38d7502d56caecfec3f3245b92d1835e21e75e7ddc479118641771eeeb93d14df51f943b21edcdcd88db002d718595e933758b273d4d83091e0ddca92b81b7e255c0d5ca0a9018036ad1d7319c8bc62f037382522d100d5783b32f806c9ceb4a0b55ae2e415784635e186fa2682ad3dcba287be2908d516d58310a38fb43a261f3226306e82ee702743f146140ef3d2231fedc72f5fcad96b4708d0106035083294dcbaa906a5043fcd636d50d45ce3ac86f41480d8239a5c89fc1ea4d33c75e4ecfbbef2ac5af8db51ee431ebbe4202b067b69e3f1e7660a2e81950908066ea8c417f8d6241df74b5190c3293f23eeb071f25c4b9c9a46270d19133a82d94d425ce6bea18cef92af9215691d8fc0974b68b50191b90acc6193052efc54d2f752a9d82bb7283ff86f78c844dbd8c2ad46523cc2a5fa82724755bd6ed4275332527c147e47b6f87ebebd7ead9937138a9ca357997a88692b8b2fdd5801ff9ac777cc9559bbd2333cb3dcd5c2808dff3371c5209e51d4f9e290edf6086aaad3338a72848915906c2bee19753b1d77308463e6e8b565ca786a48b66638621329daf47c3bc880f4d18ba94fd547a01a74c18f419de03afe5f682c66d4a1f58f5af7c211274b98c5d00508355b72fc17a4c16da17264b43e83d31ff85c691d42600833b1add25bf33e303935875d58a61ee837761b3d7d0fdc735660cfe9f93a8c805e7d7184b63e47dab3b318203f83e28c9c515eca47e7b41c9ee6378368fc739abe576d93c68163b67c7072ef27cf4cd1b1c97d8433a63847eecb5e3b7dfac527625306a9d8da98541310f1a38e174a91894b20f872575b75c5539e0f32398b15dd90b5d503a0afd4fce0bad43d042e336109a04b8d8ccbffb4eba9bddfef8753cc4bd0f012c7ecd024369b7458f1a392cd06cc9b08c364b5e8cbda5bcbeafa8ca186aef96d1790a887ee02cbd313171c64963d56b873b8fc5377b32585c249fb3c89b29e0c804d4e838078e6aced953ac57f34995f600f6d09d218167abb72ca1c1fcae5b19c9e9463ab2c0a7c9346710f5380236bed06de67d1b7d89d1cd5376327143f04054547328400b504ce3524633947cc8f95d71e990e16d1e42aabcc3e35ccce5765ab6405ebc373c4b270270916ac5a3fdde54e9cc84f533f1ceb652110400a381954e1b516574596e6d26ecc2bcbd87714467cbd88c79d7fed7280d2d4971bd65dd131b7c0925971def407e737537afaf65fde5ca1823a2d560b562d0757022b378c6b63d3202f976f33ae2d9bbd81d88ea1ed75dd4fc4715928d1d707eb4ec1b0888a322ac0758c18da4854bc07d35eec543475900c5ca97e2cb4b6e015d4da40f1902efd66c112ca58dc9baa3ea034ec13d7ecd291e1b5885e1646f7970c4bbcc9933799d0bcad934b9284471698d930c0405b463910012508dc55a9fefe045afecf97861e900ef1940fb28c99d2df1f4a59be9951dc72803560d1a79bbddadf309983263f42571a2685f0fba74229f61856b8da911637146c91cbb2eff70960341e7f6a9022c65f1f389effa158d91b07931f4e4532b1697b6c786e6c98aec4308f84635404afd5efb6d20ad2d8011754c3d0e96d5c8e12ff1c086220cf1bbd3d3621fab8c16c1199a274427a0b4d5e34a0ac5c3e1890b8ccd7b1428e6fb51e6a8caf26aa8b15e9fc6878a685db826a9d3565bf54de9606ed96df3d140ed9e42f02bc4f05479a92ce52b733c761c0140c17bdd228146235ddb049ba81626c61df567d35060761902314aeedbe6c2c70f18b989f4b90f926c0abe9df6acaa6090b678ace80b4f7348f9ba08c3cf600affd118d6a7b655a0d5697305df7b4d1c82dad3e18d67179c74be3f9c1b5c0f4f0cdfb9d9d3f1013b0e731ed792d289d039cf9abc17964cc2ddafeca4d9ae9cc98071c10ab8452eec1f50da12c6c3a927f8382970edda0d80b25f33ac1710bcd7bb2bcb56dbd3d3d301cbbebe6e398f24fde921b6020dad8701d24faba3167b1a5b74862b99c603c65305ce289b057e5b1f7685afae289eafa86a62c0178f8d3aa5f662b95e2278eef0030dd4affcaf88f9b0effb6fdf83e02e14a562f9a00fb714b295671f41c0401ab3e6c895efd5bfc0fc077eba2319d39db1a8a8070a0a50b7c148163e7454f003cd245134cc59bfa298656338e693f673649ce2359f65f850381b521fe570fb474997d925fd94d7f56873632c83d791cb353f8de7804e6a1b47678cc223e0918637acbe1bbe1667735bdce5390c5616e1adbbdc71b787c2112c582d0f596ac99c95621aecb4c54643d65e2e784523da4fff75f3b908b2d08292bbdd87f3a94f14788bb2fb1b73d0f8831da77644b5520ed9769aec425e5f66ab511a9a65c255505d82d12f6357a27d8e4cfafeb8c52ebdf022e6d66eb43f9b4d27c0ed1695ddafb3ca3afbc056fc903558eb0868e9419d1608d54c26dfe00ec0c43cc23e3f88d43fc8de1919f125cb7cc17c312e02e0f4595fa3b4991f2a14655b2e5853fd76cad89bef2b23819cd954c8ea3e3f731a0a7b52cc4034fb16b2a59749b17e88cbaa5e690a2c330959987bcf17200297edf6e348d76ad7a338922ab6a9fc7d4fd2753d4d440f081e0dbe43ab7cde781f384091e0b705ff0fa94350acb377544d38a1b3b0adcd0634f5744f939d923bdbc507b593b5fdc474fb9e9216977eb8cc4fcbb4875834607f5ce0fd2e0d6acee61a36cb9a6042e10d1744b7c6def1b6c50e5ce343b9b59a818e605a54ef6a7e2049d3b903c01ff1611489a5722f2ea41366fc45c029a2aaf9f0f719fee1e54af4364cc0cde184b257e0fbe7aa4346ae96d8b2b121be40f6c35c7853031b61dfe58de9991e310965d7e1e3fb3b9719b024a199a158a09a35683bcbd088467a00af506951f1797ece1a209e9e6f5bedf59c57b9d75c54d088c59d2ca6efbf3dfcf2cc3cddbf4415dfc16639908cc1cdb8053cea57dd40652a643ef17cbc6556a301893dde628f25116b60de12e26c7f139a45ffd21f112076f46a31507227579254135cba676bf80e55b58e7bf7e5ce8093d2c6a5d989d2ee87971faf5e067a08d8df52b8e1a4e9c6247575381a054d1e1dd74728a233c277017536db534cc9b6026d3ff1c235ff3533e4ca5e31f97da47e51cb2b559fa60b048b972ca1900301b7a16fffeee70c6e14c3bc8839bede36d7bd0852ecc82ab72d70e13f0331c13db28e339e4ac77c254e1041f7cdb0f7db4f5d21df1a852a8239d469edf75f746db569ce28aca5d393ad33a25a248bd6e7583cb92aa0b8ffe382a47cde4091ebcc1a02b13e706dda64d03cfdb6493621c2fc76fe09b1bcab655f8f749ffa163a18cd64e1f0b3e98eb9f30f4010e988743e0d9ed951fc39ad15fa29bb921967a449990ab092d5eab9affefe748c8c0484eacf505b3bb0b4764cce31dd096f74535e7e2dbfd67f9fb81704c1dee58db9a23ac49e7bc940c2a73d27343eac3f20ce80394afb71b4b27c940faa8e1a58e2a1e7667d8ef42312026a669995824a83d22106e295372279ccb11880dddb37ffec806c3b28a64d0a2ee0b37e651371b03918d96512efbc825ac47f5637194dfad6cadc7f2a125d0e42575eb13bbd4fd98f70c79dfa036b9533a8b2c77afeca3859a25af49f08d75965a3dfdd31336ca149226713004a8d8c925ffebae3fd5cd982053996425013a15f6fdc90c340e5d011cd3da465fb7b573319b98a569424dc25be4c409ea0e926f1c0df2ed28bebecfcf425d6679a85823e19e5909efc51ed2fe7a88c84fff8a0707a4194439c8b9a3606649d51045e3773bfb8ef07521c3e9ba6aa1f9b625b12ab1f35ca3ec8ee01cb4e4a66119b5da3e754939581b89871b73c42f2388599dc47cca369efca7765b4b80d5d3bb48d65c53f50c463aa63a43b5104acc2d8c4243c6dfd31055b661f1679dc07add86cbfe809d6478bad7d0133849b4beb4a1e1994334fba6e5763e86200cd500f617bd2fce088c2eb8b03868255899fdf012398b8dba1a452a262e83da1c112810c182ffc50e2205f50354cc055aeb7b18036c65f76baf4c2bb6ea0bd7e7c1789240ab824d87adfffa7ad8474a924afd5d1acfbd4dc2ba67924fdb4c2c51cfe637c19bc1c6f8255cb401fb9b25427650084e64cc3971e85e4e907a58dfd41a5509fda4960eb7a1ac54aca86c234fc6e31bafa6b48ddf3f8e3f3f696d18ad4b89f30a9a123cd24e59505d5566c426449b6576c318f6f90d590b4c69b6231d4ead9006651e7f745b8535286b0a1e91e6bb1df1ddbd112545eb16dcd8b378903735302a5e063e7c4dc5e4155ca800a57a98ab781db35712afa2ff3c6cb26d2169b100b1c262e9ecf287e406b7ffa2263028c22dcc222890f51ede45518ecf05c2ca6d83d7ea39e4bee49b25cd2ac245938a3ec661f99c7cc8b9580ac135473ce865c4a16fa7e83f0242be62a47a3bd868e3f66c7c613b3ce3b6db7a2974b9aec4b9b5904acacb1598d5c38a9c3c5ff3bf500a11bd66da3eed8b18b6be82646f9a7e3fbd5e7299b2e7f7b2bdd578faed87340cd8fc28cf4699b41b37760df0dcdf4949ecc2277da526c5286d862eed151cc547513ea27186cea1e09220bfeb9c09e83210e78d261f30c6d393f76089ca75c93cc662308697c71766e7ae9223d395ddf7ed35edc3f043db7e6dee954b18ed33985f3bd56265248ac9a11cd3284ac4451837ab6cd0eb077391ffc53d91c11c373737a9f797ecdb85564d5b9a20fb15b6bd591e72d96b6d4663466de54f5bbfafd885e53fd05d43b77a2dffaad11e64545eaf6927ed5bd89b6448a8b59f8ceb1ad7032fc6dad396b84120a1c08300c8ca023b39e72052149314115a9727f63a5b143ba0f1c7469bf5b69faba82529067f6511325f2924f287c78ca89ede257fd4e794225e4d7e12d96a05ada172bdb5c4d648214e4d488688e595ab4ae76a3b46d39b3743b25a1e429af24d72f5cfbdf9c8109398c83e2cd1a5217d17bbb95fe6e342a174f6caac6e1298a3259e7cfc93f7cd67b75a2f0fca1ee5b4c4d01d7a28c49a6eb2fa7e133d4b193d65bf8bf41754c7cecc68759093d4e34819b0ea22da4474cb4336c2a3890344fa2b8afc6ea9a514c158901dcbe9502c75002acc2aaba289c2b7d2cfedcb62156b99ad45e8466678c9ff142a62c9ac9a624f8b9f932a1d8c88e5853ad454148bb2b56f9bcdaf1934b889fffa95a39dcc9a4a3bc07fb2878920f3e671b6a493de464b885c836f98de5f3639f218b69723b4935d0d5f06eae4204b1c842feab11b9033b60d6b253c78be82c065d22b679484a880309920074c4acfdf4e253281754c5e2969c4b0bf0dae82d40791b2eea67c6cef8c4cc7b33ab0cbc505f1ee80ffc8d8df05d71c159e928304384cd6c85d9bc1838d1594f2b69d37cbca1407560b6c40b71e6111b3e26f7892b02a25f2b30f413a9804409345aef97dfa53fdbf635f8f4f10f4840e1866012ca175c3214f42f8ecb048d1fada50ad4263fa8309e2b2f51cf5b8cea2846dfaf425ea0331b242d2ef06c9247ea48600d92388eacea920eb6ba3d054a3b7030938412ac2fd102794e747f74aa7c0fb235c4840d312777b6aeef771c8245160d76c520495065983a4a15cdd1871f045b90f329b56dd83efcb61adc324c83b6fd75ef6d1f5d52e91f5ec5e6cd46e4e586039c2ff0ecb321dd49b1c918c2fab532731c41dcb4dc430a316626f7348b0fa75fd8024fdc70139facca83c3785f15995da546efd6800b10398f230127912158e2069545e2e001a9efe0b90ba37742d0bec971c35eb34eac6b40dda40b9add92877608817cb9a504a876d939e0172bd92d6a3b39b86c78ce3615450e2b284fda2fb328aadbff3fbe4214367bc09413f49eea20b1b5335e23b57b5e9c2f2605ef4ec5d5b4d068be214a17be8ccf8b5fbf9e18290d549b5f09d2394d530af816dd31aa02ddd01dfd6d84ed47779c71fa05ae434752d335ad7c1e96e7c891ce73daec71615a661341e5eda33ffa4413d7c3a634f3c59081d9f76860f62c4726aec5b6caf2d5095dbb89a10d0f29221a0b45694eb1651c47448f4cb3c9e11b82526816a1007a7e4e0361920bb525a9102de01feedbcc84a00ab8046e8a9875ca43c02a4b0fdd2707592a12d5171c9933130cdfd92809743e03b1eb84bffe5d196219b10672ae4b0e21c679dcce0f1b53782c8296dd61ced90c150259720a5755cd09c782522c1ac5a428595edf01a3f48094e27de1c3f823c184d485681383f0ee9dae89a56f99bcfb2aaf14f8e1ef4b9d3d3ec06a21567782dd364a5bcfae405cb2bc21a47e737cae27173987a16b53c787dd6f28de78a677ce459f255088fc3c44d7fe3e36f157bf89619a87341af90a45781261225425021834eaac20f7c7712ec916aa892bca537349913a0ef58101a557a5577fd981c6801ae8e93794a768f88eb71b3b4011761982a7d2e79cdf090867ee923b66a29f950d24ea835f6c9a1a7b61a42d737fe90eb884d84f0332414721314395e09b1748da75434bd7e5244ca8c7ac130a028c07d2ead5621bf1f2575bf950ea6977f6f7a4bd5f4029b5c9077eda378c5211cece4ff62aa4f318ddf6374fa035c90e0b1e16615444252adab57298e9ddde709fc061515199101bde3269a582134d5ad27c2697a7d06c934e1992577f849e3a73546e08b93b6a1822b9947feeb3d48e5f24aa58fa5a825688d952e66721bc3245106b8fe37ca4c3500e0a52542db26e5c4b3c4cefc8fa1bd22b4ad6393d76f0a878b002b547aa52b5576d296e10210f54158a3b28e5625cdb1ba55351d61eff22566fdafafe9aed8d1dd3dd669adc8b8bb23e09aed22e11ed21f79bcc379925c13226caf2fdb68ad4b1399fea81e5dcd69cb12ba35659a62fcab3ae04c0417503826528f3466d9ceaae3dd42f006d11a4bb1dbfa61dcb3f563cb259cc35b015971989d3458fe5160ef4249d6440cf08f80aed4c42f55d011c29353baaaf367774e35d310b4cbeb4d83c038a5caff79e2df326cc95e95bc7bbfb02f6da5d99b7648ad8cfaa804c3ff7ab7cab23dbfbe1891c149cad022f86bebc419544b00d076f57cff2fcf1e5c787542caf2ec13515429ee9edef1531570ddd9755502099a595f49b3135350d07127c7bb8f11e9637030aa746fc869904af3a9785a36a328df7d8f31db9d48c1f8ddaef2a2b0ecccb5cea22d565275de8166dda1a01ffbb892c206fb316a8c44c3cc6faf0f0d5593e6790e6e99859a81223275df116eb3b7bc07cf2b91fb168b101e7f609e224a50907b39c2cc258f7e32a5fda591ca55f4f332be6bc0adc1eb27f9acca2fc2ec283b7ca7f35b47eaeef207c3d69b5046cd1f990680b3a2a145d1f9a5122afffb7637788f390006849f1cc7669d1752928494e00c1787fd63afb740b4ec9b7fa2b78d6db9a12e5ffadbce452d90c78329dc1ae3df546ef34a01d65426a3f69ee354f76678a13baf82c0ddf1bd69dfbab0f0e035303e1d811d882efdc35b470fe1f98c3420806ba176ac13e3de53137cdff039283556dbab7ed415e8a279753022dee53ffa781fd3ddc80ecda5d28a47a846846216b3e8e1e2a4fc1761c7b87411a4f8c9e356fc00bf4dee4b33ebbcd9848dd13877996a74c7c51d89a9cb6bf45752afa63ebdfec794b0790912031fa6ad16a96f63939a726dc46adf36f49fce1ee0045b727d39787c60196cf5b32bfa16174f76633169428c1425a88ea0986c346057dbb288c63f716ea07896289b321a7994cde7ca809333ba7c89a19b3f69c1beacfdbb30bf07d076c5324a6a2588fe19f981e7292d5636c510faec61945da81369d121bdfe2e8651161f347a2ede4875300f73a2ac015ec0113506d89fd9a9dd577c319599fa797674819991f755a579e82631ede984d8fc4712ef6c98563a1d54c373440712d76bda19818d1763a3bc83839e772defefd5f5c9d28f03e6507ab26304f9b01c68d9ac177cecf35f5bbd80e65e01c547d586944c61ba352667d2d3900f4281a93c94426d63e5f2a170efa7f312cfa49d398c25ee35a09fb7238085eb16acef15942150f725133f927503a1be56d70f291e680f7fda0a3d1b9ecc6ea9b2e391ca0287d78a2573bae220e48e83202e995a18358cf9f888ade436e1361b7d8751044f8898137361884c9d83c1af21c2239c1d1ba3308733e717cae751055cd736116fe8dff840f65e63595027957863827d3b3a6cc51ed3de013210f0cb2c5411c7bcc0b5a9a0217315314d6e57f01c88726b0c86c30dddf4a8cd070ad84af23b12e4b75409542313a336763c326026f73df91f18b62afc06aec3543c306cdecfe12babb050753a0be2f8f2b380bcc2b4ed43813770e1dbb34365be459005e8489f202b76ea85da1234c714e5b41b3fee0e60cb81b8c19c93e480d49f8cea4e4305754a2c00f98503b773e0f0388f20554a9ce4c985030b9fce12a65c33db305ec880f8372fa54e0afbfdf72aa743f7c9034fcd0f205898aed3809078867e5eba7698c80c9eb3fa60c39a03a19eefa8a723a438d67913e0b378da8444564c06f8bf5f9c5615bc198b9504494a698f10198d469040bfb3b1e231cf9920427f863585c832218e779e831296ca0422bdb3dd1b8f51c784d964c947d8a8e27b0973b9499c68587b98a28f6e8b825c66f8ee03ef4e9a5afc1e21340967c60570ebde929a3e6669132f9dd452f2a15876b0568b51c5649e95cd88f0cd58f61bc0d79601099da7ecfd8b94cdcea417badf808537a52367f014e405a935ef1421c03c727035fa275ff16035925e5fbdff3a65523d25c9eec21a4185019b9f225ac68f4300e085e843af6bad20143066d38164caa8d21d37b05b0fcfaf2d65aa3cf72b46235614a04345a4277ff571bbbcb38ca8d086aba52bb0462cd4696fd7a21b44a51301ba22f5fac69612c5d9543bec09dd370922ebd7a2a54be0136784be1cc1d61188e2208adfffc0a009e580275e2e5f61fc6f5e7061c674ad46bfbcc317eb54fe655ffecba18d9f4668c797c6eca382f39684b7e891a09e2c47cb4c45859d8878915f78766e758348f6771c03784518df5f1db74eda11dc0f2cc7fe5d1ac766ad051d245718bb5b56bbfbac5d0e38642c0d00bd7b1f3081aa1a8d640a6b4ae7db051d0d3f9420dc459e6bcb00e62a2d9ae4ce0c5e6876d7abc44cefcffde7a88c834b9d6864b0887623020adea215ec4cd8f9aa7bbe3a886e80d9e10b1dbdbf5c79ce11d7464f5b35631c93c969986fdf33de2b8568fe676545a192b581bb6ce6775d49f48fa329d3127b75beff8cadbad9fc06b558316ba5f08c79cb1bc2898592d8929d1a5cede9e1326eefda6814f1cfb4be0ddb8c91206e522ebaa1f3f8c3ff70be4a767f7ce34276f2344da4389d1eca77ea611d125a1585a771fac1f34624cb00e9ea027a7fc6f60936fb3e9cec340c0225548f5868bf47ff3202084adc4cfee209dc36ec99a82f61214a1a703baeb014e55865da817e04c9f4ff9726ce75b7566242e488e9ce40955b95acf63c3b581733d7fa008bc860cfda192117ea2cd0a7e6f31c910e7cc6c67286b86eab7fd8f2d9ef44d9f5540b1f49ebe012093389b38fa8eaa5a53bcbceec77d7e7c2d8542026e145fa00777c425e63c42195454c55b5b35e58b64ce8204b37055778e062540edfd689d90e8596172b9596bbdc6d94876239c9c11e61e6277e5ee29f811510716f5f59af166e228f3e7c86123db1747dc7072afb397e1bff57066cde9faa1f984cf2d693efcd613fe8b706720fd8458b960720537cfeaaefaf051a26a1ee7290919a6dcbec77feda65c7bc0337b5e6dc9e57380d75679ac447a86710f81258823c5b6279c47b61689b9000a2d8ea6ff9ba33a089f5903b3dfae12b27d3f4d24fd90dbccdee01ce0f0b68ae0c764202614dcd8809cbd1ba3898418ea5a1e418007fd15449770ca8de7040735c226809f065b9b8b19c0e85fc0afcd992af6d96c6711014392ae8f6c3f4584d71faf146665c9aa455970c5ec624822e3e766a6429c4d2463e642684267d0d2503697cb9d1e0565d26b6e9e250fa6a2acf216a03d28403004bcbf7f5770fcdce82b8d5a9e8054dbda6eb85b97d896146ed1905d0bc02a7c13faa9fefce00a831c613a40db76a7b6b289efdbfdce3d89055ab52027247bdcce1cbf294de022b485bdbfc00391a461e34353e32fbf2ee283d794d9675231a58b7ed0986908ece99c96e4e1c345416f75d4c0c7d0f5f762aaa3a89e30f26c63f44834d898fc06dbab562d3f7df58f83735dd0c3825b8a17c7876c3ad41e4c1dd9dce5befd614d6ef5341870861e1feef22579a4b9e743245a6b700898f1c0dccf5917d222fbc4537728ac30f3919e3e112a96622f1ace6234545e7de5ad55afd5b41f76b0e4559587f924965274f60d419e48b673b77b5ff1928194f51ecfb28a665dfb06b68b6f44613b0fa3fde3cbe44ee671aaf28501bcfa1314872c443e0d3f68e4d4ac7e5916c3ec80f2c5ae494fd7dab372c63ae81be2048c90da259fc01003d0badde5e01fc3dc87a67e4286b8ad02f699e29f8006396b459fb3cfa81145a63bbef48f04d0c71270693a8bccc23b7d166e0b95daae3ffa4ba5bd38e622981a4b17079f0b8c9247fe7eb05437eef83e5af8248c10b9bc87414485e130c587f11801bd0b86b456893563df5e4d69f4eac31bc047b183574b36a34d41b3c775d8b14dc2368fbe17ead21a2af44f5a3e9eef799e075cafe203e1eb5d7582f0b456f7b2a80a91fa4acf38f02956f15090a23bde1f7c592097ffd8385565521a845234a08417e5166137c0f7718e0c8f0918707d224d1234c12485b9a0156e511f650b20aa335ef67ac10d4af91a7f45cfbc7c0ef69816a5e199a59703073495c8f482e3615693a7403e7c91513377c04278080e37cb6515383b83897ade741ca53338648fe1b502b0625f1312af129e0d58f34143dc3a6fd9f208d96ad25661e380aa00e98c91d2958a5f4190911c646199f1dae5f935c3245e1986f23c8faa23f57e625bc54853ca85c3419ba3b9ccac70adbe0250a159ef2628f5dfb21fc165b990c3780645230ec6542e902055c8f2785fee6a422f9ad65b1ffbb4be982eb3cb37e0ffc4ddff8ec3a39691849de2acb2f23371e69774c33cf036696a9dfb424f389a3380d2cf1c7ff5ba920e257feafd4981416c9e94e0ad0df1a59b100adaefc0c25ef7f498bff8e82da0745c39ae5bdba15b8f3514ca18aebba67666859cb6c07ebcb1d07172b98a005f24c39192689eb842ab9f2f05020c75e07087a1486fb446318e77b223edac6243bc19a14c1dd01a466441bdeb5c9789df6b62466e900448f3c9f7877a077086b72de4bc65bdce4d58c1cbc93a94390bb55b9ad0204e362cef5ca1ef10eaf46a25173985bdaa53161eb296ecf8569920eb4f1d1af940c7ac9df792694770edec5f3c8a533106176e0fdf704f3d9f616c9f35575e939ea9740af2bc459fbc921701911d3dbb1088c4070898470b928b729da9e7bb0fa5a407757fdd97d8b18eaf124085fb6ec188c4004f390b797e3ce7819ba2fd9a6e5f7ae297a7931da45a4093a15020d9473e4654ce8a084dde989db2bfd44c3845553a92fb9c7b2e3ee50b6b2b515fa22ae604174c918b2e88cbd668b22fe04ad22b4594638bde6c2371955168338fa99007687763657fffff0b7a9f72cfb3bbb03ac40e03c3b45c9b03bdd65b5cd9b8355767aa795570d2140f11490642fdf7677ba93a0ca0417f674654044ee836382fea36e4455edd6618b7320fe7a3278660d2d80190d3a77775f189c5e7086864b17fb456fef787cbcd276a32cf224be1af7dcde05dd1e2d134bb4be2e82103960ce7525ca1364fc85653dbd3c5a06e459dc06456790a5d0b6a0f71781694f69380532ac54f2758ede8cf45131f82a5744e8bc6d9930d747348c8781da9738b0571dd35cd90c7fcdcb74d35e6d9636fe28edea8b348ed55243ab00a3c6a235204ca4dd6665cce94488c8cbb2db150ddbc9d2273ce7173a88c69f70b3bc219fdcdb9d64ebb3def57259f723e5e492e687d3538755db4cc7152ac3b005b189abc046273222607e346d7dc1fa5141773fd8c3e26b6a2c3a068f801dd8ebf97b89015f9ee8ad9eb54e3df082f1ba9f4cc1694e56e8b826d611b54a9da3195eed05589015ca74fd52ee88d8de4c67b61de91e4ee7e3d54b2974f85bfa8fad4a1eed3e9f4b352a99199e4338d7f3b41949fa03fb0edd3ebeae54c83a8839b1104182454b05d503ae1ea74a60649a5e6638bf36ab2fb338696a2c42a576f4efe1cb07c52435cbd96c0cb0ca7b38b520da65b6a7d1f107848f04843eb0c99556256db8de3e1eb7b708a2aa0bfededebba706d3b794d5ea9453b00407c02530f12e817396a7b49a09c135308797608e88829848ddeb3edc2584bef037bd3faea684a96ee0cef8cd09e60bd3cca6c3c3a4e41366ac79dde216b7b9a6cc5e69ffc4d51772cfb57202ef976438923433b4386ea0b792c808e3cd74f92368939584eb22ad870a4b78191705f6854ee35583113a9b4dd388dcb20831ef13f121798079259e9bd8dd59272c1a393a14f63031c227837d37d0d0866512d5a4cdf76eafd1ec3db857e352e96b3b0d49d10a57390a548c79c212f4e9ef1d291608c446b85eab5b9c5aa6c52915664603c7bef1cfe79a32784fa76bb93aaaa97c56c309396a134c03fb59541aa13afd6b25533b8864bb0385985f920704ecf71e0a50d836db9d3a65801a19f60921cb12993a51de6fe833f72386f09c243ca0840159c78dd308c46fbfe07be4c1ee54d346eca5809928ac25ba0b20474b2149bcaab5a317ab92eb0187d83fb85e238e78d16089ef488ae35d395452406a2fe91b95544b222bd9fdbc81c71420188ba7da57ea981459209b875cbf9a376b68a904da1079f4925dcd4796c199ee69ace26e4f14346455ccdb05b46b299f672dcdbc66b35ac00ca946caf0a4802e42dbfb498687b1fa9e1adab17cdbf3a8a36c78056eabf5b3b5d1ec1cb7715d49038c52298fbeadcf9513f00f27a458ee29e94b144840ad6f21a26bf9de95ef9a63cc927902b3c2d40f83e1731bf2aac8524a8934f4a3ffd5ebd207a9309d01ee0af3ed680d29cab85d5a7c41b0f32450317cd631090ebaf1a96e5cfd4af682fd483a6118ed7ac667c8e4e1492851973294d1e3a04931c5fccddf2d6206a8169cb170a4029db2d4f1cd02ffd9e349aa57beda045fc645f9c62a5e987d6dd86920b56e8b283cd1220506131670ca7d4c37ec7d6130b2e2eef94f6193b460e842150b3a886daf1766470b204a4a82d63e21e0fb81174cec7bd1bc292325d70c82056a3fc99b36d7271dbbe205eea5f86860018b38c8115aef63f118c246f9c0f3d7fa7b6b681bd38631d806b813a2cfc9c7a92e0a7cb5ebe9aa482bde93d583c58c7c1fe25acd180b66588dd3d009fd46f470e715be558e279b5cdda98c4b8a60b40b7f13da1d5f8d5fe227cb1a51990efa347d76671ded78abea6bc4abc492d83556f7393309f05fa91528b0bdd3ddd878a8b501aa86788d97b8a340610a1d79b920936607a9f422e6eb5a265dd3277fa06dceb85286424043590040148343e393609340d9746fbdca684d162e44130bfbc463f10f3b0404cf425885576641a3ff75de7926275ae8deddee95c3a6ec502341db1c847d36e7e02cd4d2f0f5abc13dfdad9dcae8f78a99d9ea1acf0368fde033cb2ff8e9d0eede7679ecae4cb61865498d322f207c0c29b73e6f73e460ca615941eee7ec5a58fce4f5cd5d6c88c19a8f6fcceeaf706fc5cc363923783c2b2f4f222793635000191b45604ad37e270b5ac070fad124d4131871e92f9fcbf656d05957a01df0f08ac7c2fa103cd134d4d947c8f3a7742fe469065903b97bd062c3bc7c5db8d5c39eaa0705d407fdb5abdbe58f7946ce59f60f95679a052e54a7e4ed44ef2b4621192ee5d801f60a4ddd9f401a36e61eb53493fb6ae36977f569c3aaf340218d3342988ff303519442c66628468c0fffb814ae90526f9d5a9e6d76a80584f000b3b02e9fa8f4ddfc5a7f01570427ea4f867ac2ffb67837f12094cd915a28450b2bdd81ce8ece452aaa3905d24941d878289a9003a86e39374d813d1c607d002e5a2d1a8bc25c49ccb0c4354c27c094e575eb10e1cfb0e07dc664984bd374c4caa008ab47b6333128ca2387166f592f7a8b964b1326fb975c3515927285bef82d50e1eecf9b8691d08dadf08f15b0ee1d8bfc0e9c2548e3cfb9010d97185bad3b15f1c16fdf395536f2fe22413e2a9e6662e5339ab0ce9c42c33e05f64a2c8d1dcca79e60d9868a88215e732d13eafecaf6460b8fc452fdff0cb24cf835773b0323b2e4cc5deffb377feb7242b74847973e0001e9710072f7db57f3defa5ae7a894bcf240a41548c80f42a742c7898e5a8a3c36fc5f0278d3a9abe4033a98ba6c12deabd11ae02e14778c2404c6de5f6fbefd0c3a6356701fdfb4df2c1d878f60072dbe5af37d7e50eb85cbc3f1b58407ea01efced4032af1a3fc7f02e9cb836bd3e7e4872760bf9ccbeb7ef6918785124cfa68e313c2bff8f062e35a6255babaa923a55267eb74d438bd28d2d47e8771703b60add47af43b51abee66971133c3785dc194b30d6ca9dd46e457a59b1ea9a13f64c7d59c2f638ae1cb8c8d737314e49cc0344ed1fbca5207dc810f1d6b5135ccf2fc9eb326da12bd20596750d61eba4923f948eda9e1398c23fa7043f5596cf0fbf09d33e50cfd344b890153c1388baa2947a0a2d3db2a0b9f241c6c8230d236f60d21f2244d1e780158fdc73c22e89e261773b5606e07e9d08d373fa8d5fad943789f094ebc1ba90cc6930a4bdf5041376ab7126c2b94a72dbf217044e3c7e6e8f7b397621b6ba4c9f28a99dfc0d37510d11d4b0f9058f7a8ec7eadc9e220bf2e88f23a2da34c1841297a88cac18ccf7c5b407d5370da0f89a8c45611c18aa466b02b1728401e82a161196c6d4b1bed8452de2bbff66e7094f6961ecd46425b7d446940e6bbbdd972298f46e1e71d437e193e568120b13a74a5445c1062bc0277fb592bf3eee3f60b08857a93abbe34eb442f7219f8e2d03440c5bda8b01af0db025bf97a1ff1035e9e3ebc436f1bd289f3188028800288244abf700157abe7cbc4d3f96e8ad95cc7378fd6ff7d5b820027a692b43f3a0fd9933ab77f43427d9a4631bc62847a71c23e87ab967094048eb218d4f6e264e06cf8e86d980181fb9145afb410445c86cee9a14dd2f586ac371f9f0859535bda63c210b1c7e161d74120803c5b3447aa03a9dbd0f7cc38ff1fc8145f56993c69bacbad9dea0c5e58a21e4b2b3e01fc2f1f00ee36c8ddea416f0964b4bf4fd68aa2598daa4ccf247f783b53dd6bf0c35e9786379d5916ba5f8456f1039b4465d9cc5ed2348053e1feedc16c07a40a3930bc43098a07ff90ed68340eac7bf31be53f0112cc</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 请输入密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>加密</category>
      </categories>
  </entry>
  <entry>
    <title>系统设计与架构</title>
    <url>/2022/11/01/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>系统设计与架构常见题整理</p>
<p>GitHub地址：<a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md">点击跳转</a></p>
<h4 id="1-如何设计一个短链服务"><a href="#1-如何设计一个短链服务" class="headerlink" title="1. 如何设计一个短链服务"></a><font color=DarkOrange>1. 如何设计一个短链服务</font></h4><p>参考链接：<a href="https://mp.weixin.qq.com/s/33lcKX3bLUAC-Mj0VlXa6A">点击跳转</a></p>
<h5 id="1-1-短链的价值"><a href="#1-1-短链的价值" class="headerlink" title="1.1 短链的价值"></a><font color=DarkOrange>1.1 短链的价值</font></h5><ul>
<li><strong>更加简洁：</strong>比起一长串无意义的问题，只有差不多 10 个字符的字符串显然更加简洁</li>
<li><strong>便于使用：</strong>第一，有些平台对内容长度有限制（微博只能发 140 个字），此时短网址就可以输入更多内容。第二，我们将链接转为二维码时，短链接生成的二维码更容易识别。第三，有些平台无法识别特殊的长链参数，转为短链就没这个问题</li>
<li><strong>节省成本：</strong>当我们需要发短信的时候，短信是按照长度计费的，短网址可以节省成本</li>
</ul>
<h5 id="1-2-短链的原理"><a href="#1-2-短链的原理" class="headerlink" title="1.2 短链的原理"></a><font color=DarkOrange>1.2 短链的原理</font></h5><p>当我们输入短链时，其实访问的是短链服务器的地址。短链服务器获取到对应的长链地址之后，返回一个 302 的 HTTP 响应，在响应中包含了长链接地址。浏览器收到响应后，转而去请求长链接地址。 访问短链的整个流程如下图所示：</p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7qyiustgcj30e307zq3t.jpg" alt="image.png" style="zoom:90%;" /></div>

<p>从上面的流程中可以知道，短链涉及到的技术原理主要有两点，分别是：HTTP 重定向和短链服务的设计</p>
<p>对于 HTTP 重定向来说，301 和 302 都是重定向：</p>
<ul>
<li>301 代表永久重定向。它表示第一次拿到长链接之后，下次浏览器如果再去请求短链的话，不会再向短链服务器请求了，而是直接从浏览器的缓存中获取。</li>
<li>302 代表临时重定向。它表示每次请求短链都会去请求短链服务器，不会从浏览器缓存中获取</li>
</ul>
<p>如果我们希望统计短链接的点击次数信息，从而来分析活动的效果的话。那么我们就需要使用 302 重定向码，这样才能获取到每次的请求数据。 一般情况下，我们都是需要获取到请求的数据的，因此对于短链服务都是用 302 临时重定向</p>
<h5 id="1-3-实现思路"><a href="#1-3-实现思路" class="headerlink" title="1.3 实现思路"></a><font color=DarkOrange>1.3 实现思路</font></h5><p>系统的处理流程：</p>
<ol>
<li>用户访问短链生成页面，输入长链字符串，短链服务返回生成的短链</li>
<li>用户访问短链，短链服务返回 302 响应，用户浏览器跳转到长链地址</li>
</ol>
<p>如果我们要实现上面的系统流程，我们大致的处理思路是：</p>
<ol>
<li><strong>生成短链。</strong> 生成短链时，短链服务获取到长链，随后生成一个短链，并把短链与长链的映射关系保存下来，最后将短链返回给用户</li>
<li><strong>找到长链。</strong> 访问短链时，短链服务获取到短链，根据短链去获取到长链，返回返回 302 响应</li>
</ol>
<p>根据上面的分析，我们可以知道短链系统设计主要得解决如下两个问题：</p>
<ol>
<li>如何根据长链生成唯一短链？</li>
<li>如何保存短链与长链的映射关系</li>
</ol>
<p>对于第 1 点，我们有 2 个思路生成一个唯一短链，分别是：</p>
<ol>
<li>使用哈希算法生成唯一值</li>
<li>使用分布式唯一 ID 生成作为锻炼 ID</li>
</ol>
<p>对于第 2 点，保存短链与长链的映射关系，考虑到持久性的问题，我们肯定需要落库，所以使用 MySQL 表保存即可。如果有需要的话，可以在 MySQL 前做一层缓存。因此第 2 点相对来说比较简单</p>
<hr>
<h6 id="1-3-1-哈希算法生成短链"><a href="#1-3-1-哈希算法生成短链" class="headerlink" title="1.3.1 哈希算法生成短链"></a><font color=DarkOrange>1.3.1 哈希算法生成短链</font></h6><p>要生成一个短链，我们可以将原有的长链做一次哈希，然后就可以得到一个哈希值，计算哈希值会遇到如下2个问题：</p>
<p><strong>使用什么哈希算法</strong></p>
<p>我们都知道哈希算法是一种摘要算法，它的作用是：对任意一组输入数据进行计算，得到一个固定长度的输出摘要。我们常见的哈希算法有：MD5、SHA-1、SHA-256、SHA-512 算法等。但我们最好还是使用另一种叫做 MurmurHash 的哈希算法。为什么呢</p>
<p>因为 MD5 和 SHA 哈希算法，它们都是加密的哈希算法，也就是说我们无法从哈希值反向推导出原文，从而保证了原文的保密性</p>
<p>但对于我们这个场景而言，我们并不关心安全性，我们关注的是运算速度以及哈希冲突。而 MurmurHash 算法是一个非加密哈希算法，所以它的速度回更快</p>
<p><strong>哈希冲突</strong></p>
<p>学过 HashMap 的同学都知道，哈希冲突是哈希算法不可避免的问题。而解决哈希冲突的方式有两种，分别是：链表法和重哈希法。HashMap 使用了链表法，但我们这里使用的是重哈希法</p>
<p>所谓的重哈希法，指的是当发生哈希冲突的时候，我们在原有长链后面加上固定的特殊字符，后续拿出长链时再将其去掉，如下所示</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">原有长链：https://mp.weixin.qq.com/s1caec8eb1b81d6ee5dd7b</span><br><span class="line">              ↓↓  </span><br><span class="line">           发生哈希冲突</span><br><span class="line">              ↓↓  </span><br><span class="line">补上特殊字符：https://mp.weixin.qq.com/s1caec8eb1b81d6ee5dd7b[SPECIAL-CHARACTER]</span><br><span class="line">              ↓↓  </span><br><span class="line">           再次进行哈希</span><br></pre></td></tr></table></figure>

<p>通过这种办法，我们就可以解决哈希冲突的问题了。如果再次发生，那么就再进行哈希，一直到不冲突位置。一般来说，哈希冲突的可能性微乎其微</p>
<p>好了，现在我们通过哈希算法得到了一个哈希值：<code>29541341303115543223957290326355</code>，变成了这样：<code>http://dwz.com/29541341303115543223957290326355</code></p>
<p>有没有办法让网址变得再短一点呢</p>
<p>我们知道在网址 URL 中，常用的合法字符有 0～9、a～z、A～Z 这样 62 个字符。如果我们用哈希值与 62 取余，那么余数肯定是在 0-61 之间</p>
<p>这 62 个数字刚好与 62 个合法网址字符一一对应。接着，我们再用除 62 得到的值，再次与 62 取余，一直到位 0 为止。通过这样的处理，我们就可以得到一个字符为 62 个字符、长度很短的字符串了</p>
<p>上面讲有点晦涩难懂，我们来举个例子。假设我们得到的哈希值为 181338494，那么上面的处理流程为：</p>
<ol>
<li>将 181338494 除以 62，得到结果为 2924814，余数为 26，此时余数 26 对应字符为 q。</li>
<li>将 2924814 除以 62，得到结果为 47174，余数为 26，此时余数 26 对应字符为 q。</li>
<li>将 47174 除以 62，得到结果为 760，余数为 54，此时余数 54 对应字符为 S。</li>
<li>省略剩余步骤</li>
</ol>
<p>整个处理流程如下图所示：</p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7qyyjct7rj30ia0bk405.jpg" alt="image.png" style="zoom:90%;" /></div>

<p>可以看到，我们把 181338494 这个十进制数，转成了由合法网址字符组成的「62 进制数」—— <code>cgSqq</code></p>
<p>到这里，我们不仅生成了短链，还将短链的长度极大地缩短了</p>
<p>这就是使用哈希算法生成唯一锻炼的全部内容了，我们总结一下：<strong>首先，使用 MurmurHash 生成哈希值，并且用重哈希法解决哈希冲突的问题。接着，将 10 进制的哈希值转成 62 进制的合法网址字符，从而缩短网址长度</strong></p>
<h6 id="1-3-2-分布式-ID-生成短链"><a href="#1-3-2-分布式-ID-生成短链" class="headerlink" title="1.3.2 分布式 ID 生成短链"></a><font color=DarkOrange>1.3.2 分布式 ID 生成短链</font></h6><p>上面使用哈希算法生成唯一短链的方式，相对来说是比较形象的。但其实我们也可以用分布式 ID 的方式，来完成唯一短链的生成</p>
<p>例如第一次请求的长链，我们为其生成一个唯一 ID，将其长链与唯一 ID 对应起来。第二次请求，我们再为其生成一个唯一 ID，再次将长链与唯一 ID 对应起来，如下所示。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">第一次请求：https://mp.weixin.qq.com/s1caec8eb1b81d6ee5dd7b</span><br><span class="line">              ↓↓  </span><br><span class="line">生成短链：https://dwz.com/1021000001</span><br><span class="line"></span><br><span class="line">第一次请求：https://mp.weixin.qq.com/s1caec8eb1b81d6ee5ff7b</span><br><span class="line">              ↓↓  </span><br><span class="line">生成短链：https://dwz.com/1021000002</span><br></pre></td></tr></table></figure>

<p>因为生成的唯一 ID 也可能非常长，因此我们可以采用上面同样的方式，将 10 进制的唯一 ID 转成 62 进制的合法网址字符，从而缩短字符长度</p>
<p>那么接下来的问题就变成了：如何设计一个全局唯一 ID 发号器了</p>
<p>对于如何设计一个全局唯一的 ID 发号器，就属于另外一个话题，我们这里就不深入探讨了</p>
<h5 id="1-4-性能优化"><a href="#1-4-性能优化" class="headerlink" title="1.4 性能优化"></a><font color=DarkOrange>1.4 性能优化</font></h5><p>看到这里，我们基本上有了一个完整的思路：拿到长链地址后，可以用哈希算法或唯一 ID 分号器获取唯一字符串，从而建立长链与短链的映射关系。为了缩短短链长度，我们还可以将其用 62 进制数表示，整个短链生成过程如下图所示</p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7qz2vgn49j30f10d3gn7.jpg" alt="image.png" style="zoom:80%;" /></div>

<p>短链生成完，并且已经存到了数据库中，接下里该使用了。通常的做法是会根据请求的短链字符串，从数据库中找到数据，然后返回 HTTP 重定向原始地址。而在不断使用过程中，还有一些可能发现的优化点，这里简单讲讲</p>
<ul>
<li><p>索引优化</p>
<ul>
<li>如果使用关系型数据库的话，对于短链字段需要创建唯一索引，从而加快查询速度</li>
</ul>
</li>
<li><p>增加缓存</p>
<ul>
<li>并发量小的时候，我们都是直接访问数据库。但当并发量再次升高时，需要加上缓存抗住热点数据的访问</li>
</ul>
</li>
<li><p>读写分离</p>
<ul>
<li>短链服务肯定是读远大于写的，因此对于短链服务，可以做好读写分离</li>
</ul>
</li>
<li><p>分库分表</p>
<ul>
<li>如果是商用的短链服务，那么数据量上亿是很正常的，更不用说常年累月积累下的量了。这时候可以一开始就做好分库分表操作，避免后期再大动干戈</li>
<li>对于分库分表来说，最关键的便是根据哪个字段去作为分库分表的依据了。对于短链服务来说，当然是用转化后的 62 进制数字做分表依据了，因为它是唯一的嘛</li>
</ul>
</li>
<li><p>防止恶意攻击</p>
<ul>
<li><p>开放到公网的服务，什么事情都可能发生，其中一个可能的点就是被恶意攻击，不断循环调用</p>
</li>
<li><p>一开始我们可以做一下简单地限流操作，例如：</p>
<ol>
<li>没有授权的用户，根据 IP 进行判断，1 分钟最多只能请求 10 次</li>
<li>没有授权的用户，所有用户 1 分钟最多只能请求 4000 次，防止更换 IP 进行攻击</li>
</ol>
</li>
<li><p>简单地说，就是要不断提高攻击的成本，使得最坏情况下系统依然可以正常提供服务</p>
</li>
</ul>
</li>
</ul>
<h5 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a><font color=DarkOrange>1.5 总结</font></h5><p>在短链服务的设计思路上，最重要是解决两个问题：根据长链生成短链、根据短链找到长链。在根据长链生成短链的思路上，有两种实现思路，分别是：哈希算法生成短链、分布式全局 ID 生成短链，其中哈希算法涉及到哈希算法的选择，以及哈希冲突的处理</p>
<p>最后还列举了一些短链服务后续可能的优化点，包括：如何让网址变得更短、索引优化、增加热点数据、读写分离、分库分表、防止恶意攻击等等</p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7qz95bl1zj30u00l77d9.jpg" alt="image.png" style="zoom:100%;" /></div>

<h4 id="2-如何设计一个秒杀系统"><a href="#2-如何设计一个秒杀系统" class="headerlink" title="2. 如何设计一个秒杀系统"></a><font color=DarkOrange>2. 如何设计一个秒杀系统</font></h4><p>参考链接：<a href="https://mp.weixin.qq.com/s/kWqgzMw4qKek7QUfkDSwNg">点击跳转</a></p>
<p>秒杀系统的设计是高级职位面试中非常高频的一道题目，它可以较好地考察候选人的知识体系情况。对于我们来说，学习秒杀系统的设计，能够让我们学以致用，设计系统的时候考虑得更加全面</p>
<p>活动一般出现在电商的促销活动中，一般是指定了很少数量的商品，以极低的价格，让大量的用户参与，从而造成大量用户在极短的时间内参与活动，进而造成系统在极短的时间内有极高的流量。系统设计的目的是使系统能够稳定地支撑活动的进行，因此其稳定性、高可用是我们考虑的第一位</p>
<p>要知道如何进行秒杀系统的优化，那我们需要先对请求的整个流程有个全局的认识。<strong>一般来说，秒杀活动请求以公网为划分点，可以分为：前端部分、后端部分。</strong> 前端部分指的是从用户端到进入后端服务前的部分，包括了移动端的处理、DNS 解析、公网的数据传递等</p>
<p>后端部分指的是经公网进入了后端的服务器网络里，包括了前置的负载均衡（Nginx 等）、应用服务器、数据库层等。秒杀活动的整个流程可以用下图来表示</p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7qzrdanrnj30r90bpn04.jpg" alt="image.png" style="zoom:80%;" /></div>

<p>我们要去设计一个秒杀系统，那自然也是从这两大部分来进行优化。整体思路是尽量将流量挡在前面，让尽量少的流量留到后端部分。因为越往后端，我们的处理逻辑就越重，其处理能力也越弱</p>
<h5 id="2-1-前端优化"><a href="#2-1-前端优化" class="headerlink" title="2.1 前端优化"></a><font color=DarkOrange>2.1 前端优化</font></h5><p>对于前端部分来说，常见的优化手段有：页面静态化 + CDN、请求频率限制</p>
<h6 id="2-1-1-页面静态化-CDN"><a href="#2-1-1-页面静态化-CDN" class="headerlink" title="2.1.1 页面静态化 + CDN"></a><font color=DarkOrange>2.1.1 页面静态化 + CDN</font></h6><p>一般来说，活动页面是流量最大的地方。活动页面上绝大部分内容都是固定的，比如：商品描述、图片等。这时候没有必要每次都去请求服务端，而是将这些静态的内容放到 CDN 上</p>
<p>每次打开页面的时候，直接去请求 CDN 服务器，能极大地减少后端的请求流量。加入了 CDN 之后，其请求过程如下：</p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7qzu0en0vj30k105ldh2.jpg" alt="image.png" style="zoom:100%;" /></div>

<p>所谓的 CDN 就是内容分发网络，它由非常多台分布在世界各地的缓存服务器组成。每次用户请求特定域名的时候，会转发到对应 CDN 的 DNS 解析服务器，随后会返回一台离用户地理位置最近的一台 CDN 服务器</p>
<p>随后，用户直接请求这台 CDN 服务器获取数据，从而极大地减少了长途网络传输的时间，并且也减少了后端服务器的压力</p>
<p><strong>因此，对于秒杀活动设计来说，我们可以将所有可以静态化的内容全部静态化，然后将其配置在 CDN 服务器上。这样既提高了用户打开页面的时间，又减少了后端服务器的压力</strong></p>
<h6 id="2-1-2-请求频率限制"><a href="#2-1-2-请求频率限制" class="headerlink" title="2.1.2 请求频率限制"></a><font color=DarkOrange>2.1.2 请求频率限制</font></h6><p>请求频率限制，指的是根据业务的特点，在前端做一些流量拦截，减少后端服务器的压力。常见的拦截方式有：</p>
<ol>
<li>设定一个请求概率，只允许 30% 的概率向后端发送接口请求。</li>
<li>设定一个请求频率，例如 10 秒钟只能请求 1 次，随后按钮置灰</li>
</ol>
<p>通过这种方式，我们可以减少很大一部分流量。但在具体实现的时候，可能需要考虑安全问题，预防某些用户直接调用后台接口，绕过前端的频率检查</p>
<p>常见的方法是在频率检查时生成一个参数，随后请求后端服务时携带上该参数。没有该参数的请求，都视为非法请求，直接拒绝该请求</p>
<h5 id="2-2-后端优化"><a href="#2-2-后端优化" class="headerlink" title="2.2 后端优化"></a><font color=DarkOrange>2.2 后端优化</font></h5><p>无论我们做多大的努力，始终还是会有不少流量会来到后端服务器这里。一般来说，后端的优化有如下几种方式：</p>
<ol>
<li>增加缓存层 + 预热数据</li>
<li>MQ 异步处理</li>
<li>限流、熔断、兜底</li>
<li>业务侧优化</li>
</ol>
<h6 id="2-2-1-增加缓存层-预热数据"><a href="#2-2-1-增加缓存层-预热数据" class="headerlink" title="2.2.1 增加缓存层 + 预热数据"></a><font color=DarkOrange>2.2.1 增加缓存层 + 预热数据</font></h6><p>如果我们所有数据都去读取数据库，数据库可能无法承受较大的流量，此时一个常见的优化就是增加缓存层</p>
<p>当我们需要查询数据库之前，我们先去查询缓存，这样可以减少绝大部分的数据库请求，减轻数据库压力。如果在缓存中找不到数据，我们再去请求数据库，随后再将数据缓存到缓存中</p>
<p>在引入缓存层的时候，我们需要考虑缓存击穿、缓存穿透的可能性，在写相关代码的时候就要做好这些优化。另外，我们在秒杀活动开始之前，可以手动将热点数据加载到缓存中，从而避免秒杀时去请求数据库</p>
<h6 id="2-2-2-MQ-异步处理"><a href="#2-2-2-MQ-异步处理" class="headerlink" title="2.2.2 MQ 异步处理"></a><font color=DarkOrange>2.2.2 MQ 异步处理</font></h6><p>我们知道秒杀活动一般涉及抢购、下单、支付、发货等阶段，而抢购与后续的几个阶段是可以异步执行的。为了避免对下单、支付、发货等阶段产生影响，我们可以将抢购阶段与后续阶段用 MQ 进行解耦处理。当用户抢购成功后，往消息队列中丢入一台消息，随后再由订单系统消费进行下单处理</p>
<p>通过各系统之间的解耦处理，我们可以将原本同步的处理方式变为异步处理，从而大大的减少了请求的处理时间，提高了系统的并发处理能力。其次，也能避免系统之间相互影响，提高了整体系统的稳定性</p>
<h6 id="2-2-3-限流、熔断、兜底"><a href="#2-2-3-限流、熔断、兜底" class="headerlink" title="2.2.3 限流、熔断、兜底"></a><font color=DarkOrange>2.2.3 限流、熔断、兜底</font></h6><p>我们可以在每个业务系统做限流操作，从而避免因为请求太多，导致整个系统都无法工作。当并发请求在正常范围内时，我们正常处理请求。当超过设置的限流阈值时，我们则直接拒绝该请求，提示用户抢购失败</p>
<p>如果没有限流操作，那么系统直接崩溃了，一个请求都处理不了。而通过限流这种方式，系统至少还可以保持正常工作，而不至于一个请求都处理不了。而超量的需求，本来就处理不了，因此提示失败也是情理之中</p>
<p>除了限流之外，不同的系统还可以采用熔断、降级的服务治理措施</p>
<p>熔断指的是请求的错误次数超过阈值时，不再到用后端服务，直接返回失败。同时每隔一定时间放几个请求去重试后端服务，看看是否正常。如果正常则关闭熔断状态，如果失败则继续快速失败。<strong>熔断的目的是避免因下游短暂的异常，导致上游不断重试，最终造成下游有太多请求，最终压垮下游系统</strong></p>
<p>降级指的是当服务失败或异常后，返回指定的默认信息。<strong>降级的目的是保证有基本的信息，当下游异常时，与其返回空信息，不如返回一个有业务含义的默认信息，可以提高用户体验</strong></p>
<h6 id="2-2-4-业务侧优化"><a href="#2-2-4-业务侧优化" class="headerlink" title="2.2.4 业务侧优化"></a><font color=DarkOrange>2.2.4 业务侧优化</font></h6><p>一般来说，经过上述的整体优化之后，系统已经能够比较稳当地应对秒杀活动了。如果此时还是流量比较大，那么或许应该从业务侧去进行优化了</p>
<p>例如 12306 刚开始的时候，购买时间都在同一时刻，这导致同一时刻并发量太大，系统经常支撑不住。后来 12306 将购票周期放长，可以提前 20 天购买火车票。通过业务侧的优化，我们将本来在 1 个小时的抢购分摊到了 20 天，服务器压力一下子降低了 480 倍</p>
<p><strong>因此从业务侧进行优化，是一个四两拨千斤的办法，可以极大地降低技术侧实现的难度</strong></p>
<h5 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a><font color=DarkOrange>2.3 总结</font></h5><p>设计一个秒杀系统，整体而言可以从前端与后端进行优化。</p>
<p><strong>对于前端优化而言，可以从「页面静态化 + CDN」、请求频率限制进行优化</strong></p>
<p>其中「页面静态化 + CDN」指的是将不变的静态数据固定下来，然后放入 CDN 服务器，从而降低用户请求的响应速度，降低服务器的并发压力。请求频率限制，则是通过抢购概率与抢购频率限制，降低后端服务器的服务压力。</p>
<p><strong>对于后端优化而言，一般有「增加缓存层 + 预热数据」、「MQ 异步处理」、「限流、熔断、降级」、业务侧优化这 4 种优化方式</strong></p>
<p>其中「增加缓存层 + 预热数据」指的是将热点数据存入缓存，并在活动开始前提前加载到缓存中，降低数据库层的读取压力。「MQ 异步处理」指的是对于非必要的业务逻辑，通过 MQ 进行异步处理，降低请求处理延时，同时提高业务系统整体稳定性</p>
<p>「限流、熔断、降级」是对于整体微服务的保护，其中限流指的是对请求进行限制，当超过限流阈值时，直接拒绝请求，保护系统本身；熔断指的是保护下游系统，当请求下游系统连续错误超过阈值时，自动不去请求下游系统，避免因重试流量过大击垮下游系统。</p>
<p>降级指的是当请求失败时，自动返回默认数据，提高用户体验。业务侧优化，则是指从业务层面去进行逻辑优化，从而降低技术复杂度，使得业务与技术复杂度达到一个平衡的状态，有利于更好地实现秒杀系统的高可用与高并发。</p>
<p>上面说到的 6 个优化思路，是设计秒杀系统常见的优化思路。<strong>但在实际业务场景中，除了要保障正常的功能设计之外，还还考虑防刷、安全、黑产等问题</strong>，此时可能需要多考虑一些其他优化，例如：黄牛利用抢购工具抢购，导致正常用户无法抢到商品等</p>
<p>这时候可能需要考虑增加验证码，用 App 设备指纹等风控措施。<strong>此外，对于秒杀系统而言，做好业务指标和系统指标的埋点监控也是非常重要的</strong></p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7r06ob49vj30u00e145t.jpg" alt="image.png" style="zoom:100%;" /></div>



<hr>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>系统设计与架构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法面试题</title>
    <url>/2022/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>常见高频面试数据结构与算法题</p>
<hr>
<p><strong>出现的频率从上到下依次递减</strong></p>
<h4 id="1-反转链表（Go）206-容易"><a href="#1-反转链表（Go）206-容易" class="headerlink" title="1. 反转链表（Go）206-容易"></a><font color=DarkOrange>1. 反转链表（Go）206-容易</font></h4><p><strong>题目：</strong></p>
<p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输入：head = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输入：head = <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：迭代<br>假设链表为 1→2→3→∅，我们想要把它改成∅←1←2←3</p>
<p>在遍历链表时，将当前节点的 <code>next</code> 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用</p>
<div align="center"><img src="https://i.bmp.ovh/imgs/2022/06/21/935d47f8204310d8.png" style="zoom:50%;" /></div>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 是链表的长度。需要遍历链表一次</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ListNode 定义单链表</span></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Value <span class="type">int</span></span><br><span class="line">	Next  *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Solution 反转单链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Solution</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">	<span class="keyword">var</span> prev *ListNode</span><br><span class="line">	curr := head</span><br><span class="line">	<span class="keyword">for</span> curr != <span class="literal">nil</span> &#123;</span><br><span class="line">		next := curr.Next</span><br><span class="line">		curr.Next = prev</span><br><span class="line">		prev = curr</span><br><span class="line">		curr = next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateListNode 使用slice生成单链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateListNode</span><span class="params">(nums []<span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">	<span class="keyword">var</span> head ListNode</span><br><span class="line">	<span class="keyword">var</span> pre ListNode</span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		node := ListNode&#123;Value: num, Next: <span class="literal">nil</span>&#125;</span><br><span class="line">		<span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">			head.Next = &amp;node</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> pre.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">			pre.Next = &amp;node</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			pre.Next.Next = &amp;node</span><br><span class="line">			pre = *pre.Next</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Traverse 遍历链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Traverse</span><span class="params">(t *ListNode)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;空链表&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> t != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d &quot;</span>, t.Value)</span><br><span class="line">		t = t.Next</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">10</span>&#125;</span><br><span class="line">	head := CreateListNode(nums)</span><br><span class="line">	<span class="comment">// 遍历链表</span></span><br><span class="line">	Traverse(head)</span><br><span class="line">	<span class="comment">// 反转链表</span></span><br><span class="line">	solution := Solution(head)</span><br><span class="line">	<span class="comment">// 遍历反转后的链表</span></span><br><span class="line">	Traverse(solution)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-LRU缓存（Go）146-中等"><a href="#2-LRU缓存（Go）146-中等" class="headerlink" title="2. LRU缓存（Go）146-中等"></a><font color=DarkOrange>2. LRU缓存（Go）146-中等</font></h4><p><strong>题目：</strong></p>
<p>请你设计并实现一个满足 <code>LRU (最近最少使用)</code> 缓存 约束的数据结构<br>实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以 正整数 作为容量 <code>capacity</code> 初始化 <code>LRU</code> 缓存</li>
<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 -1 </li>
<li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 逐出 最久未使用的关键字</li>
</ul>
<p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line"><span class="punctuation">[</span><span class="string">&quot;LRUCache&quot;</span><span class="punctuation">,</span> <span class="string">&quot;put&quot;</span><span class="punctuation">,</span> <span class="string">&quot;put&quot;</span><span class="punctuation">,</span> <span class="string">&quot;get&quot;</span><span class="punctuation">,</span> <span class="string">&quot;put&quot;</span><span class="punctuation">,</span> <span class="string">&quot;get&quot;</span><span class="punctuation">,</span> <span class="string">&quot;put&quot;</span><span class="punctuation">,</span> <span class="string">&quot;get&quot;</span><span class="punctuation">,</span> <span class="string">&quot;get&quot;</span><span class="punctuation">,</span> <span class="string">&quot;get&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">4</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">输出</span><br><span class="line"><span class="punctuation">[</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="number">-1</span><span class="punctuation">,</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="number">-1</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">LRUCache lRUCache = new LRUCache(<span class="number">2</span>);</span><br><span class="line">lRUCache.put(<span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span>); <span class="comment">// 缓存是 &#123;1=1&#125;</span></span><br><span class="line">lRUCache.put(<span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span>); <span class="comment">// 缓存是 &#123;1=1, 2=2&#125;</span></span><br><span class="line">lRUCache.get(<span class="number">1</span>);    <span class="comment">// 返回 1</span></span><br><span class="line">lRUCache.put(<span class="number">3</span><span class="punctuation">,</span> <span class="number">3</span>); <span class="comment">// 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span></span><br><span class="line">lRUCache.get(<span class="number">2</span>);    <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">lRUCache.put(<span class="number">4</span><span class="punctuation">,</span> <span class="number">4</span>); <span class="comment">// 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span></span><br><span class="line">lRUCache.get(<span class="number">1</span>);    <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">lRUCache.get(<span class="number">3</span>);    <span class="comment">// 返回 3</span></span><br><span class="line">lRUCache.get(<span class="number">4</span>);    <span class="comment">// 返回 4</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= capacity &lt;= 3000</code></li>
<li><code>0 &lt;= key &lt;= 10000</code></li>
<li><code>0 &lt;= value &lt;= 105</code></li>
<li>最多调用 <code>2 * 105</code> 次 <code>get</code> 和 <code>put</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：哈希表 + 双向链表</p>
<p>LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对</p>
<ul>
<li>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的</li>
<li>哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置</li>
</ul>
<p>这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 O(1) 的时间内完成 <code>get</code> 或者 <code>put</code> 操作。具体的方法如下：</p>
<ul>
<li><p>对于 <code>get</code> 操作，首先判断 <code>key</code> 是否存在：</p>
<ul>
<li>如果 <code>key</code> 不存在，则返回 −1</li>
<li>如果 <code>key</code> 存在，则 <code>key</code> 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值</li>
</ul>
</li>
<li><p>对于 <code>put</code> 操作，首先判断 <code>key</code> 是否存在：</p>
<ul>
<li>如果 <code>key</code> 不存在，使用 <code>key</code> 和 <code>value</code> 创建一个新的节点，在双向链表的头部添加该节点，并将 <code>key</code> 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项</li>
<li>如果 <code>key</code> 存在，则与 <code>get</code> 操作类似，先通过哈希表定位，再将对应的节点的值更新为 <code>value</code>，并将该节点移到双向链表的头部</li>
</ul>
</li>
</ul>
<p>上述各项操作中，访问哈希表的时间复杂度为 O(1)，在双向链表的头部添加节点、在双向链表的尾部删除节点的复杂度也为 O(1)。而将一个节点移到双向链表的头部，可以分成「删除该节点」和「在双向链表的头部添加节点」两步操作，都可以在 O(1) 时间内完成</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：对于 <code>put</code> 和 <code>get</code> 都是 O(1)</li>
<li>空间复杂度：O(capacity)，因为哈希表和双向链表最多存储 capacity+1 个元素</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    size <span class="type">int</span></span><br><span class="line">    capacity <span class="type">int</span></span><br><span class="line">    cache <span class="keyword">map</span>[<span class="type">int</span>]*DLinkedNode</span><br><span class="line">    head, tail *DLinkedNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DLinkedNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    key, value <span class="type">int</span></span><br><span class="line">    prev, next *DLinkedNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDLinkedNode</span><span class="params">(key, value <span class="type">int</span>)</span></span> *DLinkedNode &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;DLinkedNode&#123;</span><br><span class="line">        key: key,</span><br><span class="line">        value: value,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line">    lruCache := LRUCache&#123;</span><br><span class="line">        cache: <span class="keyword">map</span>[<span class="type">int</span>]*DLinkedNode&#123;&#125;,</span><br><span class="line">        head: initDLinkedNode(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        tail: initDLinkedNode(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        capacity: capacity,</span><br><span class="line">    &#125;</span><br><span class="line">    lruCache.head.next = lruCache.tail</span><br><span class="line">    lruCache.tail.prev = lruCache.head</span><br><span class="line">    <span class="keyword">return</span> lruCache</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    _, ok := this.cache[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    node := this.cache[key]</span><br><span class="line">    this.moveToHead(node)</span><br><span class="line">    <span class="keyword">return</span> node.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>)  &#123;</span><br><span class="line">    _, ok := this.cache[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        node := initDLinkedNode(key, value)</span><br><span class="line">        this.cache[key] = node</span><br><span class="line">        this.addToHead(node)</span><br><span class="line">        this.size++</span><br><span class="line">        <span class="keyword">if</span> this.size &gt; this.capacity &#123;</span><br><span class="line">            removeed :=this.removeTail()</span><br><span class="line">            <span class="built_in">delete</span>(this.cache, removeed.key)</span><br><span class="line">            this.size--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node := this.cache[key]</span><br><span class="line">        node.value = value</span><br><span class="line">        this.moveToHead(node)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> addToHead(node *DLinkedNode) &#123;</span><br><span class="line">    node.prev = this.head</span><br><span class="line">    node.next = this.head.next</span><br><span class="line">    this.head.next.prev = node</span><br><span class="line">    this.head.next = node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> removeNode(node *DLinkedNode) &#123;</span><br><span class="line">    node.prev.next = node.next</span><br><span class="line">    node.next.prev = node.prev</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> moveToHead(node *DLinkedNode) &#123;</span><br><span class="line">    this.removeNode(node)</span><br><span class="line">    this.addToHead(node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> removeTail() *DLinkedNode &#123;</span><br><span class="line">    node := this.tail.prev</span><br><span class="line">    this.removeNode(node)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-CodeTop补充题：手撕快速排序（Go）-排序数组-912-中等"><a href="#3-CodeTop补充题：手撕快速排序（Go）-排序数组-912-中等" class="headerlink" title="3. CodeTop补充题：手撕快速排序（Go） | 排序数组 912-中等"></a><font color=DarkOrange>3. CodeTop补充题：手撕快速排序（Go） | 排序数组 912-中等</font></h4><blockquote>
<p><font color=red><strong>10大排序算法： 1. 冒泡排序，2. 选择排序，3. 插入排序，4. 归并排序，5. 快速排序，6. 堆排序，8. 计数排序，9. 桶排序，10. 基数排序</strong></font></p>
</blockquote>
<p><strong>题目：</strong></p>
<p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 5 * 10^4</code></li>
<li><code>-5 * 10^4 &lt;= nums[i] &lt;= 5 * 10^4</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：快速排序<br>思路和算法</p>
<p>快速排序的主要思想是通过划分将待排序的序列分成前后两部分，其中前一部分的数据都比后一部分的数据要小，然后再递归调用函数对两部分的序列分别进行快速排序，以此使整个序列达到有序</p>
<p>我们定义函数 <code>randomized_quicksort(nums, l, r)</code> 为对 <code>nums</code> 数组里 [l,r]的部分进行排序，每次先调用 <code>randomized_partition</code> 函数对 <code>nums</code> 数组里 [l,r]的部分进行划分，并返回分界值的下标 <code>pos</code>，然后按上述将的递归调用 <code>randomized_quicksort(nums, l, pos - 1)</code> 和 <code>randomized_quicksort(nums, pos + 1, r)</code> 即可</p>
<p>那么核心就是划分函数的实现了，划分函数一开始需要确定一个分界值（我们称之为主元 <code>pivot</code>)，然后再进行划分。而主元的选取有很多种方式，这里我们采用随机的方式，对当前划分区间 [l,r] 里的数等概率随机一个作为我们的主元，再将主元放到区间末尾，进行划分</p>
<p>整个划分函数 <code>partition</code> 主要涉及两个指针 i 和 j，一开始 <code>i = l - 1</code>，<code>j = l</code>。我们需要实时维护两个指针使得任意时候，对于任意数组下标 k，我们有如下条件成立：</p>
<ol>
<li>l≤k≤i 时，nums[k]≤pivot</li>
<li>i+1≤k≤j−1 时，nums[k]&gt;pivot</li>
<li>k&#x3D;&#x3D;r 时，nums[k]&#x3D;pivot</li>
</ol>
<p>我们每次移动指针 j ，如果 nums[j]&gt;pivot，我们只需要继续移动指针 j ，即能使上述三个条件成立，否则我们需要将指针 i 加一，然后交换 nums[i] 和 nums[j]，再移动指针 j 才能使得三个条件成立</p>
<p>当 j 移动到 r−1 时结束循环，此时我们可以由上述三个条件知道 [l,i] 的数都小于等于主元 <code>pivot</code>，[i+1,r−1] 的数都大于主元 <code>pivot</code>，那么我们只要交换 nums[i+1] 和 nums[r] ，即能使得 [l,i+1] 区间的数都小于 [i+2,r] 区间的数，完成一次划分，且分界值下标为 i+1，返回即可</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：基于随机选取主元的快速排序时间复杂度为期望 O(nlogn)，其中 n 为数组的长度</li>
<li>空间复杂度：O(h)，其中 h 为快速排序递归调用的层数。我们需要额外的 O(h) 的递归调用的栈空间，由于划分的结果不同导致了快速排序递归调用的层数也会不同，最坏情况下需 O(n) 的空间，最优情况下每次都平衡，此时整个递归树高度为 logn，空间复杂度为 O(logn)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数将对数组进行原地排序，不返回任何东西。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(nums []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 如果左索引小于右索引，说明还有元素需要排序</span></span><br><span class="line">	<span class="keyword">if</span> left &lt; right &#123;</span><br><span class="line">		<span class="comment">// 执行分区操作，获取基准元素的索引</span></span><br><span class="line">		pivot := partition(nums, left, right)</span><br><span class="line">		<span class="comment">// 递归地对基准元素的左边和右边进行快速排序</span></span><br><span class="line">		quickSort(nums, left, pivot<span class="number">-1</span>)</span><br><span class="line">		quickSort(nums, pivot+<span class="number">1</span>, right)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个分区函数，接受一个整数数组和左右索引，返回基准元素的索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(nums []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 选择最右边的元素作为基准元素</span></span><br><span class="line">	pivot := nums[right]</span><br><span class="line">	<span class="comment">// 定义 i 为小于基准元素的区域的右边界，初始值为 left-1</span></span><br><span class="line">	i := left - <span class="number">1</span></span><br><span class="line">	<span class="comment">// 遍历左边到右边之间的元素</span></span><br><span class="line">	<span class="keyword">for</span> j := left; j &lt; right; j++ &#123;</span><br><span class="line">		<span class="comment">// 如果当前元素小于基准元素，就将其移到小于区域的右边界之后</span></span><br><span class="line">		<span class="keyword">if</span> nums[j] &lt; pivot &#123;</span><br><span class="line">			i++</span><br><span class="line">			nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 最后，将基准元素移到小于区域的右边界之后，并返回其索引</span></span><br><span class="line">	nums[i+<span class="number">1</span>], nums[right] = nums[right], nums[i+<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">25</span>, <span class="number">11</span>&#125;</span><br><span class="line">	quickSort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Sorted nums:&quot;</span>, nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-合并两个有序链表（Go）-21-简单"><a href="#4-合并两个有序链表（Go）-21-简单" class="headerlink" title="4. 合并两个有序链表（Go） 21-简单"></a><font color=DarkOrange>4. 合并两个有序链表（Go） 21-简单</font></h4><p><strong>题目：</strong></p>
<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：l1 = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">,</span> l2 = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span></span><br><span class="line">输入：l1 = <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> l2 = <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">输入：l1 = <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> l2 = <span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>两个链表的节点数目范围是 <code>[0, 50]</code></li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：递归<br>思路</p>
<p>我们可以如下递归地定义两个链表里的 merge 操作（忽略边界情况，比如空链表等）：</p>
<p>list1[0] + merge(list1[1:], list2) list1[0] &lt; list2[0]</p>
<p>list2[0] + merge(list1, list2[1:]) otherwise </p>
<p>也就是说，两个链表头部值较小的一个节点与剩下元素的 <code>merge</code> 操作结果合并</p>
<p>算法：</p>
<p>我们直接将以上递归过程建模，同时需要考虑边界情况</p>
<p>如果 <code>l1</code> 或者 <code>l2</code> 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 <code>l1</code> 和 <code>l2</code> 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。因为每次调用递归都会去掉 <code>l1</code> 或者 <code>l2</code> 的头节点（直到至少有一个链表为空），函数 <code>mergeTwoList</code> 至多只会递归调用每个节点一次。因此，时间复杂度取决于合并后的链表长度，即 O(n+m)</li>
<li>空间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。递归调用 <code>mergeTwoLists</code> 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。结束递归调用时 mergeTwoLists 函数最多调用 n+m 次，因此空间复杂度为 O(n+m)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> ListNode struct &#123;</span><br><span class="line">	Value <span class="built_in">int</span></span><br><span class="line">	Next  *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// CreateListNode 使用<span class="built_in">slice</span>创建单链表</span><br><span class="line">func CreateListNode(nums []<span class="built_in">int</span>) *ListNode &#123;</span><br><span class="line">	var head ListNode</span><br><span class="line">	var pre ListNode</span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="built_in">range</span> nums &#123;</span><br><span class="line">		node := ListNode&#123;Value: num, Next: nil&#125;</span><br><span class="line">		<span class="keyword">if</span> head.Next == nil &#123;</span><br><span class="line">			head.Next = &amp;node</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> pre.Next == nil &#123;</span><br><span class="line">			pre.Next = &amp;node</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			pre.Next.Next = &amp;node</span><br><span class="line">			pre = *pre.Next</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Traverse 遍历链表</span><br><span class="line">func Traverse(t *ListNode) &#123;</span><br><span class="line">	<span class="keyword">if</span> t == nil &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;空链表&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> t != nil &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot; %d&quot;</span>, t.Value)</span><br><span class="line">		t = t.Next</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// MergeTwoListNode 合并<span class="number">2</span>个链表</span><br><span class="line">func MergeTwoListNode(List1, List2 *ListNode) *ListNode &#123;</span><br><span class="line">	// 如果有一条链表为nil，直接返回另一条链表</span><br><span class="line">	<span class="keyword">if</span> List1 == nil &#123;</span><br><span class="line">		<span class="keyword">return</span> List2</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> List2 == nil &#123;</span><br><span class="line">		<span class="keyword">return</span> List1</span><br><span class="line">	&#125;</span><br><span class="line">	// 定义一个节点</span><br><span class="line">	var result *ListNode</span><br><span class="line">	<span class="keyword">if</span> List1.Value &gt;= List2.Value &#123;</span><br><span class="line">		result = List2</span><br><span class="line">		result.Next = MergeTwoListNode(List1, List2.Next)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		result = List1</span><br><span class="line">		result.Next = MergeTwoListNode(List1.Next, List2)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	nums1 := []<span class="built_in">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;</span><br><span class="line">	nums2 := []<span class="built_in">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>&#125;</span><br><span class="line">	lis1 := CreateListNode(nums1)</span><br><span class="line">	lis2 := CreateListNode(nums2)</span><br><span class="line">	mergeTwoListNode := MergeTwoListNode(lis1, lis2)</span><br><span class="line">	Traverse(mergeTwoListNode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-最大子数组和（Go）53-简单"><a href="#5-最大子数组和（Go）53-简单" class="headerlink" title="5. 最大子数组和（Go）53-简单"></a><font color=DarkOrange>5. 最大子数组和（Go）53-简单</font></h4><p><strong>题目：</strong></p>
<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和</p>
<p><strong>子数组</strong> 是数组中的一个连续部分</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">-2</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">-3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">-1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">-5</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：连续子数组 <span class="punctuation">[</span><span class="number">4</span><span class="punctuation">,</span><span class="number">-1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span> 的和最大，为 <span class="number">6</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">-1</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">23</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：动态规划（核心：若前一个元素大于0，则将其加到当前元素上）<br>思路和算法</p>
<p>假设 nums 数组的长度是 n，下标从 0 到 n−1</p>
<p>我们用 f(i) 代表以第 i 个数结尾的「连续子数组的最大和」，那么很显然我们要求的答案就是：<br>0≤i的max≤n−1的{f(i)}</p>
<p>因此我们只需要求出每个位置的 f(i)，然后返回 f 数组中的最大值即可。那么我们如何求 f(i) 呢？我们可以考虑 nums[i] 单独成为一段还是加入 f(i−1) 对应的那一段，这取决于 nums[i] 和 f(i-1) +nums[i] 的大小，我们希望获得一个比较大的，于是可以写出这样的动态规划转移方程：<br>f(i)&#x3D;max{f(i−1)+nums[i],nums[i]}</p>
<p>不难给出一个时间复杂度 O(n)、空间复杂度 O(n) 的实现，即用一个 ff 数组来保存 f(i) 的值，用一个循环求出所有 f(i)。考虑到 f(i) 只和 f(i−1) 相关，于是我们可以只用一个变量 pre 来维护对于当前 f(i) 的 f(i−1) 的值是多少，从而让空间复杂度降低到 O(1)，这有点类似「滚动数组」的思想</p>
<div align="center"><img src="https://i.bmp.ovh/imgs/2022/06/21/2f768ff06b617809.png" style="zoom:50%;" /></div>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 为 nums 数组的长度。我们只需要遍历一遍数组即可求得答案</li>
<li>空间复杂度：O(1)。我们只需要常数空间存放若干变量</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    max := nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] + nums[i - <span class="number">1</span>] &gt; nums[i] &#123;</span><br><span class="line">            nums[i] += nums[i - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; max &#123;</span><br><span class="line">            max = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-字符串相加（Go）415-简单"><a href="#6-字符串相加（Go）415-简单" class="headerlink" title="6. 字符串相加（Go）415-简单"></a><font color=DarkOrange>6. 字符串相加（Go）415-简单</font></h4><p><strong>题目：</strong></p>
<p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回</p>
<p>你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：num1 = <span class="string">&quot;11&quot;</span><span class="punctuation">,</span> num2 = <span class="string">&quot;123&quot;</span></span><br><span class="line">输出：<span class="string">&quot;134&quot;</span></span><br><span class="line">输入：num1 = <span class="string">&quot;456&quot;</span><span class="punctuation">,</span> num2 = <span class="string">&quot;77&quot;</span></span><br><span class="line">输出：<span class="string">&quot;533&quot;</span></span><br><span class="line">输入：num1 = <span class="string">&quot;0&quot;</span><span class="punctuation">,</span> num2 = <span class="string">&quot;0&quot;</span></span><br><span class="line">输出：<span class="string">&quot;0&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= num1.length, num2.length &lt;= 10的4次方</code></li>
<li><code>num1</code> 和<code>num2</code> 都只包含数字 <code>0-9</code></li>
<li><code>num1</code> 和<code>num2</code> 都不包含任何前导零</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：模拟<br>思路与算法</p>
<p>本题我们只需要对两个大整数模拟「竖式加法」的过程。竖式加法就是我们平常学习生活中常用的对两个整数相加的方法，回想一下我们在纸上对两个整数相加的操作，是不是如下图将相同数位对齐，从低到高逐位相加，如果当前位和超过 10，则向高位进一位？因此我们只要将这个过程用代码写出来即可</p>
<p>具体实现也不复杂，我们定义两个指针 i 和 j 分别指向 num1  和 num 2 的末尾，即最低位，同时定义一个变量 add 维护当前是否有进位，然后从末尾到开头逐位相加即可。你可能会想两个数字位数不同怎么处理，这里我们统一在指针当前下标处于负数的时候返回 0，等价于对位数较短的数字进行了补零操作，这样就可以除去两个数字位数不同情况的处理，具体可以看下面的代码</p>
<div align="center"><img src="https://i.bmp.ovh/imgs/2022/06/21/83dd1b48338dee5d.png" style="zoom:50%;" /></div>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(max(len1,len2))，其中 len1&#x3D;num1.length，len2&#x3D;num2.length。竖式加法的次数取决于较大数的位数</li>
<li>空间复杂度：O(1)。除答案外我们只需要常数空间存放若干变量。在 Java 解法中使用到了 <code>StringBuffer</code>，故 Java 解法的空间复杂度为O(n)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addStrings</span><span class="params">(num1 <span class="type">string</span>, num2 <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    add := <span class="number">0</span></span><br><span class="line">    ans := <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="built_in">len</span>(num1) - <span class="number">1</span>, <span class="built_in">len</span>(num2) - <span class="number">1</span>; i &gt;= <span class="number">0</span> ||</span><br><span class="line">    j &gt;= <span class="number">0</span> || add != <span class="number">0</span>; i, j = i - <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> x, y <span class="type">int</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            x = <span class="type">int</span>(num1[i] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> j &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            y = <span class="type">int</span>(num2[j] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        result := x + y + add</span><br><span class="line">        ans = strconv.Itoa(result % <span class="number">10</span>) + ans</span><br><span class="line">        add = result / <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-二分查找（Go）704-简单"><a href="#7-二分查找（Go）704-简单" class="headerlink" title="7. 二分查找（Go）704-简单"></a><font color=DarkOrange>7. 二分查找（Go）704-简单</font></h4><p><strong>题目：</strong></p>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 <code>target</code>  ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 -1</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入<span class="punctuation">:</span> nums = <span class="punctuation">[</span><span class="number">-1</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">12</span><span class="punctuation">]</span><span class="punctuation">,</span> target = <span class="number">9</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line">解释<span class="punctuation">:</span> <span class="number">9</span> 出现在 nums 中并且下标为 <span class="number">4</span></span><br><span class="line">输入<span class="punctuation">:</span> nums = <span class="punctuation">[</span><span class="number">-1</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">12</span><span class="punctuation">]</span><span class="punctuation">,</span> target = <span class="number">2</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="number">-1</span></span><br><span class="line">解释<span class="punctuation">:</span> <span class="number">2</span> 不存在 nums 中因此返回 <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li>你可以假设 <code>nums</code> 中的所有元素是不重复的</li>
<li><code>n</code> 将在 <code>[1, 10000]</code>之间</li>
<li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间</li>
</ol>
<p><strong>思路：</strong></p>
<p>方法一：二分查找<br>在升序数组 nums 中寻找目标值 target，对于特定下标 i，比较 nums[i] 和 target 的大小：</p>
<ul>
<li><p>如果 nums[i] &#x3D; target，则下标 i 即为要寻找的下标</p>
</li>
<li><p>如果 nums[i] &gt; target，则 target 只可能在下标 i 的左侧</p>
</li>
<li><p>如果 nums[i] &lt; target，则 target 只可能在下标 i 的右侧</p>
</li>
</ul>
<p>基于上述事实，可以在有序数组中使用二分查找寻找目标值<br>二分查找的做法是，定义查找的范围 [left,right]，初始查找范围是整个数组。每次取查找范围的中点 mid，比较 nums[mid] 和 target 的大小，如果相等则 mid 即为要寻找的下标，如果不相等则根据 nums[mid] 和 target 的大小关系将查找范围缩小一半</p>
<p>由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是 O(logn)，其中 n 是数组的长度</p>
<p>二分查找的条件是查找范围不为空，即 left &lt;&#x3D; right。如果 target 在数组中，二分查找可以保证找到 target，返回 target 在数组中的下标。如果 target 不在数组中，则当 left &gt; right 时结束查找，返回 -1</p>
<div align="center"><img src="https://i.bmp.ovh/imgs/2022/06/21/736001c2f7e7a333.png" style="zoom:50%;" /></div>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(logn)，其中 n 是数组的长度</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        mid := (right - left) / <span class="number">2</span> + left</span><br><span class="line">        num := nums[mid]</span><br><span class="line">        <span class="keyword">if</span> num == target &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> num &gt; target &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-无重复字符串的最长子串（Go）3-中等"><a href="#8-无重复字符串的最长子串（Go）3-中等" class="headerlink" title="8. 无重复字符串的最长子串（Go）3-中等"></a><font color=DarkOrange>8. 无重复字符串的最长子串（Go）3-中等</font></h4><p><strong>题目：</strong></p>
<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入<span class="punctuation">:</span> s = <span class="string">&quot;abcabcbb&quot;</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="number">3</span> </span><br><span class="line">解释<span class="punctuation">:</span> 因为无重复字符的最长子串是 <span class="string">&quot;abc&quot;</span>，所以其长度为 <span class="number">3</span></span><br><span class="line">输入<span class="punctuation">:</span> s = <span class="string">&quot;bbbbb&quot;</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">解释<span class="punctuation">:</span> 因为无重复字符的最长子串是 <span class="string">&quot;b&quot;</span>，所以其长度为 <span class="number">1</span></span><br><span class="line">输入<span class="punctuation">:</span> s = <span class="string">&quot;pwwkew&quot;</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="number">3</span></span><br><span class="line">解释<span class="punctuation">:</span> 因为无重复字符的最长子串是 <span class="string">&quot;wke&quot;</span>，所以其长度为 <span class="number">3</span></span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">&quot;pwke&quot;</span> 是一个子序列，不是子串</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 5 * 10^4</code></li>
<li><code>s</code> 由英文字母、数字、符号和空格组成</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：滑动窗口</p>
<p>思路和算法</p>
<p>我们先用一个例子考虑如何在较优的时间复杂度内通过本题</p>
<p>我们不妨以示例一中的字符串 abcabcbb 为例，找出从每一个字符开始的，不包含重复字符的最长子串，那么其中最长的那个字符串即为答案。对于示例一中的字符串，我们列举出这些结果，其中括号中表示选中的字符以及最长的字符串：</p>
<ul>
<li><p>以 (a)bcabcbb 开始的最长字符串为 (abc)abcbb</p>
</li>
<li><p>以 a(b)cabcbb 开始的最长字符串为 a(bca)bcbb</p>
</li>
<li><p>以 ab(c)abcbb 开始的最长字符串为 ab(cab)cbb</p>
</li>
<li><p>以 abc(a)bcbb 开始的最长字符串为 abc(abc)bb</p>
</li>
<li><p>以 abca(b)cbb 开始的最长字符串为 abca(bc)bb</p>
</li>
<li><p>以 abcab(c)bb 开始的最长字符串为 abcab(cb)b</p>
</li>
<li><p>以 abcabc(b)b 开始的最长字符串为 abcabc(b)b</p>
</li>
<li><p>以 abcabcb(b) 开始的最长字符串为 abcabcb(b)</p>
</li>
</ul>
<p>发现了什么？如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的！这里的原因在于，假设我们选择字符串中的第 k 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 tk 。那么当我们选择第 k+1 个字符作为起始位置时，首先从 k+1 到 tk  的字符显然是不重复的，并且由于少了原本的第 k 个字符，我们可以尝试继续增大 tk，直到右侧出现了重复字符为止</p>
<p>这样一来，我们就可以使用「滑动窗口」来解决这个问题了：</p>
<ul>
<li>我们使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的 rk</li>
<li>在每一步的操作中，我们会将左指针向右移动一格，表示 我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 以左指针开始的，不包含重复字符的最长子串。我们记录下这个子串的长度</li>
<li>在枚举结束后，我们找到的最长的子串的长度即为答案</li>
</ul>
<p>判断重复字符：</p>
<p>在上面的流程中，我们还需要使用一种数据结构来判断 是否有重复的字符，常用的数据结构为哈希集合（即 <code>C++</code>中的 <code>std::unordered_set</code>，<code>Java</code> 中的 <code>HashSet</code>，<code>Python</code> 中的 <code>set</code> , <code>JavaScript</code> 中的 <code>Set</code>）。在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，我们往哈希集合中添加一个字符</p>
<p>至此，我们就完美解决了本题</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N 是字符串的长度。左指针和右指针分别会遍历整个字符串一次</li>
<li>空间复杂度：O(∣Σ∣)，其中Σ 表示字符集（即字符串中可以出现的字符），∣Σ∣ 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 [0,128) 内的字符，即 ∣Σ∣&#x3D;128。我们需要用到哈希集合来存储出现过的字符，而字符最多有 ∣Σ∣ 个，因此空间复杂度为 O(∣Σ∣)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 哈希集合，记录每个字符串是否出现过</span></span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="comment">// 右指针，初始值为-1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">    rk, ans := <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 左指针向右移动一格，移除一个字符串</span></span><br><span class="line">            <span class="built_in">delete</span>(m, s[i - <span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> rk + <span class="number">1</span> &lt; n &amp;&amp; m[s[rk + <span class="number">1</span>]] == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 不断的移动右指针</span></span><br><span class="line">            m[s[rk + <span class="number">1</span>]]++</span><br><span class="line">            rk++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第i到rk个字符是一个极长的无重复字符子串</span></span><br><span class="line">        ans = max(ans, rk - i + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-数组中的第K个最大元素（Go）215-中等"><a href="#9-数组中的第K个最大元素（Go）215-中等" class="headerlink" title="9. 数组中的第K个最大元素（Go）215-中等"></a><font color=DarkOrange>9. 数组中的第K个最大元素（Go）215-中等</font></h4><p><strong>题目：</strong></p>
<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素</p>
<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入<span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span> 和 k = <span class="number">2</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="number">5</span></span><br><span class="line">输入<span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">]</span> 和 k = <span class="number">4</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= nums.length &lt;= 10的4次方</code></li>
<li><code>-10的4次方 &lt;= nums[i] &lt;= 10的4次方</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：基于快速排序的选择方法</p>
<p>思路和算法</p>
<p>我们可以用快速排序来解决这个问题，先对原数组排序，再返回倒数第 k 个位置，这样平均时间复杂度是 O(nlogn)，但其实我们可以做的更快</p>
<p>首先我们来回顾一下快速排序，这是一个典型的分治算法。我们对数组 a[l⋯r] 做快速排序的过程是（参考《算法导论》）：</p>
<ul>
<li>分解： 将数组 a[l⋯r] 「划分」成两个子数组 a[l⋯q−1]、a[q+1⋯r]，使得 a[l⋯q−1] 中的每个元素小于等于 a[q]，且 a[q] 小于等于 a[q+1⋯r] 中的每个元素。其中，计算下标 q 也是「划分」过程的一部分</li>
<li>解决： 通过递归调用快速排序，对子数组 a[l⋯q−1] 和 a[q+1⋯r] 进行排序</li>
<li>合并： 因为子数组都是原址排序的，所以不需要进行合并操作，a[l⋯r] 已经有序</li>
<li>上文中提到的 「划分」 过程是：从子数组 a[l⋯r] 中选择任意一个元素 x 作为主元，调整子数组的元素使得左边的元素都小于等于它，右边的元素都大于等于它， x 的最终位置就是 q</li>
</ul>
<p>由此可以发现每次经过「划分」操作后，我们一定可以确定一个元素的最终位置，即 x 的最终位置为 q，并且保证 a[l⋯q−1] 中的每个元素小于等于 a[q]，且 a[q] 小于等于 a[q+1⋯r] 中的每个元素。所以只要某次划分的 q 为倒数第 k 个下标的时候，我们就已经找到了答案。 我们只关心这一点，至于 a[l⋯q−1] 和 a[q+1⋯r] 是否是有序的，我们不关心</p>
<p>因此我们可以改进快速排序算法来解决这个问题：在分解的过程当中，我们会对子数组进行划分，如果划分得到的 q 正好就是我们需要的下标，就直接返回 a[q]；否则，如果 q 比目标下标小，就递归右子区间，否则递归左子区间。这样就可以把原来递归两个区间变成只递归一个区间，提高了时间效率。这就是「快速选择」算法</p>
<p>我们知道快速排序的性能和「划分」出的子数组的长度密切相关。直观地理解如果每次规模为 n 的问题我们都划分成 1 和 n−1，每次递归的时候又向 n−1 的集合中递归，这种情况是最坏的，时间代价是 O n的2次方。我们可以引入随机化来加速这个过程，它的时间代价的期望是 O(n)，证明过程可以参考「《算法导论》9.2：期望为线性的选择算法」</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)，如上文所述，证明过程可以参考「《算法导论》9.2：期望为线性的选择算法」</li>
<li>空间复杂度：O(logn)，递归使用栈空间的空间代价的期望为 O(logn)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthLargest</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>, <span class="built_in">len</span>(nums) - k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSelect</span><span class="params">(a []<span class="type">int</span>, l, r, index <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    q := randomPartition(a, l, r)</span><br><span class="line">    <span class="keyword">if</span> q == index &#123;</span><br><span class="line">        <span class="keyword">return</span> a[q]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> q &lt; index &#123;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(a, q + <span class="number">1</span>, r, index)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSelect(a, l, q - <span class="number">1</span>, index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomPartition</span><span class="params">(a []<span class="type">int</span>, l, r <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    i := rand.Int() % (r - l + <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">    a[i], a[r] = a[r], a[i]</span><br><span class="line">    <span class="keyword">return</span> partition(a, l, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(a []<span class="type">int</span>, l, r <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    x := a[r]</span><br><span class="line">    i := l - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; r; j ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> a[j] &lt;= x &#123;</span><br><span class="line">            i++</span><br><span class="line">            a[i], a[j] = a[j], a[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[i + <span class="number">1</span>], a[r] = a[r], a[i + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-字符串转换整数-8-中等"><a href="#10-字符串转换整数-8-中等" class="headerlink" title="10. 字符串转换整数 8-中等"></a><font color=DarkOrange>10. 字符串转换整数 8-中等</font></h4><p>题目：</p>
<p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C&#x2F;C++ 中的 <code>atoi</code> 函数</p>
<p>函数 <code>myAtoi(string s)</code> 的算法如下：</p>
<ol>
<li>读入字符串并丢弃无用的前导空格</li>
<li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正</li>
<li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略<br>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）</li>
<li>如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整</li>
<li>应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 </li>
<li>返回整数作为最终结果</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>本题中的空白字符只包括空格字符 <code>&#39; &#39;</code> </li>
<li>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong> 任何其他字符</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;42&quot;</span></span><br><span class="line">输出：<span class="number">42</span></span><br><span class="line">解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符</span><br><span class="line">第 <span class="number">1</span> 步：<span class="string">&quot;42&quot;</span>（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 <span class="number">2</span> 步：<span class="string">&quot;42&quot;</span>（当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;）</span><br><span class="line">         ^</span><br><span class="line">第 <span class="number">3</span> 步：<span class="string">&quot;42&quot;</span>（读入 <span class="string">&quot;42&quot;</span>）</span><br><span class="line">           ^</span><br><span class="line">解析得到整数 <span class="number">42</span></span><br><span class="line">由于 <span class="string">&quot;42&quot;</span> 在范围 <span class="punctuation">[</span><span class="number">-231</span><span class="punctuation">,</span> <span class="number">231</span> - <span class="number">1</span><span class="punctuation">]</span> 内，最终结果为 <span class="number">42</span></span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;   -42&quot;</span></span><br><span class="line">输出：<span class="number">-42</span></span><br><span class="line">解释：</span><br><span class="line">第 <span class="number">1</span> 步：<span class="string">&quot;   -42&quot;</span>（读入前导空格，但忽视掉）</span><br><span class="line">            ^</span><br><span class="line">第 <span class="number">2</span> 步：<span class="string">&quot;   -42&quot;</span>（读入 &#x27;-&#x27; 字符，所以结果应该是负数）</span><br><span class="line">             ^</span><br><span class="line">第 <span class="number">3</span> 步：<span class="string">&quot;   -42&quot;</span>（读入 <span class="string">&quot;42&quot;</span>）</span><br><span class="line">               ^</span><br><span class="line">解析得到整数 <span class="number">-42</span></span><br><span class="line">由于 <span class="string">&quot;-42&quot;</span> 在范围 <span class="punctuation">[</span><span class="number">-231</span><span class="punctuation">,</span> <span class="number">231</span> - <span class="number">1</span><span class="punctuation">]</span> 内，最终结果为 <span class="number">-42</span></span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;4193 with words&quot;</span></span><br><span class="line">输出：<span class="number">4193</span></span><br><span class="line">解释：</span><br><span class="line">第 <span class="number">1</span> 步：<span class="string">&quot;4193 with words&quot;</span>（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 <span class="number">2</span> 步：<span class="string">&quot;4193 with words&quot;</span>（当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;）</span><br><span class="line">         ^</span><br><span class="line">第 <span class="number">3</span> 步：<span class="string">&quot;4193 with words&quot;</span>（读入 <span class="string">&quot;4193&quot;</span>；由于下一个字符不是一个数字，所以读入停止）</span><br><span class="line">             ^</span><br><span class="line">解析得到整数 <span class="number">4193</span></span><br><span class="line">由于 <span class="string">&quot;4193&quot;</span> 在范围 <span class="punctuation">[</span><span class="number">-231</span><span class="punctuation">,</span> <span class="number">231</span> - <span class="number">1</span><span class="punctuation">]</span> 内，最终结果为 <span class="number">4193</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 200</code></li>
<li><code>s</code> 由英文字母（大写和小写）、数字（<code>0-9</code>）、<code>&#39; &#39;</code>、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code> 和 <code>&#39;.&#39;</code> 组成</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：自动机</p>
<p>思路</p>
<p>字符串处理的题目往往涉及复杂的流程以及条件情况，如果直接上手写程序，一不小心就会写出极其臃肿的代码</p>
<p>因此，为了有条理地分析每个输入字符的处理方法，我们可以使用自动机这个概念：</p>
<p>我们的程序在每个时刻有一个状态 <code>s</code>，每次从序列中输入一个字符 <code>c</code>，并根据字符 <code>c</code> 转移到下一个状态 <code>s</code>。这样，我们只需要建立一个覆盖所有情况的从 <code>s</code> 与 <code>c</code> 映射到 <code>s</code> 的表格即可解决题目中的问题</p>
<p>算法</p>
<p>本题可以建立如下图所示的自动机：</p>
<p>我们也可以用下面的表格来表示这个自动机：</p>
<p>接下来编程部分就非常简单了：我们只需要把上面这个状态转换表抄进代码即可</p>
<p>另外自动机也需要记录当前已经输入的数字，只要在 <code>s</code> 为 <code>in_number</code> 时，更新我们输入的数字，即可最终得到输入的数字</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 nn 为字符串的长度。我们只需要依次处理所有的字符，处理每个字符需要的时间为 O(1)</li>
<li>空间复杂度：O(1)。自动机的状态只需要常数空间存储</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">myAtoi</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">min</span>(<span class="built_in">int</span>(*re.findall(<span class="string">&#x27;^[\+\-]?\d+&#x27;</span>, s.lstrip())), <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>), -<span class="number">2</span>**<span class="number">31</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INT_MAX = <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span></span><br><span class="line">INT_MIN = -<span class="number">2</span> ** <span class="number">31</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Automaton</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.state = <span class="string">&#x27;start&#x27;</span></span><br><span class="line">        self.sign = <span class="number">1</span></span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line">        self.table = &#123;</span><br><span class="line">            <span class="string">&#x27;start&#x27;</span>: [<span class="string">&#x27;start&#x27;</span>, <span class="string">&#x27;signed&#x27;</span>, <span class="string">&#x27;in_number&#x27;</span>, <span class="string">&#x27;end&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;signed&#x27;</span>: [<span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;in_number&#x27;</span>, <span class="string">&#x27;end&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;in_number&#x27;</span>: [<span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;in_number&#x27;</span>, <span class="string">&#x27;end&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;end&#x27;</span>: [<span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>],</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_col</span>(<span class="params">self, c</span>):</span><br><span class="line">        <span class="keyword">if</span> c.isspace():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&#x27;+&#x27;</span> <span class="keyword">or</span> c == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> c.isdigit():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, c</span>):</span><br><span class="line">        self.state = self.table[self.state][self.get_col(c)]</span><br><span class="line">        <span class="keyword">if</span> self.state == <span class="string">&#x27;in_number&#x27;</span>:</span><br><span class="line">            self.ans = self.ans * <span class="number">10</span> + <span class="built_in">int</span>(c)</span><br><span class="line">            self.ans = <span class="built_in">min</span>(self.ans, INT_MAX) <span class="keyword">if</span> self.sign == <span class="number">1</span> <span class="keyword">else</span> <span class="built_in">min</span>(self.ans, -INT_MIN)</span><br><span class="line">        <span class="keyword">elif</span> self.state == <span class="string">&#x27;signed&#x27;</span>:</span><br><span class="line">            self.sign = <span class="number">1</span> <span class="keyword">if</span> c == <span class="string">&#x27;+&#x27;</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">myAtoi</span>(<span class="params">self, <span class="built_in">str</span>: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        automaton = Automaton()</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">            automaton.get(c)</span><br><span class="line">        <span class="keyword">return</span> automaton.sign * automaton.ans</span><br></pre></td></tr></table></figure>

<h4 id="11-回文链表（Go）234-简单"><a href="#11-回文链表（Go）234-简单" class="headerlink" title="11. 回文链表（Go）234-简单"></a><font color=DarkOrange>11. 回文链表（Go）234-简单</font></h4><p><strong>题目：</strong></p>
<p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> </p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">true</span></span></span><br><span class="line">输入：head = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">false</span></span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点数目在范围<code>[1, 10^5]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：将值复制到数组中后用双指针法<br>思路</p>
<p>如果你还不太熟悉链表，下面有关于列表的概要讲述</p>
<p>有两种常用的列表实现，分别为数组列表和链表。如果我们想在列表中存储值，它们是如何实现的呢</p>
<ul>
<li>数组列表底层是使用数组存储值，我们可以通过索引在 O(1) 的时间访问列表任何位置的值，这是由基于内存寻址的方式</li>
<li>链表存储的是称为节点的对象，每个节点保存一个值和指向下一个节点的指针。访问某个特定索引的节点需要 O(n) 的时间，因为要通过指针获取到下一个位置的节点</li>
</ul>
<p>确定数组列表是否回文很简单，我们可以使用双指针法来比较两端的元素，并向中间移动。一个指针从起点向中间移动，另一个指针从终点向中间移动。这需要 O(n) 的时间，因为访问每个元素的时间是 O(1)，而有 n 个元素要访问</p>
<p>然而同样的方法在链表上操作并不简单，因为不论是正向访问还是反向访问都不是 O(1)。而将链表的值复制到数组列表中是 O(n)，因此最简单的方法就是将链表的值复制到数组列表中，再使用双指针法判断</p>
<p>算法</p>
<p>一共为两个步骤：</p>
<ol>
<li>复制链表值到数组列表中</li>
<li>使用双指针法判断是否为回文</li>
</ol>
<p>第一步，我们需要遍历链表将值复制到数组列表中。我们用 <code>currentNode</code> 指向当前节点。每次迭代向数组添加 <code>currentNode.val</code>，并更新 <code>currentNode = currentNode.next</code>，当 currentNode &#x3D; null&#96; 时停止循环</p>
<p>执行第二步的最佳方法取决于你使用的语言。在 Python 中，很容易构造一个列表的反向副本，也很容易比较两个列表。而在其他语言中，就没有那么简单。因此最好使用双指针法来检查是否为回文。我们在起点放置一个指针，在结尾放置一个指针，每一次迭代判断两个指针指向的元素是否相同，若不同，返回 <code>false</code>；相同则将两个指针向内移动，并继续判断，直到两个指针相遇</p>
<p>在编码的过程中，注意我们比较的是节点值的大小，而不是节点本身。正确的比较方式是：<code>node_1.val == node_2.val</code>，而 <code>node_1 == node_2</code> 是错误的</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li><p>时间复杂度：O(n)，其中 n 指的是链表的元素个数</p>
<ul>
<li>第一步： 遍历链表并将值复制到数组中，O(n)</li>
<li>第二步：双指针判断是否为回文，执行了 O(n&#x2F;2) 次的判断，即 O(n)</li>
<li>总的时间复杂度：O(2n)&#x3D;O(n)</li>
</ul>
</li>
<li><p>空间复杂度：O(n)，其中 nn 指的是链表的元素个数，我们使用了一个数组列表存放链表的元素值</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(head *ListNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    vals := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> ; head != <span class="literal">nil</span>; head = head.Next &#123;</span><br><span class="line">        vals = <span class="built_in">append</span>(vals, head.Val)</span><br><span class="line">    &#125;</span><br><span class="line">    n := <span class="built_in">len</span>(vals)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> vals[:n / <span class="number">2</span>] &#123;</span><br><span class="line">        <span class="keyword">if</span> v != vals[n - <span class="number">1</span> - i] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-用Rand7-实现Rand10-（Go）470-中等"><a href="#12-用Rand7-实现Rand10-（Go）470-中等" class="headerlink" title="12. 用Rand7()实现Rand10()（Go）470-中等"></a><font color=DarkOrange>12. 用Rand7()实现Rand10()（Go）470-中等</font></h4><p><strong>题目：</strong></p>
<p>给定方法 <code>rand7</code> 可生成 <code>[1,7]</code> 范围内的均匀随机整数，试写一个方法 <code>rand10</code> 生成 <code>[1,10]</code> 范围内的均匀随机整数</p>
<p>你只能调用 <code>rand7()</code> 且不能调用其他方法。请不要使用系统的 <code>Math.random()</code> 方法</p>
<p>每个测试用例将有一个内部参数 <code>n</code>，即你实现的函数 <code>rand10()</code> 在测试时将被调用的次数。请注意，这不是传递给 <code>rand10()</code> 的参数</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入<span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">输入<span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">]</span></span><br><span class="line">输入<span class="punctuation">:</span> <span class="number">3</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">,</span><span class="number">10</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
</ul>
<p><strong>思想：</strong></p>
<p>方法一：拒绝采样</p>
<p>思路与算法</p>
<p>我们可以用拒绝采样的方法实现 Rand10()。在拒绝采样中，如果生成的随机数满足要求，那么就返回该随机数，否则会不断生成，直到生成一个满足要求的随机数为止</p>
<ul>
<li>我们只需要能够满足等概率的生成 10 个不同的数即可，具体的生成方法可以有很多种，比如我们可以利用两个 Rand7() 相乘，我们只取其中等概率的 10 个不同的数的组合即可，当然还有许多其他不同的解法，可以利用各种运算和函数的组合等方式来实现<ul>
<li>比如我们可以利用两个Rand7()相乘，分别可以得到结果如下：一大个表格</li>
<li>我们可以得到每个数生成的概率为：一大个表格</li>
<li>我们可以从中挑选 10个等概率的数即可</li>
</ul>
</li>
<li>题目中要求尽可能的减少 Rand7() 的调用次数，则我们应该尽量保证生成的每个不同的数的生成概率尽可能的大，即调用 Rand7() 期望次数尽可能的小</li>
<li>我们可以调用两次 Rand7()，那么可以生成 [1,49] 之间的随机整数，我们只用到其中的前 40 个用来实现 Rand10()，而拒绝剩下的 9 个数，如下图所示</li>
<li>我们可以看到表中的 [1,49] 每个数生成的概率为49分之1。我们实际上只取 [1,40] 这前 40 个数，转化为 [1,10] 时，这 10 个数中每个数的生成概率则为 49分之1</li>
</ul>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：期望时间复杂度为 O(1)，但最坏情况下会达到 O*(∞)（一直被拒绝）</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rand10</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        row := rand7()</span><br><span class="line">        col := rand7()</span><br><span class="line">        idx := (row - <span class="number">1</span>) * <span class="number">7</span> + col</span><br><span class="line">        <span class="keyword">if</span> idx &lt;= <span class="number">40</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + (idx - <span class="number">1</span>) % <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="13-两数之和（Go）1-简单"><a href="#13-两数之和（Go）1-简单" class="headerlink" title="13. 两数之和（Go）1-简单"></a><font color=DarkOrange>13. 两数之和（Go）1-简单</font></h4><p>题目：</p>
<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 和为目标值 <code>target</code>  的那 两个 整数，并返回它们的数组下标</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现</p>
<p>你可以按任意顺序返回答案</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">11</span><span class="punctuation">,</span><span class="number">15</span><span class="punctuation">]</span><span class="punctuation">,</span> target = <span class="number">9</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">解释：因为 nums<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span> + nums<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> == <span class="number">9</span> ，返回 <span class="punctuation">[</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">,</span> target = <span class="number">6</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">,</span> target = <span class="number">6</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 10^4</code></li>
<li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li>
<li><code>-10^9 &lt;= target &lt;= 10^9</code></li>
<li><strong>只会存在一个有效答案</strong></li>
</ul>
<p><strong>思想：</strong></p>
<p>方法二：哈希表</p>
<p>思路及算法</p>
<p>注意到方法一的时间复杂度较高的原因是寻找 <code>target - x</code> 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引</p>
<p>使用哈希表，可以将寻找 <code>target - x</code> 的时间复杂度降低到从 O(N) 降低到 O(1)</p>
<p>这样我们创建一个哈希表，对于每一个 <code>x</code>，我们首先查询哈希表中是否存在 <code>target - x</code>，然后将 <code>x</code> 插入到哈希表中，即可保证不会让 <code>x</code> 和自己匹配</p>
<p><strong>复杂度分析：</strong></p>
<p>时间复杂度：O(N)，其中 NN 是数组中的元素数量。对于每一个元素 <code>x</code>，我们可以 O(1) 地寻找 <code>target - x</code></p>
<p>空间复杂度：O(N)，其中 N 是数组中的元素数量。主要为哈希表的开销</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    hashTable := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> p, ok := hashTable[target - x]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;p, i&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        hashTable[x] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="14-爬楼梯（Go）70-简单"><a href="#14-爬楼梯（Go）70-简单" class="headerlink" title="14. 爬楼梯（Go）70-简单"></a><font color=DarkOrange>14. 爬楼梯（Go）70-简单</font></h4><p><strong>题目：</strong></p>
<p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：有两种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1.</span> <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span> <span class="number">2</span> 阶</span><br><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：有三种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1.</span> <span class="number">1</span> 阶 + <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span> <span class="number">1</span> 阶 + <span class="number">2</span> 阶</span><br><span class="line"><span class="number">3.</span> <span class="number">2</span> 阶 + <span class="number">1</span> 阶</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 45</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：动态规划</p>
<p>思路和算法</p>
<p>我们用 f(x) 表示爬到第 x 级台阶的方案数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，所以我们可以列出如下式子：<br>f(x)&#x3D;f(x−1)+f(x−2)</p>
<p>它意味着爬到第 x 级台阶的方案数是爬到第 x−1 级台阶的方案数和爬到第 x−2 级台阶的方案数的和。很好理解，因为每次只能爬 1 级或 2 级，所以 f(x) 只能从 f(x−1) 和 f(x−2) 转移过来，而这里要统计方案总数，我们就需要对这两项的贡献求和</p>
<p>以上是动态规划的转移方程，下面我们来讨论边界条件。我们是从第 0 级开始爬的，所以从第 0 级爬到第 0 级我们可以看作只有一种方案，即 f(0)&#x3D;1；从第 0 级到第 1 级也只有一种方案，即爬一级，f(1)&#x3D;1。这两个作为边界条件就可以继续向后推导出第 n 级的正确结果</p>
<p>我们不妨写几项来验证一下，根据转移方程得到 f(2)&#x3D;2，f(3)&#x3D;3，f(4)&#x3D;5，……，我们把这些情况都枚举出来，发现计算的结果是正确的</p>
<p>我们不难通过转移方程和边界条件给出一个时间复杂度和空间复杂度都是 O(n) 的实现，但是由于这里的 f(x) 只和 f(x−1) 与 f(x−2) 有关，所以我们可以用「滚动数组思想」把空间复杂度优化成 O(1)。下面的代码中给出的就是这种实现</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：循环执行 n 次，每次花费常数的时间代价，故渐进时间复杂度为 O(n)</li>
<li>空间复杂度：这里只用了常数个变量作为辅助空间，故渐进空间复杂度为 O(1)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    p, q, r := <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        p = q</span><br><span class="line">        q = r</span><br><span class="line">        r = p + q</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-最长递增子系列（Go）-300-中等"><a href="#15-最长递增子系列（Go）-300-中等" class="headerlink" title="15. 最长递增子系列（Go） 300-中等"></a><font color=DarkOrange>15. 最长递增子系列（Go） 300-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度</p>
<p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">10</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">101</span><span class="punctuation">,</span><span class="number">18</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：最长递增子序列是 <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">101</span><span class="punctuation">]</span>，因此长度为 <span class="number">4</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">7</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2500</code></li>
<li><code>-10的4次方 &lt;= nums[i] &lt;= 10的4次方</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：动态规划</p>
<p>思路与算法</p>
<p>定义 dp[i] 为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取</p>
<p>我们从小到大计算 dp 数组的值，在计算 dp[i] 之前，我们已经计算出 dp[0…i−1] 的值，则状态转移方程为：<br>dp[i] &#x3D; max(dp[j]) + 1，其中0&lt;&#x3D;j&lt;i并且num[j]&lt;num[i]</p>
<p>即考虑往 dp[0…i−1] 中最长的上升子序列后面再加一个 nums[i]。由于 dp[j] 代表 nums[0…j] 中以 nums[j] 结尾的最长上升子序列，所以如果能从 dp[j] 这个状态转移过来，那么 nums[i] 必然要大于 nums[j]，才能将 nums[i] 放在 nums[j] 后面以形成更长的上升子序列</p>
<p>最后，整个数组的最长上升子序列即所有 dp[i] 中的最大值</p>
<p>LISlength &#x3D; max(dp[i])，其中0&lt;&#x3D;i&lt;n</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n的2次方)，其中 n 为数组 nums 的长度。动态规划的状态数为 n，计算状态 dp[i] 时，需要 O(n) 的时间遍历 dp[0…i−1] 的所有状态，所以总时间复杂度为 O(n的2次方)</li>
<li>空间复杂度：O(n)，需要额外使用长度为 n 的 dp 数组</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">func LengthOfList(nums []<span class="built_in">int</span>) <span class="built_in">int</span> &#123;</span><br><span class="line">	// 定义dp[i]标识以nums[i]这个数据结尾的最长递增子系列的长度</span><br><span class="line">	dp := make([]<span class="built_in">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">	ans := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(dp); i++ &#123;</span><br><span class="line">		dp[i] = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">		<span class="keyword">for</span> k := <span class="number">0</span>; k &lt; j; k++ &#123;</span><br><span class="line">			<span class="keyword">if</span> nums[j] &gt; nums[k] &#123;</span><br><span class="line">				<span class="keyword">if</span> dp[j] &lt; dp[k]+<span class="number">1</span> &#123;</span><br><span class="line">					dp[j] = dp[k] + <span class="number">1</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="built_in">range</span> dp &#123;</span><br><span class="line">		<span class="keyword">if</span> v &gt; ans &#123;</span><br><span class="line">			ans = v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	nums := []<span class="built_in">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">11</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;结果为：&quot;</span>, LengthOfList(nums))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="16-有效的括号（Go）20-简单"><a href="#16-有效的括号（Go）20-简单" class="headerlink" title="16. 有效的括号（Go）20-简单"></a><font color=DarkOrange>16. 有效的括号（Go）20-简单</font></h4><p><strong>题目：</strong></p>
<p>给定一个只包括 <code>&#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合</li>
<li>左括号必须以正确的顺序闭合</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;()&quot;</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">true</span></span></span><br><span class="line">输入：s = <span class="string">&quot;()[]&#123;&#125;&quot;</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">true</span></span></span><br><span class="line">输入：s = <span class="string">&quot;(]&quot;</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">false</span></span></span><br><span class="line">输入：s = <span class="string">&quot;([)]&quot;</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">false</span></span></span><br><span class="line">输入：s = <span class="string">&quot;&#123;[]&#125;&quot;</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">true</span></span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10^4</code></li>
<li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：栈</p>
<p>判断括号的有效性可以使用「栈」这一数据结构来解决</p>
<p>我们遍历给定的字符串 s。当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶</p>
<p>当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串 s 无效，返回 False。为了快速判断括号的类型，我们可以使用哈希表存储每一种括号。哈希表的键为右括号，值为相同类型的左括号</p>
<p>在遍历结束后，如果栈中没有左括号，说明我们将字符串 s 中的所有左括号闭合，返回 True，否则返回 False</p>
<p>注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 False，省去后续的遍历判断过程</p>
<div align="center"><img src="https://i.bmp.ovh/imgs/2022/06/22/f79a7d99292db85e.png" style="zoom:50%;" /></div>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 是字符串 s 的长度</li>
<li>空间复杂度：O(n+∣Σ∣)，其中 Σ 表示字符集，本题中字符串只包含 6 种括号，∣Σ∣&#x3D;6。栈中的字符数量为 O(n)，而哈希表使用的空间为 O(∣Σ∣)，相加即可得到总空间复杂度</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    pairs := <span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">byte</span>&#123;</span><br><span class="line">        <span class="string">&#x27;)&#x27;</span>:<span class="string">&#x27;(&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;]&#x27;</span>:<span class="string">&#x27;[&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>:<span class="string">&#x27;&#123;&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    stack := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> pairs[s[i]] &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> || stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>] != pairs[s[i]] &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, s[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="17-环形链表（Go）141-简单"><a href="#17-环形链表（Go）141-简单" class="headerlink" title="17. 环形链表（Go）141-简单"></a><font color=DarkOrange>17. 环形链表（Go）141-简单</font></h4><p><strong>题目：</strong></p>
<p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环</p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：<code>pos</code> 不作为参数进行传递 。仅仅是为了标识链表的实际情况</p>
<p>如果链表中存在环 ，则返回 <code>true</code> 。 否则，返回 <code>false</code> </p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">-4</span><span class="punctuation">]</span><span class="punctuation">,</span> pos = <span class="number">1</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">true</span></span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点</span><br><span class="line">输入：head = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> pos = <span class="number">0</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">true</span></span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点</span><br><span class="line">输入：head = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> pos = <span class="number">-1</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">false</span></span></span><br><span class="line">解释：链表中没有环</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 10^4]</code></li>
<li><code>-10^5&lt;= Node.val &lt;= 10^5</code></li>
<li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：哈希表<br>思路及算法</p>
<p>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过</p>
<p>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N 是链表中的节点数。最坏情况下我们需要遍历每个节点一次</li>
<li>空间复杂度：O(N)，其中 N 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    seen := <span class="keyword">map</span>[*ListNode]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> _, ok := seen[head]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        seen[head] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        head = head.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="18-寻找旋转排序数组中的最小值（Go）153-中等"><a href="#18-寻找旋转排序数组中的最小值（Go）153-中等" class="headerlink" title="18. 寻找旋转排序数组中的最小值（Go）153-中等"></a><font color=DarkOrange>18. 寻找旋转排序数组中的最小值（Go）153-中等</font></h4><p><strong>题目：</strong></p>
<p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 旋转 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p>
<ul>
<li>若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]</li>
<li>若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]</li>
</ul>
<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 旋转一次 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> </p>
<p>给你一个元素值 互不相同 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 </p>
<p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：原数组为 <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span> ，旋转 <span class="number">3</span> 次得到输入数组</span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：原数组为 <span class="punctuation">[</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">]</span> ，旋转 <span class="number">4</span> 次得到输入数组</span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">11</span><span class="punctuation">,</span><span class="number">13</span><span class="punctuation">,</span><span class="number">15</span><span class="punctuation">,</span><span class="number">17</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">11</span></span><br><span class="line">解释：原数组为 <span class="punctuation">[</span><span class="number">11</span><span class="punctuation">,</span><span class="number">13</span><span class="punctuation">,</span><span class="number">15</span><span class="punctuation">,</span><span class="number">17</span><span class="punctuation">]</span> ，旋转 <span class="number">4</span> 次得到输入数组</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 5000</code></li>
<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>
<li><code>nums</code> 中的所有整数 互不相同</li>
<li><code>nums</code> 原来是一个升序排序的数组，并进行了 1 至 n 次旋转</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：二分查找</p>
<p>思路与算法</p>
<p>一个不包含重复元素的升序数组在经过旋转之后，可以得到下面可视化的折线图：</p>
<p>其中横轴表示数组元素的下标，纵轴表示数组元素的值。图中标出了最小值的位置，是我们需要查找的目标</p>
<p>我们考虑数组中的最后一个元素 x：在最小值右侧的元素（不包括最后一个元素本身），它们的值一定都严格小于 x；而在最小值左侧的元素，它们的值一定都严格大于 x。因此，我们可以根据这一条性质，通过二分查找的方法找出最小值</p>
<p>在二分查找的每一步中，左边界为 low，右边界为 high，区间的中点为 pivot，最小值就在该区间内。我们将中轴元素 nums[pivot] 与右边界元素 nums[high] 进行比较，可能会有以下的三种情况：</p>
<p>第一种情况是 nums[pivot]&lt;nums[high]。如下图所示，这说明 nums[pivot] 是最小值右侧的元素，因此我们可以忽略二分查找区间的右半部分</p>
<p>第二种情况是 nums[pivot]&gt;nums[high]。如下图所示，这说明 nums[pivot] 是最小值左侧的元素，因此我们可以忽略二分查找区间的左半部分</p>
<p>由于数组不包含重复元素，并且只要当前的区间长度不为 1，pivot 就不会与 high 重合；而如果当前的区间长度为 1，这说明我们已经可以结束二分查找了。因此不会存在 nums[pivot]&#x3D;nums[high] 的情况</p>
<p>当二分查找结束时，我们就得到了最小值所在的位置</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：时间复杂度为 O(logn)，其中 nn 是数组 nums 的长度。在二分查找的过程中，每一步会忽略一半的区间，因此时间复杂度为 O(logn)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMin</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    low, high := <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> low &lt; high &#123;</span><br><span class="line">        pivot := low + (high - low) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[pivot] &lt; nums[high] &#123;</span><br><span class="line">            high = pivot</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = pivot + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[low]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="19-最长回文子串（Go）5-中等"><a href="#19-最长回文子串（Go）5-中等" class="headerlink" title="19. 最长回文子串（Go）5-中等"></a><font color=DarkOrange>19. 最长回文子串（Go）5-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;babad&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bab&quot;</span></span><br><span class="line">解释：<span class="string">&quot;aba&quot;</span> 同样是符合题意的答案</span><br><span class="line">输入：s = <span class="string">&quot;cbbd&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bb&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 仅由数字和英文字母组成</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法二：中心扩展算法</p>
<p>思路与算法</p>
<p>我们仔细观察一下方法一中的状态转移方程：</p>
<p>P(i,i) &#x3D; true<br>P(i,i+1) &#x3D; (Si&#x3D;&#x3D;Si+1)</p>
<p>P(i,j) &#x3D; P(i+1, j+1)^(Si&#x3D;&#x3D;Sj)</p>
<p>找出其中的状态转移链：</p>
<p><em>P</em>(<em>i</em>,<em>j</em>)←<em>P</em>(<em>i</em>+1,<em>j</em>−1)←<em>P</em>(<em>i</em>+2,<em>j</em>−2)←⋯←某一边界情况</p>
<p>可以发现，所有的状态在转移的时候的可能性都是唯一的。也就是说，我们可以从每一种边界情况开始「扩展」，也可以得出所有的状态对应的答案</p>
<p>边界情况即为子串长度为 1 或 2 的情况。我们枚举每一种边界情况，并从对应的子串开始不断地向两边扩展。如果两边的字母相同，我们就可以继续扩展，例如从 P(i+1,j−1) 扩展到 P(i,j)；如果两边的字母不同，我们就可以停止扩展，因为在这之后的子串都不能是回文串了</p>
<p>聪明的读者此时应该可以发现，「边界情况」对应的子串实际上就是我们「扩展」出的回文串的「回文中心」。方法二的本质即为：我们枚举所有的「回文中心」并尝试「扩展」，直到无法扩展为止，此时的回文串长度即为此「回文中心」下的最长回文串长度。我们对所有的长度求出最大值，即可得到最终的答案</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n的2次方)，其中 n 是字符串的长度。长度为 1 和 2 的回文中心分别有 n 和 n−1 个，每个回文中心最多会向外扩展 O(n) 次</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    start, end := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        left1, right1 := expandAroundCenter(s, i ,i)</span><br><span class="line">        left2, right2 := expandAroundCenter(s, i, i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> right1 - left1 &gt; end - start &#123;</span><br><span class="line">            start, end = left1, right1</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> right2 - left2 &gt; end - start &#123;</span><br><span class="line">            start ,end = left2, right2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s[start:end + <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">expandAroundCenter</span><span class="params">(s <span class="type">string</span>, left, right <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> ; left &gt;= <span class="number">0</span> &amp;&amp; right &lt; <span class="built_in">len</span>(s) &amp;&amp; s[left] == s[right]; </span><br><span class="line">    left, right = left - <span class="number">1</span>, right + <span class="number">1</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">return</span> left + <span class="number">1</span>, right - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="20-最长公共子序列（Go）1143-中等"><a href="#20-最长公共子序列（Go）1143-中等" class="headerlink" title="20. 最长公共子序列（Go）1143-中等"></a><font color=DarkOrange>20. 最长公共子序列（Go）1143-中等</font></h4><p><strong>题目：</strong></p>
<p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 </p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串</p>
<ul>
<li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列</li>
</ul>
<p>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：text1 = <span class="string">&quot;abcde&quot;</span><span class="punctuation">,</span> text2 = <span class="string">&quot;ace&quot;</span> </span><br><span class="line">输出：<span class="number">3</span>  </span><br><span class="line">解释：最长公共子序列是 <span class="string">&quot;ace&quot;</span> ，它的长度为 <span class="number">3</span></span><br><span class="line">输入：text1 = <span class="string">&quot;abc&quot;</span><span class="punctuation">,</span> text2 = <span class="string">&quot;abc&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：最长公共子序列是 <span class="string">&quot;abc&quot;</span> ，它的长度为 <span class="number">3</span></span><br><span class="line">输入：text1 = <span class="string">&quot;abc&quot;</span><span class="punctuation">,</span> text2 = <span class="string">&quot;def&quot;</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：两个字符串没有公共子序列，返回 <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li>
<li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：动态规划<br>最长公共子序列问题是典型的二维动态规划问题</p>
<p>假设字符串 text 1和 text2的长度分别为 m 和 n，创建 m+1 行 n+1 列的二维数组 dp，其中 dp[i] [j]表示 text1[0:i] 和 text2[0:j] 的最长公共子序列的长度</p>
<p>上述表示中，text1[0:i] 表示 text1的长度为 i 的前缀，text2[0:j] 表示 text2的长度为 j 的前缀</p>
<p>考虑动态规划的边界情况：</p>
<ul>
<li>当 i&#x3D;0 时，text1[0:i] 为空，空字符串和任何字符串的最长公共子序列的长度都是 0，因此对任意 0≤j≤n，有 dp[0] [j]&#x3D;0</li>
<li>当 j&#x3D;0 时，text2 [0:j] 为空，同理可得，对任意 0≤i≤m，有 dp[i] [0]&#x3D;0</li>
</ul>
<p>因此动态规划的边界情况是：当 i&#x3D;0 或 j&#x3D;0 时，dp[i] [j]&#x3D;0</p>
<p>当 i&gt;0 且 j&gt;0 时，考虑 dp[i] [j] 的计算：</p>
<ul>
<li>当text1[i-1]!&#x3D;text2[j-1]时，将这两个相同的字符称为公共字符，考虑text1[0:i-1]和text2[0:j-1]的最长公共子序列，再增加一个字符（即公共字符）即可得到text1[0:i]和text2[0:j]的最长公共子序列，因此dp[i] [j]&#x3D;dp[i-1] [j-1]+1</li>
<li>当text1[i-1]!&#x3D;text2[j-1]时，考虑以下两项：<ul>
<li>text1[0:i-1]和text2[0:j]的最长公共子序列</li>
<li>text1[0:i]和text2[0:j-1]的最长公共子系列</li>
</ul>
</li>
</ul>
<p>要得到text1[0:i]和text[o:j]的最长公共子系列，应取两项中的长度较大的一项，因此dp[i] [j]&#x3D;max(dp[i-1],dp[i][j-1])</p>
<p>由此可得到如下状态转移方程：</p>
<p>dp[i] [j]&#x3D;1:dp[i-1] [j-1]+1,text1[i-1]&#x3D;text2[j-1] 2:max(dp[i-1] [j],dp[i] [j-1]),text[i-1]!&#x3D;text[j-1]</p>
<p>最终计算得到db[m] [n] 即为text1和text2的最长公共子系列的长度</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(mn)，其中 m 和 n 分别是字符串 text1和 text 2的长度。二维数组 dp 有m+1 行和 n+1 列，需要对 dp 中的每个元素进行计算</li>
<li>空间复杂度：O(mn)，其中 m 和 n 分别是字符串 text1和 text 2的长度。创建了 m+1 行 n+1 列的二维数组 dp</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonSubsequence</span><span class="params">(text1 <span class="type">string</span>, text2 <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    m, n := <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, c1 := <span class="keyword">range</span> text1 &#123;</span><br><span class="line">        <span class="keyword">for</span> j, c2 := <span class="keyword">range</span> text2 &#123;</span><br><span class="line">            <span class="keyword">if</span> c1 == c2 &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j] + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = max(dp[i][j + <span class="number">1</span>], dp[i + <span class="number">1</span>][j]) </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="21-三数之和（Go）15-中等"><a href="#21-三数之和（Go）15-中等" class="headerlink" title="21. 三数之和（Go）15-中等"></a><font color=DarkOrange>21. 三数之和（Go）15-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <code>a，b，c</code> ，使得 <code>a + b + c = 0</code> ？请你找出所有和为 <code>0</code> 且不重复的三元组。<strong>注意：</strong>答案中不可以包含重复的三元组</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">-1</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">-1</span><span class="punctuation">,</span><span class="number">-4</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="punctuation">[</span><span class="number">-1</span><span class="punctuation">,</span><span class="number">-1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="punctuation">[</span><span class="number">-1</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 3000</code></li>
<li><code>-10的5次方 &lt;= nums[i] &lt;= 10的5次方</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：排序 + 双指针</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(N的2次方)，其中 N 是数组 nums 的长度</li>
<li>空间复杂度：O(logN)。我们忽略存储答案的空间，额外的排序的空间复杂度为 O(logN)。然而我们修改了输入的数组 nums，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了 nums 的副本并进行排序，空间复杂度为 O(N)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    ans := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 枚举a</span></span><br><span class="line">    <span class="keyword">for</span> first := <span class="number">0</span>; first &lt; n; first++ &#123;</span><br><span class="line">        <span class="comment">// 需要和上一次枚举的数不同</span></span><br><span class="line">        <span class="keyword">if</span> first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first <span class="number">-1</span>] &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// c对应的指针初始指向数组的最右端</span></span><br><span class="line">        third := n - <span class="number">1</span></span><br><span class="line">        target := <span class="number">-1</span> * nums[first]</span><br><span class="line">        <span class="comment">// 枚举b</span></span><br><span class="line">        <span class="keyword">for</span> second := first + <span class="number">1</span>; second &lt; n; second++ &#123;</span><br><span class="line">            <span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">            <span class="keyword">if</span> second &gt; first + <span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 需要保证b的指针在c的指针左侧</span></span><br><span class="line">            <span class="keyword">for</span> second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target &#123;</span><br><span class="line">                third --</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果指针重合，随着b后续的增加，就不会有满足a+b+c=0并且b&lt;c的c了，可以退出循环</span></span><br><span class="line">            <span class="keyword">if</span> second == third &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> nums[second] + nums[third] == target &#123;</span><br><span class="line">                ans = <span class="built_in">append</span>(ans, []<span class="type">int</span>&#123;nums[first], nums[second], nums[third]&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="22-寻找两个正序数组的中位数（Go）4-困难"><a href="#22-寻找两个正序数组的中位数（Go）4-困难" class="headerlink" title="22. 寻找两个正序数组的中位数（Go）4-困难"></a><font color=DarkOrange>22. 寻找两个正序数组的中位数（Go）4-困难</font></h4><p><strong>题目：</strong></p>
<p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> </p>
<p>算法的时间复杂度应该为 <code>O(log (m+n))</code> </p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：nums1 = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">,</span> nums2 = <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">2.00000</span></span><br><span class="line">解释：合并数组 = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span> ，中位数 <span class="number">2</span></span><br><span class="line">===</span><br><span class="line">输入：nums1 = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> nums2 = <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">2.50000</span></span><br><span class="line">解释：合并数组 = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span> ，中位数 (<span class="number">2</span> + <span class="number">3</span>) / <span class="number">2</span> = <span class="number">2.5</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<p><strong>思路：</strong></p>
<p>方法一：二分查找</p>
<p>给定两个有序数组，要求找到两个有序数组的中位数，最直观的思路有以下两种：</p>
<ul>
<li>使用归并的方式，合并两个有序数组，得到一个大的有序数组。大的有序数组的中间位置的元素，即为中位数</li>
<li>不需要合并两个有序数组，只要找到中位数的位置即可。由于两个数组的长度已知，因此中位数对应的两个数组的下标之和也是已知的。维护两个指针，初始时分别指向两个数组的下标 00 的位置，每次将指向较小值的指针后移一位（如果一个指针已经到达数组末尾，则只需要移动另一个数组的指针），直到到达中位数的位置</li>
</ul>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(log(m+n))，其中 mm 和 nn 分别是数组nums1和 nums2的长度。初始时有 k&#x3D;(m+n)&#x2F;2 或 k&#x3D;(m+n)&#x2F;2+1，每一轮循环可以将查找范围减少一半，因此时间复杂度是 O(log(m+n))</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="type">int</span>, nums2 []<span class="type">int</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">	totalLength := <span class="built_in">len</span>(nums1) + <span class="built_in">len</span>(nums2)</span><br><span class="line">	<span class="keyword">if</span> totalLength%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">		midIndex := totalLength / <span class="number">2</span></span><br><span class="line">		<span class="keyword">return</span> <span class="type">float64</span>(getKthElement(nums1, nums2, midIndex+<span class="number">1</span>))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		midIndex1, midIndex2 := totalLength/<span class="number">2</span><span class="number">-1</span>, totalLength/<span class="number">2</span></span><br><span class="line">		<span class="keyword">return</span> <span class="type">float64</span>(getKthElement(nums1, nums2, midIndex1+<span class="number">1</span>)+getKthElement(nums1, nums2, midIndex2+<span class="number">1</span>)) / <span class="number">2.0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getKthElement</span><span class="params">(nums1, nums2 []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	index1, index2 := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> index1 == <span class="built_in">len</span>(nums1) &#123;</span><br><span class="line">			<span class="keyword">return</span> nums2[index2+k<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> index2 == <span class="built_in">len</span>(nums2) &#123;</span><br><span class="line">			<span class="keyword">return</span> nums1[index1+k<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> k == <span class="number">1</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> min(nums1[index1], nums2[index2])</span><br><span class="line">		&#125;</span><br><span class="line">		half := k / <span class="number">2</span></span><br><span class="line">		newIndex1 := min(index1+half, <span class="built_in">len</span>(nums1)) - <span class="number">1</span></span><br><span class="line">		newIndex2 := min(index2+half, <span class="built_in">len</span>(nums2)) - <span class="number">1</span></span><br><span class="line">		pivot1, pivot2 := nums1[newIndex1], nums2[newIndex2]</span><br><span class="line">		<span class="keyword">if</span> pivot1 &lt;= pivot2 &#123;</span><br><span class="line">			k -= (newIndex1 - index1 + <span class="number">1</span>)</span><br><span class="line">			index1 = newIndex1 + <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			k -= (newIndex2 - index2 + <span class="number">1</span>)</span><br><span class="line">			index2 = newIndex2 + <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>&#125;</span><br><span class="line">	nums2 := []<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;结果为：&quot;</span>, findMedianSortedArrays(nums1, nums2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="23-二叉树的层序遍历（Go）102-中等"><a href="#23-二叉树的层序遍历（Go）102-中等" class="headerlink" title="23. 二叉树的层序遍历（Go）102-中等"></a><font color=DarkOrange>23. 二叉树的层序遍历（Go）102-中等</font></h4><p><strong>题目：</strong></p>
<p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：root = <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">20</span><span class="punctuation">,</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="number">15</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="punctuation">[</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="punctuation">[</span><span class="number">9</span><span class="punctuation">,</span><span class="number">20</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="punctuation">[</span><span class="number">15</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">输入：root = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">输入：root = <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[0, 2000]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：广度优先搜索</p>
<p>思路和算法</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：每个点进队出队各一次，故渐进时间复杂度为 O(n)</li>
<li>空间复杂度：队列中元素的个数不超过 n 个，故渐进空间复杂度为 O(n)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeNode 定义二叉树</span></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Val   <span class="type">int</span></span><br><span class="line">	Left  *TreeNode</span><br><span class="line">	Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateNode 创建二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateNode</span><span class="params">(i <span class="type">int</span>, nums []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">	tree := &amp;TreeNode&#123;nums[i], <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">	<span class="comment">// 左节点的数组下标为1，,3，,5...2*i+1</span></span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(nums) &amp;&amp; <span class="number">2</span>*i+<span class="number">1</span> &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">		tree.Left = CreateNode(<span class="number">2</span>*i+<span class="number">1</span>, nums)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 右节点的数组下标为2,4,6...2*i+2</span></span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(nums) &amp;&amp; <span class="number">2</span>*i+<span class="number">2</span> &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">		tree.Right = CreateNode(<span class="number">2</span>*i+<span class="number">2</span>, nums)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LevelOrder 二叉树层序遍历（广度优先搜索）-中等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LevelOrder</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ret [][]<span class="type">int</span></span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ret</span><br><span class="line">	&#125;</span><br><span class="line">	q := []*TreeNode&#123;root&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; <span class="built_in">len</span>(q) &gt; <span class="number">0</span>; i++ &#123;</span><br><span class="line">		ret = <span class="built_in">append</span>(ret, []<span class="type">int</span>&#123;&#125;)</span><br><span class="line">		<span class="keyword">var</span> p []*TreeNode</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(q); j++ &#123;</span><br><span class="line">			node := q[j]</span><br><span class="line">			ret[i] = <span class="built_in">append</span>(ret[i], node.Val)</span><br><span class="line">			<span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">				p = <span class="built_in">append</span>(p, node.Left)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">				p = <span class="built_in">append</span>(p, node.Right)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		q = p</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PreorderTraversal 二叉树前序遍历（递归）-简单-根节点——左子树——右子树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PreorderTraversal</span><span class="params">(root *TreeNode)</span></span> (vals []<span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> preorder <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span></span><br><span class="line">	preorder = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		vals = <span class="built_in">append</span>(vals, node.Val)</span><br><span class="line">		preorder(node.Left)</span><br><span class="line">		preorder(node.Right)</span><br><span class="line">	&#125;</span><br><span class="line">	preorder(root)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InorderTraversal 二叉树中序遍历（递归）-简单-左子树——根节点——右子树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InorderTraversal</span><span class="params">(root *TreeNode)</span></span> (res []<span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> inorder <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span></span><br><span class="line">	inorder = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		inorder(node.Left)</span><br><span class="line">		res = <span class="built_in">append</span>(res, node.Val)</span><br><span class="line">		inorder(node.Right)</span><br><span class="line">	&#125;</span><br><span class="line">	inorder(root)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PostorderTraversal 二叉树后续遍历（递归）-简单-左子树——右子树——根节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PostorderTraversal</span><span class="params">(root *TreeNode)</span></span> (res []<span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> postorder <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span></span><br><span class="line">	postorder = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		postorder(node.Left)</span><br><span class="line">		postorder(node.Right)</span><br><span class="line">		res = <span class="built_in">append</span>(res, node.Val)</span><br><span class="line">	&#125;</span><br><span class="line">	postorder(root)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 0代表节点为空</span></span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line">	<span class="comment">// 将数组切片转化为二叉树结构体</span></span><br><span class="line">	tree := CreateNode(<span class="number">0</span>, nums)</span><br><span class="line">	levelOrder := LevelOrder(tree)</span><br><span class="line">	fmt.Println(<span class="string">&quot;二叉树层序遍历：&quot;</span>, levelOrder)</span><br><span class="line">	preorderTraversal := PreorderTraversal(tree)</span><br><span class="line">	fmt.Println(<span class="string">&quot;二叉树前序遍历：&quot;</span>, preorderTraversal)</span><br><span class="line">	inorderTraversal := InorderTraversal(tree)</span><br><span class="line">	fmt.Println(<span class="string">&quot;二叉树中序遍历：&quot;</span>, inorderTraversal)</span><br><span class="line">	postorderTraversal := PostorderTraversal(tree)</span><br><span class="line">	fmt.Println(<span class="string">&quot;二叉树后序遍历：&quot;</span>, postorderTraversal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="24-补充题6：手撕堆排序（Go）-912-中等"><a href="#24-补充题6：手撕堆排序（Go）-912-中等" class="headerlink" title="24. 补充题6：手撕堆排序（Go） 912-中等"></a><font color=DarkOrange>24. 补充题6：手撕堆排序（Go） 912-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<p><strong>思路：</strong></p>
<p>算法描述：首先建一个堆，然后调整堆，调整过程是将节点和子节点进行比较，将 其中最大的值变为父节点，递归调整调整次数lgn,最后将根节点和尾节点交换再n次 调整<strong>O(nlgn)</strong></p>
<p>步骤：</p>
<ul>
<li>创建最大堆或者最小堆（我是最小堆）</li>
<li>调整堆</li>
<li>交换首尾节点(为了维持一个完全二叉树才要进行收尾交换)</li>
</ul>
<p><strong>复杂度分析：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapSortMax</span><span class="params">(nums []<span class="type">int</span>, length <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> length &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> nums</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 二叉树深度</span></span><br><span class="line">	depth := length/<span class="number">2</span> - <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := depth; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		<span class="comment">// 假定最大的位置就在i的位置</span></span><br><span class="line">		topmax := i</span><br><span class="line">		leftchild := <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">		rightchild := <span class="number">2</span>*i + <span class="number">2</span></span><br><span class="line">		<span class="comment">// nums[leftchild] &gt; nums[topmax] 防止越界</span></span><br><span class="line">		<span class="keyword">if</span> leftchild &lt;= length<span class="number">-1</span> &amp;&amp; nums[leftchild] &gt; nums[topmax] &#123;</span><br><span class="line">			topmax = leftchild</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// nums[rightchild] &gt; nums[topmax] 防止越界</span></span><br><span class="line">		<span class="keyword">if</span> rightchild &lt;= length<span class="number">-1</span> &amp;&amp; nums[rightchild] &gt; nums[topmax] &#123;</span><br><span class="line">			topmax = rightchild</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> topmax != i &#123;</span><br><span class="line">			nums[i], nums[topmax] = nums[topmax], nums[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	lenght := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; lenght; i++ &#123;</span><br><span class="line">		lastLen := lenght - i</span><br><span class="line">		HeapSortMax(nums, lastLen)</span><br><span class="line">		<span class="keyword">if</span> i &lt; lenght &#123;</span><br><span class="line">			nums[<span class="number">0</span>], nums[lastLen<span class="number">-1</span>] = nums[lastLen<span class="number">-1</span>], nums[<span class="number">0</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">6</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;结果为：&quot;</span>, HeapSort(nums))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="25-相交链表（Go）160-简单"><a href="#25-相交链表（Go）160-简单" class="headerlink" title="25. 相交链表（Go）160-简单"></a><font color=DarkOrange>25. 相交链表（Go）160-简单</font></h4><p><strong>题目：</strong></p>
<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> </p>
<p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p>
<p>题目数据 保证 整个链式结构中不存在环</p>
<p>注意，函数返回结果后，链表必须 保持其原始结构 </p>
<p>自定义评测：</p>
<p>评测系统 的输入如下（你设计的程序 不适用 此输入）：</p>
<ul>
<li>intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0</li>
<li>listA - 第一个链表</li>
<li>listB - 第二个链表</li>
<li>skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数</li>
<li>skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数</li>
</ul>
<p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 </p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = <span class="number">8</span><span class="punctuation">,</span> listA = <span class="punctuation">[</span><span class="number">4</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span><span class="punctuation">,</span> listB = <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span><span class="punctuation">,</span> skipA = <span class="number">2</span><span class="punctuation">,</span> skipB = <span class="number">3</span></span><br><span class="line">输出：Intersected at &#x27;<span class="number">8</span>&#x27;</span><br><span class="line">解释：相交节点的值为 <span class="number">8</span> （注意，如果两个链表相交则不能为 <span class="number">0</span>）</span><br><span class="line">从各自的表头开始算起，链表 A 为 <span class="punctuation">[</span><span class="number">4</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span>，链表 B 为 <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span></span><br><span class="line">在 A 中，相交节点前有 <span class="number">2</span> 个节点；在 B 中，相交节点前有 <span class="number">3</span> 个节点</span><br><span class="line">输入：intersectVal = <span class="number">2</span><span class="punctuation">,</span> listA = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">,</span> listB = <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">,</span> skipA = <span class="number">3</span><span class="punctuation">,</span> skipB = <span class="number">1</span></span><br><span class="line">输出：Intersected at &#x27;<span class="number">2</span>&#x27;</span><br><span class="line">解释：相交节点的值为 <span class="number">2</span> （注意，如果两个链表相交则不能为 <span class="number">0</span>）</span><br><span class="line">从各自的表头开始算起，链表 A 为 <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span>，链表 B 为 <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span></span><br><span class="line">在 A 中，相交节点前有 <span class="number">3</span> 个节点；在 B 中，相交节点前有 <span class="number">1</span> 个节点。</span><br><span class="line">输入：intersectVal = <span class="number">0</span><span class="punctuation">,</span> listA = <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">,</span> listB = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span><span class="punctuation">,</span> skipA = <span class="number">3</span><span class="punctuation">,</span> skipB = <span class="number">2</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">null</span></span></span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span>，链表 B 为 <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span></span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 <span class="number">0</span>，而 skipA 和 skipB 可以是任意值</span><br><span class="line">这两个链表不相交，因此返回 <span class="literal"><span class="keyword">null</span></span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<p><strong>思路：</strong></p>
<p>方法一：哈希集合<br>思路和算法</p>
<p>判断两个链表是否相交，可以使用哈希集合存储链表节点</p>
<p>首先遍历链表 headA，并将链表 headA 中的每个节点加入哈希集合中。然后遍历链表 headB，对于遍历到的每个节点，判断该节点是否在哈希集合中：</p>
<ul>
<li>如果当前节点不在哈希集合中，则继续遍历下一个节点</li>
<li>如果当前节点在哈希集合中，则后面的节点都在哈希集合中，即从当前节点开始的所有节点都在两个链表的相交部分，因此在链表 headB 中遍历到的第一个在哈希集合中的节点就是两个链表相交的节点，返回该节点</li>
</ul>
<p>如果链表 headB 中的所有节点都不在哈希集合中，则两个链表不相交，返回 null</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(m+n)，其中 m 和 n 是分别是链表 headA 和 headB 的长度。需要遍历两个链表各一次</li>
<li>空间复杂度：O(m)，其中 m 是链表 headA 的长度。需要使用哈希集合存储链表 headA 中的全部节点</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    vis := <span class="keyword">map</span>[*ListNode]<span class="type">bool</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> tmp := headA; tmp != <span class="literal">nil</span>; tmp = tmp.Next &#123;</span><br><span class="line">        vis[tmp] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> tmp := headB; tmp != <span class="literal">nil</span>; tmp = tmp.Next &#123;</span><br><span class="line">        <span class="keyword">if</span> vis[tmp] &#123;</span><br><span class="line">            <span class="keyword">return</span> tmp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="26-二叉搜索树的第K大节点（Go）-剑指offer54-简单"><a href="#26-二叉搜索树的第K大节点（Go）-剑指offer54-简单" class="headerlink" title="26. 二叉搜索树的第K大节点（Go） 剑指offer54-简单"></a><font color=DarkOrange>26. 二叉搜索树的第K大节点（Go） 剑指offer54-简单</font></h4><p><strong>题目：</strong></p>
<p>给定一棵二叉搜索树，请找出其中第 <code>k</code> 大的节点的值</p>
<p><strong>示例：</strong></p>
<p><strong>提示：</strong></p>
<p><strong>思路：</strong></p>
<ol>
<li>通过二叉树的中序遍历便是一个从小到大的排序</li>
<li>设置一个count，每遍历一个数据便自增1，当count&#x3D;k时，就找到了正确答案</li>
</ol>
<p><strong>复杂度分析：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 思路：返回中序遍历生成的序列中的第k个节点</span></span><br><span class="line"><span class="comment">// 此题最好只实现：InorderTraverse和KthLargest</span></span><br><span class="line"><span class="comment">// 在Goland IDE里实现全部貌似结果不正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Val   <span class="type">int</span></span><br><span class="line">	Left  *TreeNode</span><br><span class="line">	Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateNode 创建二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateNode</span><span class="params">(i <span class="type">int</span>, nums []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">	tree := &amp;TreeNode&#123;nums[i], <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">	<span class="comment">// 左节点的数组下标为1,3,5...2*i+1</span></span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(nums) &amp;&amp; <span class="number">2</span>*i+<span class="number">1</span> &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">		tree.Left = CreateNode(<span class="number">2</span>*i+<span class="number">1</span>, nums)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 右节点的数组下标为2,4,6...2*i+2</span></span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(nums) &amp;&amp; <span class="number">2</span>*i+<span class="number">2</span> &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">		tree.Right = CreateNode(<span class="number">2</span>*i+<span class="number">2</span>, nums)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InorderTraverse</span><span class="params">(root *TreeNode, ret *[]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	InorderTraverse(root.Left, ret)</span><br><span class="line">	*ret = <span class="built_in">append</span>(*ret, root.Val)</span><br><span class="line">	InorderTraverse(root.Right, ret)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">KthLargest</span><span class="params">(root *TreeNode, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	ret := &amp;[]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	InorderTraverse(root, ret)</span><br><span class="line">	<span class="comment">// 说明没找到第k大节点</span></span><br><span class="line">	<span class="keyword">if</span> k &lt; <span class="number">1</span> &amp;&amp; k &gt; <span class="built_in">len</span>(*ret) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (*ret)[<span class="built_in">len</span>(*ret)-k]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	<span class="comment">// 0代表节点为空</span></span><br><span class="line">	treeNode := CreateNode(<span class="number">0</span>, nums)</span><br><span class="line">	fmt.Println(<span class="string">&quot;结果为：&quot;</span>, KthLargest(treeNode, <span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="27-LFU缓存（Go）-460-困难"><a href="#27-LFU缓存（Go）-460-困难" class="headerlink" title="27. LFU缓存（Go） 460-困难"></a><font color=DarkOrange>27. LFU缓存（Go） 460-困难</font></h4><p><strong>题目：</strong></p>
<p>请你为 最不经常使用（LFU）缓存算法设计并实现数据结构</p>
<p><strong>示例：</strong></p>
<p><strong>提示：</strong></p>
<p><strong>思路：</strong></p>
<p>方法二：双哈希表</p>
<p><strong>复杂度分析：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">	Key   <span class="type">int</span></span><br><span class="line">	Value <span class="type">int</span></span><br><span class="line">	freq  <span class="type">int</span></span><br><span class="line">	pre   *Node</span><br><span class="line">	next  *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LFUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">	limit   <span class="type">int</span></span><br><span class="line">	HashMap <span class="keyword">map</span>[<span class="type">int</span>]*Node</span><br><span class="line">	head    *Node</span><br><span class="line">	end     *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LFUConstructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LFUCache &#123;</span><br><span class="line">	lfuCache := LFUCache&#123;&#125;</span><br><span class="line">	lfuCache.limit = capacity</span><br><span class="line">	lfuCache.HashMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*Node, capacity)</span><br><span class="line">	<span class="keyword">return</span> lfuCache</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lfuCache *LFUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> value, ok := lfuCache.HashMap[key]; ok &#123;</span><br><span class="line">		value.freq++</span><br><span class="line">		lfuCache.refreshNode(value)</span><br><span class="line">		<span class="keyword">return</span> value.Value</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lfuCache *LFUCache)</span></span> Put(key, value <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> v, ok := lfuCache.HashMap[key]; !ok &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(lfuCache.HashMap) &gt;= lfuCache.limit &#123;</span><br><span class="line">			oldKey := lfuCache.removeNode(lfuCache.head)</span><br><span class="line">			<span class="built_in">delete</span>(lfuCache.HashMap, oldKey)</span><br><span class="line">		&#125;</span><br><span class="line">		node := Node&#123;Key: key, Value: value, freq: <span class="number">1</span>&#125;</span><br><span class="line">		lfuCache.addNode(&amp;node)</span><br><span class="line">		lfuCache.HashMap[key] = &amp;node</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		v.Value = value</span><br><span class="line">		v.freq++</span><br><span class="line">		lfuCache.refreshNode(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lfuCache *LFUCache)</span></span> refreshNode(node *Node) &#123;</span><br><span class="line">	<span class="keyword">if</span> node == lfuCache.end &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	lfuCache.removeNode(node)</span><br><span class="line">	lfuCache.addNode(node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lfuCache *LFUCache)</span></span> removeNode(node *Node) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> node == lfuCache.end &#123;</span><br><span class="line">		lfuCache.end = lfuCache.end.pre</span><br><span class="line">		lfuCache.end.next = <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> node == lfuCache.head &#123;</span><br><span class="line">		lfuCache.head = lfuCache.head.next</span><br><span class="line">		lfuCache.head.pre = <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		node.pre.next = node.next</span><br><span class="line">		node.next.pre = node.pre</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> node.Key</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lfuCache *LFUCache)</span></span> addNode(node *Node) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> lfuCache.head == <span class="literal">nil</span> &amp;&amp; lfuCache.end == <span class="literal">nil</span> &#123;</span><br><span class="line">		lfuCache.head = node</span><br><span class="line">		lfuCache.end = node</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	head := lfuCache.head</span><br><span class="line">	<span class="keyword">for</span> head != <span class="literal">nil</span> &amp;&amp; node.freq &gt;= head.freq &#123;</span><br><span class="line">		head = head.next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">		lfuCache.end.next = node</span><br><span class="line">		node.pre = lfuCache.end</span><br><span class="line">		lfuCache.end = node</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">		head.pre.next = node</span><br><span class="line">		node.pre = head.pre</span><br><span class="line">		head.pre = node</span><br><span class="line">		node.next = head</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lfuCache.head.pre = <span class="literal">nil</span></span><br><span class="line">	lfuCache.end.next = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	lfuCache := LFUConstructor(<span class="number">3</span>)</span><br><span class="line">	lfuCache.Put(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">	lfuCache.Put(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">	lfuCache.Put(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">	fmt.Println(lfuCache) <span class="comment">// 此时的链表顺序应该是 1 : 3   2 : 4   3 : 5   lfuCache.head 为1 : 3   lfuCache.end 为3 : 5</span></span><br><span class="line">	lfuCache.Get(<span class="number">1</span>)</span><br><span class="line">	fmt.Println(lfuCache) <span class="comment">// 此时的链表顺序应该是  2 : 4   3 : 5  1 : 3   lfuCache.head 为2 : 4    lfuCache.end 为1 : 3</span></span><br><span class="line">	lfuCache.Put(<span class="number">4</span>, <span class="number">6</span>)</span><br><span class="line">	fmt.Println(lfuCache) <span class="comment">// 此时的链表顺序应该是  3 : 5  4 : 6   1 : 3    lfuCache.head 为3 : 5   lfuCache.end 为1 : 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="28-K个一组翻转链表（Go）25-困难"><a href="#28-K个一组翻转链表（Go）25-困难" class="headerlink" title="28. K个一组翻转链表（Go）25-困难"></a><font color=DarkOrange>28. K个一组翻转链表（Go）25-困难</font></h4><p><strong>题目：</strong></p>
<p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。<code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换</p>
<p><strong>示例：</strong></p>
<p><strong>提示：</strong></p>
<p><strong>思路：</strong></p>
<p><strong>复杂度分析：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Value <span class="type">int</span></span><br><span class="line">	Next  *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseKGroup</span><span class="params">(head *ListNode, k <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">	dummyNode := &amp;ListNode&#123;Next: head&#125;</span><br><span class="line">	pre := dummyNode</span><br><span class="line">	<span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">		tail := pre</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">			tail = tail.Next</span><br><span class="line">			<span class="keyword">if</span> tail == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> dummyNode.Next</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//记录tail后一个节点，以及pre后一个节点</span></span><br><span class="line">		nextGroupHead := tail.Next</span><br><span class="line">		head = pre.Next</span><br><span class="line">		<span class="comment">//反转</span></span><br><span class="line">		ReverseList(head, tail)</span><br><span class="line">		<span class="comment">//拼接</span></span><br><span class="line">		pre.Next = tail</span><br><span class="line">		head.Next = nextGroupHead</span><br><span class="line">		<span class="comment">//更新pre和head</span></span><br><span class="line">		pre = head</span><br><span class="line">		head = nextGroupHead</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dummyNode.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReverseList 翻转链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReverseList</span><span class="params">(head *ListNode, tail *ListNode)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> pre *ListNode</span><br><span class="line">	cur := head</span><br><span class="line">	<span class="keyword">for</span> pre != tail &#123;</span><br><span class="line">		next := cur.Next</span><br><span class="line">		cur.Next = pre</span><br><span class="line">		pre = cur</span><br><span class="line">		cur = next</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="29-买卖股票的最佳时机（Go）121-简单"><a href="#29-买卖股票的最佳时机（Go）121-简单" class="headerlink" title="29. 买卖股票的最佳时机（Go）121-简单"></a><font color=DarkOrange>29. 买卖股票的最佳时机（Go）121-简单</font></h4><p><strong>题目：</strong></p>
<p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 </p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：<span class="punctuation">[</span><span class="number">7</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出，最大利润 = <span class="number">6</span><span class="number">-1</span> = <span class="number">5</span></span><br><span class="line">     注意利润不能是 <span class="number">7</span><span class="number">-1</span> = <span class="number">6</span><span class="punctuation">,</span> 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票</span><br><span class="line">输入：prices = <span class="punctuation">[</span><span class="number">7</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：在这种情况下<span class="punctuation">,</span> 没有交易完成<span class="punctuation">,</span> 所以最大利润为 <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 10的5次方</code></li>
<li><code>0 &lt;= prices[i] &lt;= 10的4次方</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法二：一次遍历（贪心算法）</p>
<p>算法</p>
<p>假设给定的数组为：<code>[7, 1, 5, 3, 6, 4]</code></p>
<p>如果我们在图表上绘制给定数组中的数字，我们将会得到：</p>
<p>我们来假设自己来购买股票。随着时间的推移，每天我们都可以选择出售股票与否。那么，假设在第 i 天，如果我们要在今天卖股票，那么我们能赚多少钱呢</p>
<p>显然，如果我们真的在买卖股票，我们肯定会想：如果我是在历史最低点买的股票就好了！太好了，在题目中，我们只要用一个变量记录一个历史最低价格 minprice，我们就可以假设自己的股票是在那天买的。那么我们在第 i 天卖出股票能得到的利润就是 prices[i] - minprice</p>
<p>因此，我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)，只需要遍历一次</li>
<li>空间复杂度：O(1)，只使用了常数个变量</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MaxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 贪心</span></span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	m := prices[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> prices[i] &gt; m &#123;</span><br><span class="line">			<span class="keyword">if</span> (prices[i] - m) &gt; res &#123;</span><br><span class="line">				res = prices[i] - m</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			m = prices[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;结果为：&quot;</span>, MaxProfit(nums))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="30-基本计算器2（Go）227-中等"><a href="#30-基本计算器2（Go）227-中等" class="headerlink" title="30. 基本计算器2（Go）227-中等"></a><font color=DarkOrange>30. 基本计算器2（Go）227-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值</p>
<p>整数除法仅保留整数部分</p>
<p>你可以假设给定的表达式总是有效的。所有中间结果将在 <code>[-2^31, 2^31 - 1]</code> 的范围内</p>
<p>注意：不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval()</code> </p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;3+2*2&quot;</span></span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">输入：s = <span class="string">&quot; 3/2 &quot;</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">输入：s = <span class="string">&quot; 3+5 / 2 &quot;</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; s.length &lt;&#x3D; 3 * 10^5</li>
<li>s 由整数和算符 (‘+’, ‘-‘, ‘*’, ‘&#x2F;‘) 组成，中间由一些空格隔开</li>
<li>s 表示一个 有效表达式</li>
<li>表达式中的所有整数都是非负整数，且在范围 [0, 2^31 - 1] 内</li>
<li>题目数据保证答案是一个 32-bit 整数</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：栈<br>思路</p>
<p>由于乘除优先于加减计算，因此不妨考虑先进行所有乘除运算，并将这些乘除运算后的整数值放回原表达式的相应位置，则随后整个表达式的值，就等于一系列整数加减后的值</p>
<p>基于此，我们可以用一个栈，保存这些（进行乘除运算后的）整数的值。对于加减号后的数字，将其直接压入栈中；对于乘除号后的数字，可以直接与栈顶元素计算，并替换栈顶元素为计算后的结果</p>
<p>具体来说，遍历字符串 s，并用变量 preSign 记录每个数字之前的运算符，对于第一个数字，其之前的运算符视为加号。每次遍历到数字末尾时，根据 preSign 来决定计算方式：</p>
<ul>
<li>加号：将数字压入栈</li>
<li>减号：将数字的相反数压入栈</li>
<li>乘除号：计算数字与栈顶元素，并将栈顶元素替换为计算结果</li>
</ul>
<p>代码实现中，若读到一个运算符，或者遍历到字符串末尾，即认为是遍历到了数字末尾。处理完该数字后，更新 preSign 为当前遍历的字符</p>
<p>遍历完字符串 s 后，将栈中元素累加，即为该字符串表达式的值</p>
<p><strong>复杂度分析：</strong></p>
<p>时间复杂度：O(n)，其中 n 为字符串 s 的长度。需要遍历字符串 s 一次，计算表达式的值</p>
<p>空间复杂度：O(n)，其中 n 为字符串 s 的长度。空间复杂度主要取决于栈的空间，栈的元素个数不超过 n</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculate</span><span class="params">(s <span class="type">string</span>)</span></span> (ans <span class="type">int</span>) &#123;</span><br><span class="line">    stack := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    preSign := <span class="string">&#x27;+&#x27;</span></span><br><span class="line">    num := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, ch := <span class="keyword">range</span> s &#123;</span><br><span class="line">        isDigit := <span class="string">&#x27;0&#x27;</span> &lt; ch &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> isDigit &#123;</span><br><span class="line">            num = num * <span class="number">10</span> + <span class="type">int</span>(ch - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !isDigit &amp;&amp; ch != <span class="string">&#x27; &#x27;</span> || i == <span class="built_in">len</span>(s) - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> preSign &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, num)</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, -num)</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>] *= num</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>] /= num</span><br><span class="line">            &#125;</span><br><span class="line">            preSign = ch</span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> stack &#123;</span><br><span class="line">        ans += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="31-数组中重复的数据（Go）442-中等"><a href="#31-数组中重复的数据（Go）442-中等" class="headerlink" title="31. 数组中重复的数据（Go）442-中等"></a><font color=DarkOrange>31. 数组中重复的数据（Go）442-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，其中 <code>nums</code> 的所有整数都在范围 <code>[1, n]</code> 内，且每个整数出现 一次 或 两次 。请你找出所有出现 两次 的整数，并以数组形式返回</p>
<p>你必须设计并实现一个时间复杂度为 <code>O(n)</code> 且仅使用常量额外空间的算法解决此问题</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">4</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= n</code></li>
<li><code>nums</code> 中的每个元素出现 <strong>一次</strong> 或 <strong>两次</strong></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：将元素交换到对应的位置<br>思路与算法</p>
<p>由于给定的 n 个数都在 [1,n] 的范围内，如果有数字出现了两次，就意味着 [1,n] 中有数字没有出现过</p>
<p>因此，我们可以尝试将每一个数放在对应的位置。由于数组的下标范围是 [0,n−1]，我们需要将数 i 放在数组中下标为 i−1 的位置：</p>
<ul>
<li>如果 i 恰好出现了一次，那么将 i 放在数组中下标为 i−1 的位置即可</li>
<li>如果 i 出现了两次，那么我们希望其中的一个 i 放在数组下标中为 i−1 的位置，另一个 i 放置在任意「不冲突」的位置 j。也就是说，数 j+1 没有在数组中出现过</li>
</ul>
<p>这样一来，如果我们按照上述的规则放置每一个数，那么我们只需要对数组进行一次遍历。当遍历到位置 i 时，如果 nums[i]−1!&#x3D;i，说明 nums[i] 出现了两次（另一次出现在位置 num[i]−1），我们就可以将 num[i] 放入答案</p>
<p>放置的方法也很直观：我们对数组进行一次遍历。当遍历到位置 i 时，我们知道 nums[i] 应该被放在位置 nums[i]−1。因此我们交换 num[i] 和 nums[nums[i]−1] 即可，直到待交换的两个元素相等为止</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li><p>时间复杂度：O(n)。每一次交换操作会使得至少一个元素被交换到对应的正确位置，因此交换的次数为 O(n)，总时间复杂度为 O(n)</p>
</li>
<li><p>空间复杂度：O(1)。返回值不计入空间复杂度</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDuplicates</span><span class="params">(nums []<span class="type">int</span>)</span></span> (ans []<span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">for</span> nums[i] != nums[nums[i] - <span class="number">1</span>] &#123;</span><br><span class="line">            nums[i], nums[nums[i] - <span class="number">1</span>] = nums[nums[i] - <span class="number">1</span>], nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num - <span class="number">1</span> != i &#123;</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, num)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="32-零钱兑换（Go）-332-中等"><a href="#32-零钱兑换（Go）-332-中等" class="headerlink" title="32. 零钱兑换（Go） 332-中等"></a><font color=DarkOrange>32. 零钱兑换（Go） 332-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。你可以认为每种硬币的数量是无限的</p>
<p><strong>示例：</strong></p>
<p><strong>提示：</strong></p>
<p><strong>思路：</strong></p>
<p>动态规划</p>
<p><strong>复杂度分析：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CoinChange</span><span class="params">(coins []<span class="type">int</span>, amount <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">	<span class="comment">// 初始化线性备忘录</span></span><br><span class="line">	<span class="keyword">for</span> k := <span class="keyword">range</span> dp &#123;</span><br><span class="line">		<span class="comment">// 相当于无限大，方便比较</span></span><br><span class="line">		dp[k] = amount + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 这个就是占位的</span></span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(dp); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> _, coin := <span class="keyword">range</span> coins &#123;</span><br><span class="line">			<span class="comment">// 至少包含 1 枚某种硬币</span></span><br><span class="line">			<span class="keyword">if</span> i-coin &lt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span> <span class="comment">// 这种情况别闹</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 选择一个较小的</span></span><br><span class="line">			dp[i] = min(dp[i], <span class="number">1</span>+dp[i-coin])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> dp[amount] == amount+<span class="number">1</span> &#123;</span><br><span class="line">		<span class="comment">// 没有合适的</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;结果为：&quot;</span>, CoinChange(nums, <span class="number">11</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="33-两数相加（Go）2-中等"><a href="#33-两数相加（Go）2-中等" class="headerlink" title="33. 两数相加（Go）2-中等"></a><font color=DarkOrange>33. 两数相加（Go）2-中等</font></h4><p><strong>题目：</strong></p>
<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：l1 = <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">,</span> l2 = <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">7</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">]</span></span><br><span class="line">解释：<span class="number">342</span> + <span class="number">465</span> = <span class="number">807.</span></span><br><span class="line">输入：l1 = <span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span><span class="punctuation">,</span> l2 = <span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span></span><br><span class="line">输入：l1 = <span class="punctuation">[</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">]</span><span class="punctuation">,</span> l2 = <span class="punctuation">[</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">8</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
<li>题目数据保证列表表示的数字不含前导零</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：模拟<br>思路与算法</p>
<p>由于输入的两个链表都是逆序存储数字的位数的，因此两个链表中同一位置的数字可以直接相加</p>
<p>我们同时遍历两个链表，逐位计算它们的和，并与当前位置的进位值相加。具体而言，如果当前两个链表处相应位置的数字为 n1,n2，进位值为 carry，则它们的和为 n1+n2+carry；其中，答案链表处相应位置的数字为 (n1+n2+carry)mod10，而新的进位值为 ⌊<br>n1+n2+carry除以10⌋</p>
<p>如果两个链表的长度不同，则可以认为长度短的链表的后面有若干个 0 </p>
<p>此外，如果链表遍历结束后，有 carry&gt;0，还需要在答案链表的后面附加一个节点，节点的值为 carry</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(max(m,n))，其中 m 和 n 分别为两个链表的长度。我们要遍历两个链表的全部位置，而处理每个位置只需要 O(1) 的时间</li>
<li>空间复杂度：O(1)。注意返回值不计入空间复杂度</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span></span> (head *ListNode) &#123;</span><br><span class="line">    <span class="keyword">var</span> tail *ListNode</span><br><span class="line">    carry := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> l1 != <span class="literal">nil</span> || l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        n1, n2 := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            n1 = l1.Val</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            n2 = l2.Val</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        sum := n1 + n2 +carry</span><br><span class="line">        sum, carry = sum % <span class="number">10</span>, sum / <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">            head = &amp;ListNode&#123;Val: sum&#125;</span><br><span class="line">            tail = head</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail.Next = &amp;ListNode&#123;Val: sum&#125;</span><br><span class="line">            tail = tail.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> carry &gt; <span class="number">0</span> &#123;</span><br><span class="line">        tail.Next = &amp;ListNode&#123;Val: carry&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="34-链表中倒数第K个节点（Go）剑指offer22-简单"><a href="#34-链表中倒数第K个节点（Go）剑指offer22-简单" class="headerlink" title="34. 链表中倒数第K个节点（Go）剑指offer22-简单"></a><font color=DarkOrange>34. 链表中倒数第K个节点（Go）剑指offer22-简单</font></h4><p><strong>题目：</strong></p>
<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点</p>
<p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 <code>1、2、3、4、5、6</code>。这个链表的倒数第 3 个节点是值为 4 的节点</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">给定一个链表<span class="punctuation">:</span> <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span><span class="punctuation">,</span> 和 k = <span class="number">2.</span></span><br><span class="line">返回链表 <span class="number">4</span>-&gt;<span class="number">5.</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<p><strong>思路：</strong></p>
<p>方法一：顺序查找<br>思路与算法</p>
<p>最简单直接的方法即为顺序查找，假设当前链表的长度为 n，则我们知道链表的倒数第 k 个节点即为正数第 n−k 个节点，此时我们只需要顺序遍历到链表的第 n−k 个节点即为倒数第 k 个节点</p>
<p>我们首先求出链表的长度 n，然后顺序遍历到链表的第 n−k 个节点返回即可</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 为链表的长度。需要两次遍历</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getKthFromEnd</span><span class="params">(head *ListNode, k <span class="type">int</span>)</span></span> (kth *ListNode) &#123;</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> node := head; node != <span class="literal">nil</span>; node = node.Next &#123;</span><br><span class="line">        n++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> kth = head; n &gt; k; n-- &#123;</span><br><span class="line">        kth = kth.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="35-路径总和（Go）112-简单"><a href="#35-路径总和（Go）112-简单" class="headerlink" title="35. 路径总和（Go）112-简单"></a><font color=DarkOrange>35. 路径总和（Go）112-简单</font></h4><p><strong>题目：</strong></p>
<p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> </p>
<p>叶子节点 是指没有子节点的节点</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：root = <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">,</span><span class="number">11</span><span class="punctuation">,</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="number">13</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> targetSum = <span class="number">22</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">true</span></span></span><br><span class="line">解释：等于目标和的根节点到叶节点路径如上图所示</span><br><span class="line">输入：root = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">,</span> targetSum = <span class="number">5</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">false</span></span></span><br><span class="line">解释：树中存在两条根节点到叶子节点的路径：</span><br><span class="line">(<span class="number">1</span> --&gt; <span class="number">2</span>)<span class="punctuation">:</span> 和为 <span class="number">3</span></span><br><span class="line">(<span class="number">1</span> --&gt; <span class="number">3</span>)<span class="punctuation">:</span> 和为 <span class="number">4</span></span><br><span class="line">不存在 sum = <span class="number">5</span> 的根节点到叶子节点的路径</span><br><span class="line">输入：root = <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> targetSum = <span class="number">0</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">false</span></span></span><br><span class="line">解释：由于树是空的，所以不存在根节点到叶子节点的路径</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目在范围 <code>[0, 5000]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：广度优先搜索<br>思路及算法</p>
<p>首先我们可以想到使用广度优先搜索的方式，记录从根节点到当前节点的路径和，以防止重复计算</p>
<p>这样我们使用两个队列，分别存储将要遍历的节点，以及根节点到这些节点的路径和即可</p>
<p><strong>复杂度分析：</strong></p>
<p>时间复杂度：O(N)，其中 N 是树的节点数。对每个节点访问一次</p>
<p>空间复杂度：O(N)，其中 N 是树的节点数。空间复杂度主要取决于队列的开销，队列中的元素个数不会超过树的节点数</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasPathSum</span><span class="params">(root *TreeNode, targetSum <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    queNode := []*TreeNode&#123;&#125;</span><br><span class="line">    queVal := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    queNode = <span class="built_in">append</span>(queNode, root)</span><br><span class="line">    queVal = <span class="built_in">append</span>(queVal, root.Val)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queNode) != <span class="number">0</span> &#123;</span><br><span class="line">        now := queNode[<span class="number">0</span>]</span><br><span class="line">        queNode = queNode[<span class="number">1</span>:]</span><br><span class="line">        temp := queVal[<span class="number">0</span>]</span><br><span class="line">        queVal = queVal[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">if</span> now.Left == <span class="literal">nil</span> &amp;&amp; now.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> temp == targetSum &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> now.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">            queNode = <span class="built_in">append</span>(queNode, now.Left)</span><br><span class="line">            queVal = <span class="built_in">append</span>(queVal, now.Left.Val + temp)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> now.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">            queNode = <span class="built_in">append</span>(queNode, now.Right)</span><br><span class="line">            queVal = <span class="built_in">append</span>(queVal, now.Right.Val + temp)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="36-字符串相乘（Go）43-中等"><a href="#36-字符串相乘（Go）43-中等" class="headerlink" title="36. 字符串相乘（Go）43-中等"></a><font color=DarkOrange>36. 字符串相乘（Go）43-中等</font></h4><p><strong>题目：</strong></p>
<p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式</p>
<p>注意：不能使用任何内置的 <code>BigInteger</code> 库或直接将输入转换为整数</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入<span class="punctuation">:</span> num1 = <span class="string">&quot;2&quot;</span><span class="punctuation">,</span> num2 = <span class="string">&quot;3&quot;</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="string">&quot;6&quot;</span></span><br><span class="line">输入<span class="punctuation">:</span> num1 = <span class="string">&quot;123&quot;</span><span class="punctuation">,</span> num2 = <span class="string">&quot;456&quot;</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="string">&quot;56088&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; num1.length, num2.length &lt;&#x3D; 200</li>
<li>num1 和 num2 只能由数字组成</li>
<li>num1 和 num2 都不包含任何前导零，除了数字0本身</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：做加法<br>如果 num1和 num2之一是 0，则直接将 0 作为结果返回即可</p>
<p>如果 num1和 num2都不是 0，则可以通过模拟「竖式乘法」的方法计算乘积。从右往左遍历乘数，将乘数的每一位与被乘数相乘得到对应的结果，再将每次得到的结果累加。这道题中，被乘数是 num1，乘数是 num2</p>
<p>需要注意的是，num2除了最低位以外，其余的每一位的运算结果都需要补 0</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(mn+n^2)，其中 m 和 n 分别是 num1和 num2的长度。需要从右往左遍历 num2，对于 num2 的每一位，都需要和 num1的每一位计算乘积，因此计算乘积的总次数是 mn。字符串相加操作共有 n 次，相加的字符串长度最长为 m+n，因此字符串相加的时间复杂度是 O(mn+n^2)。总时间复杂度是 O(mn+n^2)</li>
<li>空间复杂度：O(m+n)，其中 m 和 n 分别是 num1和 num2的长度。空间复杂度取决于存储中间状态的字符串，由于乘积的最大长度为 m+n，因此存储中间状态的字符串的长度不会超过 m+n</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiply</span><span class="params">(num1 <span class="type">string</span>, num2 <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> num1 == <span class="string">&quot;0&quot;</span> || num2 == <span class="string">&quot;0&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="string">&quot;0&quot;</span></span><br><span class="line">    m, n := <span class="built_in">len</span>(num1), <span class="built_in">len</span>(num2)</span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        curr := <span class="string">&quot;&quot;</span></span><br><span class="line">        add := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j := n - <span class="number">1</span>; j &gt; i; j-- &#123;</span><br><span class="line">            curr += <span class="string">&quot;0&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        y := <span class="type">int</span>(num2[i] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> j := m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j-- &#123;</span><br><span class="line">            x := <span class="type">int</span>(num1[j] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            product := x * y + add</span><br><span class="line">            curr = strconv.Itoa(product % <span class="number">10</span>) + curr</span><br><span class="line">            add = product / <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ; add != <span class="number">0</span>; add /= <span class="number">10</span> &#123;</span><br><span class="line">            curr = strconv.Itoa(add % <span class="number">10</span>) + curr</span><br><span class="line">        &#125;</span><br><span class="line">        ans = addStrings(ans, curr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addStrings</span><span class="params">(num1, num2 <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    i, j := <span class="built_in">len</span>(num1) - <span class="number">1</span>, <span class="built_in">len</span>(num2) - <span class="number">1</span></span><br><span class="line">    add := <span class="number">0</span></span><br><span class="line">    ans := <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> ; i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>; i, j = i - <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">        x, y := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> x &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            x = <span class="type">int</span>(num1[i] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> j &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            y = <span class="type">int</span>(num2[j] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        result := x + y + add</span><br><span class="line">        ans = strconv.Itoa(result % <span class="number">10</span>) + ans</span><br><span class="line">        add = result / <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="37-用栈实现队列（Go）-232-简单"><a href="#37-用栈实现队列（Go）-232-简单" class="headerlink" title="37. 用栈实现队列（Go） 232-简单"></a><font color=DarkOrange>37. 用栈实现队列（Go） 232-简单</font></h4><p><strong>题目：</strong></p>
<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p>
<p>实现 <code>MyQueue</code> 类：</p>
<ul>
<li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li>
<li><code>int pop()</code> 从队列的开头移除并返回元素</li>
<li><code>int peek()</code> 返回队列开头的元素</li>
<li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li>
</ul>
<p>说明：</p>
<ul>
<li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="punctuation">[</span><span class="string">&quot;MyQueue&quot;</span><span class="punctuation">,</span> <span class="string">&quot;push&quot;</span><span class="punctuation">,</span> <span class="string">&quot;push&quot;</span><span class="punctuation">,</span> <span class="string">&quot;peek&quot;</span><span class="punctuation">,</span> <span class="string">&quot;pop&quot;</span><span class="punctuation">,</span> <span class="string">&quot;empty&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">输出：</span><br><span class="line"><span class="punctuation">[</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyQueue myQueue = new MyQueue();</span><br><span class="line">myQueue.push(<span class="number">1</span>); <span class="comment">// queue is: [1]</span></span><br><span class="line">myQueue.push(<span class="number">2</span>); <span class="comment">// queue is: [1, 2] (leftmost is front of the queue)</span></span><br><span class="line">myQueue.peek(); <span class="comment">// return 1</span></span><br><span class="line">myQueue.pop(); <span class="comment">// return 1, queue is [2]</span></span><br><span class="line">myQueue.empty(); <span class="comment">// return false</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= x &lt;= 9</code></li>
<li>最多调用 <code>100</code> 次 <code>push</code>、<code>pop</code>、pe<code>ek</code> 和 <code>empty</code></li>
<li>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li>
</ul>
<p><strong>思路：</strong></p>
<p>队列是一种 先进先出（first in - first out， FIFO）的数据结构，队列中的元素都从后端（rear）入队（push），从前端（front）出队（pop）<br>实现队列最直观的方法是用链表，但在这篇文章里我会介绍另一个方法 - 使用栈</p>
<p>栈是一种 后进先出（last in - first out， LIFO）的数据结构，栈中元素从栈顶（top）压入（push)，也从栈顶弹出（pop）</p>
<p>为了满足队列的 FIFO 的特性，我们需要用到两个栈，用它们其中一个来反转元素的入队顺序，用另一个来存储元素的最终顺序</p>
<p>方法一（使用两个栈 入队 - O(n)， 出队 - O(1)）</p>
<p>算法</p>
<p><strong>一. 入队（push）</strong></p>
<p>一个队列是 FIFO 的，但一个栈是 LIFO 的。这就意味着最新压入的元素必须得放在栈底。为了实现这个目的，我们首先需要把 s1 中所有的元素移到 s2 中，接着把新元素压入 s2。最后把 s2 中所有的元素弹出，再把弹出的元素压入 s1</p>
<p><strong>二. 出队（pop）</strong></p>
<p>直接从 <code>s1</code> 弹出就可以了，因为 <code>s1</code> 的栈顶元素就是队列的队首元素。同时我们把弹出之后 <code>s1</code> 的栈顶元素赋值给代表队首元素的 <code>front</code> 变量</p>
<p><strong>三. 判断空（empty）</strong></p>
<p><code>s1</code> 存储了队列所有的元素，所以只需要检查 <code>s1</code> 的是否为空就可以了</p>
<p><strong>四. 取队首元素（peek）</strong></p>
<p>在我们的算法中，用了 <code>front</code> 变量来存储队首元素，在每次 <code>入队</code> 操作或者 <code>出队</code> 操作之后这个变量都会随之更新</p>
<p><strong>复杂度分析：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> MyQueue struct &#123;</span><br><span class="line">    stack []<span class="built_in">int</span></span><br><span class="line">    back []<span class="built_in">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Constructor() MyQueue &#123;</span><br><span class="line">    <span class="keyword">return</span> MyQueue&#123;</span><br><span class="line">        stack: make([]<span class="built_in">int</span>, <span class="number">0</span>),</span><br><span class="line">        back: make([]<span class="built_in">int</span>, <span class="number">0</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (this *MyQueue) Push(x <span class="built_in">int</span>)  &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(this.back) != <span class="number">0</span> &#123;</span><br><span class="line">        val := this.back[<span class="built_in">len</span>(this.back) - <span class="number">1</span>]</span><br><span class="line">        this.back = this.back[:<span class="built_in">len</span>(this.back) - <span class="number">1</span>]</span><br><span class="line">        this.stack = append(this.stack, val)</span><br><span class="line">    &#125;</span><br><span class="line">    this.stack = append(this.stack, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (this *MyQueue) Pop() <span class="built_in">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(this.stack) != <span class="number">0</span> &#123;</span><br><span class="line">        val := this.stack[<span class="built_in">len</span>(this.stack) - <span class="number">1</span>]</span><br><span class="line">        this.stack = this.stack[:<span class="built_in">len</span>(this.stack) - <span class="number">1</span>]</span><br><span class="line">        this.back = append(this.back, val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.back) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    val := this.back[<span class="built_in">len</span>(this.back) - <span class="number">1</span>]</span><br><span class="line">    this.back = this.back[:<span class="built_in">len</span>(this.back) - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (this *MyQueue) Peek() <span class="built_in">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(this.stack) != <span class="number">0</span> &#123;</span><br><span class="line">        val := this.stack[<span class="built_in">len</span>(this.stack) - <span class="number">1</span>]</span><br><span class="line">        this.stack = this.stack[:<span class="built_in">len</span>(this.stack) - <span class="number">1</span>]</span><br><span class="line">        this.back = append(this.back, val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.back) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    val := this.back[<span class="built_in">len</span>(this.back) - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (this *MyQueue) Empty() <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(this.stack) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(this.back) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="38-用队列实现栈（Go）225-简单"><a href="#38-用队列实现栈（Go）225-简单" class="headerlink" title="38. 用队列实现栈（Go）225-简单"></a><font color=DarkOrange>38. 用队列实现栈（Go）225-简单</font></h4><p><strong>题目：</strong></p>
<p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）</p>
<p><strong>示例：</strong></p>
<p><strong>提示：</strong></p>
<p><strong>思路：</strong></p>
<p><strong>复杂度分析：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyStack <span class="keyword">struct</span> &#123;</span><br><span class="line">	queue1, queue2 []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructor 在这里初始化你的数据结构</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> (s MyStack) &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyStack)</span></span> Push(x <span class="type">int</span>) &#123;</span><br><span class="line">	s.queue2 = <span class="built_in">append</span>(s.queue2, x)</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(s.queue1) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		s.queue2 = <span class="built_in">append</span>(s.queue2, s.queue1[<span class="number">0</span>])</span><br><span class="line">		s.queue1 = s.queue1[<span class="number">1</span>:]</span><br><span class="line">	&#125;</span><br><span class="line">	s.queue1, s.queue2 = s.queue2, s.queue1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyStack)</span></span> Pop() <span class="type">int</span> &#123;</span><br><span class="line">	v := s.queue1[<span class="number">0</span>]</span><br><span class="line">	s.queue1 = s.queue1[<span class="number">1</span>:]</span><br><span class="line">	<span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyStack)</span></span> Top() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.queue1[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyStack)</span></span> Empty() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s.queue1) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="39-翻转字符串里的单词-151-中等"><a href="#39-翻转字符串里的单词-151-中等" class="headerlink" title="39. 翻转字符串里的单词 151-中等"></a><font color=DarkOrange>39. 翻转字符串里的单词 151-中等</font></h4><p><strong>题目：</strong></p>
<p><strong>示例：</strong></p>
<p><strong>提示：</strong></p>
<p><strong>思路：</strong></p>
<p><strong>复杂度分析：</strong></p>
<p><strong>代码：</strong></p>
<h4 id="40-平衡二叉树（Go）110-简单"><a href="#40-平衡二叉树（Go）110-简单" class="headerlink" title="40. 平衡二叉树（Go）110-简单"></a><font color=DarkOrange>40. 平衡二叉树（Go）110-简单</font></h4><p><strong>题目：</strong></p>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树</p>
<p>本题中，一棵高度平衡二叉树定义为：一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 </p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：root = <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">20</span><span class="punctuation">,</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="number">15</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">true</span></span></span><br><span class="line">输入：root = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">false</span></span></span><br><span class="line">输入：root = <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">true</span></span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中的节点数在范围 <code>[0, 5000]</code> 内</li>
<li><code>-10^4 &lt;= Node.val &lt;= 10^4</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>前言<br>这道题中的平衡二叉树的定义是：二叉树的每个节点的左右子树的高度差的绝对值不超过 1，则二叉树是平衡二叉树。根据定义，一棵二叉树是平衡二叉树，当且仅当其所有子树也都是平衡二叉树，因此可以使用递归的方式判断二叉树是不是平衡二叉树，递归的顺序可以是自顶向下或者自底向上</p>
<p>方法一：自顶向下的递归<br>定义函数 height，用于计算二叉树中的任意一个节点 p 的高度：</p>
<p>有了计算节点高度的函数，即可判断二叉树是否平衡。具体做法类似于二叉树的前序遍历，即对于当前遍历到的节点，首先计算左右子树的高度，如果左右子树的高度差是否不超过 1，再分别递归地遍历左右子节点，并判断左子树和右子树是否平衡。这是一个自顶向下的递归的过程</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li><p>时间复杂度：O(n^2)，其中 n 是二叉树中的节点个数</p>
<p>最坏情况下，二叉树是满二叉树，需要遍历二叉树中的所有节点，时间复杂度是 O(n)</p>
<p>对于节点 p，如果它的高度是 d，则 height(p) 最多会被调用 d 次（即遍历到它的每一个祖先节点时）。对于平均的情况，一棵树的高度 h 满足 O(h)&#x3D;O(logn)，因为 d≤h，所以总时间复杂度为 O(nlogn)。对于最坏的情况，二叉树形成链式结构，高度为 O(n)，此时总时间复杂度为 O(n^2)</p>
</li>
<li><p>空间复杂度：O(n)，其中 n 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 n</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isBalanced</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> abs(height(root.Left) - height(root.Right)) &lt;= <span class="number">1</span> &amp;&amp;</span><br><span class="line">    isBalanced(root.Left) &amp;&amp; isBalanced(root.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">height</span><span class="params">(root * TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(height(root.Left), height(root.Right)) + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> * x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="41-螺旋矩阵（Go）54-中等"><a href="#41-螺旋矩阵（Go）54-中等" class="headerlink" title="41. 螺旋矩阵（Go）54-中等"></a><font color=DarkOrange>41. 螺旋矩阵（Go）54-中等</font></h4><p><strong>题目：</strong></p>
<p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：matrix = <span class="punctuation">[</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="punctuation">[</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="punctuation">[</span><span class="number">7</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span></span><br><span class="line">输入：matrix = <span class="punctuation">[</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="punctuation">[</span><span class="number">9</span><span class="punctuation">,</span><span class="number">10</span><span class="punctuation">,</span><span class="number">11</span><span class="punctuation">,</span><span class="number">12</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">,</span><span class="number">12</span><span class="punctuation">,</span><span class="number">11</span><span class="punctuation">,</span><span class="number">10</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 10</code></li>
<li><code>-100 &lt;= matrix[i] [j] &lt;= 100</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：模拟<br>可以模拟螺旋矩阵的路径。初始位置是矩阵的左上角，初始方向是向右，当路径超出界限或者进入之前访问过的位置时，顺时针旋转，进入下一个方向</p>
<p>判断路径是否进入之前访问过的位置需要使用一个与输入矩阵大小相同的辅助矩阵 visited，其中的每个元素表示该位置是否被访问过。当一个元素被访问时，将 visited 中的对应位置的元素设为已访问</p>
<p>如何判断路径是否结束？由于矩阵中的每个元素都被访问一次，因此路径的长度即为矩阵中的元素数量，当路径的长度达到矩阵中的元素数量时即为完整路径，将该路径返回</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(mn)，其中 m 和 n 分别是输入矩阵的行数和列数。矩阵中的每个元素都要被访问一次</li>
<li>空间复杂度：O(mn)。需要创建一个大小为 m×n 的矩阵 visited 记录每个位置是否被访问过</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SpiralOrder</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> || <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	rows, columns := <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">	visited := <span class="built_in">make</span>([][]<span class="type">bool</span>, rows)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ &#123;</span><br><span class="line">		visited[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, columns)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		total          = rows * columns</span><br><span class="line">		order          = <span class="built_in">make</span>([]<span class="type">int</span>, total)</span><br><span class="line">		row, column    = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">		directions     = [][]<span class="type">int</span>&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;</span><br><span class="line">		directionIndex = <span class="number">0</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; total; i++ &#123;</span><br><span class="line">		order[i] = matrix[row][column]</span><br><span class="line">		visited[row][column] = <span class="literal">true</span></span><br><span class="line">		nextRow, nextColumn := row+directions[directionIndex][<span class="number">0</span>],</span><br><span class="line">			column+directions[directionIndex][<span class="number">1</span>]</span><br><span class="line">		<span class="keyword">if</span> nextRow &lt; <span class="number">0</span> || nextRow &gt;= rows || nextColumn &lt; <span class="number">0</span> ||</span><br><span class="line">			nextColumn &gt;= columns || visited[nextRow][nextColumn] &#123;</span><br><span class="line">			directionIndex = (directionIndex + <span class="number">1</span>) % <span class="number">4</span></span><br><span class="line">		&#125;</span><br><span class="line">		row += directions[directionIndex][<span class="number">0</span>]</span><br><span class="line">		column += directions[directionIndex][<span class="number">1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> order</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := [][]<span class="type">int</span>&#123;</span><br><span class="line">		&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">		&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">		&#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(SpiralOrder(nums))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>下面的题为面试经历过的题目</strong></p>
<h4 id="1-Golang合并2个切片并去重排序"><a href="#1-Golang合并2个切片并去重排序" class="headerlink" title="1. Golang合并2个切片并去重排序"></a><font color=DarkOrange>1. Golang合并2个切片并去重排序</font></h4><p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Solution</span><span class="params">(nums1, nums2 []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	nums1 = <span class="built_in">append</span>(nums1, nums2...)</span><br><span class="line">	hashMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">var</span> result []<span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums1 &#123;</span><br><span class="line">		<span class="comment">// 先计算Map长度，然后再往Map里添加数据</span></span><br><span class="line">		hashMapLen := <span class="built_in">len</span>(hashMap)</span><br><span class="line">		hashMap[num] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		<span class="comment">// 如何Map的长度有变化，说明num没有重复，可以将其添加到切片里</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(hashMap) != hashMapLen &#123;</span><br><span class="line">			result = <span class="built_in">append</span>(result, num)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 内置方法排序</span></span><br><span class="line">	sort.Ints(result)</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">2</span>&#125;</span><br><span class="line">	nums2 := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">1</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;结果为：&quot;</span>, Solution(nums1, nums2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-约瑟夫环问题"><a href="#2-约瑟夫环问题" class="headerlink" title="2. 约瑟夫环问题"></a><font color=DarkOrange>2. 约瑟夫环问题</font></h4><p><strong>题目：</strong>有n个人围成一圈，顺序排号。从第1个人开始报数（从1到3报数），凡报到3的人退出圈子，循环报数，问最后剩下的人是开始围圈时的第几号</p>
<p><strong>思路：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">JosephRing</span><span class="params">(nums [13]<span class="type">int</span>, n, m <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> front, rear, round = <span class="number">0</span>, n, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 队不为空</span></span><br><span class="line">		<span class="keyword">if</span> rear-front == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m<span class="number">-1</span>; i++ &#123;</span><br><span class="line">			front = (front + <span class="number">1</span>) % n</span><br><span class="line">			rear = (rear + <span class="number">1</span>) % n</span><br><span class="line">			nums[rear] = nums[front]</span><br><span class="line">		&#125;</span><br><span class="line">		front = (front + <span class="number">1</span>) % n</span><br><span class="line">		round++</span><br><span class="line">		fmt.Printf(<span class="string">&quot;第%d轮：%d\n&quot;</span>, round, nums[front])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> nums [<span class="number">13</span>]<span class="type">int</span></span><br><span class="line">	<span class="keyword">var</span> n, m = <span class="number">12</span>, <span class="number">3</span></span><br><span class="line">	nums[<span class="number">0</span>] = n</span><br><span class="line">	<span class="comment">// 初始化队列，入队</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n+<span class="number">1</span>; i++ &#123;</span><br><span class="line">		nums[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">	JosephRing(nums, n, m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Josephus</span><span class="params">(n <span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (Josephus(n<span class="number">-1</span>, k)+k<span class="number">-1</span>)%n + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	n := <span class="number">12</span></span><br><span class="line">	k := <span class="number">3</span></span><br><span class="line">	res := Josephus(n, k)</span><br><span class="line">	fmt.Println(<span class="string">&quot;结果为：&quot;</span>, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-一个单链表，如何求倒数第n-1个节点的值"><a href="#3-一个单链表，如何求倒数第n-1个节点的值" class="headerlink" title="3. 一个单链表，如何求倒数第n-1个节点的值"></a><font color=DarkOrange>3. 一个单链表，如何求倒数第n-1个节点的值</font></h4><p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Value <span class="type">int</span></span><br><span class="line">	Next  *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListNodeLen 求单链表长度</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">// 	head：单链表</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">// 	lenght：单链表长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListNodeLen</span><span class="params">(head *ListNode)</span></span> (lenght <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> ; head != <span class="literal">nil</span>; head = head.Next &#123;</span><br><span class="line">		lenght++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lenght</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ToSlice 将链表转化切片，然后直接下标取值</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">// 	head：单链表；n：第n个元素</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">// 	result：单链表第倒数n-1个元素的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToSlice</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> values []<span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> ; head != <span class="literal">nil</span>; head = head.Next &#123;</span><br><span class="line">		values = <span class="built_in">append</span>(values, head.Value)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 切片长度=链表长度</span></span><br><span class="line">	valuesLen := <span class="built_in">len</span>(values)</span><br><span class="line">	<span class="comment">// 判断是否会越界，左右都需要判断</span></span><br><span class="line">	<span class="keyword">if</span> n<span class="number">-1</span> &gt;= <span class="number">1</span> &amp;&amp; n &lt;= valuesLen+<span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> values[valuesLen-n+<span class="number">1</span>]</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FastSlow 快慢指针</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">// 	head：单链表；n：第n个元素</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">// 	result：单链表第倒数n-1个元素的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FastSlow</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">	dummy := &amp;ListNode&#123;<span class="number">0</span>, head&#125;</span><br><span class="line">	first, second := head, dummy</span><br><span class="line">	<span class="comment">// 需要判断是否会越界</span></span><br><span class="line">	listNodeLen := ListNodeLen(head)</span><br><span class="line">	<span class="keyword">if</span> n<span class="number">-1</span> &gt;= <span class="number">1</span> &amp;&amp; n &lt;= listNodeLen+<span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++ &#123;</span><br><span class="line">			first = first.Next</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> ; first != <span class="literal">nil</span>; first = first.Next &#123;</span><br><span class="line">			second = second.Next</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> second.Next.Value</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DoublePointer 双指针，优化后，不需要判断临界值</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">// 	head：单链表；n：第n个元素</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">// 	result：单链表第倒数n-1个元素的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoublePointer</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> second, first *ListNode</span><br><span class="line">	first = head</span><br><span class="line">	second = head</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; first.Next != <span class="literal">nil</span>; i++ &#123;</span><br><span class="line">		<span class="comment">//间隔n-1才赋值</span></span><br><span class="line">		<span class="keyword">if</span> i &gt;= n<span class="number">-1</span> &#123;</span><br><span class="line">			second = second.Next</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//头部往后移动</span></span><br><span class="line">		first = first.Next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> second.Value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReverseList 反转链表，链表反转后，未反转的链表的倒数第n-1个节点的值就是反转后链表的第n-1个的值</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">// 	head：单链表；n：第n个元素</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">// 	result：单链表第倒数n-1个元素的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReverseList</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> prev *ListNode</span><br><span class="line">	curr := head</span><br><span class="line">	<span class="keyword">for</span> curr != <span class="literal">nil</span> &#123;</span><br><span class="line">		next := curr.Next</span><br><span class="line">		curr.Next = prev</span><br><span class="line">		prev = curr</span><br><span class="line">		curr = next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历反转后的链表，然后取出第n-1个的值</span></span><br><span class="line">	i := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> prev != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> i == n<span class="number">-1</span> &#123;</span><br><span class="line">			result = prev.Value</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		i++</span><br><span class="line">		prev = prev.Next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateListNode 使用slice生成单链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateListNode</span><span class="params">(nums []<span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">	<span class="keyword">var</span> head ListNode</span><br><span class="line">	<span class="keyword">var</span> pre ListNode</span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		node := ListNode&#123;Value: num, Next: <span class="literal">nil</span>&#125;</span><br><span class="line">		<span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">			head.Next = &amp;node</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> pre.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">			pre.Next = &amp;node</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			pre.Next.Next = &amp;node</span><br><span class="line">			pre = *pre.Next</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>&#125;</span><br><span class="line">	n := <span class="number">5</span></span><br><span class="line">	head := CreateListNode(nums)</span><br><span class="line">	<span class="comment">// n值如果不在临界值内，返回0</span></span><br><span class="line">	toSlice := ToSlice(head, n)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;链表转切片，链表倒数第%d-1个：%d\n&quot;</span>, n, toSlice)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// n值如果不在临界值内，返回0</span></span><br><span class="line">	fastSlow := FastSlow(head, n)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;快慢指针，链表倒数第%d-1个：%d\n&quot;</span>, n, fastSlow)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// n值如果小于临界值指向链表最后一个元素，大于临界值指向链表第一个元素（倒数第n-1个元素）</span></span><br><span class="line">	doublePointer := DoublePointer(head, n)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;双指针优化后，链表倒数第%d-1个：%d\n&quot;</span>, n, doublePointer)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// n值如果不在临界值内，返回0</span></span><br><span class="line">	reverseList := ReverseList(head, n)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;反转链表，链表倒数第%d-1个：%d\n&quot;</span>, n, reverseList)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ToDo</span></span><br><span class="line">	<span class="comment">// 将单链表转为双链表，只需要找到第n个节点，然后取出双链表的第n个节点的上一个节点的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-abc组成的字符串删除"><a href="#4-abc组成的字符串删除" class="headerlink" title="4. abc组成的字符串删除"></a><font color=DarkOrange>4. abc组成的字符串删除</font></h4><p><strong>题目：</strong> 一个字符串，只有abc三个字符组成，现在需要删除字符串，删除规则为：每次只能删除2个字符，删除a和b或者删除a和c，字符串能否被全部删除，如果能，需要多少次</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Solution</span><span class="params">(str <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 判断字符串长度是否为奇数，奇数则无法完全删除</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(str) == <span class="number">0</span> || <span class="built_in">len</span>(str)%<span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	a, b, c := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> str &#123;</span><br><span class="line">		<span class="keyword">switch</span> <span class="type">string</span>(s) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">			a += <span class="number">1</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;b&quot;</span>:</span><br><span class="line">			b += <span class="number">1</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;c&quot;</span>:</span><br><span class="line">			c += <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// a的数量等于b+c的数量</span></span><br><span class="line">	<span class="keyword">if</span> a == b+c &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;aabbccaaaaabbcbb&quot;</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;结果为：&quot;</span>, Solution(str))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-计算非负数的平方根"><a href="#5-计算非负数的平方根" class="headerlink" title="5. 计算非负数的平方根"></a><font color=DarkOrange>5. 计算非负数的平方根</font></h4><p>给你一个非负小数x，计算并返回x的算术平方根。保留2位小数</p>
<p><strong>注意：</strong>不允许使用任何内置指数函数和算符，例如Pow(x,0.5)或者 ×**0.5</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrt</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 初始的猜测值为x的一半</span></span><br><span class="line">	z := x / <span class="number">2</span></span><br><span class="line">	<span class="comment">// 迭代求解</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		z = z - (z*z-x)/(<span class="number">2</span>*z)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="number">8.0</span></span><br><span class="line">	result := sqrt(x)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%.2f\n&quot;</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Go编程题30题"><a href="#Go编程题30题" class="headerlink" title="Go编程题30题"></a><font color=DarkOrange>Go编程题30题</font></h4><p>链接：<a href="https://blog.csdn.net/weixin_45604257/article/details/101649973">点击跳转</a></p>
<hr>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>行为面试</title>
    <url>/2022/11/03/%E8%A1%8C%E4%B8%BA%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容">
  <script id="hbeData" type="hbeData" data-hmacdigest="d9ad02a6bf918ab84a9dccd75aca0b83568e8b2e0b17b238666c0a15ff21ca9d">77cc46b16fd309e8f5b42a0dad109aa88a81e87c9c9da4bbe0e82fdb8f02350273396b224922682040dddaf374fdbd152468338375b7e9ecbef99520493261f98aadeb4386b0a1a31516e127915f7be88d28dc6db414b9ff26156e6205e8126656a86387e7f1d128be43a117f95e81abc3b405fecb4145d6d031848c6e5d5658a7aa67182903a5fd4529bc8e2efd24e4fee6dc14b1060fe9ed2b026267d1efb54d670797ea1e4ff25b052ee1fefdc068be355b954e628650d253f0be35ce315909fb1b7416434c7e0fed05fb533858be3f45bbe8a78e909e28380447bf627c6221cd539505fd0ed0bb26683beef47d80aa2fcc9ab1fea5d3c2c1c17af86dc13840c9c9fcd578d00bc043e3282258b615c6ae8c9621625fca0cac48487011b5b745791116f01e9cb39ed580428d398b262161d8e42afed1ded7fa0136bb897fbf48d1e75f5bde4f97aae87ed1bb7f487439ca923d7bde75cf20d3eb945d757b5b20f39f2b659af32bac387e7fbdfd0f125ab5ac8df39ee740b4a97ffa8320d227719ef2c74a64a3babaf4a6620ef2134588b3d6e2373643acc70aabce8ff192bc937edd98380020d8434ac28927bad7191dfe304b0e9ee8464ca3267095d5339bfe2a0f3d01863d336f2ab16fe0705808a17e2dc0e82dc18b6c9283c9076a75c84d7b075a4971342e92e0f8800140a639cadc1147869159722a7061b69809d92b07cf6794230cc05eb5e633bcec8c1a5d7c46ef62f84a472949a6e6e77a364f4380408795294526ec0f2b9898afee2a8e0eaee7cec7108f03c8514cafa4952dfbe2e9f2327d252bb8c92364e12c39d1d818865377e6207acba04e6fe966b15dadca7466bc72135ee052f84462f5f4b99750f368344800689ff8a674ad3ad2ebeeb73b219a0fe0e522aea4b2bc077a7ff6b9c2e4844b0b0c0f278d2278cd305fda88ca8660ed5a2580cf7e388c05f3c1b74d157a5a8d9688a2e439f6c1013382002bbd16ea3d778726b4140cad48af6914db90d72d08dd99425b8f6be7ccea0ee43d33d4169505f353c7ed4eba9748e44f4ad8a3764272575f8b510f3c0fb3c9caa76d7b270581318fabece2d92098e2d5672dd598159f0534b2c30924f39b37596db1c6456a55bea9d1aedbb6f03aa6062b02616fc284daf7c3c9dd313a5b8adfe9a63c466e936b45f19f0379fe50bcc3b7843046c5e909fd9e21ce09d4186060006e6937aeada39319ef03b945a8e1a18ad16f96e3c201775378bce72cee7a5e3f00e7a15f4d06d73c273947f82ac5c2be6f0a9e1edfa9a1b0ae9230bd62b99c489af3a2517ebb7986b020fd3f3a0994ca84a4c2a311a10f24fc589447f4a113355cdcef24e3764f85116566405006504c26d743b4e3810a51567d208f7e1f5c7111ba6ead35501463965fede10028970d4d0a3080af8eb8f3e5c6043b7fd68674236f242cc3154740b9e12617e509962519e4554a6a9f531c10d46791cc1b8756b18901212dd2d187b688bc2975f261d377fe9b2ba44b8447ab1cdf30bc20f1ed17bc7e2591bc72207b976b3b6f7a5e751f6de9fb20a4e9b417243fb4611f090dc1d4af73d60d7016360ea3d3a780383688136d19cd8ed1dae201f20ba87c28f270d4ba59169ee4693f2d71ca647e05c0dda309ac231f8c3c4c14564140dadbc8eb03ae8479a92bc2cd9f8c31b97c45b48619389fe4103a25a78e8f2c50bfdfa181e1e340b5a55b220fafa4ee4cdbb854e486cae0ba876625c686bf48fabb519ce5b30a6a396cf07213aa2cb10d54b5fc4019ff287df2775e90f6877a6541f89576a21aab7ad3aaf938d87575f583fbf8dbb096f1f54f5df7fa5b615b750e0a928c3e3695efe6ff8ae1eefda7585f67c7e4698ef548865aa97dade3704a18e5aa2c77f916f773ec0aa01c4dd5e25f2160fc75fcc2557fcdd3f911049cd8bb239825ffb65ab1b79e21123391361ffd6a4fbe22aa2ceab418d30c4664d3d76ebf2137783cb4bf06052d8a85da5d159b4a1aa7bed9b123262e1042d773c0b4406bf9fae494fe73d384e1d447eb5269cda854fd1e339a47e5d743ece4f94f4559f0e98633104841f2eb31074b816317c4ff46fa47bd048773453c5e510cce5a2b0d60976260d7593af701d9cf79933377fe0d078deae51c8445313b2bfb60b43dc5660ee1442762ede2292bba5336b72bf86a9012a2a02089b10c8310df4d6c7001754ea92bf8096e07211250aea921a05feec3f2b067e616786e0c4ba9e867a65d3e1e7c06ce1cbbd6231f0417361753f56bd54ac0be9bf12932e24a06f4b2992d154bf9bcf7a29cbbdf9286b7790ae049621b7084492d0d7ff09b2ffe4531dc4066b2490563de3a63791fe574007330e79e9344a2d55002d0559b5e2abdff7d4e9d8f656be7f43c18f422737918d1588100cd485d74fac893abfb636a4dd0b7f6286a51c540e6eb827540a385131db9a175c2c3b575321fb179f5c155134118630f1477c1f8bb66d04e36e99e4e1b72db33fca7c94c0c6f6bccc665bf1fc6f4593abdb356aed5cc85388066fe677abe65ed86b4fcd245d94c6139c68e72669f28e7fe2030c467dadbf3fdfddfb31144a272d1b0bb0e4010d37f8aa8dc25ba822af7e38d69719734f3e947aff4d51ca87312d47d09ac58f4376d4340bdd9b875d1324484e8bada974f7c57034e080aad0645af7c95bf777e6c598f173e0197b7c56d0eed7419e92ab13d1fe3eb0f78d1bc0c60ad4115484136488f6f3f4f95136accaca4b0fd7132148328a8db1efa82f238b61779e33d0144f3de57528da7222bf93213c7cba920b522bfcccb784090043834b7408d0b6c8cabb369ee9cc5dbe2539c761f9b36a113f2f3d34c41a71e65ed9f9e6e3f1f37c0e3ec5b130f9dbadd5c8b78ef724f8f50c9be5290b4b47ac60aeca15752d31aee3020a4a3950b769a1f46715410c9e2580702ac3d3299cf323359fa77098935e34b72d068ebd69bdae8465c253be22cae4fd6c618bd82f7db4737e6fe83657f8a4db8627751856a82823924eb1c422db592ee801778e488e1327534e5d5b60829fece502cbee374765122ed998a63daa7d9f8f9ee0ac1554980e3803c85b399320dafa422fc2906730d629da9787702ead7760caca57e419ec48033343b905ef156648187b228039b3118006dc3b1eeea2c7c280dc3e182b1f5fd3f67aa610365f01ed2b9cc4f6fe15b631966b2dad8b0e3335418aa21a6edb7efda1f908e630c50528937ab485a9dd3256c06540f1dea9be2411a19167c66e86eb4f59747320e760184e4ca1b3bb697a59b69fb52af06038ad99739a3d7115cb6c75de8ebea860aa9b66ff0203360666e066a8e3d7ad81ac08c4b52958ff342eeb3c1c2b04ce1fca9e3e96924c0229b49377cc1ed679667a5f62b402915738ca50e8552d4be30ccdc5c8208e0a7e261153a0cdeb11878bddd23233de17c2cd3ef16526ac96215d4eab8a753591a0105b08bb7a27c9c0ab5fd5ee19f55ca2cee11ad941e84e4b7b6e94eb20c00f6b273d44846ae731a7bc9fb131df36020671ce4fd7631a36d2ab1314e74c690fdeb81d10900de94fb8fe4ff3c69a2e361e2ac0352694d9e410a924bc7214787b4cb42038fe69233f99583953398eff40c156f3cf07c63ae02c1b2eee8070583ed23be5692a767b3e717c286a6faa01e96d93ddbfabfca7cf07d134aacca29730d5bdf5cd0572d869083a3c914a3d8f2ac6ccc2ff3d4bf2edc8f808542275fba89bd2fc1079bbacc28688dae46504cb2a6655f327fe64b24d4a4df0c879d0dcc1f5b2a35f719f10224b60bf05cb99759fa69082a09fa1405dee7042064a264d1f779d01552b9441e48aca5b8b94a30df676631452e858cc56517a89b5abea865d7266691d5ee81eccacbc50bf8508405f4d59e267813b3850a7644491acba1ae26092645088ee876741eab37d529c74261cf04c952bb662f8d80f577d3d7a2a6640b300c3e311f4c4ca7e7ca61ce44bac766b2df84c96091fd1aab25c230d144bbb566c7869031f9daea20bf7e73eae2aeccc3719ac3b11f23cb80d4041b78fc0eaeeeaf5344c0b85987dbce7f07aadd7e56584b6c4ef76c920ed79d8fcefb4cdeb3e1a5f673ef2935e20743f3eb70188b46c4d3f55a3261db7772ba84df2388826988dfed5f740ca39a89a753b2cc1cffbb3e79b4bb3b3c8820a77aecaa8cc3149d8e8fb6807464c7b432516cbe92e4d567a31b396d7948741b8af2db1c6a28e272d39488b657faee06e50d8535e9f965db77c78dfd3ce7ae466b884bad3f87f6d6d7eb0716c0371a305a9d855d51dc23034df6b0518aaebbd5ee7265e1bcb235cbeb6c3614c40210cd3001ec937721f5db1fdf239b7abd9a9b1e30d92eba60db17752d99bc038d8cb6b8ac79bbb8b3fdb809b9cdec022b75c2e9b913dd3f323a08ea0f642825bb8580cc5572d63871227015fc93d02500a97766c9a375be942955ceaab6f9efca19554afb464f7492e9c580635550e3e3263af16f0d5bf5caae8b6978c1a574b02dfed23da66d09d306bce059d1a944978c437004e7fcafb241adce3c6d718e10078d7bc0723711430148e3c2f150153c6c958b0a889307c0ffd32b9681f2d82a677e9cca0f3dc4f79ef9f0fff12abeab89a3e925d9422e67d5425e446d640573463bd3b884df9a35de6e08eca679853101d6d95e6171a6f4bc7c2590a318d7fae1e7275af742a2138451286dfff06d97d31f460facfcfde650976d7f35d243105a492882e354973898f49a8e24b2ce5b8cdba06ae57fbffbd65b6c2c6a85c062cb873bafca3708b21dc5166e032ad6dd0903ff3560e6b6e028afc8bf7557f1a3ed00b8620df6956eab4247bdceb437e42dd01c3c03bc70aab50a716f9650ec8f678da8576d1dc1e1480fe098a3df49b133dd1a50c60f7be83023376b469a8b4b39998c54c11e25ad5ac7d933623fdb2152d7eb49bd3ddc03dfc10db9b97fe073aced0461f5c3005a04ffa67d16f31ef979afe3f6353ebd867c579cc40732446b3151747464c1dead35c90de6a66fd3713715c8034886ca072673629f1f0b245182d55abacfdf1b94fafec98e93ef80e9aa67118fd431bd7e351ff832eae68138ba68a67c736e9d866bf066cd16c89a2ab0ea7182d5565a9a1aed6a43dacfeb78846c5bce58e0353135d622cd13ded752a031a0289466ed8c43e7bad597c649289953e13f50c999ebfbb2889bdda1dff9b2b0126d41e3dc72b55ef3376d4d7442876ab2e8ecb2a4c2cf9f0f1aec349a373f06be14b066688331a8198ef820520cb40526ed546e43cd3ddd9c9369bff5f6d8031974ddfb225562867c39d05113e9c700c35fa59ce13b686e3a57e0c2afe7c7068339a17f0872297b1e4e399c7f33ef5ec2d0c45a7e772e0510f80cbbff0468a3bf840148d77d86ae40291a0f2f7e57c4dadb16bed9baaa93377db7c24b8005ef226fc1ac10a8980a6e19a1eeb3c29b190495342d5b2a84c75218e953599b19403a6cb8c50e8805ef6d66ed8cd5caf4bbc5e3ef0897a87762ef1bdf5eaf408226a5e68a79b94f2e746d01fa61e8fcea7b695552958514e880c5b5567137284b9a5c474e1806827cc12445ff36cc98c15b59ab519cdf239648d37badcdee048d074e8b863ca793842b8532d1a9b0cc148dff527740f7a2ce4d3171662e5f630ec0601ef62ff08848d6e8e5c3d5ecef5320dfbad629910d861a812abfbd6a3da493bc00996cbca32e4a4a9e1ebe8166b0ee4cdb6c4387c805170d2bf2bd6d715ccc431a571411aa11211b5791634ee4597225572f3165c5cdb2ac6406bb280f29e374d357eab1b0fc9056505d1039ceb440e51ce59b98287817e00580e390402ca02536352491bf8499fc96e176f9c9dd21a1731c3ea77c3190ab2de75272817daa4553069a5f4c04fcde4acd5806882fdd42d0525f828ab39db763b5f68323e9b4e2c2e02cebfedb1c4d4f568f81d589a48c046ab9451099f93aee88196b1c4292351578060f603fc35ad80bc6812f9a0814df7621baaebbae53f10d9f060f4fe565cfd33d59dc52e35e5224b6b7838ea34735106957c096080313c692a7f10b1e10258135f47b9acac68ba7c676373a67bf1a26f6a9d40dc0ae94d4900a415244953ba50832fc0e39c13800b689b26ba9e51cb08bf631b6f0e0e593bf6d0b7c0bdd0ae598e1fdeee3f9f8c066becbaec02ef49c5695f1efeb24f0f51c92eec7ef3652fba2fdb3196f79d7b2c749ea72f604e55b227570dec08697ee2ce2432d8d413c2821259d2755a9771b8032e19aafe4e1f0d63687aa83898311b0a6a7e4efabba352bce05b8e87c7cc5ff5284c97f4829b5bea2a8ee369e17e870004189e85eb92470f6990a4737c016f905cdb2c8d869e9c7cc0f59d9855b254c2508dee54ab3856c910e08cb84ff18dc493f37df584a0cd979b818acf164d62ce79886bdbb21487425e2792e3d4f2766d40c325e1c17eefe7b20c6241a86c99a9d371a478cdd6efcb78576e31f7181048b9825f0439e58e581cfa151015e37f24d3d400db795d386799e40b912966f94d6bd7599974b6ea24ec6aa9501a8167be74332d7d1584f8e2178a14f5a6b5cdf8ecd66f46d020f398925743ad74a4a9fd25efda8990ca27a120203602caba89186de7e204bb3e9b74dcef87c21bfbabf5e0d09f4de1a546290278ecd34de142a4731b006fa58e0de4b1ecb6b9086ded17ec9f6df8ca5b973bd7cfe1665a201a75ed7fb1bbde0c2b05afdd16af8bee440297ed7a7ff11c303f95434d0f206a85877decf9431b604d92eaa837b447d72d9e6ae52bef4f54e3ec36c3af8914beaef4b72a60b860105c1f52e01fdfb5b94e77bf14f5a2eff90ec94f4de6e434678d8e6280aa1acd024a243632e1b5a81826fc0c74bf59005d73f40734b01bc93788ee5c344a233291855bfb90f7974a5406dd2ca2945cfcb3ba45d9cc16b5fa1c13f8f76de5cfdd1c126352a7083fcb0794b04b0c81af8dd11bb708517450478ab62b257983324dd84350fd48d4c72fedcd1dca41819b0f84fcbc3d2f4e7e4cc12e41bbb8e8381ed5c96f33274e37e649241dceacdff60ea07644278c7bde6c289eeeb0cdca40e7c4cac5525a931300d3a2e51fe5a6791f3a50ddf05976cb2bd318165436cc21bbfd8cd97088cbd2daf2066ba890678b4a153abadc70b4442d26d86d741af069ddd3ef171a16a37c9267c8cc950fb4dc4afe3e3fb6a7cf7e67c311e3b6816f402c75e67b9846805f1db203308749e42c1b76674d5b22e9fbca168642790b8667b30afbdb931b449ea1eb389e060d58723eaabd49d2ba96ba373cc846569499192044052e4564c7da80bb35ed06f9f19acec522593900031042bf24bf9eb0f327b949d1a506d5b54399f0aa4255192e1268f9ac58513e26dfbb5d5a648b28cf1c31a1bc4bba7995518a94d82776725efe04b568f68ac565e819d8d55321e3453b33c66e16a97a4626ec6ae8b8323cf5bf3dcaad7b415c2eabc94dea5700856050f15d92295b45c4e7eebff4e855bf58af8add4cf87a0131c7e6413ba9819336aa8d2d6e5062ce6ca337a3d285ac0d00447744bb90733861fdc4cd8cdc14636e7218e940a56519f298ce15dacca81fb00e8e4e801ba5611c4be66caf966eb6c3e44a251a7922895dbbde4081b17b72b91cf624e1c668c44161cb6c053b962996b97e0334493b7a6270a3ad3f5968a427dfee7cd6a8d32504e3c5de38ad17007fd7990667df17502a0ae973a3f0a6763950177077c31862804386c7c8651b3d479be7896605ae4c0691b2028532872a9bea82735211211e67eb634e3ab903bdf5ae9a1063023208506cf607dc29762bc2e0a4955abd86730997d64cf0195257d74c160781d21a5f08bc862f6e193bc819e78971ef6b9e2bb48bfe71d2c8e79b1b063ff5cc125f4abd905d8d842278728b21442256334beecc71d05dfbf082a6ad5909175f742455cf386391723194fc3d04088c09422a5ddfbad1dbcf4312f5b33ef53bc968d536a5905a1df61bbdc93a17a1dd35ffdd0d8c89817c4b13fa34e6ee7616a7a428352c77187ad9a335a62590ae6dc755acee1b0ce737c6aa0bdf95806ee9f5353b8f7458c38bab2116a19f89e16998ed0033a4457111675ad5ad7c1c7f659c2f6a0fe2fc125c01ccc74ac7c93ecf1811fd9cc836d7ad4845f4c63b617bc5f38ec25ac63ffeb59e2e48f2748a948984b44e39052d0de54daccc9f5d2ec80345be121807ef9e5114b25ac1705cf2d6cfeca0d6d0822b4847cd7ee354f3dfa9b64d4182061fe1af8f9b618533f043a3f535dd3ef81597a183e98946943a66fa570313a29469a509c51020f471c67d2f59cadf1d034c8057ba3562c941ad0ef7f3d9ce55e193bc9f14a7ab4bcf530cecb91616a3a6a5f694e282f97f908e659aad96188bc65a687210cbbc14acb14d863b91e250539d56c077652ff49a5f54a37a504211109c229f86af551f6ca0a4788f0ca53eb84cccfc20a4188b74bbbb93fc3faba6cf23508801db107ed708d3321028e79309bc800b8dec69f8b45fdf4781fa7b4808d7c1074e542d9576eac1e904b2c18c26cca395d5821b8c8380eaff8b974cabff9265134bfe754ad499b0b3844057857d194a40c04a588b6d41afd4685bc8400d6a44330c84b8dbc3f0a15075134a82ba34c41d9b7bd8c8973ab43cf57fbc0402bccd63b6579b4ca285c87c7afb4f1bcfbd28a0bc71391fc37f1efbe5aa2e78df64c10e2668de501f7c0e35c060a970c007de2485e40492b486ecd597fbe7b27fec1f5d57f438e95b41947ae89398ee138e03813ad9ee094cb5df745105571fb5501de93865cc0b4198aff9fcc74d5f077d6e241e5ea09ceac5b4b8b67cdf71e6a4717f6ea6926037d45f4a3ccf9d3df61003becb04b89d16fec800671c274e0b9183303c700df076d505f9e0c4bc091a953d3b18e632213200d7641a8c6165fc70e4f00d571fcc01ebe5cd8a5d6530b2c57482f51bd4cd6014c395eac90bdd3c9b545d074da3ff382bf10ea0d387ebf9c15faea5f744f90437b1ce07b016aa06222a661b7c817006f8e460937823264f14005daca38173537cdc27cced0bd49ebbdc6cb7bdc869afd159003f0834645d9bb70066c40aa3cade0f4e38ae664ab79548092c0d7e3ddeefe9a4d4e8ac1549bd8cfe4af9e38378a0c4b969fecbe81f9c9e9ffa8ee9fa35729fbb4b4ac719f3f314f9fdeb37f5cdf457ba983c33177169ea60a12f8b3ab1e3689ef73877f4e37aec77b2e4d403cfdb45d81c3e6a9f73e86478a33408f4416fb8515836bfcf9cb9a7fbf91a8c8fe10aee347b47841d6206392fb18db8b521b86651b6fa93f8b4d9032e7be83e61861a7822368af7928a39feea3332b73c90d12762fd3770746e3682266d75c3774184f1ad0437f49415304027fb02f32a1498ddd04b83f603765da80121dbddd307482125c603ef880b2a11a7eb5a1dca5f045b269b0567bf554c09862d381dbca4e1126a774ff6284cb6ce3cf437d62b940831dfdfa96c63d3b9304bbcd98ef6871bc0bb8126c5fadd9040fe70a7aee11396aaff7c23208792a51c6adb153ea4c753fe9d524bb7bc6063157c9345ee7bcd9845f16f9a6627fce1f9c9fc6c29bfe3ea85e8464ea9f63b7b58e32336d9b2fad18cd41b71821b08c5da48ff09afcd1209328b1db3dbcb035456c4392ac8e26767bb3f97550fee79c398c84634103ccd77a8125cfcd4158cebc6a9445efaea64dbdf4ff31648f9c9ed08ef3e2c9a57cd9592a487febc62575dbcafacd3abdc66b51ad268c2aecfde40787bb286725d8484805f82552e301998ddeb1fd024f190644d5c54051186a3d16ad3bba433ec9e779b329af7dd07a34b6a2e39e3a015b741ec21186dab8347e6112d071531f5b8aadae067307f78552448cd5702d0fee2ce35c4349641fee430edeb27edde619e877d110433f52b1d85f16af06b456a2e0eaf3d3b501c6b36f4551d786cdfa5c2edfca01b1234e9a5b4a146ff1f363e3a824dc00447872e4c28149c227642386e548a449224ad6669736a70a342b9015ea82b865a1f435921b0109d807bf437c948e4e043c4294e1a329ce66302cbec023705158c0cecc0c8ed96506fb7b84c1dd919a20a1220f9dfecffa51d7b605dbd0daf0a6466b061862f1150451d07f1fc4e34664cb7a2a9599ff81ee786ea3afd28ea77f417715f714f05281f52ac013f6cca90e883c0cf0aba945b1002a7e4f380ea8a1f5290ad78dab1981717b2fc9150c1ab7e95ddc3c749d2a2e6b218ba13384da82084b76438e8b6efc221e683200bbbf82244101d9bb86c53b790786c030cd9e2a06a063ee925cf9448338acac08750d0aa3a9597ae41612026023383e798c146772ee8f029d2d8986662aae9e2936df06665f1ccbd022f7d6e36fe3a1731b2c4ac6d184f4ddf2883afd3b7e865403875062f40d3683126cbb7f46032b2cfae0b2326ebf97c85757f9ddd91d306a97c95aa72db61a5e40b518aa33f244bee46f4d46ed12f1009718f30428ce5f205f567fcb7b197fdba3fae6c6df6649b854769f1ea2c82f9746a715196598afcd208844871c149d11cc075e0e66e18db927454db0c46e63f64818563605420dbc1c463c3c015e4dc30c5f03283df656c9005e81db7e0ff22a38325bb0b42dddac9c051c0a1f8d3d05bd6cc7d93c7b6d2bfd749b366f73247f98d84b9b528dadc8d31d1cc5682f9d73691758ce7990a69fedb174635b9be158ad48062db2313733f3bfda079288032b33cb79df18f50dd20cf487be9b2559c5e93b28ef3288cb3856541717e8d0d7f89de3cd48ba42d5a69fac57fa51a53b726ca5c492dd5e4ee3ed7e51c0f7e770334a60bd71b3e7798ab10094143b4689b6aa108b73832fcc02dee0560275b125c836fdd3994e96b436bae42e9c04cbf649949a405d6508b47eb82f35f20eadfb1d37a476ff73fe5bc76fc33fab01d14adf431d8d78e8a552ab4f633a54800ab5ff890fb2f09565a09e57673177e5da01d413bf5c46498414043d6016fe683cc31e316d08a6c6b413c93ad2f0474afd26731b6a0c7d8749797506b57fc85f8b83f4020c11dc2d344f57a1d1611a848ca4c65b3c2e2276967412364b160b9d4bbde732177538eb7f23ebf591706d489465adeb61b83d1d4838b8125be7b8136ce6e27d3363a1787980f0ace44df215b87307aa069c92fbf414609b207624ec9cda1d80f658d01022b64ffa530734dab593b91e091bbd7c447a9526cb90a608379729538b3a9c43d6eb55617b3e9bad64e6886a0fabf4f9157eee6c8c0364b44911e562e718fb2376a1e061372017dd346e81e2cfaf594f1cb412edbdc5a68e521f86045a951c7e434512cccc5f653f9c34003efe47e5398cf76f166872ed80aa431828edbad1a5c303f845428bd20f545064b784a0e9455dbe5c74dfa2f4a3604bbafddf358dfb66e07edb88667a169a86e449146d6c6088543230d64906f5410c9f1b5fce9cdb86937bb5fa091cd756039ad289319dbf47ea03e558f4f2026da0dfeb3e39bfff6043c1c39bb159431298b13862aae962668dbfba2772b43895c7d438c4508fa9778a9367a64e56f8fa3e82690dfbbb3cf7ac421fe19fb9e236d7d766b6db9986534f72aa32cbbff829203473a772858397f3ad6fe712d918f07aaf6d22caaa6748f7314387744308539da26f3c2445fa0c36f20da234f2e212dec79cef672a646c9e20ddd375d81619edf0ccf66e42328d1c47cb2fb94230f3188e6025b1ac783d03b93f146a4b8297c2cd5506d1a4fff0baf6c120b3ad3ac71bbf0712e9095622bf54ecd58848db9d3012506abfb68b69156353d1cb777f2d18d3b90fb66c0769a766a0a097c937c75343e573e1bec5cd6520a129423c373cf9d6c5e5ef4bbf1c2987dc0f7b9d1c4fff823aaa2af30ccc7be5236e530bb735ef767155516f46750675f14b4a8e25b5d4f06fd46c0104fc4333c37cc894dc2d349528e0b91a347fedaac5a1434141010512622db608cb73c7bf5c02bd3ce58685acec539cd470927ea00c7b79c96baf5fdef38fc3186c1d2aafda4876c955c207baaff27c2a3ce3baf6927fe6914eb48caf8b7ef52314bf460b8a775588a7a104550184f0361c07eb2fa39fd7ae05785d7695089a4d26fa7f3ec5f87ce4debcb4cefb4a1a80d635edbfb62cf1d6410bc3090572a4fdab3cdad4b6e7a680a16a0ae6b40443a4a1c67ab63e7ddf3372503a584592216108da22150bc39fbf5afc8d09fdc7012adf3314e4b2baea4dddcae4b1bb38939bbfa43fab8bb6938c1388bf91bd009cf56ee261c8242f596f6705f58eed68efc45191eeb79d6adf14c276e9d6195b99257318aea725c787042c0d88f51ec5dd0589f045580e2f39e4ca1e5c6a6efcaf760460c08072929ee9c7386cac5ce01d717d2742ddb93b5084f809a983efcad8ff93290af9d028fc7079d7a09a7bf7fdfb8bc3f57ba9bd2cf35909bb3d0513787db75464c8e57e166c8ec10bbbb14cb956520d933ff51c8e77114c221ef35915a4ee724771d35809dcc7b3faae9198d642a48a7be9b0fa8da3a54bc8fca8d46fb5e238f638fbaeae602792de938a042d1b8ca30f0287116a4b110a2fb4599c594e7cb3d2a3503fa3b81c6e52621e2459fc6b8213847742b319041802723c62f5dfe7e78fe46f46a2b223575d17ecaa1ea816be10b428f1da9027dcc0568d5224179300714713388c32cbab2043f98e6862da95f7d8d220342ae10c63f96cff0c1a4e219e05fb95ea5e2c3fc5878f76970189027348245a062f8f1c408f8a92235e0378b6efa748095182e15adffeaa3d1476f7b844dbc1ffe968d0feb3e1b9eff5e337b6733af28b24d5ce79feaae19c6b99d6f0d30b2a3421f375f0ed10d02cd9da8c80655689767620cc8a5e12398a3ec14e3cad41e720f6f8ca16aae1558630d48cb11ca2c1da2955593bdd27fb8efc59cd5805eb7032649fbdf6cb30b062c8bacea13d2abb3e3527934d51d105a6f00e70267cfd757c4ad3769585a45f6da79f464ae544841b8d589c8c1a993c0099ef7a97784126d2584df1f16fff181b7593270d9cae1ca2afc25c95a6ce4b1d02972cad04ddd6cfe4186f42e8de20deea1c59ec53047dcb293580ff86e95e49ab375a3b1d1c45cecca4501a31babc95d75b8d0c4a2d31548c86b4495046045f62b79416c10359cfe74ae4d3abca9ed57a9f23eb72cf37283ec2527f2a65824aab371d03dd004fe14ebdab975c711d22a5144df6d17ca6159b97c5e28e9664af6d7a24fc3150befb683fcc51a09dc59a7386a0147a5c2aa4ae445dca3038c1618f357152c18443070b59fc6d7d6dfc1133db4b17ad7e2727eac3a36984f4802507d6cf5ec1b736cfbbb84d7063ef388ca1ede5e2d0ed0558ad30eed5e2e10da9303ebda55b5253c1d12fb055943e7ce0eeff17a59b7e0b0db9dfe05c5075557e31f14cf678e506f7da2f16e03df1d4c33ce3e661dd00ede6cb1dcfd4918114da5ad13bb2d91eeb638535bbea1909082c4101b63610467d543dcd5c392fced3b19e48d06953e4821486bc327e7ebda581df7d674e9adb2abac3b8664eb0b0926697991ad3f8b5893d4b52838b269fbd3e0da4d6840c35e0f3940c18569e3858d49f97304938c7ad0c1bf8117c72db7f31184f702d355b3a2060d30c7a9659298bce3910fe3464259e5cd90893e5c32a83d197d4508cc6e2a31d774a8c831c42667995197e4feaf011722b749aed103a7268105ddbf277f19ade55312121c86d78e54e5612d5b5d81180ce36022bcfab16e95596676cfa70f07f382b0f68a056067de25d6c9fc862f84d2d14555b56d8f346ff3699e87b14844f7a195b9241905f63e2e5cc926f62e9bca594d5549aee687c514e300a51a3631a714b791923ae7a9ea8704215ed3877a584eaa0aace997ce049933c6f9e4919bd587f27e0b671b0b0bf7a9621effa5f32ef4dc40c481ab82d9224c07cb6179a78c2d41e7158f0d3248d900a57208ca659da97935439dd16b72053e5cb8ff3be98473dfef41cfe50fa5adc137fe9b0dd8ff9b3d69488fb2f40ae9f1522ff54c36e6b2554240bd0aa9f0783043140a551aa2d256216bece13cdbdce6e4dc799f57e4981b8559074afb1af24143f40ed303a5347541bbabebc94916c1ca10283627fe242396399a5ef9f668cd6623b17a8309874fdaf982ed2d53f7e77f8a0d1c9115f1b2c91979c1e95e1cd7abb0a28fd3e74aea0043bf9b2ad300611bcd552a68445c16626abcedebba9751399fca693360cbfbfa5a389861ae13288b282cc65a46c47e49093ade8e24497a211299e5d49d4c17adeddad85c5db6ecda869cc7cae31b1cbbb8aa907e6d891e33ba65c04e17deeb3258521eb851a05407eb123c5cda1df1022e8760af06452ae2096ae357b62b185e034a804679da12e56a41cdf7a9e002b34b8a7d5827bc85d82ce6676d8544c01eb9032fdd33519530081df7f892a7f16e191375d465c2de046a3b494fce8619c5005429af2db91fcd24ece932540a8be1574241b0750bf87b19699227129c5d3b5af7caf1d2d6937dae0d62e4b2a44375df5fb53a1d6b87d99180c028d333f5785d43f45225b0d511d35fd658ae046b180a95004246caea9b196a51e98b7435396ac6fb8bef4c31181f08f2f05acf3d609b52a0e6ae9e98554f6b0525ec68732b6455ab488e09e654e1dc95c90ec442a4813d884f306753fe8140817ef1ae1658d8278cf21d93e37aad10e6b60c2fedb1d2c059f79ebf2e4e394ba409a37f08fd0e8fddd45ae4fac2802c40a3754b7a005dab65b86d2eb3304434b65eede080aa490c99085b50837bb509de8adbbea39e3f26db9838a49e740992c961e95c31e92799a1aa04ec28e7860c867b030567b8fb3dd3e2fb3dc0bd16c4daf0c2142b10ec6a44cf4b878d55ea937b67c14308f5d871c5e0e854eb8ab8349ba6350f1fbf178f4e54937f70e4a9e74fcae1b5571422dcb91acc518405fd1806e792c2105fd23a67ed3a7f1bf0496ba78b0d6259989d9c35c4aff0a97787906af1c1ff62380ae98b0c4482663de6cb8e98cd4b8b1ab988c163065afecb491efe1727a0c1ff3422015497d7ee4f0f544e4c4e8d6f255cb8ec443daf3b87540afaeeabed77d745cfc0339062a4d9dfdf00007abe7f584b14dfff2798378a66b73c051be966de7bc79772365ccdc93ecf5d6a5b8c7ed1a1fef7a793183646a77207c28532d09c2f0913231179111225ddbc029f5a955c8daa308d56b68a3d4e9a85b763b8c1e2f44fae2e7ab6e587f7cb197ddf61df0e5ee38e9490566dd7af54113d16a11ec27da9c9c6f9ba57f45d9e5b03e5e2ee5c57315837b7ce2b13164b65cd502c4a578dc940c0d5817f9ef7266c1d773c3752736cb47a46a01ccc6ca28bdae6e253d1b224a33bc15ec2e8ae23c3f64b81656d839a6e7584f439563c20109ad03a94f94d89367bd321e49bd0b4c22d0c689598e8f70617e25a3764358c39301eab3c6b0101ecbe5565cd46394656727c885bc2a9f45b7918ca458a99edcc7721056db8214a14148417bc8a9126911fc036aae7f6635bb2a8f46d647e674304894246352f740b26884b4625e7f81a0464756cf3f483346c83583d0b1e47a8f2b6702ad421a4befb8a5ad8700af7829eb8438e7a1d8ad5e449ff0a9e988edcd9f4ab0e3953c23c8b5a4eeb14128aa90d0a915e2568d52901ecb4fd9d8ca233e741c9aacadefc1291e9cf1e29c67070a3bae5c6175f26410a1e86f857011437f3f6f34d4fdbed7350990008e6c67eb72c16901cea55e341242ed5b5ac70a5c0e67c185482c4a8a13df1fc65f8025fc3d5d2fdc3add608ea4ac514858c61c085c7d87b764d67fd303c13987bc5683ca5d847b49e08782028228b241f7427d1339e943050d8ef0f74a27eeec7dd55d79b26ba4d0a59d968571cedbd616dcbff18947c64cf37c85fe54cf35aeb7f01b44aa5d301a61a3eba4030f070af05471ca6389f15a6b9bc2473a76dc9aed9a754999037c10613438fdd215cf63b7b5003cb74d9226e524c098a58831c7d1a31df181eb31486bc767c4841b1c3d1a10c3ec095b38fede054825e10b320a24014feb99d72a81bceea1b1e336c249fd0548b71ad55db03991d99ac74ae048b2f043b36f9799ff484167b0a0908180e1f4a4daf515fe9664cec6b8578fc41bdcb0c8fa4ed450030595bb2a8319bca9fd36b42163360f15a9ccbe7d44aa03ed3ce314c21a03fd5fc950d5c5462ead7ccc531f94179ace72ddc925af1e655be364b21f6062d0741c7656e599bab286670e75e56713116771b29a0dbeadd52b2e0b319c9470ddd1d40a93619e9931a65eb3a0f20c1c3cdfb2b6670372f3c24a99d84d074fded9c6948f12c05c1838cadc1eefb3cd96b6a8f65b1916a420ce973a5c5dd3d9c79152c5644d652c7443f378b4a2b32f67ef023e5e9b128e1519917dc4a51884152a95dd75cc74e64a1bf91bafbb4a6f4fccb3f047d4c47e025dfea91fb705236885335dae2a647be914e72fef541171082ba9b32fcef30426a2ffdc1e2079805f6ef97b4f7a9a48bd1bd7c686b22d9e88e98c6b93c2eec4b0a7f578f66918c9b86a1bd1b7fc6ad02c20d8bead6312c1937fb993ad77270c21eb7c18ea065a32b59369b096cffb477250ccc6ce59dfd652cb2da3dc7b44641b505c180ead325a0297393b5bb23c5ed969c819a9e9cc6773129ddb2b0586153ff9e15056803760634dc3e56041f7dd7a149afa94ace9307c0edf2c014536a5e18f8fd3b59b6894d088b557fc7449d4807ffbd32833ffb5cd11449e8cdcba8045130fcb28ddf9a56a9f1f8be1b7c347e4206fb84897cb57568ffa940a51a9c5ebe572483c0c344d455393b17e25257bcd39038812e98776d52aeb297c3b6ba2a96d8ac2060e3197309c7dd244de77d2367545c2d4a6ef18019b7ad9b9a8bda3ed559bb32039e713a9e62799cbb83ffc52f6c3d8f065b21c5ad3c9c5b5738038fc056442326de36c4ceddbf8a5a8488bb41749ec86487c73f2caef068808d1926b6a07715d2ba6f330b0022e10472463cab0d13c74c643b0153861edb9fd6fdb16979ceaf47f8b29b01c1ba0288f7e5b7a2b25e99c60f52540d36e395184e3de5e2fa2a542897de87cd09ca26e3e45fc4ad8ab9d676b4cf6407ac41f7ab643282457e4f7a4f17a513749e7972b601dacfd632695cb17b445b1a6b7474248aa5876431b6e196e372a909dbca456b6594f5cdc214cf458e2358bef58cd64659ee20e54d94fc32180118537af2f6ac6a543f95dc6eb5cf3f60c8d5c427d268a559a118cfb69a5732999530abdc0c03ec0454200283e86fba78ff9220b731ff57ab8bc4df4965f84c60c7470b398e1bc98f6439e3f17b195b6bf9d7bcae20e2784bba3d403d0ece0704e9ebd669835b89fe69348150300dd918b9b4b36426675000a84b51f5a32f8163dcea7c94ebf6e88515eabc717cd63cb8b35c1f9329a41e4fafca3c9420e985640fb01aa802264f7f0d84634f28bfdc0a0f161b4c51722ae9cfefe7245a039c7d76e2f7ccf77af977c9f71aa48df2bb86f2aec69f1ae66aa2759293275e4e5f304ed30eb42af363b2378921444830703d0c5006446d832f3a1cba5667f0d8616ab6da3eff9cb34ce95bebd3ce81d46cef8f50af388e82d7e77eb67f51d969f22d4a00f070e9e5dbc61a227631751002ddfcd22a3124027c1e73f545a5f51fc069d9ddcadfeb4ddce038424af353d3e8f291212392c0dd00ebd58f0567c9b7168e1d84caaacff5956afd60f4b7ccacad32977bfe680f39ed32adf258e7502e001fe4cabe2d95dfd531f6079c9df522a04ba6bc00c05d138b28efb61b36eaefc7731fdccfd98d2834333376e3e6a9133d9e93527b15444d40bdb45839422a333c8db1cb13f603d9799306251f5ccb8deba4577202d1006689917cdde56dc65e7d8f8b2a7ac76b8b9c4671791e1a87f35ddeaded10dce961488e40556ec61dd7181653ad5419510a12aaa2a08a681a156406174ac3b3573375cd20e1b9153a934f0b1170dc7711f8583a2463e6476ca51af6e1b0f14a0471717c674d2fc12eb010f9dbe2cf969f5e8cdf0f8b50a9b2dbb0c126a0edd6e07258eb0d6fa23632cb959c1a7c860530e5b0c15e513e2b3eab1aa24b6dd85134e24c203bbe034a677cafb29ed2a286958cacc8a4b257dc65d60e97f1db9b65f3f43ffeef153e60c54b5ac49f7e159e8599528a5bcff4f7e85e69a203496322bd8ec9cd07c1f3c356eab68ced3415588a89d3dff056ed2783aff998760d38b61558cbf19273ca34659fdae954c4334abb0ea7c207267f4db784d56fd322e5fffcdb936b472d55a7787c4b912f182ccffe0144fde41040ddc50e8a912a43d01c0ce6875e4d4bd8c0c8b60708cdbd1a81e21d65b040a20ba1eb00d0ef8af2a0c05eee573d84e511f5d18f2f84dea391896a6a126ed278a6675ea663e0790b04fe543b4afc670705ea3042b932c3dc0625deaadb2da8b812a0c203e202ae0ecda0461e6159a5a79876387b550942f9cbdcfbf6225dda34dc5cd7d5425a7311447a0c228e677f72b29f31392244d27ce1b3b877c7cc8f93d75910b736afbf8f094d7d67a8b6ae9dd5df0270176ec66903ce6d2f101f86d8b7910d5c204e00eeb52f31e45fcbb0ec184fdd3867b70802f2ff9fdcf6c240562b8fe9d6ff8f5adfb5ebdb2bb6eba778e062c827c209e2e0dd5d26604dcd02b9f097858924a4fc199028bc2a455e611734e91ad5e2e5ffc33299764b0418879c45b0fc63c6a6085d7c2e56f32387c529dcaf885fa985572b31184171dfc2ab9c642f0608e35a3cc59cf46511b174bf35c85a12c9b60fee9c79c12580f0e22d82f957b800d8b0cd840943158083fcb958b3773896b27a9f264b3ea06a37551b41b6cf2caba9fb54199a15fcabbf1166c4918e811f16e4ff2d659ce815a424c8cf3a066497299430241392437d24a76ea90f98d558f506b1f558fd4deda06c9d6b7bcb613b8eb81ffbb93cd6f7f359d4f80925bf9b07b2588a676f9a28f7cd0d519f78f974f60d8cebc86f9aa86d002bf12f2f59e6b5b3e1c7826e1768eb00a260025f6e357ef2baa4a6a9f1d62a83a01b81c7747cbc8f0a73323df34d8d64a0f40608aaa4014ea15d64a901361a52aa84c161cffb0d8eb70ca7caa31e939784d9722fc73f967751ece7eb1c05be64a03adb421b75bd1cfc7b7af77bd5df178626eea15d493a65c72591995aa7b7d992779fa6e0bff6dc623280fa7564098c7fe7a9fc69d598836e5a1f680686b657727066247e776aa6860e1c3aa8d987f1434812cb99bcaed0455351dea13b3290ae7ae5ad0406192bb7ac4da7c9cef463a6ea6c4391c59ea3cd40291a84f2b51e7fc2dcd3f7b51873f2bd096fa016e35910bb44ced8a06f2390f038656a36c0ce690497bef2d7dce84ce165848af5f216fe73a0bd08cce55d46960ab6c476d38775598c311a5eac571045d29ab21d71c18428db0d46def44756555426ef0767cfddd3f6e027ab127392761e217ba612472cb05fea0b89cf777d910266518e522ebe00c05123cfd0f8506562d67ed5cde172202beb2ee98b11c1d2a1cf9c8d8d624ba9d944c501ab890b2301421d7ec55794af86790c40e6c2944ae7c7fb47cc66fe15035cfbcfa1e3d3cb4a1e2e460134d17554e18f251ec65678b212debfb6422ad55934b786dc58de07a9a857c96cb3622da7eedc5111676d58f588433700f22832be85259998b9738ce1c002646246a201e7c27ece58f7703c735a49f026ccb57dd5cc804a13765f69d6cb66f7f85e6cae311fea85e7e1ab0ce56c62615f3ee48525a8d383c591af2292fc314cfc71342d583813373f1c01254f42595acbda5dbf2839cadc561194859e21d0d386acdf2eb76e247da9e10f70033a7cfd3a8bc87edf7c8735d9441ffa74b7088d003820f7df77228805efafaabd00615ed79e869cf6c0b6321add4dc40ee55bdc5cf8667a91d40be2f5e219c49f9309bcf9adf4d531fdad2b22e516ec4af3b989be12e95231eee2674e82ab65e9f06092fa6e1af0af8cfd9f2a80e4822ddd95cf75b7ef6c9f2fe657b2dd42a4a2ce5658a6a04afd76bb8f44c9b91d550ec0008b7ea022140788fdcf731f77446fd48d25c4acb16b467757b3db48090b605e6f6d2987dc625a9722aa64c93b3fb6d6b62cf0f06fbbe69da5964b2156814d66226631e29fee3ca51e322284497730cc3adef5ddccd8d222ce18221568901b43deb5e2db001a2bf58d12eb29bcb870c567b338474d550d0bf80b6459a8e84f05e9545616732b269b2fce2d91045bb9508adff4346e04eecd0c83e33674140d508bb35efbc61d2e33daf038f04ff5dcc1e515d3716593442ed749734acb56cc13047a999a35ee45483a58c7f86708cb040f6b216c3daa8b17a76e7e8e8e73e1d5efa09c4066eccae9a36820f32ccb53b478692b5aa8fd891580eeab810920a2595d407a1ec1b8c44cd4397b844d73f512c17dadce251dc282b29939d9e2679c5043be229db408013ecb1c2a8f7048efbc563bf9ca709d507652f1578c07fa6652cdc1c0719aee6a4cda312d2c4db55b6aa6d05dc42de83c34ac62680e6f80e8a08b32dc3059328ef716fd057db706bf15d1d87b6b57f1fee39a4652cc9da561bca86912a0e6c6353b01fca08d9d9dd4c5c7224fcf45cb27d54cd200b05e9d68431196913b4113a4a2c873381ec5c931684241962d961dedbe079e5c07b77aa85d97df9f8f7b4f5a1ac756f50d2ee07ba66328f608b1a36782d8afd83169e5d27d707289155d38cadb816960ffe2056165973026b2085f0d21731dc3081fb62f1fa3db3b581067bbc19ac18b5ca9466d0c1e1f96e6d10377273bd37b77c6931c89394beb532f82577216966144d6f6724a1a136207f18af93618113fa7687490a37c2ef2452bd45f6a17e21c1aa08d9319bc8bfd7867a0be6e2fb3de5f2b93e570bb14bd8c4cb6607296648a0e3ad2d47b78f9caba9e2e798889bec2d24b6eb3276a1864646295dfc25284b32976c9ba58aecdb1fa9e6733f197b9fb019464c57f27fe5920ba5e4bde1b84cfe0520216e24fef46eed86cfcb687ced12b0a01eae176af77584c8b7601427e2b73104a17716d3eb94632603c32210b309a890619075f92f71eb3ee2b67c21f62d89fd8741011c73837f6739b0179d5a2cc43805146da2f94147baf61f697e81bd854d1b406ca4f4b3946e08005cda565d0f107bf24357de54d1ffd77d93e3af9f757465d665a0762c9c318f756c0f9ac97f0f8707e3721a85295e100f9416f44b709bc5160c3b081bd57238cdbe155bf460d3eda5981b37320a9345f6d64b7edb62508ac42a325f316ef0cd07eb27ea1048ce8a40fbbc0e89f3841b59f0c9e61bee37bd748b79008fa04593d5a8149d1680cbe94b5156980db006534fa981429463005f5b21f6887830d8b2575993590d46a1b546e2a885262fa852b59124c9762cbe982738f0c7f35e8a42e18b77a1132bb2e0f4e896a1fb2e11e71b2acc37706312acf04ed47de509ef227f42eb14065249e39715ce4c7ebee833b126ef7f0a2bc5a3447f1ab06a08c750654dd03b1a9df7c1d12ea6e90c9f4c0e2f95878f0f9d30ab2da5749605728b2cae53cd4ba4269701f6ab18439bf90f3a9a984edffc4fb81c10a9f2d5e78b22d7463d44e81c4de4c17982cf456a071c60e28e9c7098565ea93b695d2e6ba81835aa99a885c8e74a0087c6126d9a730c2356942d894d68238374c2be11ae767c52f7248d7a1cf4657f11b5d99b0404071c5e763b3a40ff8dd7179d4d87e1f19af7e8fd3f8b7e37735bd9510c1e125269595d0fb3f404808458040f4b215ee8c3b456b1923840f69fe09460acbe9dcc1a222f04adecd3b5f2debcd3b0f4829720e00aff94917aa865308dac42bacc935e75efc69fad98b7f569268f510952ad037ca67a11484387b6bdd57a043463c4ad6ebe4184f06782b602ca37d093dc8c32582ac203a77d028d3d62654392a2d0cfa7e5a6e4407179227b2341fe938005432fe409d955acb129f652bf3e75bfc5dcd64c5aef83a620896ca7275ab8d83ece13ae37174071dcfb52f03131dd43f43cf4525dab144989b9aea402c32e5eb13dfdda00e06caabbc7882b88521a46f4718388971e7e036ec4eb1794b5303d7acc1bc8060e99929d046b9ac6b3dd2d115b8df1c1e5fdf9f3a7c5fe34f223651420fb2d3d8be5d1de9085d556c715654b0796a8d8cd64b5b31ca4ef9d536a17d8bb1dc06cc3a9e1a29c242b335a28d9e72d5a8c53d6f59ad0515e4519b239a944082b1f7b0576b1f0b69a89be77e8307f8aad5e7b9ac99e00effb00834a24b6e1fd0fab2251c4da90e14e2f98749ab54e7eb111f5c313e8d9d2288819325a2b2a6e8e2bb743349108813e7d25b3c7714ca5e9b560c516096f9e4e303334f56447c18e05f24714ea3a23de4f926462d765218052ecd1c7e13f098c712de0d8dbe416b449c1a5bbde20b6bc67734c75edfc5f5ef1e411e91c0fe75016824d0f3c7c226aa77c770504e54a403d15ac36c2b71db367b47b22b3a860cf40e028372afb1db68b66e338d05ae26f732f660cd4394265ec004c0f5f127c28ed4661172ff3616110d7f772b0ca46b9d51544060972cb273802f02d9dca790c8cc7da56ddb9a302f576b95b837ee3345920565104e8743856ecb09a2324371706ff28fc894d7d226fe3f138f7bf9ed97f16d66a6d39522572d9423704efb3a9d7ced20a2cf4749fe9c923f7afd3b8e8873eeff0bd50db4eadacafa7a0dee74e8dc5fc8454da2ec132a25751b992c25f4ad1b7f002ebb5b741a146b268358017f0da9d2f49d9162cb1f8937b5c0ef3e3de1ca578f284146b1f984dfa2f7025f9118ab5a3a0973b6e71cc7500adfface757b8321e8dbe4d3e18b724bff351a6ee1fb565ad836be67c17f1cd14a285020c00c6c4f351df39225bc2eefa112a31b025204c85fcaff9af82edf93ea5fccb5c0cc33f564c42ddb4fd98cfdeb8c5ab029d72c4afe222ea3429bd2de8093ad915ce62f89c868ddd8fe094d5b9ee57d903dc480ab6dcdb56121ead5c522b8bf0567c6b99b9781a5d8cd8b322343d899b6680a80f9b1974642074eec0edebeeba43c4d3cb6a6ea02e226aee3ed24153ed3df61616b772026d2e9c8f814c87eb998f4c32f98a8700db7f412d74014ebcb06a20ee07eacd0e3bb7e5d38cbfe1b5982185d02e6c165bc56785aab0883aebc4af7d0f88c47f9ea7fb89942a33e8620d5bb8b244677ca3d7908a39c4790d7ea455f549885e3666cb45cbe9201d858a81b2f2364fc2df8aba22e250a8830400e0b0083878c5a38c23ecba10482c5323c6c066b13a17131dbe3c7be11877741f4cf4e62c2205c037a35e04d0cea8a7e0c2c7c8069f3eb622468e69bacb903bed3c8d50925049a0fee9100f068e99e81e31f16b02d86d8a274e0946b6766eacd411a2621927ca75983f5febde28e1a4c87c329dd817baa3447a7315fe3e8650e0130fe510540b24df3000b9bf9f02297adbe46519826f092246ddae7e73df05e61074ccd1ed45f4e264cb9499d7c6476be44f6f924c2372e9976937837aadd8f2b94c8149da77143e084f80110e0ebfe8529837e514acfbe034de7d5bc53082dab92b47a20cedfc1764d746d78dfbcd5505147674e5eb493140b6f2f6e860da07fd23e7f0040889bb5db3fcc5ed90798bf824c135a9fd18bb8a284f384ffc506a1c1fd27426b3acf0c41da5d601fa5b28862ffe1c974eb5e4ec70ce19f5d702c95830d18394241931bd4ebf976b6751a5c668104d63eac4cf7f4f9d6392f36708721983c1d4025d13de46a5aad4ede9f7d7b20471906dc252238e67a2b0c8ed2b7b9e25c504351e9bd784b959bcbea1de2d312838df6201ce1f8a360e8e821d49a2d0c756a079750e9500852a86e6770d9dcea201b54d828ffb3c91d6e8f15f3837cd57d39fd176f0f908e488725278897738c0dcb76df01fd5393ed75ffb8fc88914041c12115f3efbadd32a78eca440beb788fe6b49477697abf65409c6ce10811805eab7db60647797445db168eb1677a47d0eaa8c354ca83b37d0d1cff6913667d0a043087d744dac73e77acd6a3e6e11c040e44e3fa2810051e95d9eed9c55b7ee858549e2ebf1fa776580a0cbed884b1461171225cffbfd6c9729c9a1df27efcc8b5930bbd62e6efbdc7c6c565f237526102162dcabad2ecd8d95e8e5b20277c826c8323d1165828337c0c6c8293f4860bbafa69dcaa7836db7698ee80574020d167c816db1405cf217a1b5837b3a034500522e6bfb548205b618814893e1c4195439f383b145576846d6bda07be278dee7ec5e6680771ea03932e52716a55d05c9d9f09251b07548386c135ccabbbc0295caa97c21a2b4a3b2eb9ee8e8ba25d23941d0ccadfc951ee9396e95bd86fd4a0a724d49a4a822d0ad16044072228f9f812a9806fc5bdfde301c8c4b8ec6480da8e1071c88df87746858f1d83f394a4a52812e647ca59d2246a2999f2439b139eed66f998edc82bec0ee388e7ce2d331107c7ad3f8fd1ad99c1b7063d9bb1237193412242a54d7fbb509e1d0452e41377374d97a6f49cf729c7b8dfe30d224d095c6fcfc7362839b8595dc266d934c97346280c4c2e17c57f3a1b8f145f89d3ed08a002db7fbe02b6a3eb131a6b5da38bbd920c4f8798e3b1ed697b5f0041849dd923e51c51b1d390d1e239369a33eae321d07cc5fe85a2bacc059920e2ac2955fc664ff70d480b4392b76c0278319f45f8965a2a4fa41cd027aa31b129044529566396f8829dd78eb01bb497bd01b60b791d1c0cb2c5e7031648988eb120c0db0eeef89b13fef4bcfb3b25830ac10660e836a487e73e7b4fe92a9e696cbcf5c2b0dd2c1988f0d45a111843fbd1e049132ee060e30dd1e52b4f2391210e4540125f567f2b3fec2f22e961e794e3e3dcccd2ad297ae5ff87e71a139c8f6dadc7ebb7df321dada930d90ea7e7b841043ab48465ecb829f4d248fefe3f5907dccd13a4cf70b52dd449a63ea4c157edaef6a91693b9c2639ab62063ba77a197f61c378453af3fa9253475de4b96c0744fbb845df767aa5e95a752f231b3d611b754c940ef90166a242a9ed8efd3ff2a2e5b029c8ab3d21b8632f56b040c3f0de5083482e50fee06870f32ab25f04a566391fa132ac960836bc361730552501397299d75a89d1071b3b996b4ff7ff5a829a9f59f9f19adc7f0395412b3fb2ff1be1830941fdcd65e159dada9fc924a24cc8fcd26c637fc5ea2d66bdf4adca9afaa640d54cc225647976f20345fa060f63c0b7983e6d1eaec2b639aa00b727b839b7b9527e14da79e7d5a2e8157d4aa648742a6e75bae87947c89768555d826b190a94133b32fee71eda6711ee4a6de690d8dee120bfdd52832a3d1b75f4ce4c0a5533e76ae911c42068c7f34336445feb01cb8f861cf493671ef7180b51b254b6e1dfe924b8fbdd02ac44fd2739a6270b3c01209bc457369a83f8f0cc2d2f3c399d030d2f501a0f9019a4f556475698261fd78f31eae64f14686a69ae31a8bd3b831f4d221474ecc0e1b32793e12e378ed049851e434af70cc49b3e1f3da0cdd42903eb9dc13d6b090b7b709c5d18d6511c859a043c6ce7107d488191838e9b8c7f3556a1bdc46e7d8d48cf056c60652f47bb7cba066efe468b262f112f7a6d64e3b5226b08b7a9c7bf32f1af7a00f9c1121c527bd80b556bdd0549e2605026f0e95ef4f15a24028b86b025c6137da9b81669e7663d66d9c91ac723c57ef97dddace68ef0a6aad4ed82b77ca27029419ca77d8abeb9e207e992ebf10404c308399683f6985c55a1f2465435c3eb16faed53ff31708e52ef9f1093b3feea81824ec978554e857af032c6216bb675009f87adee9c19bf78297d198050e60e35d1daec552a993a934b4beb631503b8d3345cb46b77594d1d591cdfbf0b185b9f867c3d8a363faab7ad634751fa6f279c2dfa6eaa95711f5e4f8a39dff9d9f4304f053cc2b165ca01417046c5571c214bac2fc4647581f4ce38d3a1761179b7800d51364b4308c0395c36aaa741eaf4be511f905c2d5b81aeb451a55492f70956b165c59a62bcf6a7d31269d55379b85c4469befb74aa8ed1d4eee53fa79ae93068b37aa10aa7ac85f71a17cf2921a53c2780f248cd10d5fb3e79889cca6ddcb0e373eaadc51edcabdbb098a46d6d2ea2c3454c6febdb55867c5a4600da9dd3234af0f672c7960d848f10c1c25bca4728c372bc5e3d8d830918dde1bce3f68005fb25cc310d574ae96025b632fa87e326ec6d6f48fa4a10529c6b2723fbff151f9af49596f1d88ef71964cf38e480f935bce3cb4c314ab969d4fd3c087d1602d1493c80affc2bd620e659c413b6d2de2d80d3b78607dba8d5e1978822de91a120520bdb20eaa257a4fd48db23f5edbbaa7badd1e2e831b833a3cec4128485ef42ec9ff905f56a98b763c6cff4ab9c2bd1edd80893fcfaa59677119e526154b1d9b01ba9720b739dcf36ade1e5b7cbd652696cd706fbd8365e08efd64be85f769684560cf2c5d7527082520b51e0f50ca20c4d738d57a28796074f323b48b79ac3627e9ed1d60afd11d8c225d5c179b7d3a70c0e5aefbed36b3b7253dfbf6d3fd90baa58478dd764b208e97d2d526019e1c8de9427586db074fa770100ff7289732b41af2bfdd29a5f8a44512e6a9ce6147be619e865f3aff4d822d6aea8e4c04f57e9af8eb37d3034b6b4d0e6b753fa1b77545a145aa3436acca6ea68abb115b84ffebbca526f5390f78352da051a3753dc89d3b23055ee2a9fa35212dde2ecbc87f1dbf1e6160f747b4f004dd177f7531d9aeea38cb02cdfc2bbac42747ef0924fe03a2f19a57d77b72d7d967bd3cb1a2c6eebbf64b5b40a06b8f4df284ce4e48121bbf3d4cc00a9cb0f05198a12847a74ba0f25df85ff9b01dfe67b5f6ee25d23ce1f5506acc2623931f51a58f68829998a7d5f2d695663a5dd12ca197b209214edcd8fca4f83a44a9bf5158130b1b5c7c969001f0c3ee72f354b186457c354b7696976cef1d1edf57be9d269a37fbf265fc5abf8d045f92c97fc1e8852450da31a762ea00ba5303606eb8533883e27e2c7b2493b5f097d9729751923bc39610476f810d67b9b90745a38d32b86e7d095e0354d6c48d0b25bc3bf8f671965bf6669d5f989a452a45cf86411a07cfba5197310b0e27cf78ae6aa86de7bf48489b068d6b4705f897a74a8bb2b9fed08893521b001d5f0196e1e1319ffe461c5ca757d8d6320c20941368effa5e0c42102aa0d1b207ef8efd954dc22a3b1bbc0fd74ceefadd23a04cc4df24845e856f75ea965439886c716247eab77c796efde4608798c955736767f8063537f88f26ced19a2919120946e41e7afa847d3f2141d650c6cda183e50e15925814be36f40c25b04bca48468a69659e9741e4057928319f4640d42d46d498303dabcbb59070e61e531e01435de8b0cf7ff02fbdbc3bd1a8ce53c566dbb4b9f8a9c356b0ff78afa827d4c9c744b7832de24ac1c5e865f4e4e8b1a283f15a59a748bab906a22bad3edce24fe10a3ae9b3cbf6ad95e90699d7be02b8b17c4dcdf9fbbf8a4580ae880b229fb3165a9ede2519ae9d1fd1b7aada52aa7ec9fb98f9a2e5e3c70f165b9fd3f969f05d476faf74d3325c6e85b51f441065e2aa7ac28bd8472e9e70449c90c097e614c1c3fe291e81260af20aff8292a117b365f87c4816a3c52fdd8cad10d696f6f0e9abb5a7c89a49cd89de07911d8bf667bdb07935960abc8f85f38d354a6fcd8510685aa1051d57be92b9d37a06003e03663bffd500070cfe9ee6eeee5d030f70e480eba1cf0e3fab5ddb8147cdeeda0ef078bd64c83e3b5b128d4491512a2bc889bdc08bdcdd95b2c49e1f7b49dd03149d26125071ce4b8cbd73d0c30cd1656a1b0065e56fa0785c9a39c914817e98d016d692c4eef0f69c9ca70575d06f7959b1128adc240a89d2032d901c55725d18c1c15c50aad8b3dec6f1613c5b5ca95f1f6e0ce188aff4c414afef9a46d6b79b5990bf1010cb9d17c626d20037fdf9bfab2720a3778ff891bbbefd47911158d22ccf5438786c3d6e05f0f63602307a9e569ac5b2e3c9b787b56f49b675531d05a6e328e35339ba3dd28500433e96aaafd447c4b7ade207266b55a75714d78be1d8b65ce33b68ec0226bafe319ff522ba8b6b317d1f80ee2a56a46ff5d0696acab490364337b30aec29e670e0a0afaa9f40fe220888aee2d5bbb2c03ffaa32d4475af3cde39e9dce005f3903a13111f3bcafa10e70de6378312ba5fc52b2c8ff81cd07ba502b43ed33330bfd3020cce96e8bbab647bcc7fe1299d0bdd4842962b2afcd020f3a598f9c13a3df865d1f891e71b2a0d366fa4cd333021f9f1539f0fe76fc3b7ff939d136d8d577577b53dfb8c45b312808db437c2273ca1a557ba0a6437d7066872363acacf8a4bd465783d370779d98575b84ab55c304496844cd91c20a124d7bce3cc1751077be44f08a047d3604bc05735040af3030911ff892a2a4e7ad206df623ea0d2b6c6dd9e4d00068806d1b4deb65b3e6ab1559b4ab6544bdfdb6fbc6f3e6a63f8e3c9625f3f79bd8b23436c8eef3afa431e052b0398671c1295263821688f99f8dcf09a1c63872d214db2f66e90a9704b6d17d947ab7f33a00a5f8eb2121cb987199ef779d5e61a7637e59a7c9e2a23c6a20f591a3854a3439ab149e5acd3cf48bc79fde7492df1654d7f5c52394f6c455c0b4d0f918355d1391b8f8f25d5a57e6c5a8bad8f60fbfcc07fa1224b3c22fe09fc1f807037df836365437c6e49135d29b635b0333dd97e2304c6ed913fa3d8c9a681c0c2aee4a916320ad30b7aef94c6d38a14a83e44ed13f451c21bf5ab1340e984e7e8e262824744bdb0a911e02db631aa7e9991cbac7046ae35cf8a3657c1af789cd7c59a5238c8896ca35e536c750f1fcb4a00d770f2c99cc29e21af3dc1a29733a80a17f9c4d41f22d525294d477fdbb0f952b790da63d2febdc73047f660dedc98ea0663c1729d8cbe3a594758c660e40e445ff2894bd244a9e1e9a628b577bb45128d9d0e573d5fe6e6671a76c3a522d7442072e4fb79d4461675965fc893f4ac046386b3764aa33aac76f291efe093bc1247916abda20ca12599d0bdff096675636de70af2f27e9547bb67357712dbbe22f7798d3459761ea125be0e4d597dbda62a5569dfc5550f6d8338297027aa3548e311f94e552853a052aca677d3f0958d446455b1b1b5ca0f6dad42576c172bfe1f8904c54fed4c2049e79dcb88abb84ea0fcaaaf93976284977c4fd1015a68bafd39c8b6e2295a90339c93a25a28591a6fad63a31b0459de33dd4879327b43d250416b2d39f6607f6b298cfc31d53473caef9d4e4685555daa80406277fe9aa5fd8f32260946a3abdfcdcdc8f28e21934e78cee3a1df934580919740715def00ef9d26b9b03874d377474cab7e7f026fa65c3c2b8ae2f6add1617885fdaaa2c3ce4af8bddd3e7fc4b1651f1705ccde8ae86458f380c6679babce9d147cfe0dba6e1bc17c95267c74f853df84bea60145171984f29aed39c4737357fc6df2b3548e7e3a88157f35415252cb626e61f3773633749466b323f9e6dad231c697fae5354b4a286d00d76451f1ca12cb05370264822316f71ea24ba42ca7063635232ce52c1d62fa3f841b428010421f4bc0e78dbc18a3051a4cb94f0498012bacefb58322b570af2f2959d7c2048624f05be03f9df392730ed66549471a2a0aecf124db84cec6ad07783d9aed2eb8d5df4d3168bdbfddae4c69ed882f4d4bc68f416761457b68a38e991d99c55e8e0102b72513822ab99005172834be6cff3ccaf717a7484a9d8d87e0274de97808d14eac0f92151431a353d3d9a109a1130d82e7b3ae8c728849d5a1b8bfcc439f7cfdf0c56c0fa4a6e1d36c178b7eb3d7c31ee2ab22a66f782383ef0caacdd336429b3aec1795badb22d52185f3c09bb5b1b7331854fdd401eb3ad297e3940dc020d9fa621f253c9aea4ef66b57967ffe18f35ad3edab4c581234fd8e788b13415c23f6dbfea2094287605f3f82272cf594cfdf37bf37ebc74490011a828a955e7884e1e35621e7ab90aea4c3ec79543c0c8147f8af9207e6d44d11967b52b422e0eba049adf22b19dfa3c94081a6b34dc174f0743c776</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 请输入密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>加密</category>
      </categories>
  </entry>
  <entry>
    <title>岗位面试</title>
    <url>/2023/03/05/%E5%B2%97%E4%BD%8D%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p>与后端有关的不同的岗位要求面试题整理</p>
<h4 id="1-调度相关"><a href="#1-调度相关" class="headerlink" title="1. 调度相关"></a><font color=DarkOrange>1. 调度相关</font></h4><h5 id="1-1-调度系统有哪些，主流调度系统的异同点"><a href="#1-1-调度系统有哪些，主流调度系统的异同点" class="headerlink" title="1.1 调度系统有哪些，主流调度系统的异同点"></a><font color=DarkOrange>1.1 调度系统有哪些，主流调度系统的异同点</font></h5><p>调度系统是一种可以自动安排和管理任务的软件工具，它可以帮助用户在一组计算机资源上执行任务，并监控这些任务的执行情况，以确保任务按时完成</p>
<p><strong>主流调度系统：</strong></p>
<ol>
<li><p>Kubernetes</p>
<p>Kubernetes是一个用于容器编排的开源平台，它可以自动化部署、扩展和管理容器化应用程序。Kubernetes使用Pods作为部署和管理的基本单位，并提供了丰富的API接口，方便进行扩展和集成其他工具和服务。Kubernetes的优点包括高度可扩展、强大的API接口和控制器、良好的社区支持等。但是，它的学习曲线比较陡峭，需要一定的学习成本。</p>
</li>
<li><p>Apache Mesos</p>
<p>Mesos是一个高度可扩展的分布式系统内核，可以用于管理和调度多个应用程序框架。Mesos支持多种任务类型，并提供了API接口和命令行工具，方便进行扩展和管理。Mesos的优点包括高度可扩展、支持多种任务类型、良好的社区支持等。但是，它的配置比较繁琐，需要一定的技术水平</p>
</li>
<li><p>Docker Swarm</p>
<p>Docker Swarm是一个轻量级的容器编排工具，用于管理和调度Docker容器。它具有简单易用、集成性强等特点，适合小型或中小型部署。但是，Docker Swarm不支持多种任务类型，可扩展性比Kubernetes差。</p>
</li>
<li><p>Nomad</p>
<p>Nomad是一个现代化的应用程序调度器和编排器，支持多种类型的任务，包括容器、批处理、周期性作业等。Nomad提供了API接口和CLI工具，方便进行扩展和管理。Nomad的优点包括支持多种任务类型、易于部署和管理等。但是，它的社区支持不如Kubernetes和Mesos</p>
</li>
</ol>
<p><strong>调度系统对比：</strong></p>
<ol>
<li><p>Kubernetes vs Mesos</p>
<p>Kubernetes和Mesos是目前比较受欢迎的调度系统。它们都可以用于部署和管理容器，但两者有些许区别</p>
<ul>
<li>Kubernetes: 是一个基于容器的开源平台，支持自动化部署、扩展和管理容器化应用程序。Kubernetes使用Pods作为部署和管理的基本单位。它还提供了丰富的API接口，可以方便地扩展和集成其他工具和服务</li>
<li>Mesos: 是一个高度可扩展的分布式系统内核，可以用于管理和调度多个应用程序框架。Mesos支持多种任务类型，并提供了API接口和命令行工具，可以方便地进行扩展和管理</li>
</ul>
</li>
<li><p>Kubernetes vs Docker Swarm</p>
<p>Kubernetes和Docker Swarm都是用于部署和管理容器的调度系统，但两者有一些明显的区别</p>
<ul>
<li>Kubernetes: 是一个高度可扩展的平台，可以支持多种容器和非容器应用程序。它还提供了多种API接口和控制器，可以方便地进行自定义配置和扩展</li>
<li>Docker Swarm: 是一个轻量级的容器编排工具，主要用于管理和调度Docker容器。它具有简单易用、集成性强等特点，适合小型或中小型部署。但Docker Swarm不支持多种任务类型，并且可扩展性比Kubernetes差</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong>如果需要高度可扩展和强大的API接口和控制器，可以选择Kubernetes或Mesos；如果需要简单易用和集成性强，可以选择Docker Swarm；如果需要支持多种任务类型，可以选择Nomad</p>
<h5 id="1-2-请解释下什么是任务调度，并举例说明一下任务调度的应用场景"><a href="#1-2-请解释下什么是任务调度，并举例说明一下任务调度的应用场景" class="headerlink" title="1.2 请解释下什么是任务调度，并举例说明一下任务调度的应用场景"></a><font color=DarkOrange>1.2 请解释下什么是任务调度，并举例说明一下任务调度的应用场景</font></h5><p>任务调度是指按照预定的计划或规则，自动地调度和执行各种任务的过程。任务调度系统通常是一个计算机程序或服务，它可以根据特定的需求、优先级和时间窗口来分配和管理计算机资源和任务</p>
<p>任务调度系统的应用场景非常广泛，例如：</p>
<ol>
<li>数据备份和数据清理：数据备份和数据清理通常需要定期执行，而任务调度系统可以自动地定期执行这些任务，减少人工干预，提高效率</li>
<li>系统维护和监控：任务调度系统可以定期执行系统维护任务，例如清理缓存、更新软件、优化数据库等等。同时，它还可以执行系统监控任务，例如检查服务器负载、监控日志等等</li>
<li>批处理和数据处理：许多企业需要处理大量的数据，例如批量生成报告、数据清洗、数据导入导出等等。任务调度系统可以自动执行这些任务，减少人工干预，提高效率</li>
<li>任务队列和消息队列：任务调度系统可以将任务加入到队列中，并根据一定的规则和优先级自动地分配和执行任务</li>
<li>负载均衡和资源管理：任务调度系统可以根据资源的使用情况和任务的需求，自动地分配和管理计算机资源，以达到负载均衡和资源优化的目的</li>
</ol>
<p>举例来说，一个电商网站需要定期生成销售报告、清理无效数据、更新商品库存等等任务，而这些任务可以通过一个任务调度系统来自动执行，减少人工干预，提高效率和准确性。同时，任务调度系统还可以根据网站的访问量和服务器的负载情况，自动地分配和管理服务器资源，以达到负载均衡和资源优化的目的</p>
<h5 id="1-3-如何保证调度任务的可靠性和容错性"><a href="#1-3-如何保证调度任务的可靠性和容错性" class="headerlink" title="1.3 如何保证调度任务的可靠性和容错性"></a><font color=DarkOrange>1.3 如何保证调度任务的可靠性和容错性</font></h5><p>保证调度任务的可靠性和容错性是一个任务调度系统中非常重要的问题，以下是一些常用的技术和方法：</p>
<ol>
<li>异常处理和日志记录：当任务执行出现异常或错误时，需要对异常进行捕获和处理，同时记录日志以便后续查找和分析问题</li>
<li>任务依赖和优先级：任务之间可能存在依赖关系，例如任务 A 必须在任务 B 完成后才能执行，这时需要对任务的依赖关系进行建模，并按照优先级进行调度</li>
<li>任务重试和超时处理：当任务执行失败或超时时，可以尝试重新执行任务，同时设置重试次数和超时时间</li>
<li>任务状态和心跳监测：任务状态和心跳监测可以帮助系统及时发现任务执行状态，并进行相应的处理和调度</li>
<li>集群化和高可用：将任务调度系统部署在多台服务器上，采用集群化和高可用技术，可以保证系统的稳定性和可靠性</li>
<li>容器化和自动化部署：采用容器化技术和自动化部署工具，可以快速部署和管理任务调度系统，同时提高系统的可靠性和容错性</li>
<li>测试和验证：对任务调度系统进行充分的测试和验证，包括单元测试、集成测试、性能测试等等，可以帮助发现和解决系统的问题，提高系统的可靠性和容错性</li>
</ol>
<p>综上所述，保证任务调度系统的可靠性和容错性需要综合考虑各种技术和方法，并根据具体场景进行相应的设计和实现</p>
<h5 id="1-4-什么是调度算法，举例说明一下几种常见的调度算法"><a href="#1-4-什么是调度算法，举例说明一下几种常见的调度算法" class="headerlink" title="1.4 什么是调度算法，举例说明一下几种常见的调度算法"></a><font color=DarkOrange>1.4 什么是调度算法，举例说明一下几种常见的调度算法</font></h5><p>调度算法是指在任务调度系统中，为了提高任务执行效率和资源利用率而采用的一系列算法。调度算法通常会考虑任务的优先级、资源的限制、任务的依赖关系等因素，来实现对任务的合理分配和调度。下面是几种常见的调度算法：</p>
<ol>
<li>先来先服务（First-Come, First-Served，简称 FCFS）调度算法：任务按照到达时间的先后顺序进行调度，先到达的任务先执行，后到达的任务后执行</li>
<li>最短作业优先（Shortest Job First，简称 SJF）调度算法：任务按照执行时间的长短顺序进行调度，执行时间短的任务先执行，执行时间长的任务后执行</li>
<li>优先级调度（Priority Scheduling）算法：任务按照优先级进行调度，优先级高的任务先执行，优先级低的任务后执行</li>
<li>时间片轮转（Round Robin）调度算法：将任务分配一个固定的时间片，每个任务在时间片内进行执行，时间片用完之后，就将任务放回队列，等待下一次调度</li>
<li>最短剩余时间优先（Shortest Remaining Time Next，简称 SRTN）调度算法：任务按照执行时间的长短和剩余时间的多少进行调度，剩余时间少的任务先执行，剩余时间多的任务后执行</li>
<li>最高响应比优先（Highest Response Ratio Next，简称 HRRN）调度算法：任务按照响应比进行调度，响应比是指任务等待时间加上执行时间除以执行时间，响应比高的任务先执行，响应比低的任务后执行</li>
</ol>
<p>举例来说，假设有三个任务需要执行，它们的执行时间和优先级如下表所示：</p>
<table>
<thead>
<tr>
<th>任务名称</th>
<th>执行时间</th>
<th>优先级</th>
</tr>
</thead>
<tbody><tr>
<td>任务 A</td>
<td>4</td>
<td>1</td>
</tr>
<tr>
<td>任务 B</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>任务 C</td>
<td>3</td>
<td>3</td>
</tr>
</tbody></table>
<p>对于这个例子，采用不同的调度算法会有不同的执行顺序和效率。例如，对于 FCFS 算法，任务的执行顺序为 A-&gt;B-&gt;C，总执行时间为 9；对于 SJF 算法，任务的执行顺序为 B-&gt;C-&gt;A，总执行时间为 6；对于 HRRN 算法，任务的执行顺序为 B-&gt;C-&gt;A，总执行时间为 6。可以看出，不同的调度算法会对任务的执行效率产生很大的影响，需要根据具体场景进行选择和优化</p>
<h5 id="1-5-分布式调度系统的设计和实现"><a href="#1-5-分布式调度系统的设计和实现" class="headerlink" title="1.5 分布式调度系统的设计和实现"></a><font color=DarkOrange>1.5 分布式调度系统的设计和实现</font></h5><p>分布式调度系统是一个用于管理和调度分布式计算资源的系统，它可以在分布式环境中自动地分配和管理任务，优化资源利用率，并确保任务的可靠执行。下面是一个分布式调度系统的设计和实现步骤：</p>
<ol>
<li>架构设计：设计分布式调度系统的架构，确定系统的组成部分，如调度器、节点管理器、资源管理器等。架构设计需要考虑系统的可伸缩性、可靠性、安全性等方面，保证系统能够在大规模分布式环境中高效运行</li>
<li>数据模型设计：设计数据模型，包括任务模型、资源模型、节点模型等。数据模型需要支持分布式存储和访问，保证数据的可靠性和高效性</li>
<li>调度算法设计：根据具体需求和场景，选择合适的调度算法，如最短作业优先、最高响应比优先等，以实现任务的高效分配和调度</li>
<li>接口设计：设计系统的接口，包括用户接口和程序接口。用户接口需要提供任务提交、查询等功能，程序接口需要提供任务调度、资源管理等功能</li>
<li>节点管理器实现：实现节点管理器，负责管理分布式节点的状态和资源，包括节点的注册、心跳、资源分配等</li>
<li>资源管理器实现：实现资源管理器，负责管理系统的资源，如 CPU、内存、磁盘、网络等，包括资源的分配、释放、回收等</li>
<li>调度器实现：实现调度器，负责任务的调度和分配，根据任务的优先级、资源的限制、任务的依赖关系等因素，选择合适的节点和资源，以实现任务的高效执行</li>
<li>监控和日志记录：实现系统的监控和日志记录，包括任务执行状态、节点状态、资源使用情况等，以便及时发现和解决问题</li>
<li>集成测试和性能测试：进行集成测试和性能测试，验证系统的功能和性能，以保证系统的正确性和稳定性</li>
</ol>
<p>总体来说，分布式调度系统的设计和实现需要综合考虑系统的架构、数据模型、调度算法、节点管理、资源管理、调度器实现等方面，以满足分布式环境中的任务调度和管理需求</p>
<h4 id="2-存储相关"><a href="#2-存储相关" class="headerlink" title="2. 存储相关"></a><font color=DarkOrange>2. 存储相关</font></h4><h5 id="2-1-数据存储方式有哪些，并举例说明它们的优缺点"><a href="#2-1-数据存储方式有哪些，并举例说明它们的优缺点" class="headerlink" title="2.1 数据存储方式有哪些，并举例说明它们的优缺点"></a><font color=DarkOrange>2.1 数据存储方式有哪些，并举例说明它们的优缺点</font></h5><p>数据存储方式主要包括关系型数据库、非关系型数据库、文件系统和内存数据库等。下面是它们的优缺点及举例说明：</p>
<ol>
<li><p>关系型数据库</p>
<p> 优点：</p>
<ul>
<li>支持 SQL，易于查询和操作</li>
<li>数据结构清晰，支持 ACID 事务</li>
<li>能够保证数据一致性和完整性</li>
<li>可以存储复杂的数据关系</li>
</ul>
<p> 缺点：</p>
<ul>
<li>难以处理海量数据</li>
<li>性能不如非关系型数据库</li>
<li>需要花费较多时间和资源进行表设计和数据规范化</li>
</ul>
<p> 举例：MySQL、Oracle、SQL Server等</p>
<hr>
</li>
<li><p>非关系型数据库</p>
<p> 优点：</p>
<ul>
<li>高性能，适合处理海量数据</li>
<li>支持分布式，容易实现高可用性</li>
<li>可扩展性好，支持动态添加节点</li>
<li>适合存储非结构化和半结构化数据</li>
</ul>
<p> 缺点：</p>
<ul>
<li>不支持 SQL，查询需要编写程序</li>
<li>数据一致性和完整性无法保证</li>
<li>不支持事务</li>
</ul>
<p> 举例：MongoDB、Cassandra、Redis等</p>
<hr>
</li>
<li><p>文件系统</p>
<p> 优点：</p>
<ul>
<li>支持任意数据格式，适合存储大量文本和二进制文件</li>
<li>易于使用和备份</li>
<li>能够处理大量数据和高并发访问</li>
</ul>
<p> 缺点：</p>
<ul>
<li>不支持事务和复杂查询</li>
<li>难以保证数据的一致性和完整性</li>
<li>不适合存储结构化数据</li>
</ul>
<p> 举例：NTFS、EXT4等</p>
<hr>
</li>
<li><p>内存数据库</p>
<p> 优点：</p>
<ul>
<li>高速，数据存储在内存中，能够快速读写</li>
<li>支持事务，能够保证数据的一致性和完整性</li>
<li>支持复杂查询和高并发访问</li>
</ul>
<p> 缺点：</p>
<ul>
<li>数据容量有限，不适合存储海量数据</li>
<li>内存数据库的开销比较大，不适合存储小数据</li>
</ul>
<p> 举例：Redis、Memcached等</p>
<hr>
</li>
</ol>
<p>不同的数据存储方式各有优缺点，应根据实际需求选择合适的数据存储方式。例如，对于需要高效处理大量结构化数据的应用场景，可以选择关系型数据库；对于需要高性能处理非结构化数据的应用场景，可以选择非关系型数据库；对于需要存储大量文本和二进制文件的应用场景，可以选择文件系统；对于需要快速读写数据和保证数据一致性和完整性的应用场景，可以选择内存数据库</p>
<h5 id="2-2-如何设计一种高性能、高可靠性的分布式存储系统"><a href="#2-2-如何设计一种高性能、高可靠性的分布式存储系统" class="headerlink" title="2.2 如何设计一种高性能、高可靠性的分布式存储系统"></a><font color=DarkOrange>2.2 如何设计一种高性能、高可靠性的分布式存储系统</font></h5><ol>
<li>数据分布策略：数据如何在不同的节点之间分配是非常重要的。在分布式存储系统中，通常采用哈希函数对数据进行分片，然后将每个数据分片存储在不同的节点上。这样可以保证数据的负载均衡和高可用性</li>
<li>数据副本备份：为了保证数据的高可靠性，在设计分布式存储系统时通常需要采用数据副本备份的策略。当某个节点发生故障时，系统可以从其他节点中获取数据副本来保证数据的可用性。同时，还需要考虑如何在不同的节点之间同步数据，以避免数据不一致的问题</li>
<li>存储介质的选择：在设计分布式存储系统时，需要选择合适的存储介质来存储数据。不同的存储介质有不同的特点，例如磁盘、SSD、内存等。需要根据不同的应用场景选择合适的存储介质</li>
<li>网络传输的优化：在分布式存储系统中，数据的传输是非常重要的。需要优化网络传输协议，减少数据传输的延迟和带宽占用</li>
<li>集群管理和监控：在设计分布式存储系统时，需要考虑如何进行集群管理和监控。需要实现集群节点的自动发现和管理，以及对集群状态和性能的监控和调优</li>
<li>安全性：在设计分布式存储系统时，需要考虑数据的安全性问题。需要采用加密技术对数据进行保护，以防止数据泄露或被篡改</li>
</ol>
<p><strong>总结：</strong>设计一个高性能、高可靠性的分布式存储系统需要综合考虑数据分布策略、数据副本备份、存储介质的选择、网络传输的优化、集群管理和监控以及安全性等方面的因素。同时，需要不断进行性能测试和优化，以保证系统的高性能和可靠性</p>
<h5 id="2-3-什么是一致性哈希算法，以及在分布式存储系统中的应用场景"><a href="#2-3-什么是一致性哈希算法，以及在分布式存储系统中的应用场景" class="headerlink" title="2.3 什么是一致性哈希算法，以及在分布式存储系统中的应用场景"></a><font color=DarkOrange>2.3 什么是一致性哈希算法，以及在分布式存储系统中的应用场景</font></h5><p>一致性哈希算法（Consistent Hashing）是一种用于缓存和分布式系统中数据分布的算法，它通过将数据映射到一个哈希环上来实现数据的分布</p>
<p>具体来说，一致性哈希算法将一个哈希环分成一些小的区间，每个区间对应一个节点。当需要存储一个数据时，首先对数据进行哈希操作，然后将哈希结果映射到哈希环上，最终将数据存储在距离它最近的节点上</p>
<p>在一致性哈希算法中，如果有一个节点故障或者新加入了一个节点，那么只会对它附近的节点造成影响，其他节点的数据分布不会改变。这种特性使得一致性哈希算法在动态增减节点的分布式存储系统中具有很好的可扩展性和负载均衡性</p>
<p>在分布式存储系统中，一致性哈希算法通常被用于数据分片和数据节点的选择。通过一致性哈希算法，可以将数据均匀地分布到不同的存储节点上，并且在节点故障或新增节点时，能够保持数据的分布不变，从而实现高可用性和负载均衡</p>
<p>一致性哈希算法还可以用于缓存系统中，通过将缓存数据分布到不同的缓存节点上，提高缓存系统的性能和可用性。在一些互联网应用中，如分布式文件系统、分布式数据库、CDN（内容分发网络）等，一致性哈希算法也得到了广泛的应用</p>
<h5 id="2-4-介绍下分布式文件系统的设计和实现"><a href="#2-4-介绍下分布式文件系统的设计和实现" class="headerlink" title="2.4 介绍下分布式文件系统的设计和实现"></a><font color=DarkOrange>2.4 介绍下分布式文件系统的设计和实现</font></h5><p>分布式文件系统是一种支持文件共享和管理的分布式系统，它将文件数据分布在多个节点上，可以提高系统的性能和可用性。一个典型的分布式文件系统由以下组件构成：</p>
<ol>
<li>元数据服务器：负责存储文件系统的元数据，包括文件名、文件属性、文件所在节点等信息。元数据服务器通常是单点故障，为了提高可用性，可以采用多主备份或者分布式元数据存储等策略</li>
<li>存储节点：负责存储文件的实际数据。存储节点通常由多个节点组成，可以实现数据的冗余备份和负载均衡</li>
<li>客户端：负责向分布式文件系统发送请求，包括文件的读取、写入、删除等操作。客户端通常需要具备缓存、负载均衡、故障恢复等功能</li>
</ol>
<p>在分布式文件系统的设计和实现中，需要考虑以下几个方面：</p>
<ol>
<li>数据分布策略：文件数据如何在不同的节点之间分配是非常重要的。通常采用哈希函数对文件进行分片，然后将每个文件分片存储在不同的节点上。这样可以保证数据的负载均衡和高可用性</li>
<li>数据副本备份：为了保证数据的高可靠性，在设计分布式文件系统时通常需要采用数据副本备份的策略。当某个节点发生故障时，系统可以从其他节点中获取数据副本来保证数据的可用性</li>
<li>网络传输的优化：在分布式文件系统中，数据的传输是非常重要的。需要优化网络传输协议，减少数据传输的延迟和带宽占用</li>
<li>集群管理和监控：在设计分布式文件系统时，需要考虑如何进行集群管理和监控。需要实现集群节点的自动发现和管理，以及对集群状态和性能的监控和调优</li>
<li>安全性：在设计分布式文件系统时，需要考虑数据的安全性问题。需要采用加密技术对数据进行保护，以防止数据泄露或被篡改</li>
</ol>
<p><strong>总结：</strong>分布式文件系统的设计和实现需要综合考虑数据分布策略、数据副本备份、网络传输的优化、集群管理和监控以及安全性等方面的因素。同时，需要不断进行性能测试和优化，以保证系统的高性能和可靠性</p>
<h5 id="2-5-什么是数据冗余，以及在存储系统中的应用场景"><a href="#2-5-什么是数据冗余，以及在存储系统中的应用场景" class="headerlink" title="2.5 什么是数据冗余，以及在存储系统中的应用场景"></a><font color=DarkOrange>2.5 什么是数据冗余，以及在存储系统中的应用场景</font></h5><p>数据冗余指的是存储系统中同一份数据被存储多次的情况。冗余数据的存在可以提高存储系统的可靠性、容错性和性能。在存储系统中，通常会采用以下几种数据冗余的方式：</p>
<ol>
<li>数据备份：将数据备份到另外一台或多台设备上，以防止数据丢失或损坏。备份数据通常是完整的数据拷贝，可以在主数据损坏或丢失时快速恢复数据</li>
<li>RAID技术：RAID技术是一种将多个硬盘组合起来提供更高性能和可靠性的技术。RAID技术的主要思想是将数据划分成多个块，分别存储在多个硬盘上，同时提供数据校验和容错机制</li>
<li>冗余数据存储：将数据冗余存储在多个设备上，以提高数据的可靠性和容错性。冗余数据存储通常采用多个备份节点、多个存储节点等方式</li>
</ol>
<p>数据冗余在存储系统中的应用场景主要有以下几种：</p>
<ol>
<li>数据备份：在企业数据中心、云存储、备份恢复等场景中，通常需要对重要数据进行备份，以防止数据丢失或损坏</li>
<li>数据可靠性：在存储关键业务数据时，需要保证数据的可靠性和安全性。采用数据冗余技术可以提高存储系统的容错能力和可靠性</li>
<li>数据可用性：在高可用性应用中，需要保证数据的快速访问和传输。采用数据冗余技术可以提高存储系统的性能和可用性，减少数据访问的延迟</li>
</ol>
<p><strong>总结：</strong>数据冗余是存储系统中的一种重要技术，它可以提高系统的可靠性、容错性和性能，保证存储数据的安全性和可用性</p>
<h4 id="3-监控相关"><a href="#3-监控相关" class="headerlink" title="3. 监控相关"></a><font color=DarkOrange>3. 监控相关</font></h4><h5 id="3-1-介绍下系统监控的基本原理和常见的监控手段"><a href="#3-1-介绍下系统监控的基本原理和常见的监控手段" class="headerlink" title="3.1 介绍下系统监控的基本原理和常见的监控手段"></a><font color=DarkOrange>3.1 介绍下系统监控的基本原理和常见的监控手段</font></h5><p>系统监控是一种通过收集和分析系统运行数据来评估系统健康状况、性能和安全性的过程。系统监控的基本原理是收集系统各个方面的性能数据，包括 CPU 使用率、内存使用率、磁盘 I&#x2F;O、网络流量等，通过分析这些数据来评估系统的状态，并识别潜在问题和性能瓶颈，进而采取必要的措施来优化系统性能、提高可用性和安全性</p>
<p>常见的系统监控手段包括：</p>
<ol>
<li>监控软件：常用的监控软件包括 Nagios、Zabbix、Cacti、Ganglia等，这些软件可以监控系统各个方面的性能数据，并提供相应的报告和警报</li>
<li>日志分析：系统日志记录了系统的操作和事件，通过对日志进行分析可以发现潜在的问题和异常情况</li>
<li>性能测试：性能测试可以模拟实际工作负载，评估系统的性能和响应时间</li>
<li>负载测试：负载测试可以模拟实际的用户访问负载，测试系统的并发性能和稳定性</li>
<li>安全审计：安全审计可以跟踪系统中的安全事件，包括入侵尝试、异常访问等，并提供报告和警报</li>
<li>实时监控：实时监控可以通过实时采集和分析系统性能数据来监测系统的状态和性能，及时发现和解决潜在问题和性能瓶颈</li>
</ol>
<p><strong>总结：</strong>系统监控是一种重要的管理和优化系统性能、提高系统可用性和安全性的手段。通过采用合适的监控手段，可以及时发现并解决系统问题，提高系统的可靠性和性能</p>
<h5 id="3-2-什么是指标监控，以及在系统监控中的应用场景"><a href="#3-2-什么是指标监控，以及在系统监控中的应用场景" class="headerlink" title="3.2 什么是指标监控，以及在系统监控中的应用场景"></a><font color=DarkOrange>3.2 什么是指标监控，以及在系统监控中的应用场景</font></h5><p>指标监控是指通过监测和收集各种系统指标，来评估系统的运行状况，从而能够及时发现问题和性能瓶颈。这些指标通常包括 CPU、内存、磁盘、网络、应用程序等方面的性能数据，如 CPU 使用率、内存使用率、磁盘 I&#x2F;O、网络流量、请求响应时间等等</p>
<p>指标监控在系统监控中有着广泛的应用场景，以下是一些典型的应用场景：</p>
<ol>
<li>实时监控系统健康状况：通过监控关键指标，能够实时监控系统的健康状况，及时发现问题，并快速进行诊断和处理，从而保障系统的稳定运行</li>
<li>诊断系统性能问题：指标监控可以帮助发现性能瓶颈，比如系统响应时间变慢，磁盘 I&#x2F;O 繁忙等等，从而能够帮助开发人员和运维人员快速定位问题，加速问题解决过程</li>
<li>帮助进行容量规划：通过收集系统资源使用情况，比如 CPU、内存、磁盘等，可以帮助系统管理员预测系统容量使用情况，从而提前规划系统的升级和扩容</li>
<li>支持系统自动化运维：指标监控是自动化运维的重要组成部分，通过监控和自动化脚本可以快速处理大量的运维工作，提高运维效率</li>
<li>提高系统安全性：指标监控可以帮助发现系统的异常行为和安全事件，比如大量的登录失败、网络攻击、异常访问等等，从而能够提高系统的安全性</li>
</ol>
<p><strong>总结：</strong>指标监控是系统监控中不可或缺的一环，通过指标监控可以实时监测系统的运行情况，及时发现问题，提高系统的可用性、性能和安全性</p>
<h5 id="3-3-如何实现对分布式系统的监控和故障诊断"><a href="#3-3-如何实现对分布式系统的监控和故障诊断" class="headerlink" title="3.3 如何实现对分布式系统的监控和故障诊断"></a><font color=DarkOrange>3.3 如何实现对分布式系统的监控和故障诊断</font></h5><p>要实现对分布式系统的监控和故障诊断，需要以下步骤：</p>
<ol>
<li>设计监控指标：为了对分布式系统进行监控，首先需要确定关键性能指标，例如：吞吐量、响应时间、错误率等。可以根据应用的具体情况来设计监控指标</li>
<li>部署监控系统：在分布式系统中，每个节点都需要部署监控代理，收集监控指标，并将数据发送到中央监控系统。中央监控系统可以是一台服务器或者是一个集群，可以使用开源工具如Prometheus、Grafana等来实现监控系统</li>
<li>数据存储：收集到的监控数据需要进行存储和处理，以便进行故障诊断。可以使用开源数据库如InfluxDB、Elasticsearch等来存储监控数据</li>
<li>数据分析和告警：对收集到的监控数据进行分析，识别异常和故障，同时触发告警机制。可以使用开源工具如Alertmanager等来实现告警机制</li>
<li>故障诊断和排查：当监控系统发出警报时，需要进行故障诊断和排查。可以通过分析监控数据、查看日志、跟踪请求等方式来定位故障所在，并采取相应的措施来解决问题</li>
<li>容灾和备份：在分布式系统中，容灾和备份也非常重要。可以使用备份系统和容灾机制来保证系统的高可用性和数据的安全性</li>
</ol>
<p><strong>总结：</strong>实现对分布式系统的监控和故障诊断需要综合考虑监控指标、监控系统、数据存储、数据分析和告警、故障排查、容灾备份等多个方面</p>
<h5 id="3-4-什么是日志监控，以及在系统监控中的应用场景"><a href="#3-4-什么是日志监控，以及在系统监控中的应用场景" class="headerlink" title="3.4 什么是日志监控，以及在系统监控中的应用场景"></a><font color=DarkOrange>3.4 什么是日志监控，以及在系统监控中的应用场景</font></h5><p>日志监控是指通过对系统产生的日志进行实时监控、分析和诊断，以检测系统运行状态、识别问题并做出相应的响应和调整的过程。在系统监控中，日志监控是非常重要的一环，它可以帮助我们追踪系统的状态，及时发现并解决问题，从而保证系统的稳定性和可靠性</p>
<p>在系统监控中，日志监控通常用于以下场景：</p>
<ol>
<li>故障分析和排查：日志监控可以帮助我们快速定位故障点，分析问题并采取措施解决问题</li>
<li>性能监控和优化：日志监控可以记录系统的性能数据和运行情况，及时发现性能问题，优化系统性能</li>
<li>安全监控和防范：日志监控可以监测系统中的异常行为，识别潜在的安全威胁，并及时采取措施防范安全风险</li>
<li>运营监控和优化：日志监控可以记录用户行为和操作数据，分析用户需求和行为模式，提供数据支持和决策依据，从而优化运营效率和用户体验</li>
</ol>
<p><strong>总结：</strong>日志监控在系统监控中扮演着重要的角色，可以帮助我们实时追踪系统的状态和性能，及时发现和解决问题，保证系统的高可用性和可靠性</p>
<h5 id="3-5-如何设计一个可扩展的监控系统"><a href="#3-5-如何设计一个可扩展的监控系统" class="headerlink" title="3.5 如何设计一个可扩展的监控系统"></a><font color=DarkOrange>3.5 如何设计一个可扩展的监控系统</font></h5><p>设计一个可扩展的监控系统，需要考虑以下几个方面：</p>
<ol>
<li>采集架构的设计：监控系统需要采集大量的监控数据，因此需要设计一个高效的数据采集架构。可以采用分布式采集、采用轮询或主动推送方式采集数据等方式</li>
<li>存储架构的设计：监控系统需要处理大量的监控数据，因此需要设计一个高效的数据存储架构。可以采用分布式存储、采用列存储或时序数据库等方式存储数据</li>
<li>数据处理的设计：监控系统需要对采集到的数据进行处理和分析，以便进行故障诊断和性能优化等操作。可以采用分布式计算框架、MapReduce等方式进行数据处理</li>
<li>告警机制的设计：监控系统需要根据监控数据产生告警，及时通知管理员进行处理。可以采用消息队列等方式实现告警机制，支持多种告警方式如邮件、短信、微信等</li>
<li>可视化的设计：监控系统需要提供可视化的监控界面，便于管理员查看监控数据和告警信息。可以采用大屏展示、图表展示等方式进行数据可视化</li>
<li>可扩展性的设计：监控系统需要具备可扩展性，以便应对未来的业务扩展和监控需求的变化。可以采用微服务架构、容器化等方式，支持快速部署和扩展</li>
</ol>
<p><strong>总结：</strong>设计一个可扩展的监控系统需要从采集架构、存储架构、数据处理、告警机制、可视化、可扩展性等多个方面进行考虑，以满足不同场景下的监控需求。同时，需要根据实际情况进行适当的优化和调整，以达到最佳的监控效果</p>
<h4 id="4-日志相关"><a href="#4-日志相关" class="headerlink" title="4. 日志相关"></a><font color=DarkOrange>4. 日志相关</font></h4><h5 id="4-1-常见的日志记录方式，并举例说明它们的优缺点"><a href="#4-1-常见的日志记录方式，并举例说明它们的优缺点" class="headerlink" title="4.1 常见的日志记录方式，并举例说明它们的优缺点"></a><font color=DarkOrange>4.1 常见的日志记录方式，并举例说明它们的优缺点</font></h5><p>常见的日志记录方式有以下几种：</p>
<ol>
<li>基于文本日志：将日志记录为文本文件的形式，使用简单，可以直接通过文本编辑器进行查看和分析。例如，Apache服务器的访问日志就是使用文本日志进行记录的。文本日志的缺点是可读性较差，不易于进行高效的数据处理和分析</li>
<li>基于二进制日志：将日志记录为二进制格式，可以提高日志的可读性和可处理性。例如，MySQL数据库的二进制日志就是使用二进制格式进行记录的。二进制日志的缺点是不易于进行人工查看和分析，需要使用专门的工具进行解析和处理</li>
<li>基于数据库日志：将日志记录到数据库中，可以方便进行数据分析和查询。例如，Java应用程序常常使用Log4j或Logback等日志框架将日志记录到数据库中。数据库日志的缺点是对数据库的性能有一定的影响，并且需要对数据库进行备份和管理</li>
<li>基于消息队列日志：将日志记录到消息队列中，可以实现日志的异步处理和分发。例如，Kafka等消息队列可以用于日志的收集、存储和分发。消息队列日志的缺点是需要对消息队列进行管理和维护，并且可能会增加系统的复杂度</li>
</ol>
<p><strong>总结：</strong>不同的日志记录方式都有各自的优缺点，需要根据实际情况进行选择和使用。通常情况下，基于文本日志的方式简单易用，基于数据库日志的方式方便进行数据分析，基于消息队列日志的方式可以实现异步处理和分发</p>
<h5 id="4-2-如何设计一个高性能、高可靠性的日志系统"><a href="#4-2-如何设计一个高性能、高可靠性的日志系统" class="headerlink" title="4.2 如何设计一个高性能、高可靠性的日志系统"></a><font color=DarkOrange>4.2 如何设计一个高性能、高可靠性的日志系统</font></h5><p>要设计一个高性能、高可靠性的日志系统，需要从以下几个方面进行考虑：</p>
<ol>
<li>日志采集：日志采集是日志系统的第一步，需要设计一个高效、可靠的数据采集架构，支持多种数据源的接入。可以采用分布式采集，通过轮询或者主动推送方式来采集日志数据，避免过度依赖日志收集代理，提高系统的可靠性和扩展性</li>
<li>日志存储：日志存储是日志系统的核心，需要设计一个高性能、高可靠性的存储架构，支持快速的数据查询和访问。可以采用分布式存储，支持数据的水平扩展，避免数据单点故障，提高系统的可靠性和扩展性。同时可以考虑使用高性能的时序数据库或者列存储数据库，来支持快速的数据查询和分析</li>
<li>数据处理：日志数据量巨大，需要设计一个高效的数据处理架构，支持快速的数据查询和分析。可以采用分布式计算框架，如Hadoop、Spark等，来进行大数据处理，避免数据的串行处理，提高数据处理的效率和性能</li>
<li>数据可视化：为了便于用户查看和分析日志数据，需要设计一个高可用、高可靠性的数据可视化架构。可以使用大屏展示、图表展示等方式来进行数据可视化，同时需要支持实时的数据更新和查询，提高用户的交互体验</li>
<li>告警机制：为了及时发现系统的异常情况，需要设计一个高效、可靠的告警机制，支持多种告警方式的接入，如邮件、短信、微信等。同时需要支持可配置的告警规则，便于管理员根据实际情况进行设置和调整</li>
<li>日志的安全性：日志系统中包含着大量的敏感信息，需要考虑数据的安全性和保密性。可以采用加密、身份认证等措施，保证日志数据的安全性和保密性</li>
</ol>
<p><strong>总结：</strong>设计一个高性能、高可靠性的日志系统需要从多个方面进行考虑，包括日志采集、日志存储、数据处理、数据可视化、告警机制和日志的安全性等。需要根据实际情况进行选择和使用，并进行合理的配置和优化，以达到最佳的性能和可靠性</p>
<h5 id="4-3-什么是日志聚合，以及在日志系统中的应用场景"><a href="#4-3-什么是日志聚合，以及在日志系统中的应用场景" class="headerlink" title="4.3 什么是日志聚合，以及在日志系统中的应用场景"></a><font color=DarkOrange>4.3 什么是日志聚合，以及在日志系统中的应用场景</font></h5><p>日志聚合是指将多个来源的日志数据集中到一个统一的地方进行存储和分析的过程。在日志系统中，日志聚合是非常重要的一环，它可以帮助用户更加方便地对系统运行状态进行监控和分析</p>
<p>在实际应用中，日志聚合的应用场景非常广泛，以下是一些常见的应用场景：</p>
<ol>
<li>系统监控：通过对多个系统的日志数据进行聚合，可以获得全局的系统状态，帮助管理员及时发现异常情况，并采取相应的措施来保证系统的稳定性</li>
<li>故障排查：当系统出现故障时，可以通过对多个系统的日志数据进行聚合分析，快速定位问题，减少排查时间，提高系统的可用性</li>
<li>安全监控：通过对多个系统的日志数据进行聚合，可以快速发现系统中的安全漏洞和攻击，及时采取措施来防范安全风险</li>
<li>性能优化：通过对多个系统的日志数据进行聚合分析，可以发现系统中存在的性能瓶颈，并采取相应的措施来优化系统性能</li>
<li>统计分析：通过对多个系统的日志数据进行聚合分析，可以获得全局的统计信息，帮助用户了解系统的使用情况和趋势，以便采取相应的措施来提高系统的效率和性能</li>
</ol>
<p><strong>总结：</strong>日志聚合在日志系统中具有非常重要的应用场景，可以帮助用户更加方便地对系统运行状态进行监控和分析，从而提高系统的可用性、性能和安全性</p>
<h5 id="4-4-如何实现对分布式系统的日志收集和分析"><a href="#4-4-如何实现对分布式系统的日志收集和分析" class="headerlink" title="4.4 如何实现对分布式系统的日志收集和分析"></a><font color=DarkOrange>4.4 如何实现对分布式系统的日志收集和分析</font></h5><p>对于分布式系统的日志收集和分析，通常需要考虑以下几个方面：</p>
<ol>
<li>选择合适的日志收集工具：常见的日志收集工具包括Logstash、Fluentd、Filebeat等，这些工具都具有不同的特点和优缺点，需要根据实际场景进行选择</li>
<li>定义统一的日志格式：为了方便日志的收集和分析，需要定义统一的日志格式，包括日志的字段和数据类型等，以便于后续的处理和分析</li>
<li>配置日志收集器：根据实际情况，配置日志收集器，包括指定日志文件的路径、过滤日志、设置采集频率等，以便于采集需要的日志数据</li>
<li>日志的存储和索引：采集到的日志数据需要进行存储和索引，以便于后续的查询和分析。常见的存储方式包括Elasticsearch、Hadoop等</li>
<li>日志的分析：采集到的日志数据需要进行分析，以便于发现系统中存在的问题，常见的分析工具包括Kibana、Splunk等</li>
</ol>
<p>在实际应用中，需要根据实际场景进行配置和调优，以提高日志收集和分析的效率和准确性。同时，为了保证分布式系统的稳定性和可用性，需要采用高可用和容错的技术，例如使用多个日志收集器进行采集、采用主从复制的方式进行数据备份等</p>
<h5 id="4-5-分布式日志系统的设计和实现"><a href="#4-5-分布式日志系统的设计和实现" class="headerlink" title="4.5 分布式日志系统的设计和实现"></a><font color=DarkOrange>4.5 分布式日志系统的设计和实现</font></h5><p>分布式日志系统的设计和实现可以分为以下几个方面：</p>
<ol>
<li>日志收集：分布式系统中的日志数据通常会分散在多个节点上，需要采用合适的工具进行日志的收集。常见的工具包括Fluentd、Logstash、Filebeat等。可以根据实际情况选择合适的工具进行日志收集，并配置相关参数以便于实现高效的日志收集</li>
<li>数据传输和存储：收集到的日志数据需要进行传输和存储，通常可以采用消息队列的方式进行传输，例如使用Kafka、RabbitMQ等。在存储方面，常见的方案包括使用Elasticsearch、Hadoop等，以便于实现高效的数据存储和检索</li>
<li>数据处理和分析：分布式日志系统的设计需要考虑到数据处理和分析的问题，例如数据清洗、格式化、归一化等。可以采用流处理技术进行数据处理和分析，例如使用Spark、Storm等技术，以便于实现高效的数据处理和分析</li>
<li>查询和展示：分布式日志系统需要提供高效的查询和展示功能，例如使用Kibana、Grafana等工具进行数据展示和可视化。同时，需要考虑到分布式系统的复杂性，采用合适的查询技术进行查询，例如使用分布式搜索引擎技术等</li>
<li>容错和可扩展性：为了保证分布式日志系统的稳定性和可扩展性，需要采用容错和可扩展的技术，例如使用集群模式进行部署、采用主从复制的方式进行数据备份等</li>
</ol>
<p><strong>总结：</strong>分布式日志系统的设计和实现需要考虑到多个方面，包括日志收集、数据传输和存储、数据处理和分析、查询和展示、容错和可扩展性等，需要根据实际场景进行选择和调整。同时，需要关注系统的性能和可靠性，以便于提高系统的稳定性和可用性</p>
<hr>
<hr>
<h4 id="5-Git相关"><a href="#5-Git相关" class="headerlink" title="5. Git相关"></a><font color=DarkOrange>5. Git相关</font></h4><h5 id="5-1-什么是Git？Git常用命令"><a href="#5-1-什么是Git？Git常用命令" class="headerlink" title="5.1 什么是Git？Git常用命令"></a><font color=DarkOrange>5.1 什么是Git？Git常用命令</font></h5><p>Git是一种分布式版本控制系统，它能够追踪文件的更改历史并帮助团队进行协作开发。Git可以记录每个版本的变化，帮助开发者在项目开发过程中进行更好的版本管理，方便代码的分享、合并和撤销。Git还提供了分支、合并等功能，可以让多个开发者同时进行不同的代码开发，最终合并成一个完整的代码库</p>
<p>熟练使用Git是非常重要的技能，可以提高代码开发效率、协作效率和代码质量。在日常开发工作中，我们可以使用Git来跟踪文件变化、查看历史记录、创建和合并分支等等。同时，我们还可以使用Git与其他开发者协作，共同开发和维护代码库</p>
<p><strong>常用命令：</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>git init</code></td>
<td>在当前目录中创建一个新的Git仓库</td>
</tr>
<tr>
<td><code>git clone &lt;url&gt;</code></td>
<td>克隆一个远程Git仓库到本地</td>
</tr>
<tr>
<td><code>git add &lt;file&gt;</code></td>
<td>将文件添加到Git仓库的暂存区中</td>
</tr>
<tr>
<td><code>git commit -m &quot;&lt;message&gt;&quot;</code></td>
<td>提交暂存区中的文件到Git仓库，并添加提交信息</td>
</tr>
<tr>
<td><code>git status</code></td>
<td>显示当前Git仓库的状态，包括已修改、已暂存和未跟踪的文件</td>
</tr>
<tr>
<td><code>git log</code></td>
<td>查看Git仓库的提交历史记录</td>
</tr>
<tr>
<td><code>git branch</code></td>
<td>查看本地分支列表，以及当前所在分支</td>
</tr>
<tr>
<td><code>git checkout &lt;branch&gt;</code></td>
<td>切换到指定的分支</td>
</tr>
<tr>
<td><code>git merge &lt;branch&gt;</code></td>
<td>将指定分支的更改合并到当前分支</td>
</tr>
<tr>
<td><code>git pull</code></td>
<td>从远程Git仓库拉取最新的更改到本地</td>
</tr>
<tr>
<td><code>git push</code></td>
<td>将本地的更改推送到远程Git仓库</td>
</tr>
<tr>
<td><code>git diff</code></td>
<td>显示未暂存文件与上次提交之间的差异</td>
</tr>
<tr>
<td><code>git reset &lt;file&gt;</code></td>
<td>将指定文件从暂存区中移除，但不会删除文件</td>
</tr>
<tr>
<td><code>git rm &lt;file&gt;</code></td>
<td>从Git仓库中删除指定的文件</td>
</tr>
<tr>
<td><code>git remote -v</code></td>
<td>显示Git仓库的远程地址列表</td>
</tr>
<tr>
<td><code>git config</code></td>
<td>配置Git仓库的全局或局部参数，如用户名、邮箱等</td>
</tr>
</tbody></table>
<h5 id="5-2-Git中的分支有哪些类型？请描述它们的特点"><a href="#5-2-Git中的分支有哪些类型？请描述它们的特点" class="headerlink" title="5.2 Git中的分支有哪些类型？请描述它们的特点"></a><font color=DarkOrange>5.2 Git中的分支有哪些类型？请描述它们的特点</font></h5><ol>
<li>主分支（master branch）：主分支是Git中默认的分支，通常用于发布稳定版本或者生产环境。所有的提交都会基于主分支进行合并，保证代码的稳定性和可靠性</li>
<li>开发分支（develop branch）：开发分支是主分支的一个副本，通常用于开发新功能或者进行大型的重构。在开发过程中，开发者可以在开发分支上进行自由的提交和修改，最终再将开发分支合并回主分支</li>
<li>功能分支（feature branch）：功能分支通常用于实现某个具体的功能，比如添加一个新的页面或者修改某个模块的逻辑。功能分支是从开发分支上切出来的，开发者可以在功能分支上自由地进行开发和提交，等到功能开发完成之后再将功能分支合并回开发分支</li>
<li>发布分支（release branch）：发布分支通常用于准备发布新版本，包括进行测试、修改bug、更新文档等工作。发布分支是从开发分支上切出来的，一旦发布完成之后，发布分支就会被合并回主分支和开发分支</li>
<li>补丁分支（hotfix branch）：补丁分支通常用于修复已经发布的版本中的紧急bug，它是从主分支上切出来的。一旦修复完成之后，补丁分支会被合并回主分支和开发分支</li>
</ol>
<h5 id="5-3-如果想要合并两个分支，应该如何操作？请简要描述一下"><a href="#5-3-如果想要合并两个分支，应该如何操作？请简要描述一下" class="headerlink" title="5.3 如果想要合并两个分支，应该如何操作？请简要描述一下"></a><font color=DarkOrange>5.3 如果想要合并两个分支，应该如何操作？请简要描述一下</font></h5><p>合并两个分支可以使用<code>git merge</code>命令。具体操作步骤如下：</p>
<ol>
<li>首先，切换到需要被合并的目标分支上。比如，如果你要将特性分支合并到主分支上，那么你需要先切换到主分支上，使用命令<code>git checkout main</code></li>
<li>然后，使用<code>git merge</code>命令将需要合并的分支合并到当前分支上。比如，如果你要将特性分支<code>feature-branch</code>合并到主分支上，那么你需要使用命令<code>git merge feature-branch</code></li>
<li>如果存在冲突，Git会提示你需要手动解决冲突。你可以使用命令<code>git status</code>来查看哪些文件存在冲突，然后手动编辑这些文件，解决冲突</li>
<li>最后，提交合并的结果。如果没有冲突，Git会自动创建一个新的提交，包含两个分支的修改。如果存在冲突，你需要手动编辑冲突的文件并使用<code>git add</code>命令将修改添加到暂存区，最后使用<code>git commit</code>命令提交合并结果</li>
</ol>
<p>合并分支是Git中非常重要的操作，在合并分支的过程中，需要注意避免冲突，保证代码的稳定性和可靠性</p>
<h5 id="5-4-如果想要撤销已经提交的Git提交记录，应该如何操作？请简要描述一下"><a href="#5-4-如果想要撤销已经提交的Git提交记录，应该如何操作？请简要描述一下" class="headerlink" title="5.4 如果想要撤销已经提交的Git提交记录，应该如何操作？请简要描述一下"></a><font color=DarkOrange>5.4 如果想要撤销已经提交的Git提交记录，应该如何操作？请简要描述一下</font></h5><p>在Git中，如果想要撤销已经提交的提交记录，可以使用<code>git revert</code>或者<code>git reset</code>命令。具体操作步骤如下：</p>
<ol>
<li>使用<code>git log</code>命令查看提交记录，找到需要撤销的提交记录的commit ID</li>
<li>如果想要保留提交记录并创建一个新的提交来撤销该提交记录，可以使用<code>git revert</code>命令。比如，如果要撤销commit ID为<code>abc123</code>的提交记录，可以使用命令<code>git revert abc123</code>，Git会自动创建一个新的提交记录来撤销该提交记录</li>
<li>如果想要完全删除该提交记录以及其之后的提交记录，可以使用<code>git reset</code>命令。比如，如果要删除commit ID为<code>abc123</code>及其之后的提交记录，可以使用命令<code>git reset abc123</code>，Git会将HEAD指针和当前分支指针都指向该提交记录，从而删除该提交记录及其之后的提交记录。注意，使用<code>git reset</code>命令删除提交记录是一种非常危险的操作，应该谨慎使用</li>
</ol>
<p>无论是使用<code>git revert</code>还是<code>git reset</code>命令，都需要注意该操作会改变Git仓库中的历史记录，可能会对其他开发者产生影响，因此需要谨慎操作。建议在进行该操作前先备份代码，并且在团队协作开发中与其他开发者进行充分的沟通和协商</p>
<h5 id="5-5-Git中的三个工作区是哪些？它们之间的区别是什么"><a href="#5-5-Git中的三个工作区是哪些？它们之间的区别是什么" class="headerlink" title="5.5 Git中的三个工作区是哪些？它们之间的区别是什么"></a><font color=DarkOrange>5.5 Git中的三个工作区是哪些？它们之间的区别是什么</font></h5><ol>
<li>工作区（working directory）：也称为工作目录，是指Git仓库中存储项目文件的目录，它包含了所有源代码文件、文档、图像等文件。在工作区中进行的所有修改都会被记录在Git中，但还没有被提交</li>
<li>暂存区（staging area）：也称为索引（index），是介于工作区和版本库之间的一个区域。它是一个临时的区域，用来存储已经被修改的文件，这些修改还没有被提交到版本库中</li>
<li>版本库（repository）：也称为Git目录，是Git仓库中存储版本历史记录的地方。它包含了所有的提交记录、分支、标签等信息，是Git中最重要的部分。版本库通常包括了一个HEAD指针，指向当前所在的分支和一个对象库，存储了所有的历史版本快照</li>
</ol>
<p>这三个工作区之间的主要区别在于它们所存储的内容和作用：</p>
<ul>
<li>工作区：存储了未被跟踪的文件和修改的文件，是用户在本地编辑代码的地方</li>
<li>暂存区：存储了已被修改的文件，这些修改已经被暂时保存起来，准备提交到版本库中</li>
<li>版本库：存储了所有的历史版本记录，包括了所有的提交记录、分支、标签等信息，是Git中最重要的部分</li>
</ul>
<h4 id="6-gRPC相关"><a href="#6-gRPC相关" class="headerlink" title="6. gRPC相关"></a><font color=DarkOrange>6. gRPC相关</font></h4><h5 id="6-1-gRPC是什么？它的工作原理是什么"><a href="#6-1-gRPC是什么？它的工作原理是什么" class="headerlink" title="6.1 gRPC是什么？它的工作原理是什么"></a><font color=DarkOrange>6.1 gRPC是什么？它的工作原理是什么</font></h5><p>gRPC是一种高性能、跨语言的远程过程调用（RPC）框架，由Google开发。它基于协议缓冲区（Protocol Buffers）和HTTP&#x2F;2协议构建，并支持多种语言（如C++, Java, Python, Go等）。gRPC的设计目标是使得客户端可以像本地方法调用一样方便地调用远程服务，同时提供高效的网络传输和序列化机制</p>
<p>gRPC的工作原理如下：</p>
<ol>
<li>定义服务：首先需要定义要提供的服务和接口，这是使用协议缓冲区定义的。这个定义文件包含服务名称、方法名称和参数以及返回值等信息</li>
<li>生成代码：接下来需要根据定义文件生成客户端和服务端的代码。通过使用gRPC提供的工具，可以生成不同语言的代码，以便在客户端和服务端中使用</li>
<li>实现服务端：服务端实现具体的业务逻辑。在实现过程中需要继承自动生成的代码中提供的服务接口，并重写接口中的方法</li>
<li>实现客户端：客户端使用生成的代码中提供的客户端Stub对象，调用远程服务。通过客户端Stub对象调用远程服务时，gRPC将负责将数据序列化并通过HTTP&#x2F;2协议传输给服务端</li>
<li>序列化和传输数据：gRPC使用协议缓冲区将数据序列化为二进制格式，并使用HTTP&#x2F;2协议传输。HTTP&#x2F;2协议支持流、多路复用和头部压缩等特性，可以有效提高网络传输效率</li>
<li>处理数据：服务端接收到请求后，将数据反序列化，处理请求并返回响应。服务端通过gRPC提供的Context对象可以访问请求的元数据，如请求的来源地址、身份验证信息等</li>
<li>返回响应：服务端将处理结果序列化，并使用HTTP&#x2F;2协议返回给客户端。客户端接收到响应后，将数据反序列化，并返回给应用程序</li>
</ol>
<h5 id="6-2-gRPC支持哪些序列化协议？请简要描述它们的特点"><a href="#6-2-gRPC支持哪些序列化协议？请简要描述它们的特点" class="headerlink" title="6.2 gRPC支持哪些序列化协议？请简要描述它们的特点"></a><font color=DarkOrange>6.2 gRPC支持哪些序列化协议？请简要描述它们的特点</font></h5><p>gRPC支持使用Google开发的协议缓冲区（Protocol Buffers）进行数据序列化和反序列化。Protocol Buffers是一种高效的二进制序列化协议，具有以下特点：</p>
<ol>
<li>紧凑性：Protocol Buffers序列化后的数据非常紧凑，相比XML和JSON等文本协议，可以节省大量的网络带宽和存储空间</li>
<li>可扩展性：Protocol Buffers支持定义可扩展的消息类型，可以很方便地添加、删除和修改消息的字段，而不会影响现有的消息格式</li>
<li>语言无关性：Protocol Buffers支持多种编程语言，包括C++, Java, Python, Go等，可以方便地实现跨语言的数据交换</li>
</ol>
<p>除了使用Protocol Buffers，gRPC还支持使用JSON进行数据序列化和反序列化。JSON是一种轻量级的文本协议，具有以下特点：</p>
<ol>
<li>可读性：JSON序列化后的数据具有可读性，易于调试和理解</li>
<li>易于使用：JSON在很多编程语言中都有内置的支持，可以很方便地进行编码和解码</li>
<li>可扩展性：JSON支持嵌套结构，可以很方便地实现复杂的数据模型</li>
</ol>
<p><strong>注意：</strong>相比于使用Protocol Buffers，使用JSON进行数据序列化和反序列化会带来一定的性能损失，同时JSON不支持所有的数据类型，因此在选择序列化协议时需要根据实际情况进行权衡</p>
<h5 id="6-3-gRPC支持哪些负载均衡策略？请简述它们的优点和缺点"><a href="#6-3-gRPC支持哪些负载均衡策略？请简述它们的优点和缺点" class="headerlink" title="6.3 gRPC支持哪些负载均衡策略？请简述它们的优点和缺点"></a><font color=DarkOrange>6.3 gRPC支持哪些负载均衡策略？请简述它们的优点和缺点</font></h5><p>gRPC支持多种负载均衡策略，如轮询（Round Robin）、最少连接（Least Connection）、随机（Random）和一致性哈希（Consistent Hashing）等。每种负载均衡策略都有其优点和缺点，具体如下：</p>
<ol>
<li>轮询（Round Robin）：将请求依次分配给每个可用的服务端，循环往复。优点是实现简单，适用于服务数量较少的情况，缺点是当服务的处理能力不均衡时，可能会导致某些服务的负载过高</li>
<li>最少连接（Least Connection）：将请求分配给当前连接数最少的服务端，以实现负载均衡。优点是可以更加均衡地分配请求，缺点是需要实时监测每个服务端的连接数，实现复杂</li>
<li>随机（Random）：随机选择一个可用的服务端处理请求。优点是实现简单，适用于服务数量较少的情况，缺点是负载不够均衡，可能会导致某些服务的负载过高</li>
<li>一致性哈希（Consistent Hashing）：将每个服务端的地址映射到一个哈希环上，并根据请求的哈希值选择一个服务端处理请求。优点是在服务端的动态上下线时，能够保持原有的哈希环不变，避免大量请求被重新路由，缺点是实现相对复杂，需要维护哈希环和哈希函数</li>
</ol>
<h5 id="6-4-请解释gRPC中的流式RPC是什么？它们有什么用途"><a href="#6-4-请解释gRPC中的流式RPC是什么？它们有什么用途" class="headerlink" title="6.4 请解释gRPC中的流式RPC是什么？它们有什么用途"></a><font color=DarkOrange>6.4 请解释gRPC中的流式RPC是什么？它们有什么用途</font></h5><p>gRPC中的流式RPC是一种允许客户端和服务器之间建立持久连接并在这些连接上发送多个消息的RPC方式。这种类型的RPC可以分为两种：客户端流式RPC和服务器流式RPC</p>
<p>在客户端流式RPC中，客户端将多个请求消息发送到服务器，并等待服务器对每个请求进行响应。这种方式适用于客户端需要发送一系列相关数据的情况，例如上传文件或流媒体</p>
<p>在服务器流式RPC中，服务器将多个响应消息发送到客户端，直到处理完请求或客户端中止连接。这种方式适用于服务器需要处理大量数据的情况，例如实时日志记录或向客户端提供流媒体数据</p>
<p>流式RPC的优势在于它们可以通过单个持久连接处理大量数据，从而减少网络开销和资源占用，并提高系统性能。此外，流式RPC还允许实现实时或流式应用程序，例如视频流或实时数据分析</p>
<h5 id="6-5-gRPC提供了哪些安全机制？请简述它们的优点和缺点"><a href="#6-5-gRPC提供了哪些安全机制？请简述它们的优点和缺点" class="headerlink" title="6.5 gRPC提供了哪些安全机制？请简述它们的优点和缺点"></a><font color=DarkOrange>6.5 gRPC提供了哪些安全机制？请简述它们的优点和缺点</font></h5><p>gRPC提供了多种安全机制来保护通信的机密性、完整性和身份验证，其中包括：</p>
<ol>
<li>SSL &#x2F; TLS：通过SSL &#x2F; TLS提供端到端的加密和身份验证，防止中间人攻击和数据篡改</li>
<li>Token-based authentication：基于Token的身份验证机制，允许客户端和服务器之间交换认证和授权信息，以确保只有经过身份验证的用户才能访问受保护的资源</li>
<li>Access control lists（ACLs）：通过ACLs提供基于角色的授权机制，使得只有拥有特定权限的用户才能访问受保护的资源</li>
</ol>
<p>这些安全机制都有其优点和缺点：</p>
<ol>
<li>SSL &#x2F; TLS的优点在于它提供了端到端的加密和身份验证，同时具有广泛的浏览器和操作系统支持，但其缺点在于它可能会增加通信延迟，并且需要额外的计算资源</li>
<li>Token-based身份验证的优点在于它是无状态的，不需要维护会话，同时具有可扩展性和灵活性，但其缺点在于Token可以被截获和重播，从而导致安全漏洞</li>
<li>ACLs的优点在于它提供了基于角色的授权机制，使得只有特定的用户和组可以访问受保护的资源，同时具有灵活性和可扩展性，但其缺点在于管理ACLs可能会变得复杂和繁琐，尤其是在大型系统中</li>
</ol>
<hr>
<hr>
<h4 id="7-分布式系统"><a href="#7-分布式系统" class="headerlink" title="7. 分布式系统"></a><font color=DarkOrange>7. 分布式系统</font></h4><h5 id="7-1-什么是分布式系统？它有哪些优缺点"><a href="#7-1-什么是分布式系统？它有哪些优缺点" class="headerlink" title="7.1 什么是分布式系统？它有哪些优缺点"></a><font color=DarkOrange>7.1 什么是分布式系统？它有哪些优缺点</font></h5><p>分布式系统是由多个相互协作的计算机组成的系统，这些计算机通过网络进行通信和协作，共同完成一些任务。分布式系统通常具有以下特点：</p>
<ol>
<li>分布式系统由多个计算机组成，这些计算机通过网络连接</li>
<li>分布式系统通常是松耦合的，即不同计算机之间的任务可以相互独立地进行</li>
<li>分布式系统通常具有高可用性和容错性，即系统中的某个节点出现故障时，系统仍然可以正常运行</li>
</ol>
<p>分布式系统的优点包括：</p>
<ol>
<li>可扩展性：分布式系统可以通过增加计算机节点来扩展系统的处理能力</li>
<li>高可用性和容错性：分布式系统中的某个节点出现故障时，系统仍然可以正常运行</li>
<li>高性能：分布式系统可以将任务分解为多个子任务并行处理，从而提高系统的处理效率</li>
<li>灵活性：分布式系统可以根据需要选择不同的部署方案，如私有云、公有云、混合云等</li>
</ol>
<p>分布式系统的缺点包括：</p>
<ol>
<li>复杂性：分布式系统通常比单机系统更为复杂，需要考虑网络通信、数据一致性、容错性等问题</li>
<li>调试和测试难度：由于分布式系统中的不同节点相互独立，因此调试和测试变得更加困难</li>
<li>安全性：由于分布式系统的复杂性和多样性，因此安全性也变得更加复杂</li>
<li>高成本：分布式系统的部署、维护和管理通常比单机系统更加复杂和昂贵</li>
</ol>
<h5 id="7-2-解释一下CAP定理和BASE理论，并说明它们在分布式系统中的应用"><a href="#7-2-解释一下CAP定理和BASE理论，并说明它们在分布式系统中的应用" class="headerlink" title="7.2 解释一下CAP定理和BASE理论，并说明它们在分布式系统中的应用"></a><font color=DarkOrange>7.2 解释一下CAP定理和BASE理论，并说明它们在分布式系统中的应用</font></h5><p>CAP定理和BASE理论是分布式系统中常用的两个理论，它们都是为了解决分布式系统的可用性和一致性问题而提出的</p>
<p>CAP定理指的是在一个分布式系统中，无法同时满足以下三个特性：一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）。其中，分区容错性指的是系统中任意两个节点之间可能发生的网络分区问题。因此，在分布式系统中，需要在一致性和可用性之间做出取舍。例如，在分布式数据库系统中，有些系统可能会选择放弃一致性来保证系统的可用性</p>
<p>BASE理论是指基本可用（Basically Available）、软状态（Soft state）和最终一致性（Eventually consistent）。它强调了在分布式系统中，不需要强制要求所有节点在任何时候都达到一致状态，而是可以在满足基本可用性的前提下，通过软状态和最终一致性来保证系统的稳定性和可靠性。例如，NoSQL数据库就是基于BASE理论设计的</p>
<p>在实际的分布式系统中，CAP定理和BASE理论都具有重要的应用意义。在设计分布式系统时，需要根据实际情况进行取舍，权衡一致性和可用性的关系，同时需要根据实际需求来选择合适的数据一致性模型和分布式算法。同时，在分布式系统的实际应用中，需要结合CAP定理和BASE理论，选择合适的分布式存储和处理技术，从而保证系统的稳定性和可靠性</p>
<h5 id="7-3-什么是负载均衡？它的实现方法有哪些"><a href="#7-3-什么是负载均衡？它的实现方法有哪些" class="headerlink" title="7.3 什么是负载均衡？它的实现方法有哪些"></a><font color=DarkOrange>7.3 什么是负载均衡？它的实现方法有哪些</font></h5><p>负载均衡是一种将工作负载（workload）分配到多个计算资源上的技术，目的是提高系统的性能和可靠性。负载均衡通常被应用在服务器集群、网络负载均衡、数据库负载均衡等领域</p>
<p>负载均衡的实现方法包括：</p>
<ol>
<li>硬件负载均衡：使用专门的负载均衡硬件设备，例如F5、Cisco等，这些设备通过智能算法将请求分配到不同的服务器上，从而实现负载均衡</li>
<li>软件负载均衡：通过在普通服务器上安装负载均衡软件，例如Nginx、HAProxy等，这些软件通过负载均衡算法将请求分配到不同的服务器上</li>
<li>DNS负载均衡：通过DNS服务器来实现负载均衡，将域名解析请求分配到不同的服务器IP地址上</li>
<li>IP负载均衡：使用负载均衡设备将客户端请求发送到不同的服务器IP地址上，实现负载均衡</li>
</ol>
<p>在负载均衡的实现中，常用的负载均衡算法包括：</p>
<ol>
<li>轮询（Round Robin）算法：按照顺序将请求分配给不同的服务器</li>
<li>最少连接（Least Connections）算法：将请求发送到连接数最少的服务器上</li>
<li>IP哈希（IP Hash）算法：将请求根据客户端IP地址进行哈希计算，然后将请求发送到对应的服务器上</li>
<li>加权轮询（Weighted Round Robin）算法：按照服务器权重的比例将请求分配给不同的服务器</li>
</ol>
<p><strong>注意：</strong>不同的负载均衡算法适用于不同的应用场景，需要根据实际情况选择合适的算法。同时，在实际应用中，还需要注意负载均衡的可用性、容错性、扩展性等方面的问题，从而保证负载均衡系统的稳定性和可靠性</p>
<h5 id="7-4-分布式系统中的一致性问题，包括强一致性、弱一致性、最终一致性等"><a href="#7-4-分布式系统中的一致性问题，包括强一致性、弱一致性、最终一致性等" class="headerlink" title="7.4 分布式系统中的一致性问题，包括强一致性、弱一致性、最终一致性等"></a><font color=DarkOrange>7.4 分布式系统中的一致性问题，包括强一致性、弱一致性、最终一致性等</font></h5><p>在分布式系统中，一致性是一个重要的问题，它涉及到多个节点之间数据的同步和一致性。在分布式系统中，为了保证数据的正确性和一致性，通常采用以下三种一致性模型：</p>
<ol>
<li>强一致性（Strong Consistency）：强一致性要求在任何时候，对于任何一个数据操作，都能够保证所有节点的数据是一致的。强一致性保证了数据的强一致性和可线性化。但是，强一致性的代价是较高的延迟和低的可用性</li>
<li>弱一致性（Weak Consistency）：弱一致性是指系统允许一定时间内数据不一致的状态，但是最终数据会收敛到一致状态。弱一致性的代价是较低的延迟和较高的可用性。常见的弱一致性模型包括事件ual consistency和session consistency</li>
<li>最终一致性（Eventual Consistency）：最终一致性是指数据在一段时间内可能出现不一致的状态，但是最终会收敛到一致状态。最终一致性的代价是较低的延迟和较高的可用性。常见的最终一致性模型包括read-your-write consistency和monotonic read consistency</li>
</ol>
<p><strong>注意：</strong>在实际应用中，不同的一致性模型适用于不同的应用场景，需要根据实际情况选择合适的一致性模型。同时，为了保证分布式系统的一致性，还需要考虑数据复制、冲突解决、故障恢复等问题，从而保证系统的正确性和可靠性</p>
<h5 id="7-5-如何避免分布式系统中的单点故障问题"><a href="#7-5-如何避免分布式系统中的单点故障问题" class="headerlink" title="7.5 如何避免分布式系统中的单点故障问题"></a><font color=DarkOrange>7.5 如何避免分布式系统中的单点故障问题</font></h5><p>在分布式系统中，单点故障是指一个节点的故障会导致整个系统的故障。为了避免单点故障问题，可以采取以下措施：</p>
<ol>
<li>引入冗余：通过引入多个节点来实现冗余，当某个节点故障时，其他节点可以接管它的工作，从而保证系统的正常运行。常见的冗余技术包括主备复制、多活复制和故障转移</li>
<li>负载均衡：通过在多个节点之间均衡分配负载，可以避免某个节点的负载过高，从而降低节点故障的风险。常见的负载均衡技术包括轮询、最少连接和IP哈希</li>
<li>无单点故障架构设计：在系统设计阶段就考虑到单点故障的问题，并采取相应的措施，如使用分布式数据库、分布式缓存等技术，避免单点故障</li>
<li>容错处理：在系统中引入容错机制，如超时重试、自动恢复等，可以避免节点故障导致系统的故障</li>
</ol>
<p><strong>注意：</strong>以上措施都需要结合实际情况进行综合考虑，同时也需要考虑措施的成本和复杂度，从而选择最合适的方案</p>
<h4 id="8-linux-IO系统"><a href="#8-linux-IO系统" class="headerlink" title="8. linux IO系统"></a><font color=DarkOrange>8. linux IO系统</font></h4><h5 id="8-1-什么是Linux-IO系统？它的架构是怎样的"><a href="#8-1-什么是Linux-IO系统？它的架构是怎样的" class="headerlink" title="8.1 什么是Linux IO系统？它的架构是怎样的"></a><font color=DarkOrange>8.1 什么是Linux IO系统？它的架构是怎样的</font></h5><p>Linux IO系统是指Linux操作系统中负责管理输入输出（IO）的子系统，包括对磁盘、网络、终端等IO设备的读写操作。Linux IO系统的架构包括以下几个层次：</p>
<ol>
<li>应用程序层：应用程序通过标准的系统调用（如open、read、write等）来进行IO操作</li>
<li>VFS层：虚拟文件系统层是Linux内核中的一个抽象层，用于屏蔽不同文件系统的细节，提供统一的文件访问接口</li>
<li>块设备层：块设备层负责管理块设备（如硬盘）的读写操作，通过设备驱动程序与硬件进行交互</li>
<li>文件系统层：文件系统层负责管理文件的读写操作，包括缓存管理、索引管理、文件权限管理等</li>
<li>IO调度层：IO调度层负责管理IO请求的调度，以提高IO的效率。Linux中常用的IO调度算法包括CFQ、NOOP和Deadline等</li>
<li>设备驱动层：设备驱动层负责与硬件设备进行交互，包括设备的初始化、数据传输、中断处理等操作</li>
</ol>
<p>Linux IO系统的架构是分层次的，每一层都提供了不同的功能，并且各层之间通过标准接口进行交互，使得整个系统更加模块化和可扩展</p>
<h5 id="8-2-阻塞式IO和非阻塞式IO，以及它们的区别"><a href="#8-2-阻塞式IO和非阻塞式IO，以及它们的区别" class="headerlink" title="8.2 阻塞式IO和非阻塞式IO，以及它们的区别"></a><font color=DarkOrange>8.2 阻塞式IO和非阻塞式IO，以及它们的区别</font></h5><p>阻塞式IO和非阻塞式IO都是指应用程序在进行IO操作时的一种模式</p>
<p>阻塞式IO是指应用程序在进行IO操作时会一直等待IO操作完成后才返回，期间无法进行其他操作。例如，当应用程序调用read()函数读取文件内容时，如果文件内容还未就绪，read()函数会一直等待，直到文件内容就绪后才返回</p>
<p>非阻塞式IO是指应用程序在进行IO操作时不会一直等待IO操作完成，而是立即返回，由应用程序自行处理其他操作。例如，当应用程序调用read()函数读取文件内容时，如果文件内容还未就绪，read()函数会立即返回一个错误码（如EAGAIN），告诉应用程序当前IO操作无法完成，应用程序可以继续处理其他操作</p>
<p>阻塞式IO的优点是操作简单、效率高，但缺点是容易出现阻塞，导致应用程序的响应变慢。非阻塞式IO虽然避免了阻塞问题，但其操作比较复杂，需要应用程序自行处理多次IO操作才能完成一个完整的IO任务</p>
<p>在实际应用中，可以根据实际情况选择阻塞式IO或非阻塞式IO，或者结合两者的优点，使用IO多路复用技术（如epoll、select等）来实现高效的IO操作</p>
<h5 id="8-3-什么是异步IO？它和同步IO的区别是什么"><a href="#8-3-什么是异步IO？它和同步IO的区别是什么" class="headerlink" title="8.3 什么是异步IO？它和同步IO的区别是什么"></a><font color=DarkOrange>8.3 什么是异步IO？它和同步IO的区别是什么</font></h5><p>异步IO是指应用程序进行IO操作时，不需要等待IO操作完成，而是通过回调函数或事件通知的方式，等IO操作完成后再通知应用程序。在异步IO中，应用程序可以继续执行其他操作，无需等待IO操作完成</p>
<p>同步IO是指应用程序进行IO操作时，必须等待IO操作完成后才能继续执行后续操作。在同步IO中，应用程序进行IO操作时会一直阻塞，直到IO操作完成才能继续执行后续操作</p>
<p>异步IO相比同步IO的优点在于能够提高应用程序的并发能力和吞吐量，避免了因IO阻塞导致的性能瓶颈。异步IO适用于需要处理大量IO操作的应用场景，如高并发的网络服务、数据库等</p>
<p>但是，异步IO的实现比同步IO更加复杂，需要额外的线程或回调函数来处理IO完成后的事件通知，容易引入新的Bug，开发和调试难度较大。同时，异步IO也可能会造成资源的浪费，因为需要预留额外的线程或回调函数来处理IO完成事件，即使IO操作较少，这些线程或回调函数也需要占用一定的资源</p>
<h5 id="8-4-Linux中的文件描述符和文件IO"><a href="#8-4-Linux中的文件描述符和文件IO" class="headerlink" title="8.4 Linux中的文件描述符和文件IO"></a><font color=DarkOrange>8.4 Linux中的文件描述符和文件IO</font></h5><p>在Linux中，文件描述符（file descriptor）是一个非负整数，用于唯一标识一个进程正在使用的文件。在Linux中，每个进程都有一个文件描述符表，其中包含了当前进程所打开的所有文件的文件描述符。文件描述符通常用于执行文件IO操作，如读取文件内容、写入文件内容等</p>
<p>文件IO指的是对文件进行读写操作的过程。在Linux中，文件IO操作通常通过系统调用实现。常见的文件IO系统调用包括read、write、open、close等。这些系统调用都需要一个文件描述符作为参数，用于标识需要读写的文件</p>
<p>文件描述符和文件IO之间的关系是，应用程序通过打开文件获得文件描述符，然后使用文件描述符进行文件IO操作。文件描述符是应用程序和操作系统之间的接口，操作系统通过文件描述符识别应用程序正在使用的文件，并控制文件IO操作的流程和实现</p>
<p><strong>注意：</strong>文件描述符和文件之间并没有直接的关系。文件描述符只是一个抽象的概念，用于标识进程中正在使用的文件，而文件则是实际存在于磁盘上的数据存储实体。在文件IO操作中，操作系统会根据文件描述符找到相应的文件，然后进行实际的读写操作</p>
<h5 id="8-5-如何避免Linux中IO系统的瓶颈问题"><a href="#8-5-如何避免Linux中IO系统的瓶颈问题" class="headerlink" title="8.5 如何避免Linux中IO系统的瓶颈问题"></a><font color=DarkOrange>8.5 如何避免Linux中IO系统的瓶颈问题</font></h5><p>在Linux中，IO系统的瓶颈问题通常出现在磁盘IO和网络IO上，因为这些IO操作通常比较耗时，会影响应用程序的性能。下面是一些避免IO系统瓶颈问题的方法：</p>
<ol>
<li>使用缓存：在读写大文件时，可以使用缓存来避免频繁的磁盘IO操作。将数据先读取到内存中，然后在内存中进行操作，最后再一次性写回磁盘。使用缓存可以减少磁盘IO次数，提高应用程序的性能</li>
<li>使用多线程&#x2F;多进程：可以将IO操作放在独立的线程或进程中进行，以避免IO操作对主线程&#x2F;进程的阻塞。可以使用线程池或进程池来管理IO操作线程&#x2F;进程的创建和销毁</li>
<li>使用非阻塞IO：使用非阻塞IO可以避免IO操作对主线程&#x2F;进程的阻塞，提高应用程序的并发能力。非阻塞IO需要结合使用事件驱动机制，如epoll或select，以等待IO操作的完成事件通知</li>
<li>使用异步IO：异步IO和非阻塞IO类似，但是它通过回调函数或事件通知的方式来处理IO操作的完成事件。使用异步IO可以避免频繁的系统调用，提高应用程序的性能</li>
<li>调整IO系统参数：可以调整Linux内核中的IO系统参数来优化系统的IO性能。如修改文件系统的最大打开文件数、调整磁盘调度算法、增大内核中socket缓存的大小等</li>
</ol>
<p><strong>总结：</strong>避免Linux中IO系统的瓶颈问题需要综合考虑应用程序的需求、系统硬件环境和Linux内核的特性，并根据实际情况选择合适的优化方法</p>
<h4 id="9-高性能系统设计"><a href="#9-高性能系统设计" class="headerlink" title="9. 高性能系统设计"></a><font color=DarkOrange>9. 高性能系统设计</font></h4><h5 id="9-1-什么是高性能系统？它与传统系统的区别是什么"><a href="#9-1-什么是高性能系统？它与传统系统的区别是什么" class="headerlink" title="9.1 什么是高性能系统？它与传统系统的区别是什么"></a><font color=DarkOrange>9.1 什么是高性能系统？它与传统系统的区别是什么</font></h5><p>高性能系统通常指能够在高负载下仍然保持高效稳定运行的系统。与传统系统相比，高性能系统通常具有以下特点：</p>
<ol>
<li>更高的性能指标：高性能系统通常具有更高的吞吐量、更低的延迟和更高的并发能力，能够支持更多的用户并处理更多的请求</li>
<li>更好的可伸缩性：高性能系统能够随着负载的增加而自动扩展，并能够有效地利用多核处理器和分布式集群等硬件资源</li>
<li>更高的可用性和容错性：高性能系统通常具有更好的容错性和可用性，能够在硬件故障、网络故障等异常情况下仍然保持高效稳定运行</li>
<li>更多的高级特性：高性能系统通常支持更多的高级特性，如事务处理、多版本并发控制、分布式锁等，能够满足复杂应用场景的需求</li>
</ol>
<p>与传统系统相比，高性能系统需要更高的硬件资源、更复杂的软件架构和更多的设计工作。同时，高性能系统也需要更加严格的测试和运维流程，以确保其稳定性和可靠性</p>
<h5 id="9-2-如何设计一个高性能的数据库系统？需要考虑哪些因素"><a href="#9-2-如何设计一个高性能的数据库系统？需要考虑哪些因素" class="headerlink" title="9.2 如何设计一个高性能的数据库系统？需要考虑哪些因素"></a><font color=DarkOrange>9.2 如何设计一个高性能的数据库系统？需要考虑哪些因素</font></h5><ol>
<li>数据库架构：数据库系统的架构是设计高性能的关键。需要选择适当的数据库类型（关系型、非关系型、图形数据库等）和架构（单节点、主从复制、分片、集群等），以支持高并发、高可用、高容错等需求</li>
<li>数据库设计：在设计数据库结构时，需要考虑数据的关系、规模、类型等因素，以保证查询效率和数据存储效率。需要优化数据库的表结构、索引、存储引擎等</li>
<li>数据库调优：对数据库进行调优可以提高其性能。需要对数据库的查询语句、索引、缓存、锁等进行调优，以提高查询效率和响应速度</li>
<li>数据库集群：将数据库部署在集群中可以提高系统的可用性和性能。需要考虑集群的架构、节点数、负载均衡等因素，以确保系统的高可用和高性能</li>
<li>存储优化：选择适当的存储硬件和存储架构可以提高数据库系统的性能。需要考虑存储类型、存储容量、IOPS、带宽等因素，以满足系统的性能需求</li>
<li>缓存优化：使用缓存可以减轻数据库的负载，提高系统性能。需要考虑缓存的类型、大小、淘汰策略等因素，以提高系统的性能和稳定性</li>
<li>高可用性和容错性：需要设计高可用和容错性方案，以确保系统在故障和异常情况下的稳定运行。需要考虑备份、恢复、故障转移等因素，以保证系统的可靠性和稳定性</li>
<li>安全性：数据库系统的安全性是保护数据完整性和保密性的重要方面。需要考虑身份认证、权限管理、加密等安全机制，以确保数据库系统的安全性</li>
</ol>
<p><strong>注意：</strong>设计高性能的数据库系统是一项复杂的工作，需要综合考虑多个因素，并根据实际情况进行调整和优化</p>
<h5 id="9-3-如何设计一个高性能的消息队列系统？需要考虑哪些因素"><a href="#9-3-如何设计一个高性能的消息队列系统？需要考虑哪些因素" class="headerlink" title="9.3 如何设计一个高性能的消息队列系统？需要考虑哪些因素"></a><font color=DarkOrange>9.3 如何设计一个高性能的消息队列系统？需要考虑哪些因素</font></h5><ol>
<li>消息持久化：消息队列需要支持消息的持久化，以确保消息不会在传输过程中丢失。可以采用日志文件、数据库等方式来实现消息的持久化</li>
<li>消息传输协议：选择适当的消息传输协议可以提高消息队列的性能。需要考虑消息传输的可靠性、传输效率、拥塞控制等因素，以确保系统的高性能和高可靠性</li>
<li>集群架构：将消息队列部署在集群中可以提高系统的可用性和性能。需要考虑集群的架构、节点数、负载均衡等因素，以确保系统的高可用和高性能</li>
<li>网络优化：优化网络性能可以提高消息队列的性能。需要考虑网络带宽、延迟、丢包率等因素，以确保消息传输的效率和可靠性</li>
<li>缓存优化：使用缓存可以减轻消息队列的负载，提高系统性能。需要考虑缓存的类型、大小、淘汰策略等因素，以提高系统的性能和稳定性</li>
<li>负载均衡：采用负载均衡可以平衡消息队列的负载，提高系统性能。需要考虑负载均衡算法、节点数、响应速度等因素，以确保系统的高可用和高性能</li>
<li>高可用性和容错性：需要设计高可用和容错性方案，以确保系统在故障和异常情况下的稳定运行。需要考虑备份、恢复、故障转移等因素，以保证系统的可靠性和稳定性</li>
<li>安全性：消息队列系统的安全性是保护消息完整性和保密性的重要方面。需要考虑身份认证、权限管理、加密等安全机制，以确保消息队列系统的安全性</li>
</ol>
<p><strong>注意：</strong>设计高性能的消息队列系统是一项复杂的工作，需要综合考虑多个因素，并根据实际情况进行调整和优化</p>
<h5 id="9-4-如何设计一个高性能的缓存系统？需要考虑哪些因素"><a href="#9-4-如何设计一个高性能的缓存系统？需要考虑哪些因素" class="headerlink" title="9.4 如何设计一个高性能的缓存系统？需要考虑哪些因素"></a><font color=DarkOrange>9.4 如何设计一个高性能的缓存系统？需要考虑哪些因素</font></h5><ol>
<li>缓存的选择：选择适合当前业务场景的缓存类型，例如内存缓存、分布式缓存等</li>
<li>缓存的容量：需要根据实际业务需求和系统负载来确定缓存容量，过小会导致频繁缓存失效，过大会浪费资源</li>
<li>缓存的淘汰策略：常见的缓存淘汰策略有 LRU、LFU 等，需要根据业务场景选择合适的策略</li>
<li>缓存的并发性：并发请求会导致缓存的争用，需要设计高效的并发控制机制，例如乐观锁、悲观锁等</li>
<li>缓存的数据一致性：由于缓存可能存在数据延迟或者缓存失效等问题，需要考虑缓存与数据源的数据一致性问题，例如使用缓存更新、过期时间等方式保证数据一致性</li>
<li>缓存的高可用性：缓存故障会导致系统性能下降，需要考虑高可用性的设计，例如多节点部署、主从同步等方式</li>
<li>缓存的监控和运维：需要设计缓存的监控和运维方案，例如缓存性能监控、缓存失效告警、缓存节点扩容缩容等</li>
</ol>
<h5 id="9-5-如何避免高性能系统中的并发问题"><a href="#9-5-如何避免高性能系统中的并发问题" class="headerlink" title="9.5 如何避免高性能系统中的并发问题"></a><font color=DarkOrange>9.5 如何避免高性能系统中的并发问题</font></h5><ol>
<li>采用高效的并发控制机制：例如使用乐观锁、悲观锁、分段锁、读写锁等技术，确保在高并发的场景下，数据的正确性和一致性</li>
<li>采用异步编程模型：将一些IO密集型或者计算密集型的任务异步化处理，避免阻塞主线程，提高系统的并发性能</li>
<li>负载均衡：将请求分发到多个处理节点，均衡系统的负载，提高系统的并发处理能力</li>
<li>采用分布式架构：将系统拆分成多个服务，通过分布式技术实现数据共享和资源调度，提高系统的并发处理能力和容错能力</li>
<li>避免死锁和饥饿：对于并发控制机制的设计，需要避免死锁和饥饿的问题，例如避免循环等待和资源独占等</li>
<li>避免共享数据：尽可能避免共享数据，减少锁的竞争，例如使用局部变量、避免全局变量等</li>
<li>监控和优化：实时监控系统的性能和状态，发现并发问题，及时进行优化和调整，保证系统的稳定性和高性能</li>
</ol>
<h4 id="10-性能调优"><a href="#10-性能调优" class="headerlink" title="10. 性能调优"></a><font color=DarkOrange>10. 性能调优</font></h4><h5 id="10-1-什么是性能调优？为什么需要进行性能调优"><a href="#10-1-什么是性能调优？为什么需要进行性能调优" class="headerlink" title="10.1 什么是性能调优？为什么需要进行性能调优"></a><font color=DarkOrange>10.1 什么是性能调优？为什么需要进行性能调优</font></h5><p>性能调优是指对系统、应用程序或者数据库等进行优化，以提高其响应速度、吞吐量、稳定性和可伸缩性等性能指标的过程</p>
<p>在实际应用中，随着数据量和用户量的不断增加，系统的性能可能会逐渐降低，出现瓶颈，导致系统的响应变慢或者不稳定。而性能调优则可以通过调整系统的硬件资源配置、优化程序代码、采用缓存技术、增加服务器数量等方法，提高系统的性能，避免这些问题的出现</p>
<p>另外，进行性能调优还可以帮助我们发现系统中的瓶颈，了解系统的性能瓶颈所在，为进一步优化系统提供了重要的参考依据。因此，对于需要处理大量数据、高并发、低延迟等场景的应用，进行性能调优是非常必要的</p>
<h5 id="10-2-如何分析系统性能瓶颈？可以使用哪些工具"><a href="#10-2-如何分析系统性能瓶颈？可以使用哪些工具" class="headerlink" title="10.2 如何分析系统性能瓶颈？可以使用哪些工具"></a><font color=DarkOrange>10.2 如何分析系统性能瓶颈？可以使用哪些工具</font></h5><p>分析系统性能瓶颈可以采用以下方法：</p>
<ol>
<li>监控系统指标：通过监控系统的 CPU、内存、磁盘、网络等指标，了解系统的负载情况和瓶颈所在</li>
<li>分析日志文件：对系统的日志文件进行分析，查找出现错误或异常的地方，从而确定性能瓶颈</li>
<li>排查代码问题：通过代码分析、调试等手段，找出代码中存在的性能问题，并进行优化</li>
<li>压力测试：通过模拟高并发、大数据量等场景对系统进行压力测试，发现系统的瓶颈所在</li>
</ol>
<p>在实际操作中，可以使用各种工具来辅助进行系统性能瓶颈分析，例如：</p>
<ol>
<li>top、sar、vmstat等命令用于监控系统资源使用情况</li>
<li>tcpdump、wireshark等网络抓包工具用于分析网络流量和协议</li>
<li>strace、ltrace等系统调用跟踪工具用于分析程序的系统调用和系统资源使用情况</li>
<li>perf、gprof等性能分析工具用于分析程序的瓶颈和性能问题</li>
<li>jstat、jvisualvm等Java性能分析工具用于分析Java应用程序的性能问题</li>
</ol>
<p>以上仅是一部分常用的工具，具体选择何种工具需要根据实际情况和需求进行选</p>
<h5 id="10-3-如何通过代码优化来提高系统性能"><a href="#10-3-如何通过代码优化来提高系统性能" class="headerlink" title="10.3 如何通过代码优化来提高系统性能"></a><font color=DarkOrange>10.3 如何通过代码优化来提高系统性能</font></h5><ol>
<li>算法优化：对于涉及到大量数据处理的模块，可以通过优化算法来减少时间和空间复杂度，从而提高系统性能</li>
<li>数据结构优化：合理选择数据结构，可以提高代码的效率和性能。例如，使用哈希表而不是数组可以快速进行查找、插入和删除操作</li>
<li>编译优化：在编译过程中使用优化选项，例如-O2、-O3等，可以提高程序的执行效率</li>
<li>并发优化：使用多线程、多进程等技术来提高系统的并发能力，从而提高系统的吞吐量</li>
<li>内存优化：对于大量数据处理的程序，可以考虑使用内存池、对象池等技术来减少内存分配和回收的开销</li>
<li>IO优化：通过采用异步IO、缓存等技术来提高IO性能</li>
<li>数据库优化：对于频繁访问数据库的系统，可以通过合理设计数据库表结构、索引等来提高数据库性能</li>
</ol>
<p><strong>注意：</strong>在进行代码优化时，要根据实际情况和业务需求来选择优化策略，不能盲目追求性能，导致代码难以维护和扩展。同时，需要结合性能测试和性能监控等手段来验证优化效果，并及时调整优化策略</p>
<h5 id="10-4-如何通过系统配置来提高系统性能"><a href="#10-4-如何通过系统配置来提高系统性能" class="headerlink" title="10.4 如何通过系统配置来提高系统性能"></a><font color=DarkOrange>10.4 如何通过系统配置来提高系统性能</font></h5><ol>
<li>调整内核参数：可以通过修改系统内核参数来提高系统性能。例如，通过调整TCP缓冲区大小、最大文件句柄数等参数来优化网络性能和文件IO性能</li>
<li>磁盘优化：可以通过调整磁盘调度器、设置RAID、使用SSD等方式来提高磁盘IO性能</li>
<li>内存优化：可以通过调整系统内存参数、启用大页内存、使用内存压缩等方式来提高内存性能</li>
<li>网络优化：可以通过调整网络设备参数、配置网络优化工具等方式来提高网络性能</li>
<li>CPU优化：可以通过禁用不必要的CPU功能、调整CPU频率等方式来提高CPU性能</li>
</ol>
<p><strong>注意：</strong>在进行系统配置调整时，要根据实际情况和业务需求来选择优化策略，并进行充分的测试和验证。同时，需要注意系统安全和稳定性，不可盲目调整系统参数，导致系统不稳定或者存在安全风险</p>
<h5 id="10-5-如何通过硬件升级来提高系统性能？需要注意哪些问题"><a href="#10-5-如何通过硬件升级来提高系统性能？需要注意哪些问题" class="headerlink" title="10.5 如何通过硬件升级来提高系统性能？需要注意哪些问题"></a><font color=DarkOrange>10.5 如何通过硬件升级来提高系统性能？需要注意哪些问题</font></h5><p>通过硬件升级来提高系统性能可以从以下几个方面入手：</p>
<ol>
<li>CPU升级：可以将旧的CPU替换为性能更高的CPU，提高计算能力和并发处理能力</li>
<li>内存升级：可以增加系统内存容量，提高系统运行效率和响应速度</li>
<li>磁盘升级：可以将机械硬盘替换为固态硬盘（SSD），提高磁盘IO性能和文件读写速度</li>
<li>网络卡升级：可以将旧的网络接口卡替换为高速网络接口卡，提高网络数据传输速率</li>
</ol>
<p>需要注意的是，在进行硬件升级时，需要考虑以下问题：</p>
<ol>
<li>兼容性问题：新的硬件设备是否与原有的硬件兼容，是否需要更新驱动程序或操作系统版本</li>
<li>电源供应问题：新硬件设备是否需要更多的电力支持，是否需要更高级别的电源保护</li>
<li>空间和散热问题：新硬件设备是否需要更多的空间容纳，是否需要更好的散热装置</li>
<li>成本和预算问题：硬件升级需要投入一定的成本，需要在业务需求和预算范围内进行权衡和决策</li>
</ol>
<p><strong>总结：</strong>在进行硬件升级时，需要综合考虑硬件兼容性、电源供应、空间和散热、成本和预算等因素，进行合理的规划和决策</p>
<hr>
<hr>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>项目经验面试题</title>
    <url>/2022/10/28/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容">
  <script id="hbeData" type="hbeData" data-hmacdigest="211100b00cf3841e3d58958446db7b469efb2d805a0b7cfa51825184e3d45b01">77cc46b16fd309e8f5b42a0dad109aa88a81e87c9c9da4bbe0e82fdb8f0235028e78338c19170f99d2383f3abdd4e98fae824092bc07345b49baf095afb7f81b15541b2aa5c2e525ab4f690d3d3c0dc1f5b84fd6c518e5dd3fd78324f232157f1218680b54feb74870c2513780c1c92bb30736d289743200ee95bed39e9c5eb21b440793f04a13b2ecb05b08e98a5cd4ba622cc7d1b084c61f57b18e4ed7201c81938310c187cf1294a9d5179663a96d1f39e0755e6bdd6826585d2f7c6598d4db2d3e1b7c066b83416c55b8dae7c9aee7cd4e4ef5d4cec3b7a7b74a7c50a59ae38afda3a840f2ccd997abe7df69d54bb243898fc195bc72975b0e822486ada70ec1371e77aa2223b06187ce8b3b9b46305728db810f25f10e323df322be2bcc90283d4653944f632655f03104182a2ecfdffc371a651db56703722c1b468078b74cbdabf0c98fc31e488bab5dfd7d51e2e7f590c65141b79b7b5431d96860316a1f9fbdaf8172bd13c0170dee82cbadd1481d0beee659369faf777cd9577a49705b2e0d88fc4911d8140ba6773880cf15e7466f925ea49ed54effac77dac7e1ceead081b00452cd224fbcee4ccdc246ebb240411a3100927773d27df47d48f5c2066f593b610d54b6e7f5d664f5e0b2192065033babba923ce6974611ed5bcb4dbcf328504539d6a52efc398e6f0c2098a075f47342f7e3dc8ce988c9b094e0beb6d8866250cdbc6e1c9d355524aed80462a723b08b5ed37ae9def91fb89485bc043b18f48d0e9dd175f74ae0098bfd2cb17b270908fdfcc5b30d2ae094f7f146734ea25a763d01d72954f439f0b4cfe6b65609162f7216e29c97c433968afe97ab3a3196a475ac8693b0c1ef73a4bd1c1c60cd7f9e3e92443bf69c716b5d98abf1c67174d1e4bacfa8b2f17a1bc2270f30661e2f4f73a8d9ebcdd66ba2b84e74e82e127593e012f6810a4afa5d83385fc32374e95bdc479dba6577bb00e890ba6400174597b15533699eaafa4774134da61bb8eeb4344071784e62254bbec42d4bfd37e858e2c6c71ae028917e88815fd8afb6ae2388d7e44ffc1dcc98b8b7ffe5031f0dc018d6f6e9a9142cb5e437b7eb7345c969a3278f6c513a5abe03f615fbb0dafb0b4343e286ef612fd570caa4fe82ef344910769e56f270617d6dd602b08ff561e5365099946404736fe85402be330290d3f77629be6cb92cc454f67a65c04e6e68e1940014307a5c290e924a5359deedb76e42a866723ae4d125e56fda410b5c74189146db466fd44fda6adec44b56f4ef83b548c5d360be3330ae263fb0b7b9620333c228414b68b1772084156d8e5dd912a96455eec6d541deabb5c08451bebc588b68d8a6efd86715a9d8977cc208a86e27d59e752e8cfe88d8aed9e79f7c21a2e9e376f94da703e1448fd4871002dcde7594812858a6e5ad9622b74d8b2f955304b8eae6eb22c067ef7c935731928ceba320fe7f6e5a77994db0b940692234ec843d687aae462ef30766e922b453b7dd1f91ab3da9a506c70ae0c38b0e66e6e4bb3181f69f7f20cd25590aa23c69dae8dca2403a5922a26a044d57292c02d84998be1560815f2f842270c04334afd71c6d76eb8dcaf95497da786ff1be59f48b030b5978e78260e0623d1988ff324075e1e2ef5d3e5e245b503f2e4c0ed4ef176b8af972b7304d87f76197bf94ca45302c34b3ec6be66cc6c06ca539a35ce143546afeb038a147c058d8abd1b5d1544a458f2110229c3625b8ef1b57e3caf7e7d2c2d8f1a17a1d74e4ee87b53690f67309b823696926b9349a7eabab5eb7f5b885dfaf3123cb8ee2486ded6362b4ce316a21ef6c89f6ebc9f867712bbf72dc70370d977773c6c3dce687eed13e59fc1f3e30abfaef1058f7eef146a0bbd8faa99df8fc0f8f36d83259227965d0ae8ae44d46af4eb8765aead150b172beb5312d08c5b60499700e539d59a406b7f68251613478345afc16d58f48d8a30882fd0701167339f68ef9fa35274072c43df8872e458d042ee32b57d4db5cd080a8bd7d74187ff63f167761669e2ffee8c91056cda31b370725807a797a0d111c188c5a2753d21143c48d1d012da447f0a8f2dd86864fd8886c56f1931d67ae484ffd5dd57887be242d68cd18bd3407f932c30154b4b52f77dad180f3048c5c28f0f1973a4c925aaba482fbbb5b3a123fbcc6a0c9516ced471e1d9ae166376a9cc48a397e8721d7e303a650f7a5d822b751cf061ea2369d07bd981c6effef6d1ce431ac578d4cb4ccc41e65ceaf334acb50774649e5d2eedb95c75568fc17ec9ac295cafb6d8fca1ea37f73a7de9b6efe1b8f2f092b1cec9dcffdd456e6c9b5e23a476b1b7759565615db54304628bf02555c7676902a5a7a7cbf66a069bce43d6682c4967041b93d87e89187ff7c98d6de4d8dc140c18093164def5c99dacb304990c4f39b5757b8f6d863f3b120871390c13921ddc178d2ad402ea2848d0e8d61f3fd30a4c777d56998794753ae44c9d623e4470a2db0bb9e0cf1ab382dab21e5b23a8b6c55142bea833fe4347f973cd3e37a8d25f573ea2c915e9f7d3d453eb829dc17e39619ebc1ba8ebb27991d2ffebf7163d6ff382ac38709208aa55f198ab20cb0ac9288917e599ce335f1b0cb293f8862c20d9c0b327dee88c747252b37a33448510f95775cc6b17d20d53b4bd18a17c0ce10703462b60fee589298602992dd5496f8f983d47b4de9c4a4621c38f0eeddf1e9b54b42907343fcc238aa9cf5182f228c0548a5d35a9ed945856685a09e3060433275412ee51c0aa0b15818f78ec314cfbcae8d58b51a9554c35340ebd79b9e5d99d2ff0b390157760dc058a712f7c191f3d2f02d3a25036cb06ba2c9ef8f5424e612f6b295831b7409a13337866d6fcd723ce2613239297614a44a1d1f8a3aaa3169e67c2f0922df026585be4435f2a102f69f0a17e21f1e87985cf8881a30f254fb69ed1db12df47f699fd3f3a097585bc46de7f0197e82e84a1a04e43dfe15e4c27392837dfc665618a05d242b5cf7245a9dfacbb8f3e9a6b97851f1437bee6b0a4828b550b5db40c8dea13ed2ee8da8caa83079e4a2744f1012a88c9c8c00117e6ceeffd70952cb53236acd4b48557aaa4dd417710348c4f2c1370d602d3e75e32863e71fdb4c7d3ebdcb83f45150831e38d409dc4b9d1a0c4706f046295a8df6e2b72d90f4091e29c199ae2d6652f4fad60cac8e96de44b9cfe29925fbb3e537722ca670abe5ff377c2671a429ab0d920d38a1550a10b6299eec5a3a0e84b52f4d4d7cb5ceb68644c74fdc3a376a4786599d28b3fd73d26b31dd8000a29cbf293339e6e3720ba61d43303888f505268543a9a899b67183cf6c38d09f75b48e7091f1df3089abddee469d6e1cfdd85015163930c53aeb149227f52193796dbb602dde0c6d2a5dfdaa0186d35cba3c5a975a3b2272d36c56e9d23f9d8465d86c720aafd048622c74f60fb4c0b5be8bc00b9eb46adff2cf86e1334c60ab7c162617b3942a1e570fa5308aab7da97d674f1cdc293b847776d3625f51da52ad51e88d38e0350012ccb6049b1f513d2e802c4359b3bf560023849c3ccd8922c2d1a4e6d936b3a9e55d1751e5a1eeff4780af2c35218ee419639586bedc77f4701b3a9131f26af0b19e747bffd7de694bbd2a8dbe531ed3136b0d64d25e6d245a26ab94167c3cd869a102d866b50ac4286ff909ad1bbdf04deca7f8eec801dfc8f4c38315da8fc83ab173d1a82f8842b73b570e19ea1f430775b5b296f74e4dd5877647d5c6776ce776ca85bc45161716b61328cbbc0653eaba05c02851615542c3962c01748a5940a97e5619e5a3169faf9a02b5579a7a4d933fac3f21fcec9cab5ef0c95bb2f758112efc48d928d789585ddd68599468f053f0d8f4246cdd9dfc71bb6172b22b5e3e9a0dee3fd71f07e63aeb05198ded94f02ad165f08ee4a57bae81c677b50560d0353f8b73143d7abee505196d7e50bb7121bda79b07c044c2fc1020d32c9d72f36c4417cfa53b6ebf3655712e5a557c320b27c1f88fde9e8a413013e60e007493a052af1e149ad6d15a9187497d17c95c752b2da0f1a6da66c7f9c9894156ff851fe7e6057e3f22bd4e8d29afd40a07f7acb4e79fdbf4ba51d3b6ef4e75b18f7b45c1254daa56dfc13a865413da07723a4c3c735efc0c7e2c5c4866bb4384fff9249deae8915504d8d64d04733d0aea5af9e7a4c25d89af668af9eb8c7ad8797386fb99ec15a3716791183f9b1ac77490c01004a647d83abea32e080dfcb5df3ff07954ba65c18b35b3e345c831e4b3c20486a9ec9cb2e196cff56c6b693beea091697213512b41ea782d3b005b37ac559e785c048f952539d958697191f818163301e3c46e8636f1bd838d8e77503fd33e62ad656b58a82e9d7eed3ad60b1d816b32afdb55e8c1ae6f7a28c931b39d416c86728c2d8164d0f0afd22552c6a5a772e8da66d406757172936a4ffa182210328790cb72c65ced1fde4fb89171c462d6d1bff0f2c488367c89ed25952e49c82d5e65053d3895db5110e8058fcc0e86555087701ffb208ae291fca99d5f3503be2319172e53d62cb90f009adb5e2c2fecfda9eaac1e28c05dc90e3b92e0d799712b2acad0ae41984738b7d2e01ae239c161f6998aaba72e44dab0a5cff755c67cdad19163b5391d12028373941de4e4a912b54e65b558fea996dc23a3d972eaa9e5cebd56c8b33c0be101d316ef50e7120f8ce47b8a4c2d430a038e792e7271c3a27e74e3d60688201db5a11e8069d5175bf012396ea3536f5f49e9308188d98ca641d2315717be54c75ddb350dd22d46ac8a50475a4c9e8374fba65a88a37327ba87b1e827f4d6a871f80b0939b29c96c5dfe1f478ceae60be28ecbd5a7a7be3fcd9dfa0be4d472e7fad57f4584abb9dd318b3a504ffb1810d5901be3ba892a3258a25833cc06ff570a71b5861092543054cb6d81239e7de38cc55d6e1f5866535790e6d18ea1dff5a58f944c58031aabdfad7e161344539c6a5e853321270c495c993ec01c763679a137799075a2c99abbec66ca164e5c7a79bce105f94ee43949e5ae7797b0f3ea2ed7a596191da8526841527cda65db4ab383dc07d1e227f841e59a210b2b8b654594f4b7174e49b6979456dc60a31ed282280279bbc1fc8c0b740f8c1ecdc45b0433eb57638a3d72a02edb988e138a0154d8638b28f94d7bd6c7099a4123b140f8f97f4efe0825083cfcee5de3bcc507fb396658350e4f795b3ae6f4169f58a71eb385651f4104f5dc8232970f5082fbdb36a8094b7a803415aa5a703a052d0ecdc3e6efe50b2061fc944abb45f0faf4bcb5057a541186e7623ec9b0b59b1472c28e78b802c56e815afa594f6879c1f69425289d22c02b8239a5e5494edd657c4aa329077cc7b75db9e3fa4c6ec139d2c3506ff1e1576bec610f798dec27f9e086b713db7758086ad2443efdbb91cbb3cc6332dd056f375483ac2f5426a270ba4d813320838aaccbfb4d88d89d45a282908fa2e498cb52fdb52813a4b5ef988c60e39eb327e1a9362744c21f211608954cdbd32fd19a240440b4385fd9a96c7b1eff3722198bf6b2bb80199be4ae38b7084badea245c208c185bea9846bc6b6035c5829eed56238e6efcd82b59241b06493310cabcba44e40aad730cdb30a2b4134736d84e3ff885ab7fcd28226f01d5bf07c8c451afa2f702b12c6ed6e2beb976f1e620872a47c91853a287cb52dbc09d4581a945ee0ebe9a2eca8792aa302049ba0963afae9c806ec97c1dccd9abd345943f1e03230d748a7645060387db4b85677d5272890767ef341430a03fbe4dfd67b848331879be65e562137f220599833d86106738a41f04251f8d0d0d04309946b9099a3f2a656b6aa608d79a7a1bb39cb184ee7d6ed550caa11e3fd3deb7c1171ae5c1f166d3843849b72be7bda61fd34abe7f7e7b39bebbf260bf2fee3245a39e9fdf70f6d10f25d4a42808cb55a9c2a2b8f5d12173aacfd937e2f6a37fcf8b9c2b9d25e8351435108a84403aec2d3545e5f21e0edf5bc616f3b27d67a9ce21a49e959b898ebb4eed475fbbb8c7e4b6c0d2bc75ae00f0fa81bb7f02a5f2b77ef3c5a4e58979bbb1b70c248f61371dfc416dfd718c6713b1b7b45b942cca6d6102919cd42999be3fdbc99b20594d8c006c355791bd983af0fe0faa3abf6050591f032f66cb4decdb1e8cdbc9472d4a39e8e2c4411f0ed859b99ced08b71ad53140b2ff12bed7c2d3b5650b8d4e338e0c3d06e6cfb1919b91d1d3d2d7cff88d6748c7bfb1c0e6fa9ba044dacbec1b0d11791467e2de45632d47317637a1b18eb92598fcf65c402eb6827fc487dec3ba5514ccdce3a0f5b91d64011778a4e6cc0a3867283b4b2cf8bc2b09086f0035bf321d72aefd230ef97f57ecc8a8b351ed2e00bf0d64b82cfd6ff8a157e5149598dab1f08a7a31ebe42b7fde821d12af7047e6694a05574afa3d48cd15735e2e6e54249e017227d4447b47da38f23d5de8daf70e7337a37afe90644ffb881396f246c57bcb3c58ebbde4197670a9cf952aba35e8b5b7a01090aab443716d10c4ad15f2cfa28436b1fd2f3249b8ea45a31840556c3f85b4c11f0a18beb74142408645d9e98938bd674f5e52465691588b0d498f227bef29d7f6cacf91068f452cb1977de04a19c8fbbb09b6962f698877492072469da5c8d5ecd26bc24c8c2a73a875ed8bc814f912988124b0639cf5e21daca7dfcae64a9cf50668dd58e5ae112c0a5331e37801f78f81fb511ee42e8b2a5f5c307934306c74fd2cf408a2236feccf8290cdf812bb354d2e3c9dedd72d4ffe00cf5218f29302cd074dbcbbfc9142f766a48340fc8c56d6a2e324871e1a024dc2e6e301dde17ac674c59c52a6b2126ff875ecb8137346768b5ec525b9bdddae3ead2f18d5178fe38c1d3d158584a0da10941cee610050b2806437c1f97623d1d782658e77af3ed4a8e675f78a22a863f9404888480d64e4793502ffa62d0a5561edc2181f8b0c28b4ee46e4344ece76380b12e89768384efc0ff023dfca0dd9e420fd396651011b5665b160229caa9ff7bda83bb13be6e9fe7c4f1238f259db15c7ee7958803df927d6bf966c27dc763579a520d172fb5eaba2ccbf9dc37914bda05e55e9d763dc2c3627fea5b5bd88509beaca99de9c7e42df55c7890b742263e28b3407ac0d8a13ac290f71c2f8ad5da184dac9b7882bcc21053068a6989df0b490ad2417a64ad2b97e434027784c71b4201a8a11b6e7be748ed6cf067585867b4a45c7226a2f21d70607a920f5c3181b153d8766efa8579d0ed037ad34c8cf4a1308f6ba0769ede217e0fb432cb67f3e158ce5d8d1c5f5d5134429e861569de9b77c868ccddbcf4c724c2ba07b6fa540d264453dc85a7d23d1c959bd6be993665a6d9ab01e70d8f0087e435317c1abc2820b229a46144eeb3e2c0148a07f33cb143fe5c0dbb6b39b5d269e3ba72c98904677668b3a63372717f96f3000f807e9f2987e0fd614ec7d53e8dabf017f8b9c5636046642e865c33ca12fa6047d02279c8d908b3a023c1f3535ce4e0112acb9dc2beda3f378b2083b66fd95295f66ecb0b41a55196d85fde22e768c2621a3ebeb86c19c4381677cb6abb8e4dd29993ad11b63f8cde112c0c61352816f457d0bec00cf1ef019caa6551cf1e051e1adb8919508a178ea1a115df6860b6a68502ec23305e272168c86dd62e4a49d7f9ab165930e5fdd28e3b8fbf6295714b9efed46ad9b520d1158eba6c677c37db15d6e54f30fdaf61880636d0885743dcf24f3f910e74f8343f4e4026bb46851cd4242117f2b4de4f217e9b691c9ee77dc88113b5f461ff717773f0b694316dc6e241014a242dc882852c1186211730be27e26bd248f3aea47729264754e831943ab1b432eb07ac5c5b2eda02f117de5c6176cf4d918689744823d465cb42b0fc5a6bd9cf3fcf637eb3002f4ca8a9e39d58ebf5a47802c54fe92368a3ac0caa8e34b38cbe3ecf98665fc020d2183c5047f951a6651f7c48b3dc2bc943627e7752429720692666dc3b103c358d4ab08d24db911ed37a2775539a36b40e035ebfee33c453e4548264b64298970271f99b2806343cd4525b80de4c9b6173229e1d475f5247bcf5f364c5fc0f196f685d194fa8f2835a15e38d2a7a896b41a34b56354afdfcb9df3a89c63be79d9956fbf22510a58908e6dabeb9366a401d88ea2af0bd3c62f051018abffe53b2ffc86417d726ff6a78ba234d45311438f6aac68ca52904bce522f8bd26171d42447c59cd6c41c2a1b836ee144bde671e376c4d4ba83409bbe9e1e92ea585e38441abf67004c27a8e3a28c585406202fe2d8707bd827b7aa857792d125a8f24b94ddf99f65edf60418a2662af3bb4b59c53437be9054ccabee9aeaab700714fa517837eaef31abc4fef5e0f836326fdaf58ad610a2b319e83a3e1181034e736956ebaf5681d59bc0118b5a21764cd25c0aa34d0b3a84fa6169cfce667bf97f749b7e223343d131e8e3c69dd37f7b27b2dba3c254ea92c4c5b557b719c1cf55edfa5ff8bea11d49ef76db8bbd8279cfbf9231e856888a9db759d433b44b6f0fda1aa2e3d10ed385707d4763c1842055ec62dcfba4fd5fd37e4c2476c9c1ff8e4b3597a81449e5cb4e8689107cab1303c0de2a27d8d777e1f913ebee006bd64be202e60356e428af55b4de33b09756475e90cb6593b2d2df37bda4ee8d157459d50022240fef6b55b4f4e144516b5e1b3728efd048ff339afe8b235eaad10cd0ba808a4d77254899cba18127655b1ca3e97337402e0ce6d6395ed06d82713af50eefb6687d27602fb2d2c6f37f51f8d99d0389a6d575fd7311c74fe58484e391f315bc13e73418ca375f25ab883ae3c01252963811df88a28cad62fa989b77f8a80ac1d4ee49a47bb531088085b77edee522674f4e8a22feda4a87b373ce8f848f74de5c069ef2b68d38602d2229224f50eda1b69f86f4273c792829b3618385cc66fd5d02761cb063228dee3780a5b7821431232b05cfedaac38b109df199d6adc4a758a8f6f63b44039905a0282fe187c7f05cfdff610f95fee3145f2147eb379513c3fc0999f004ee4ed28721e7b729b581ed6e276531cabdf7cf5b8711ad6abb4abc3e6e0e6a7957c46c2ec8b0245f87b7eb34e691d0065e437c8f61df13b38170826477c04143242d7d67cd4f1c1e898038570df0ad1c4761e22f4d87b0e97cbba7ba2cd34b6792e938b9773e197dd8d4e110e608a1b0f0adaaec9029f108a0dc3965c23b4c0810075bd3cccfb3d6f289f14801a743137cff50aab46517ff7e778b76e44cc814ce97e4e735cccf9f83c1b66898abf544bfb9f9693a90606445d32b795f5f45516d584547fc6f8fcf7fe54440e8d20708fe025eb0f4ac5fb8d732839e2a544ecdfcac143d90fd469f8fa7eb356897710c65b0fe618dcfbd838e396ca1789d8d196ec0b73540984a3bea4118589deda261d3e83bbd9a7ac1008ff4b14e77e29b4b4b254ff60458baff5dfd3619ff09115b4c67fcf41f46c952d73a1f31db38ea9f7fbb10ae1d1a2390b7ea4e1ea96b11c8d54fa421bd259aba25f30559b0d783d4a2d8b760062eb2d6f8f9d719148dbdc705cec22d4d3d02dd400218f34d1f61ff6936d8be342341297dbae46abc22000147753a988158b33616ce15e0b50ed35e635c6324e40deb6a18c6f05cff180413914f2fa6b39b35d8fe29ffe208ef39453724858252b221a20b2ecf006998b1dbdbe889b40a8fb5faf66c7028246905ec736d2853e625c77704e68a5d81ea43169a59286b3cd3d2363a7c0b3305876c5edd8eb1c236340a3d8a49ea141ec4210b2c328397fc898d760301c08e061e71c23fd037f6ba8d252c6306fe006b6a546dd50be58fac5ef3abbfdf9816b9fff08b8ee8836c4de3d8b581a35e86238dc7b6c3d4d3a0e4381407a9042cd8125820548180f84030bae6c7e8405c4662eab76da07c25a25bc7b4948b914a8bacf78ac3c8b3d5e065f8368f75a6cedeb7ecab3341a9dbe1b9b8c84124110db9ed56842fa045cbc0eaf4fd8a215b271f44553ebb805b5cfa8dbc9576d9c28fa6fcbb339fd31def826505b4207d46df45b65998882cad02ed694064fd2b97621fee5eac3169991621c287a8d2d401456b896accbc987a75c53f312be69463f6fe018eeea1e5846fc7fe78b51b0854c249b4769d1acb59d28e56e57ea62d33235dc9df5b4bbdcbca8d26f32f95cce0f8f7edc3806615575bda550b0dce93efa35b6c1f2b9d7ad776522881492af7f36e13dcc68eabd4ad04f11095d1a26420d25c2c1c902d180281ed3044fad2ec197a1d5f7152ab5767006b191037248dd949447d7df0152decd46fe1895b67c1814ec4770ee08bf7acbe681447e97e80968fa732ff851b0c88a5897c9ebcde0b4a92d801df9f1dd5dca80f048d32114704ce5e6730e3cb6011ef3b4e6038ccf5b8899323e3f0394de383a600703360a0381aacfb21b57558928439a4c80c9d875bb2d05205f8b530855b0b69d849a57a7fa4364fbd913f8e7ba9fd73a093e3a64da0bda9d32ab12e8932dc7754faac80337cd2950033090512f9ac4d61628f72d65fd3086b736830c68ac39b7f276d6866877cb8ae3ffc9494bb08291f932af12db6512fd872dcfb3854941dd9338c0ec0a25ca8ad0f5bb05e631b8bb43719053aa8c80f86fc0c70935e4854bbae4a7b4ad0bac5f5fa92aa043a7ae1efbc21acc6bc0e875bc57fb201d323fcf8d3a91247d2fb097dfbd64d68ec8b842a6f4dcf9e11495f68779c817c89b95d85d082242552092afcdd59f08051145103600662574801a0774db2f8bff2408137de335c3ebfb3cfb80b4547d5aa20583ef36aa60627bb9cbf0ebdf3e871150a5708d0638663a01e294db51f385dd8e447c7670dbff0fc1c8c85b2de69f1a7d6104aad7891c555d489f615876641b4898280570be766edbc90249c3f0e442b09d066a5a4f8f88376478b8c2bdf51b8b7f8362c93d6e455a579504c196c180e05bb08c25c2c26075bc010089d5ac187656ce0cd40fd8818b90be70d1676dbaa492421595f52708f454bb5283cc494c6a4fc66ec8e4c47ed8cd50a7cff7abb75bc2e162b8400afe1d92cbd2192859f4b5d745b9f409c145462978ddc269dc5e732032806015bcc52d4facded393c4d03546ddb2630f298c6e981344664cf9d1cb0d8b667199a6639d7d370e39b1e1d4496d5369772ca3ee5ede7b398534091edfcccb3560063bc266747c2d65e5ac180bf296e2b57c86dbd6a01ce88fd917eaafe2552d1dd82011becdf19589f5b7410142bfcc710be340ef6d11432badfd9f116cc323381df30ad55cb1f01b699649a784a47507026bb4b6a336bd0b0803ecd1732e636680bf462b9d0bcd4d51c08a20abb1926907bf319d5dc3039cb6c66f45bdb4cf69a7945f9ac7f7bed9be34b8bd3848b21b9d6fe8688caba679228d0277475c0dbcfd77cbdc47ff7eb1c8ed959873cd6e14565e55b6596a4c7f052fbc2063c9985dba0801ddeffef85c201cf5c335699abc97d1ff77d0080caf67e4b374c42306250b1f57667f26c0ad427312b66cc8591f64e11190cb85c2b0b68223a4dc9c785aa5926771fd69168f68e0ad2ebb8643ae928be2b622614e98862cea697111ae72c776c8a676e3ac5b43d020f87a17c3f1b8c2f74c75ac92dc71a343362f69273d19f09296d8547a7e82542182adc726625de7f0684325ec3962ce264b649e2ede7af39b7bb8608e99ab402a3983d1273c8f7aa2bb9085407bb436d0bb0a32a101fe4d8f79a7092150ebd2f88707c605bea6cb0e69ed773a1d58a9621c5ee4faeaae040ade0d8f5e7b57b79ead7a9282b37af4044f19742c3d1d1271ed71fb131d91fada2eae27bdc0d626cceea277e8ce85af4e17d1cd5907c2a23303b2e5cd5721a0cf395708e893ca13c22b91cb2fde575c944a3a67ffd2a2fdcdb826838a2473344261c92b127adaf5c1f8d7b8971dae9e5884a17e7b3b269109dda1452e6d962a0fcc6589946c06bad3848ef26bb6f71ca688700fd8898fc3d5462c2b9b5bea1e518fd973e25d74ba8c2c984562e0cd1bae70f02e1f6b55932c0b16fc4b584aa154094fab37d5c502f209ea83d280e72ff9d6cc2676fc15b5d2a5ed94d3a1711cb9d003d4cfe1f423bd266d3f09fac1710ec92268107fb6d04fe30619674ca6d610a9e3a709d50900ef6accf738d17931764c87e3bc91ddf451cbe78672c017f9b1ee6e88e2fd5bed23a1f7848a1809093aeb4e5d902a21d25b42e52da91958219d2c4d7534e530919b36a97a252aba48bb117a2408952550b857f9471bc17182de3ba6c5c6842c7dffa0a5fbf01102a6d0da94bbb29319dfcfc37ea7acf420334e0de37ae49d75ecc76f48a320a5815598090f673f7ec3439396faf3bb852864cbffa094ef94971f232857c5ca574a4dd0bb89958ed3b193611bf62274ee4af1749948c61203cf0d55bc4eb5b16483e110e56db10db35bd64d993f5c7273ff5d2e84ec73be8bdcc01da2d222c83d6dded8581347013f6755af9cc6fdb33ae8eb32165e5ff0d84500ec273ec429e10a65d3ab82b82d52ff450af01a503a2a14a3babcceec0254f59e8f086c5834aed2c58709d6d9faba278d8a5ee4f6b4d41cc0d6c6d39359edbc6c2c2c3bd2f0d0bc52399b3ee82e003d7b8b604e52f96e2d6577ae668e158bf93f09aa6df89948f6d444de1db1a557fc25b9e1726b9a7b065c7ca8e10f2014469b183df12125eba916d524b843ece89935faeddc04e7dd65cb1227bc58d3f67a481f0d5df12a766c6862d85fb330c276cb9df676d4610520e11ae45186f06898aa1dda6324e8cf41470db61553fcfefe8a9adc6603defeb2d6b9937f1f4324ac5a0fbb9d23bb9b272bf5aeb1e25bbadcf818de5004109f9f29bace1cebfa4d8ee6c723cf4180af1cc993d28114fa97c1e08cd93051fe482fb06536c8dd733e5ee5df739f3825435467365ce452d4a8d3f8cddbf075876f8d1f0d4c906f56c0fd0a25002462c7042c6dac355dbd79ce7142339fbf518a6169d8396e7d9d50a97f804fd159be2f2c28a1e8bc5ca68c415d7705f4c89d8f4b96f93d0255d2cdd783d50761ff01e1ddbe8be59c8c65f734daa7421c8905ff746dd3a599207524fa8cd3f71995c298947e9b823af59259cc26b46f35919809768f6c93847e3f817ffdd32256055df5a5078c20f8bfd5d04ab240d60d869812848d759bb8479b8f9142f6f599a7ae49362b55f9f7f81b0748ab726bc3c2df252f67800bd6189fa9fa6295c33f7bc86b0086231779319fcd7164fa1d9cac80324180a2548337db3884513a0ad443a39d5a3f7fa499acdefa88b439b1ed51693e5f4fd9aaa8dab705ef0975264c9a02d7dc8dbd9e72e6761b665fece42c53114a5cd0dcf06095d827bfd6990a493747af09ff97c128be0ccd3d01660b7b6c9bbd0ce55f273c1e7ff88368b2e51d0080fd1c5a45a7f545a68c365a6ea7f98b4d0d39e30fabddc331e65f75662ec2779fc52e54614b9548136e1d58a9820c111b1030ae1be6d82c73d9dcc6089a1d106dd743bb1e9b0466600a077089264b0bd83b58f2dc674dc7e8f776ede3ca0229cf6a6af3d3788965993b4fbf14adf722a2892fada373c06bf5dc12de734e3f28b9b0cd86ac46b234ea1d4d15e41563a4e4d079ffcb6157db8d6425ce07287232b4c7157dbff58845e85c3f9168e16b79acfc033dce58d9ca91ecc81c357717a38642a4fd28d58adfc610be1737d40e5be24ce003ecc3c863f40b10b86eed894ecfed23bc4849ed95fae6c0241d24676e3601192e10f26fd01f04d7464916038a4fd0fe89594294802fd9f891073c2141544985edd672c1e1c5d0d7eb6a539c4afc08ad2f0aca54528b35bce79419d46cc3c8e9c270f39f16fcd3e1cdaf0aa675d2cc32f489ecee2a228a85546b2e9abfe94c6604c3a872d1cacc6a4f25477ec7c664d3d4ade82c31d8f8644371f4813baa222ac1274a0bbc423c1272ffa958c00ae7b68baf60cf3628d83e3632aeb4a5bf390aaf10eb5d43ce162059acead3d69f6882380988b770acccd7e9fa19cb5f4da5f0c6365915a1dbabfab0a94a797121c4c7e668e154d3c7b3e57866a29b6545b76f91b24c392c388e7fc268174f35a4b676b6be847cd660b06317b840ba0e89c3dd41178ba81f5165005403d67f41d64f39bbd07c0ef729f2520a0c576dd787d20a6bed33117c6f14ef5483fe585bbca061126e438fa5267f65cf608624b0a103e4fd0baaa9f1dfbe095ac596d107e408971779dd1733234485e21fa488471ffe130a9e736f9fb49952112e03143a0b113b0ee9438a8ec8116203cc78dfe60ba349d08c10b790820ec600284f37716a76b1a1804993761b90e88204b0b315f44e1efe10d98616d176ca55e3aa68b6c3364a825ba9c01b221d3deb9139133f15579ae5d03eaf1b5d5df0bcce377767ff9123f7b1093f3495b4c1e21070529c8be5d08a362fc6c431186dfa249c4a02b16ad92cfed2a96a82296073bc081d60009a1f593538cd1ed8dba111a7f34261ae377fc6a786e2d8eedf72e261e5564b23d5f855eae5d907662db23f11ca060d6be3d44f4b06de62c4ea0fc863fbbfba31394ae20503cfc610c1593612bf30f67e1ba4a2fc0dedab2e04b21872d541ce83cec9d142fe8033613a9eb3d9dadf0efa2b8ee8e09e9c2472e04a1cad0d1528d94fe201b6f5f6b1ad50247660d65403556532e17fa03057916616ad119085072edfa995a6be79d9bf488ab5f2747d3545f3fb30f4d41fbc087319c2a9fec68345bab90c1113614e83696537431498c37f0e3d062027152b95ea75801b6347c42c4749d6f4ec43aa057c57b666ee6332a087ab0c8e53a4ffd0bd0a032d8c7447772a77f28bcf82760ad8a694db710761677c5f0716f62b43e263fdd66da88372d2d9d0e92443d3c7053dc70dd34267a1452a4f70c8c95c4b84cfec9dc99c671ca81c2c951a3535bd7ac817110d2597dd0b374813c9b5e16a48a5c048516f306856802bbc181c82ee67e1079583f22aee93912a76ebeb41c87a4992e146ce9b226e7a912e48e68e230c2b2eaafc19011dd811f34e77b8483e72879e8933efa559b9ae2c33d64385c2a1981f555ab9c0fae31ad7f9962a1804e3ea8e1df6bb793428ea19f25861dad181e429e19ac8ec8423600e1b5e8a8195904abf0e7f6cd0dc8d2dd7a49f6847415f95a8fe3e3826b58c4b0e5155e3aff592bb88d4d4596764e0b90333fa019da5812a372d3aac8dfcd34c9cfb4220ff1cea9c3549725b0a66396dcdc6441df4e61cbffb1514b24b13514d747272fd8362de6abf8722548f27b6e4e638598aa5c4cc2c2d86fe87ed851b746eab5fc3d419314f075dd9a5f20202ccb490a16ffcae7031263870d95c9330544ebe96b41fb515f82bb2f63497aecc8ad0545708afb250db4310686c1d4fd7bce4ed5298ad8e126ef46336865c2e328e5945f502eb88604ec63e96f211b64b3b1afce040dd80b7b660b8083f72516f743dbc5813d1e814b0b6174a7f0d6b68ee9b7b5401741487952f8410366703c7d38f68b87223c5ee2d84bd14eec501b71029cd22abc548fdf64783c3ed4b297e4802b521fcedd4bc3bbf83b461419c3087408cd2dcfab826b9508e85d7a98d681db0eddf4dc0d8946bef668374bad7108c050953a42d175001d9b20a5362835c49157a119ecf6ad10fe3374db006b6081cc5b15c330b471422b82ab1e6b5963b2f0e89c1f327279890a29770e2bfa46da1209aeaa4dda9e3a17430e671c8e54ac0451730e372fc0a615994fbbd960108491606063f43ac6f6f030d332040f9b01df347bad6b7758dae3cd5135e0737b3e0848e47443319683f19f853ac2de7ed85c280dac7acec8e8a1296bb254d1551630b82c0f9af0122b2358bdbaee27f8b41b367068a1ac310b82bac07f850611fd03ecac3a6cce7980689a823eb690d1ba5214f7a92d455563bebdcd5b24bbdc0aa04f94694b4106b56fafdf0acdb3e6a6255d869f79457180151f70ed6b9d140e6910e2dc91eaa325aaaed16d9160b27866f52c229b3232675f7957450c4d49169b63220e4f745ab53377853b76bf664a93e4f68c7a3ebdf0d5f705ebceb2186d799816613f2f5dfed409780bdc1efb3d60122a36a66fbe7e958b5c09e406bb94fe15cc089f24b3eed85e6e7718df4ea31b07132039bbf7524993c3ac234aa513d01e158113d95e4f3519efb14aaa625b37eac31bc433c33070ec33cae4b3d767fc6d3c97be8cf6a613c850dce9031bb05684e458f6ddf02178bfa3b075b8a2d351ef1fdf385a0450929684ab69ce82b4348c0a8e3ebe98d9ab90f120baf41d27434d1bce8387fd2cb3bb87c7a1f5020bd747fb3f6cc2446800266e8dced3d292d2f0ad5ae59bb19dd7632008ab5f1756c0ad5f57fd50420bca1f1dd71458b1e2f35a2a8a3da2e27ed51eb220adbf24a81c2a6fea2635d8641515d8ff1acd41ddb2b33cb2f38ec8a477dedd2ac6309afdad1557a1d7a23e4f0ce27fa22fa23bdfdb400e208c22b7aa0e328a5d9b22e6740f36211fc87aa137fd3aa28875b87dc134af1225db18e9f11ad1a9be3056a8fc86ea70ac32b655acc23076cce80c8c1a826a839a57584245ad61e152b898759c3218dd5176f653d45875e2b46a878e33ed9cba9024327f90e976d1c7b4340bfb778f91ad6ef4cb25da3643e7982a9c15a2e0af6b4cfcbe99731b5a6bb19614a087c2b3361cf86b1acf3d0ce0399dca3f6b1584341c6c4c768e98e91f86274d127b7488998e45fefe0960ddae25b2de084f0a7329466667c7bc3e40a49d4c3b6683d2501bc04b8fdd9abc19715ea1025a6983105121490fe928a6a4bb73b6d95799a3d3befe5b379c816e1e0906e35805eb2235b92287dbf8c6903a00db89c51afe933824edd48ce0bacf944d1c7fc97a0756b7d37cc8a316c2877ada51fa58b37829a03d3b0a1e1b5e50e2dd33e4418ec6d5edd525f84c66a705b86ef1b5008d6b14b55c03cf2c969f2de0dae86085d9a94fe6b4d9400f438b442660fd886f83ba2f51dde8a7bd4c5bf5ace901e570f2201a71fc7c67c559e7c84900ac0927dccae541cbd028415ce79f175aa0ca52f42095f9e8f0e0ed86c37a992e1c1d7b878593e1950b7262b902c0e6a9b086350ee442e869903b866b58f74dba6ff7a2879665defa1d0647d49d9b0a9b4419ee6a40ee7f1ea4a444eac1133f3460955221761610038b6e0bdca425ec972d70e8aeac10f39d9d9425b2bf44b6895f4e6bf7d9a8d63d982c46c98e401c86adc0904441426f1dc07bb1151c1266376a309ddf3b21b40e4e01ceed6b9d202f087325d3cb66910c270080e64c6e4898f2bd88568ed542706fb4a40f8b4e3e76c02221c0a48f8f7d76accb784c9eaf91f8d75ec89cc9c5400fde4a60b62eec8a44c03e6b0d01665b1fa3221a1336ee5f35e197b23148cd66d0519eaa11d42d7a767f38d24e0ab66729f00bce56f313148498bfec39ae7e50cc12493ab5a2f582ebfba387d56b9e94673641d784e123062c39b8fee122d25f02f22d779382eff680315958607cb8ff684d152f0e713c7c9b04836f4dd73d111d4866d7df1397acc86c27ac1bc3039705da8c0cc98556f5b1321bbfa8ba1cd8a3acb71b70a293455352fbcef9625867d42de76e20aca46ffbcd0f4bac709481ad3e72d33c9f26dfa9b66562b8f08931393b3eff05695a8beca0933ff12fe24f459d9dfaacd0c68636a89a84f365664bf1f1c531070dcf4e3b8c718b23616559c6800eedfa04e710d2d3aaaf18ed804deebd267bcaaff8f4395bb247a1a9f65b795751f02a3797ed068b6087efd476a4c47b6df2e7d7263e81bb405749e579b948f7df2e262868f6051c2b0ffb2eb7ba02cb66d939099c20faa226cfcdee01c12c6ee2625b4b4adecc3b7f8be10b275e5304366c2091f12d47f005e6eb46f88be64ac6b8b01d1a452957556102f9308b5bef145044b7aa9b47a8fcbc67cef56231b29ab44440debeffbc5c3f7ba0e30208f55b38fd2f602a4ea42fd25c37c06ff93108d3f1ebcdc747947c9618869f37a27075ca95ab0ae5e01b39b983a265a2d9d680c917ebf41e0dd022ac9b7a664dedcce2b78cdc3453526a526ee76e702603e75c01d301e410d5ba35b499ea730dea5b7ad1a179fad6f007de7983d7b684f45958ebf81238386172aa14812270afdb3ba1347074451e6266410601c189b0efaff95606d3846ee9af29dd8fac805e44e7a0d47cd8f4a27e3653b44c1f1fac0856f47bf01d6578ebb70329d324f2a524a146369553113673566fd2775bd1ccc303b0f086d82ec8f8a3b39dcd4742751272e38d09d6479fa23b37dcdea058fafe24a60f1f51af14de5b64be1cf1c62287f4f252b2261a9e54015ea60445270023568d9c3d7efe81c0a1f5392e7c2c38fb74d67905dd3f81ed419cf87f30b1a3ba692aeeeda0d87b692df723718f911c908c5ec8ddc5cf3ff10d7a07a6544f022a4b5d3872ca81636825d6ec57bcf9985e91274914864bb29f1480a9c15bbea8b0e3c057abd1b13a842540e11e22a49bd40668da03d4e2411e858fd48634027e1fac3bca342355ecac90cf51ce5a53a94dfc094b7d9acf8f55033665629b1ef35fb7d9cb6a16c662043074fbd6438e19538c6c97126bc87a558d77f4ce41e7b5732d4add97f69dfb31699ec55acf82b2b7cfae35531677b7eef70ae43246ceb5b3d139da0dca33e0fa2fec3e74ee4fbd21044d1faa070ea2f17b3c750c4cf5df14effb3f3fc280d57d285da985c8830199bac6711161d007a4ca3a5cb9200ff60aa1b4d920478522c3d34d9bd2613467927909b65df09688e84f4d75a768d80ecad870b27a0196d5cfe5cfeab01b8c6346d353cbe6a943cf15c8f811221a8aed942c118215156a82d44074165b124ed33133daf9d99aba159ce7e8542a1879f2d0db7d86ffd30fae9605c762a135ef534a7f8b973e24c1e432bc7c481d14730098a9767df38682ab868af5a3bc850d7c74c1f57dc9289b66fe3853ae5abf2907a66aebfcb9318b61af08e411b43842faa4f5f7408b01bfe3467e699ec3f6ab354f9082437229eee1c996460acb97d8b7724a67aff8c21bf4a3de7a5a229850d9f65507ec363a5d6ebafa914026ba58abdffa5a707b0617bb8d3efa7b90a111c9ed62c54b08ac82651a0047201cca0be20a2ecd9c44b853b87b96fb029be5529a963aac1572ee5831bca68b33a7a3c6bfbf67ed52f44823f9ff824ae48043d3ba8e86314a031536431e2a298bb3f59502dbccdf2b3e3263b026448d1855d7e21b50e7ac731d765fbd3ebf2c02b5ff6b8602ee2bfa3ca4fea00237315ea7214cc5b76f9c6c754f461092ff9d79492fbe4355099e565942266b18c0707c88ec39692806b3b441119e1478bcd8f8c561447fa250f2e33161ced45a2de2a2f4f5ecbd534c0c21f70d6a6b238b5ce4a51abcc4f5f6920788b4c1e671c4048bf5c1e4fa7fb5bbcc53b8b10c29e2e1a626c639b6abe1c62e3bda0bdee1cc0f9d269d62e9f7b878423cd13850d615e7aa4075ff8a54466df25a8cab832d6f41bf518a041ec53afbbd38b2fb2da478021c071b531527326708bab4e99ff5e41299538a299384d1cb734b0c26417e11505e7fc0c8de0c6f0170c159e2e5b2c98ef87d2fd37b4866a59fd5ae37e28fa99a429aff31c518434f7f6b18f9a065306bc44a3028224f965485253e171d82729cc62a9a33f62a2e6a114a42fdbaffa7f9e8411475cedc8b3cebe99ceeb1c4d5e9afd7d6a6a465cc6441b3e6745a538301b5c1b3bc24acf8a0f4e032279394e827fd4db0c5ec800f01fe88cb7d465b04cb93b5b2e33666c428d351b421c70896ee7a7675c7497cc8f5c990fc9e12444d04e1c36eb7cbae5750264bf66b2901822dcd0f78e5283574ddf8135c6593db301e1c61aced5260ed02f4f4b0e3b65939a66c37f2dc98bfda3ceb67f225498c3aa5b9a73e7d49519c8ad8dca59d6280f46f208f6280470a086f3db0ed3462c92bb0de70f1e0d726ef6b28e7b67f127b3fc93912a9fc6d02e5e204aebd1993cc9c0d56800452ad9534546d073c12a6f68d3a6910b264acdc20489d973b9e73f9816cd44917ef16223ee19cc289929bad7c5ec133431f89dc3e4b4f43393c088e79cb8d8724664c340fbcc19296c3361977ff940817d10d8122affa453dc4d5b58a7dfba86a18de9ef2acec32b39c222878d3fd466b3284cf0da7e4fdfcb615ddf157c6769a47935cad96e5867742e890ca2c0100b4f907bb1d13b35bb85cd782740e7f44059c7666b26026b98c7e47b133f42c11cf313ca6ed2eb10596357acf6a942dd90b70b69ec124f6c4cbf9adc55343e1ab64854835e37f751ff1f555be0db8e6813415e1555c2af8be0ac1e908c68096134678c9827b2683eff4180f4ab6e268dfc296725b9640c2d559aef17455469f44fbf47848f87a2882884b63a7b110ad22025698b1def03725b8757e7a5ece32fdb5cabcb41bc3d0f9764e1be7063f473b2e1ca4c9816b2f9bff3850ffca1a218878fab0832c6c204bc9291f9f653af999d3236eb2ea72499cb7ce6640f58f7e0b1e7cf355c6d4ba9f2e9577b2cfa220880c3fe31a6bb2c599612c817aaacebd021a71ee3fc4b99a64bf29ae254fcb34825e830de402a46d2c7b11413f52718f855292a12cf647bb3237022e4470fc4ba2be832ba06872b4abd7e68c63724da3993a9f4b10c8344172150b789737da881ff156d23365a7a639f03a859e9171884cd4d6ec1ef9521a85a65adda9648d058053a2026f0a7606acf4d354cec667c9bad2ca9ffdaf82e78a3bd29f832b2c9e695c86c5b4ed4ff0bb3398d97573f5f1592576f6448632b55b67f382ca8a6fd55577b315217cfba5b975fb986351dc64abb109f228edfe7b3003e3775164600407616aa00e22c27a3b207bb76516809269e4d0f96ac50e580ae985cac8816bc0005491c64ffbdf599810c10a995e006462ebb323aef0cf346d2f62d5c692ffc21c23ba7383cb6bf6414d1727aec7ecfdf9efa05cc0015c4fc1087717e56372a2f81680e7f3d3ecd3fb5a067ff33a4925a9d5156bec85ed0bc6636d4a50d6f6160dad2d646a2c65946b0d65127bcee4712e2e7679a9e3dfca21fb7a790c5c749aee2acdb49108a392a86b44b425f0fe0abce38d2b692d3569148a0f302ee015a60448d850c75a91eb77a99de90bf99963b4ab710d2b2fa35152688f6971e3c5dc395e2164833324390224c3ef1dfedd09be20cc8b37313c434d0c26017a3903454a31fb1004b106f90c0b0eb34af58e8868fa5e0a65daafe673ff01f93b1cbd2bee6d0d0f7c1689a3e0a3073f52e9dd07c695ce2906e3fc7b32a544d9bd88946c250103be0812850b4b0f12c43e6057aeb17395a5d8ba4866c64d74b1e09cb76142c805b0c6af32185c658e78613ff4ffbb7a04dfd6e31f99cbdfd6b1e7717672a70f23e6adf4e3b275c74a248a596123845eeb11eedab0415c6add689457da513e7f887c0329eb10a46bccf9d081e710315f7ee0835bf71bad2adbaf57e4d2b7123e20b6fec88daa22c35c1fdfdc749a6fc6f29827ddaaf852abb3bd2a2204e7bfd4e34bcd904407d0018fc9ccec93990e348d665e1c28f0dcbfc33293a08385b8901d2f85a4c4b2f670d181266257e1e68747e10a6f5434396c50383d30019921a609512137876ca853b8ae8174c947880788225e56901b69246cc3415ba63563525aaffab78837205a3ed6bf683e6e911370a38a31d100b4b0cb79bca542a4292046f23cbe1144c50e5a3a45031a4f6914253ba18c886ca0fe944c1284c56fcb35867c3c243acbbf492d8931305460f175097fe02d9f96e2fd556e4369c80df44e6a24cf7f493e8959202a2b74a373ae8ac9751db649f6da6973af25c2d729affbcea9655fbc7e184875345b94c8bf6a89ff70507cc5f8236991255f50744112a36d4a20678e6e4ce11a7ea339108ad142dac6c45d37a7f5796a8ac663c750924016d68167d2ec6f4f30db501041d89157bc1504a202aeb1b644d5c5e6c79df1bacf081c0431e99901172028f0c5d16cbf38b32260aa9866f5a1a172e10e3c47b496ed4efa74402ce8123e5b5c8bccc1441563c5d54bc3ea242f7974dfa125c87fb851922d4b96f8f4a73cf4f5bfe652b3066cfc5d5eb8fbdfeb216c8385ab3f24b5d264bfa97f6821ba519fac98ef69305775b3881362be7e9b0ac4a247e1ca7e3c9f1cbc8601567ea95b7c56f2eeef70878244b2b419e5b32a3288b89f7ee2ab81f7407ecfcedf0b29a9f53d36083fa1de1eed689589bc611a44878135ee299762ffc1f5b554510fddd9c6e6a23a26f3abdc1dda786362332b4aaf3bb301c9d8db9f58dcb64a23174b88204aaea27e1800ad512abc66543f235ace647b3d1d5b95128cb9fe7a8fc425960d44803f2d11102bf821e1cd392670089ec5c6d22e2cd4ecb4832dee8599ef2c91fef814153e2920fa1663267c4fb8fb03e7b2f351cd9728b45b89529bc449a6f0c0e40250669500bda9d1a54c3237068a99128f48c86f6c0cbbc59c0c4455ea34fcaba44d7829c5a4bd02dedb425f5cecbac50a8b6d13314f1cf0df024d628198e9dec7859f3584a11a4ad7ceebd09628018a0efc0373c9c51d263a64b16a66f154e8a84a32ce32d6e152c4d04c883081af72fc527ad2fc5e89aadd8a705a63596941b7b4dfdeb09e96b277ab2ef7ef86f411b58a6dbb305f1fa86b07345b2b9c0638d95e4cc0edd1f2d860e1b373567e4e86b35a6602af4919f5fdf9e6f03e3647daa24ee4eca2c5ed67de3513e8d8ad3b8572483388c631be5b5e5a9cd25c70f8e98b62ae32aa154fc6b2e18593c54c800de7dcf3c72d1c33730a9c4c0035685df50da6fb845c4037a9288d35c884f05afe3d5a654594061b4ba1bbe3dc71df6945a13b4022488792120f863b708b076a35a621028c10489e1b6258ab4b640360a114152fc340b4fb635d36cdba70d2ed6ca01156752e97749c89d89f1fe235ad79cfc6127171c600329ff6676dbb8cca3a3e61b5828816214f949fca9a144545611f52d876ed39fe40c373da19f1c85065b2f804195fd958c166b5a82bd6d1de16b67def293b11e8d4be63bdc3b3203810dd48b930934b02bbaa979eedd3393fe52367268a23a85c35c66e1978b09d3f3340d318d5299b6a08d5177642e69f4fd29372b527e84aef83acb8d64d6bd27f9f8e62637a63a4548dfd0a9bb4cd80a64f40e5a612f0afe6e634ab12b7581e444a451a00064aa4a7ac4a08f84dcdc17f533b0de1ae551a33a29f52225cff34de00c54c8be0ee39994a2350b8b73044dd91f97e3ce5bf559f59f6f1cef0ad2b3c183c662e7052f5a5cb50b4b20d94f7f2ecd80b1db98d17bcfcd85ab4bdfb599b171fba38740dd1dbb828d896d71d9d1096695592d6cbe385cbc54b9bec2d7fa13960b5f26365bc50d8e684f68d6fce3ff7395bd83f609f41267fab9a9af3de2dcd9f187c5e60013ceafd2551f69044e233cf5b642a087acb4ddbe9513eaf68c0b17d55411ed2e7ff30b411090b23d560fb8ad5c0b6b9fe646410514aa7e90a5fbf6307684439bf90f21044f9a525c84b4ed244a38cac388b4fe20798703f480568292552ef8e1b0fce78cc6ddf320736f48c37bcd25bd403a31b3d71425c49d7f9969b1cc6b010ffa86b0a01672c9835fc3c7b127dd4f359123371d644d0605258ff784196946579bd46da657961a6a967419cffcf30a2884360bb7314546961e17ca2a2607a7ae2f9920e08a751e22904be80ba2d5211ea33675a7701b40e2fa2ddf62a9bc9cbbbef345aa27d94a5931bff57e594a8925c3854219d1e91ba40e423d3022dee15a9c375b123f8548cf8e029aa53e5a33cf1c5bddf887524a789008107053702674c9bd1ba3a64f53a1e314edbfb2ee6f12a42af6163e42ffdc5596878e7016526bdefde88e0ce541e19cf80ee2d14aed5c5820b7397bbc862778cd4b7f611d68193ca8152d3c852615baae7bf5c1cc4a75b1b6bbff26870f079924804be642f6b3abcdf17f77f4ed8184d87f818f36199ec46e04312b3877baa5546d34c21c1f54848e2eabb06ef45d42febdcc9a14b10c846656ab9e23de6e184f7fe09fd30efc722b6504bd2b3599b059d089389c217053b0c71c92281cc875b5bc67852aa0bbe29aa6e86f08699f482ca7b11a451ad4331d56bbe359a571b36e4d6c944970e18554adba332b00a16936a3b3cec1f303c0677387b9cfc9f084034b12590f7bedfd619d1abd49f4ef43b300e7c6bbcde9cd1f647b62c6d7912b7b21c3abc441b77a0eb01bd72c22589f94cf93021d16ee70a47827b5095df01354dfe10756a92e34e3a564d75a58f8bd309c0eb4bd883aff58c7fe6d00fbd4b49e6166f49a0bb5d18086493af08d4326884b81850c26cb9a05c1b3f265e6954b3eefae6ff65a17e097810ee756b94b199cd9d07e01ff1055fe6db0ae546cde2bd566f8b9509247c2b2709006a8a046fcd9318a95a294bb4bf1f766cebc646ebba41731b4a1309aae9b76e77be9e595c54e6ff687a34b483c38d5ee2d3e97a0f2c3fac0e7cdef1a4810c1afdcdf9a0267a6230316acd6a99d5c226e0d71feeb2dc849204433068b049cca1a58bb2ea0a5fe176154268c95e2f062cd1cc111fb89d0764b7b80e7ddf3e5aa728b04fb5426cbd7e14759abe421c1b7ef500e68c6fb44f0c390f1bdf60302a054c2b11b7dfd51a95c3814de6b4fb832319bbdec2225677be0717422ad5a05478add32cda551f16e1a4ad8547634fabb07d309146082b63e795039a52615e77e503daefa98a92841334e09b23f24114cafc59dfe2c9ca6d1f44295524be88a8e6f43a3d438e97a797436e3b7cc554eabd404ceca21540bc4cc31c88e55b242268e1a545ac6feb9948b747ce0cd77006645a83bdf5cc89769c6f48bf03c3e6dfbf65f1baba1ecc6db698aecd3969d4dcc9e77bcbff2be54b664b124baf8db07deea3be6a8b4ce5d6e168e8e4f75c2f2eced95b03cf19263e6aa1cedc8f4e1def433f6a65f2d4d8dc89adc7eb37da420d0bccb3abfd2daf91b093c96ef2d64bc5c57adf9fffa6038cc24eb137c941a0fb5948f20cf63f9f10802eb7409016d760d814d0cd84250dae62618029c1697d69386e69481f6140296bf6721f2e9b7d3da0deee689e0146a2f46ed2e73e07141d8b55eda62bb797e0e1f986cba1f13ed43c35100d9a2de763b2b9433e83e40d42c3c76697f7f4d66128194d41566e617913721eeb7303206266bcc41b6dc0147763fdc2292ed30d9844a7caf7e72512e9602b29b8a85c7d8e58e33d96c3079b13daca99d0963ff4f3ab4c35f5b34dec19577b7ecf7d4e325acbc4efce1001daa398d1e08779b733f82c3cdefa21cfcc7041c41e63b560399d08aafdee65a9f6401cfb86aec7de2d08c35586d8e17455fff10707390758a4347bd44bbbc6b6c996e861561eefa4a5fcc520b07e5702b3001cafa7e78cf462dd9ca3426a3c69cba6141de5964ed87c02638beb0416e5edab7a7401458a030d0a697f853d8826f786f56b8b281e2ac60da17a6d198cffd27e498a9f5442d0bcfb520191e12b1eb57137f3369eaf85bf119f0808729c2c2eecade6b06f8c433105a6e27a592bcd1a89565423404900d461c768e255388f2924a1ae489a1a802018fa64c705d6b51b880cec4db945e2d206d8eb43b96cc81c4188862194f964bb80426f33fb051c30d95ab9eb7850919ab09b23b0b7b8d28898169f054324a852e9375fcd523360288241b42206d0dd471f16947b666ab134a7ea3ba04975f5dffb0d281662f62ce75792a45c82d015d0c3138613e98b0a6b64d8c0db20dcce15fccbd4e4a43a2274fd0dcefa5a26f7acf232259b6d6e1ed464518cfe246bcac0045b3e66963dde5db4e26ce1450f044d7b251fd489b0d23757b5768f52e3d302a6b747d70dad1b44b7b1d</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 请输入密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>加密</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络面试题</title>
    <url>/2022/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>计算机网络常见面试题</p>
<h4 id="1-OSI七层模型，TCP-x2F-IP四层模型，五层协议"><a href="#1-OSI七层模型，TCP-x2F-IP四层模型，五层协议" class="headerlink" title="1. OSI七层模型，TCP&#x2F;IP四层模型，五层协议"></a><font color=DarkOrange>1. OSI七层模型，TCP&#x2F;IP四层模型，五层协议</font></h4><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7m5w06lbkj313n0iawpi.jpg" alt="69.jpg" style="zoom:55%;" /></div>

<h5 id="1-1-OSI七层模型"><a href="#1-1-OSI七层模型" class="headerlink" title="1.1 OSI七层模型"></a><font color=DarkOrange>1.1 OSI七层模型</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7m5mu30e3j30v41834qp.jpg" alt="1.jpeg" style="zoom:80%;" /></div>

<h5 id="1-2-TCP-x2F-IP四层模型"><a href="#1-2-TCP-x2F-IP四层模型" class="headerlink" title="1.2 TCP&#x2F;IP四层模型"></a><font color=DarkOrange>1.2 TCP&#x2F;IP四层模型</font></h5><ul>
<li>它只有四层，相当于五层协议中<strong>数据链路层和物理层合并为网络接口层</strong></li>
<li>现在的 TCP&#x2F;IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层</li>
<li>TCP&#x2F;IP 协议族是一种沙漏形状，中间小两边大，IP 协议在其中占用举足轻重的地位</li>
</ul>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7m62vqibaj324q0v8amp.jpg" alt="image.png" style="zoom:20%;" /></div>

<h5 id="1-3-五层协议"><a href="#1-3-五层协议" class="headerlink" title="1.3 五层协议"></a><font color=DarkOrange>1.3 五层协议</font></h5><ul>
<li><strong>应用层：</strong> 提供用户接口，特指能够发起网络流量的程序，比如客户端程序：QQ，MSN，浏览器等；服务器程序：web服务器，邮件服务器，流媒体服务器等等。数据单位为报文</li>
<li><strong>传输层：</strong> 提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议</li>
<li><strong>网络层：</strong> 为主机间提供数据传输服务，而运输层协议是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组</li>
<li><strong>数据链路层：</strong> 不同的网络类型，发送数据的机制不同，数据链路层就是将数据包封装成能够在不同的网络传输的帧。能够进行差错检验，但不纠错，监测处错误丢掉该帧</li>
<li><strong>物理层：</strong> 物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的主要任务描述为：确定与传输媒体的接口的一些特性</li>
</ul>
<h4 id="2-TCP和UDP有什么区别"><a href="#2-TCP和UDP有什么区别" class="headerlink" title="2. TCP和UDP有什么区别"></a><font color=DarkOrange>2. TCP和UDP有什么区别</font></h4><ul>
<li>TCP面向连接（如打电话要先拨号建立连接）；UDP是无连接的，即发送数据之前不需要建立连接</li>
<li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付.</li>
<li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文的</li>
<li>每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信</li>
<li>TCP首部开销20字节；UDP的首部开销小，只有8个字节</li>
<li>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</li>
</ul>
<p>TCP使用场景：</p>
<ul>
<li>相对于 UDP，TCP 实现了数据传输过程中的各种控制，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。在对可靠性要求较高的情况下，可以使用 TCP，即不考虑 UDP 的时候，都可以选择 TCP</li>
</ul>
<hr>
<p>UDP使用场景：</p>
<ul>
<li>包总量较小的通信（DNS、SNMP）</li>
<li>视频、音频等多媒体通信（即时通信）</li>
<li>广播通信</li>
</ul>
<h4 id="3-TCP中三次握手和四次挥手"><a href="#3-TCP中三次握手和四次挥手" class="headerlink" title="3. TCP中三次握手和四次挥手"></a><font color=DarkOrange>3. TCP中三次握手和四次挥手</font></h4><h5 id="3-1-三次握手"><a href="#3-1-三次握手" class="headerlink" title="3.1 三次握手"></a><font color=DarkOrange>3.1 三次握手</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7m6hb6w0oj318a0o6qau.jpg" alt="75.jpg" style="zoom:30%;" /></div>

<p>假设 A 为客户端，B 为服务器端：</p>
<ul>
<li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求</li>
<li>A 向 B 发送连接请求报文段，<code>SYN=1</code>，<code>ACK=0</code>，选择一个初始的序号 <code>seq = x</code></li>
<li>B 收到连接请求报文段，如果同意建立连接，则向 A 发送连接确认报文段，<code>SYN=1</code>，<code>ACK=1</code>，确认号为 <code>x+1</code>，同时也选择一个初始的序号 <code>seq = y</code></li>
<li>A 收到 B 的连接确认报文段后，还要向 B 发出确认，确认号为 <code>ack = y+1</code>，序号为 <code>seq = x+1</code></li>
<li>A 的 TCP 通知上层应用进程，连接已经建立。</li>
<li>B 收到 A 的确认后，连接建立。</li>
<li>B 的 TCP 收到主机 A 的确认后，也通知其上层应用进程：TCP 连接已经建立</li>
</ul>
<p><strong>为什么TCP连接需要三次握手，两次不可以吗?</strong></p>
<ul>
<li>TCP是一个双向通信协议，通信双方都有能力发送信息，并接收响应。如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认</li>
<li>为了防止已失效的连接请求报文段突然又传送到了服务端，占用服务器资源<ul>
<li>现假定出现一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络节点长时间滞留了，以致延误到连接释放以后的某个时间才到B。本来这是一个已失效的报文段。但是B收到此失效的连接请求报文段后，就误认为是A有发出一次新的连接请求。于是就向A发出确认报文段，同意建立连接。假定不采用三次握手，那么只要B发出确认，新的连接就建立了</li>
<li>由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据。但B却以为新的运输连接已经建立了，并一直等待A发来数据。B的许多资源就这样白白浪费了</li>
<li>采用三次握手的办法可以防止上述现象的发生。例如在刚才的情况下，A不会向B的确认发出确认。B由于收不到确认，就知道A并没有要求建立连接</li>
</ul>
</li>
</ul>
<h5 id="3-2-四次挥手"><a href="#3-2-四次挥手" class="headerlink" title="3.2 四次挥手"></a><font color=DarkOrange>3.2 四次挥手</font></h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7m6m8l61xj31hc0u0h05.jpg" alt="76.jpg" style="zoom:30%;" /></div>

<p>数据传输结束后，通信的双方都可释放连接。现在 A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP连接</p>
<ul>
<li>A 把连接释放报文段首部的 <code>FIN = 1</code>，其序号 <code>seq = u</code>，等待 B 的确认。</li>
<li>B 发出确认，确认号 <code>ack = u+1</code>，而这个报文段自己的序号 <code>seq = v</code>。（TCP 服务器进程通知高层应用进程）</li>
<li>从 A 到 B 这个方向的连接就释放了，TCP 连接处于半关闭状态。A 不能向 B 发送数据；B 若发送数据，A 仍要接收</li>
<li>当 B 不再需要连接时，发送连接释放请求报文段，FIN&#x3D;1。</li>
<li>A 收到后发出确认，进入<code>TIME-WAIT</code>状态，等待 <code>2 MSL（2*2 = 4 mins）</code>时间后释放连接。</li>
<li>B 收到 A 的确认后释放连接</li>
</ul>
<p><strong>为什么需要四次挥手</strong></p>
<ul>
<li>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 <code>CLOSE-WAIT</code>状态</li>
<li>这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文</li>
</ul>
<h4 id="4-常见的HTTP状态码有哪些"><a href="#4-常见的HTTP状态码有哪些" class="headerlink" title="4. 常见的HTTP状态码有哪些"></a><font color=DarkOrange>4. 常见的HTTP状态码有哪些</font></h4><table>
<thead>
<tr>
<th align="left">状态码</th>
<th align="left">类别</th>
<th align="left">原因短语</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1XX</td>
<td align="left">Informational（信息性状态码）</td>
<td align="left">接收的请求正在处理</td>
</tr>
<tr>
<td align="left">2XX</td>
<td align="left">Success（成功状态码）</td>
<td align="left">请求正常处理完毕</td>
</tr>
<tr>
<td align="left">3XX</td>
<td align="left">Redirection（重定向状态码）</td>
<td align="left">需要进行附加操作以完成请求</td>
</tr>
<tr>
<td align="left">4XX</td>
<td align="left">Client Error（客户端错误状态码）</td>
<td align="left">服务器无法处理请求</td>
</tr>
<tr>
<td align="left">5XX</td>
<td align="left">Server Error（服务器错误状态码）</td>
<td align="left">服务器处理请求出错</td>
</tr>
</tbody></table>
<ul>
<li>1XX：<ul>
<li><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应</li>
</ul>
</li>
<li>2XX：<ul>
<li><strong>200 OK</strong></li>
<li><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用</li>
<li><strong>206 Partial Content</strong> ：表示客户端进行了范围请求。响应报文包含由 Content-Range 指定范围的实体内容</li>
</ul>
</li>
<li>3XX：<ul>
<li><strong>301 Moved Permanently</strong> ：永久性重定向</li>
<li><strong>302 Found</strong> ：临时性重定向</li>
<li>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法</li>
<li><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源</li>
<li><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码</li>
<li><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法</li>
</ul>
</li>
<li>4XX：<ul>
<li><strong>400 Bad Request</strong> ：请求报文中存在语法错误</li>
<li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败</li>
<li><strong>403 Forbidden</strong> ：请求被拒绝，服务器端没有必要给出拒绝的详细理由</li>
<li><strong>404 Not Found</strong></li>
</ul>
</li>
<li>5XX：<ul>
<li><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误</li>
<li><strong>502 Bad Gateway</strong> : 是用来表示代理或网关在处理请求时发生了错误，并不一定是原始服务器出现了问题</li>
<li><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</li>
<li><strong>504 Gateway Timeout</strong>：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应</li>
</ul>
</li>
</ul>
<p><strong>注意：某些代理服务器在DNS查询超时时会返回400或者500错误</strong></p>
<h4 id="5-HTTPS和HTTP有什么区别"><a href="#5-HTTPS和HTTP有什么区别" class="headerlink" title="5. HTTPS和HTTP有什么区别"></a><font color=DarkOrange>5. HTTPS和HTTP有什么区别</font></h4><p>http协议和https协议的区别：<strong>传输信息安全性不同</strong>、<strong>连接方式不同</strong>、<strong>端口不同</strong>、<strong>证书专申请方式不同</strong></p>
<ul>
<li>传输信息安全性不同<ul>
<li>http协议：是超文本传输协议，信息是明文传输。如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息</li>
<li>https协议：是具有安全性的SSL&#x2F;TLS加密传输协议，为浏览器和服务器之间的通信加密，确保数据传输的安全性</li>
</ul>
</li>
<li>连接方式不同<ul>
<li>http协议：http的连接很简单，是无状态的，客户端和服务器端都无法验证对方的身份</li>
<li>https协议：是由SSL&#x2F;TLS＋HTTP协议构建的可进行加密传输、身份认证的网络协议。客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份</li>
</ul>
</li>
<li>端口不同<ul>
<li>http协议：使用的端口是80</li>
<li>https协议：使用的端口是443</li>
</ul>
</li>
<li>证书申请方式不同<ul>
<li>http协议：无需申请证书</li>
<li>https协议：需要到ca申请证书，一般免费证书很少，需要交费</li>
</ul>
</li>
</ul>
<h4 id="6-HTTP-x2F-HTPS安全性"><a href="#6-HTTP-x2F-HTPS安全性" class="headerlink" title="6. HTTP&#x2F;HTPS安全性"></a><font color=DarkOrange>6. HTTP&#x2F;HTPS安全性</font></h4><h5 id="6-1-HTTP的安全性问题"><a href="#6-1-HTTP的安全性问题" class="headerlink" title="6.1 HTTP的安全性问题"></a><font color=DarkOrange>6.1 HTTP的安全性问题</font></h5><ul>
<li>使用明文进行通信，内容可能会被窃听</li>
<li>不验证通信方的身份，通信方的身份有可能遭遇伪装</li>
<li>无法证明报文的完整性，报文有可能遭篡改</li>
</ul>
<hr>
<p>HTTPs（Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲HTTPs是HTTP的安全版。HTTPs 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信。也就是说 HTTPs 使用了隧道进行通信。通过使用 SSL，HTTPs 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）</p>
<h5 id="6-2-对称密钥加密"><a href="#6-2-对称密钥加密" class="headerlink" title="6.2 对称密钥加密"></a><font color=DarkOrange>6.2 对称密钥加密</font></h5><p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥</p>
<ul>
<li>优点：运算速度快；</li>
<li>缺点：无法安全地将密钥传输给通信方</li>
</ul>
<h5 id="6-3-非对称密钥加密"><a href="#6-3-非对称密钥加密" class="headerlink" title="6.3 非对称密钥加密"></a><font color=DarkOrange>6.3 非对称密钥加密</font></h5><p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密</p>
<p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确</p>
<ul>
<li>优点：可以更安全地将公开密钥传输给通信发送方</li>
<li>缺点：运算速度慢</li>
</ul>
<h5 id="6-4-HTTPs-采用的加密方式"><a href="#6-4-HTTPs-采用的加密方式" class="headerlink" title="6.4 HTTPs 采用的加密方式"></a><font color=DarkOrange>6.4 HTTPs 采用的加密方式</font></h5><p>HTTPs 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证安全性，之后使用对称密钥加密进行通信来保证效率</p>
<h4 id="7-SSL-x2F-TLS协议的握手过程"><a href="#7-SSL-x2F-TLS协议的握手过程" class="headerlink" title="7. SSL&#x2F;TLS协议的握手过程"></a><font color=DarkOrange>7. SSL&#x2F;TLS协议的握手过程</font></h4><p>我们知道，HTTP 协议都是明文传输内容，在早期只展示静态内容时没有问题。伴随着互联网的快速发展，人们对于网络传输安全性的要求也越来越高，HTTPS 协议因此出现。如上图所示，在 HTTPS 加密中真正起作用的其实是 SSL&#x2F;TLS 协议。SSL&#x2F;TLS 协议作用在 HTTP 协议之下，对于上层应用来说，原来的发送接收数据流程不变，这就很好地兼容了老的 HTTP 协议，这也是软件开发中分层实现的体现</p>
<h5 id="7-1-SSL-Secure-Socket-Layer，安全套接字层"><a href="#7-1-SSL-Secure-Socket-Layer，安全套接字层" class="headerlink" title="7.1 SSL (Secure Socket Layer，安全套接字层)"></a><font color=DarkOrange>7.1 SSL (Secure Socket Layer，安全套接字层)</font></h5><p>SSL为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取，当前为3.0版本</p>
<p>SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等</p>
<h5 id="7-2-TLS-Transport-Layer-Security，传输层安全协议"><a href="#7-2-TLS-Transport-Layer-Security，传输层安全协议" class="headerlink" title="7.2 TLS (Transport Layer Security，传输层安全协议)"></a><font color=DarkOrange>7.2 TLS (Transport Layer Security，传输层安全协议)</font></h5><p>用于两个应用程序之间提供保密性和数据完整性</p>
<p>TLS 1.0是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本，可以理解为SSL 3.1，它是写入了 RFC 的。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面</p>
<h5 id="7-3-握手过程"><a href="#7-3-握手过程" class="headerlink" title="7.3 握手过程"></a><font color=DarkOrange>7.3 握手过程</font></h5><ul>
<li><p><strong>1-client hello：</strong> 握手第一步是客户端向服务端发送 Client Hello 消息，这个消息里包含了一个客户端生成的随机数 <strong>Random1</strong>、客户端支持的<strong>加密套件</strong>（Support Ciphers）和 SSL Version 等信息</p>
</li>
<li><p><strong>2-server hello：</strong> 第二步是服务端向客户端发送 Server Hello 消息，这个消息会从 Client Hello 传过来的 Support Ciphers 里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法，另外还会生成一份随机数 <strong>Random2</strong>。注意，至此客户端和服务端都拥有了两个随机数（Random1+ Random2），这两个随机数会在后续生成对称秘钥时用到</p>
</li>
<li><p><strong>3-server certificate：</strong> 这一步是服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥</p>
</li>
<li><p><strong>4-Server Hello Done：</strong> Server Hello Done 通知客户端 Server Hello 过程结束</p>
</li>
<li><p><strong>5-Client Key Exchange：</strong> 上面客户端根据服务器传来的公钥生成了 <strong>PreMaster Key</strong>，Client Key Exchange 就是将这个 key 传给服务端，服务端再用自己的私钥解出这个 <strong>PreMaster Key</strong> 得到客户端生成的 <strong>Random3</strong>。至此，客户端和服务端都拥有 <strong>Random1</strong> + <strong>Random2</strong> + <strong>Random3</strong>，两边再根据同样的算法就可以生成一份秘钥，握手结束后的应用层数据都是使用这个秘钥进行对称加密。为什么要使用三个随机数呢？这是因为 SSL&#x2F;TLS 握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解出来</p>
</li>
<li><p><strong>6-Change Cipher Spec(Client)：</strong> 这一步是客户端通知服务端后面再发送的消息都会使用前面协商出来的秘钥加密了，是一条事件消息</p>
</li>
<li><p><strong>7-Finished(Client)：</strong> 客户端发送Finished报文。该报文包含连接至今全部报文的整理校验值。这次握手协议是否能成功，要以服务器是否能够正确解密该报文作为判定标准</p>
</li>
<li><p><strong>8-Change Cipher Spec(Server)：</strong> 服务器同样发送Change Cipher Spec报文给客户端</p>
</li>
<li><p><strong>9-Finished(Server)：</strong> 服务器同样发送Finished报文给客户端</p>
</li>
<li><p><strong>10-11Application Data：</strong> 到这里，双方已安全地协商出了同一份秘钥，所有的应用层数据都会用这个秘钥加密后再通过 TCP 进行可靠传输</p>
</li>
<li><p><strong>12-Alert：warning, close notify：</strong> 最后由客户端断开连接。断开连接时，发送close_notify报文。上图做了一些省略，在这步之后再发送一种叫做MAC（Message Authentication Code）的报文摘要。MAC能够查知报文是否遭到篡改，从而保护报文的完整性</p>
</li>
</ul>
<h4 id="8-Get和Post区别"><a href="#8-Get和Post区别" class="headerlink" title="8. Get和Post区别"></a><font color=DarkOrange>8. Get和Post区别</font></h4><ul>
<li><p>一般约束为：GET是从服务器上获取数据，POST是向服务器传送数据</p>
</li>
<li><p>Get是不安全的，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的</p>
</li>
<li><p>Get传送的数据量较小，这主要是因为受URL长度限制；Post传送的数据量较大，一般被默认为不受限制</p>
</li>
<li><p>Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集</p>
</li>
<li><p>Get执行效率却比Post方法好。Get是form提交的默认方法</p>
</li>
<li><p>GET产生一个TCP数据包；POST产生两个TCP数据包（非必然，客户端可灵活决定）</p>
</li>
</ul>
<h4 id="9-从输入网址到获得页面的网络请求过程"><a href="#9-从输入网址到获得页面的网络请求过程" class="headerlink" title="9. 从输入网址到获得页面的网络请求过程"></a><font color=DarkOrange>9. 从输入网址到获得页面的网络请求过程</font></h4><ol>
<li>输入地址</li>
<li>浏览器查找域名的 IP 地址</li>
<li>浏览器向 web 服务器发送一个 HTTP 请求</li>
<li>服务器的永久重定向响应</li>
<li>服务器处理请求</li>
<li>服务器返回一个 HTTP 响应</li>
<li>浏览器显示 HTML</li>
<li>浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）</li>
</ol>
<p><strong>详细解读：</strong> <a href="https://zhuanlan.zhihu.com/p/133906695">点击跳转至网页</a></p>
<h4 id="10-TCP报头格式和UDP报头格式"><a href="#10-TCP报头格式和UDP报头格式" class="headerlink" title="10. TCP报头格式和UDP报头格式"></a><font color=DarkOrange>10. TCP报头格式和UDP报头格式</font></h4><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。运输层提供了进程间的逻辑通信，运输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个运输层实体之间有一条端到端的逻辑通信信道</p>
<ul>
<li><p>TCP和UDP的特点</p>
<ul>
<li><strong>传输控制协议 TCP</strong>（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）</li>
<li><strong>用户数据报协议 UDP</strong>（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。例如：视频传输、实时通信</li>
</ul>
</li>
<li><p>TCP首部格式</p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7m8ophl1uj317p0r3n7l.jpg" alt="74.jpg" style="zoom:30%;" /></div>

<ul>
<li><strong>序号 seq</strong> ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。[301,400]为序号301的数据长度，下一个则为401。</li>
<li><strong>确认号 ack</strong> ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</li>
<li><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度</li>
<li><strong>确认 ACK</strong> ：当 ACK&#x3D;1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1</li>
<li><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当 SYN&#x3D;1，ACK&#x3D;0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN&#x3D;1，ACK&#x3D;1。</li>
<li><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN&#x3D;1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</li>
<li><strong>窗口</strong> ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的</li>
</ul>
</li>
<li><p>UDP首部格式</p>
<p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的</p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7m8rstr7dj31580k211a.jpg" alt="73.jpg" style="zoom:33%;" /></div></li>
</ul>
<h4 id="11-TCP连接中如果断电怎么办"><a href="#11-TCP连接中如果断电怎么办" class="headerlink" title="11. TCP连接中如果断电怎么办"></a><font color=DarkOrange>11. TCP连接中如果断电怎么办</font></h4><p>都已经断电了，还能怎么办，等电来</p>
<h4 id="12-TCP滑动窗口"><a href="#12-TCP滑动窗口" class="headerlink" title="12. TCP滑动窗口"></a><font color=DarkOrange>12. TCP滑动窗口</font></h4><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7mctzf6qaj31hm0setua.jpg" alt="78.jpg" style="zoom:30%;" /></div>

<p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，<strong>接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小</strong></p>
<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口</p>
<p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {32, 33} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收</p>
<h4 id="13-TCP流量控制"><a href="#13-TCP流量控制" class="headerlink" title="13. TCP流量控制"></a><font color=DarkOrange>13. TCP流量控制</font></h4><ul>
<li>流量控制是为了控制发送方发送速率，保证接收方来得及接收</li>
<li>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据</li>
</ul>
<h4 id="14-TCP拥塞处理（Congestion-Handling）"><a href="#14-TCP拥塞处理（Congestion-Handling）" class="headerlink" title="14. TCP拥塞处理（Congestion Handling）"></a><font color=DarkOrange>14. TCP拥塞处理（Congestion Handling）</font></h4><p><strong>拥塞控制的一般原理：</strong></p>
<ul>
<li>在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏——产生拥塞(congestion)。</li>
<li>出现资源拥塞的条件：对资源需求的总和 &gt; 可用资源</li>
<li>若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降</li>
</ul>
<p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度</p>
<p>TCP 主要通过四种算法来进行拥塞控制：<strong>慢开始</strong>、<strong>拥塞避免</strong>、<strong>快重传</strong>、<strong>快恢复</strong></p>
<h4 id="15-TCP的LISTEN状态是什么"><a href="#15-TCP的LISTEN状态是什么" class="headerlink" title="15. TCP的LISTEN状态是什么"></a><font color=DarkOrange>15. TCP的LISTEN状态是什么</font></h4><p>TCP的LISTEN是服务器处于监听状态：</p>
<ul>
<li><strong>CLOSED：</strong> 初始状态</li>
<li><strong>LISTEN：</strong> 服务器处于监听状态</li>
<li><strong>TIME_WAIT：</strong> 客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态</li>
</ul>
<h4 id="16-Tcp中的拆包和粘包"><a href="#16-Tcp中的拆包和粘包" class="headerlink" title="16. Tcp中的拆包和粘包"></a><font color=DarkOrange>16. Tcp中的拆包和粘包</font></h4><ul>
<li><strong>粘包：</strong> 在socket通讯过程中，如果通讯的一端一次性连续发送多条数据包，tcp协议会将多个数据包打包成一个tcp报文发送出去，这就是所谓的粘包</li>
<li><strong>拆包：</strong> 而如果通讯的一端发送的数据包超过一次tcp报文所能传输的最大值时，就会将一个数据包拆成多个最大tcp长度的tcp报文分开传输，这就叫做拆包</li>
</ul>
<h4 id="17-HTTP的请求和响应报文"><a href="#17-HTTP的请求和响应报文" class="headerlink" title="17. HTTP的请求和响应报文"></a><font color=DarkOrange>17. HTTP的请求和响应报文</font></h4><ul>
<li><p>请求报文</p>
<ul>
<li>请求行：由三部分组成（请求方法、请求URL-不包括域名、HTTP版本协议）</li>
<li>请求头：由关键字-值对组成，每行一对</li>
<li>空行：通知服务器以下不再有请求头</li>
<li>请求体</li>
</ul>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7m91nfjb1j30i8065djn.jpg" alt="84.jpg" style="zoom:80%;" /></div>
</li>
<li><p>响应报文</p>
<ul>
<li>响应行：由三部分组成：服务器HTTP协议版本，响应状态码，状态码的文本描述</li>
<li>响应头：由关键字-值对组成，每行一对</li>
<li>空行：通知服务器以下不再有响应头</li>
<li>响应体</li>
</ul>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7m93g347vj30jk07faec.jpg" alt="96.jpg" style="zoom:80%;" /></div></li>
</ul>
<h4 id="18-HTTP方法"><a href="#18-HTTP方法" class="headerlink" title="18. HTTP方法"></a><font color=DarkOrange>18. HTTP方法</font></h4><ul>
<li>GET：获取资源<ul>
<li>当前网络请求中，绝大部分使用的是GET方法</li>
</ul>
</li>
<li>HEAD：获取报文首部<ul>
<li>和GET方法一样，但是不返回报文实体主体部分</li>
<li>主要用于确认 URL 的有效性以及资源更新的日期时间等</li>
</ul>
</li>
<li>POST：传输实体主体<ul>
<li>POST 主要用来传输数据，而 GET 主要用来获取资源</li>
</ul>
</li>
<li>PUT：上传文件<ul>
<li>由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法</li>
</ul>
</li>
<li>PATCH：对资源进行部分修改<ul>
<li>PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改</li>
</ul>
</li>
<li>DELETE：删除文件<ul>
<li>与 PUT 功能相反，并且同样不带验证机制</li>
</ul>
</li>
<li>OPTIONS：查询支持的方法<ul>
<li>查询指定的 URL 能够支持的方法</li>
<li>会返回 Allow：GET，POST，HEAD，OPTIONS 这样的内容</li>
</ul>
</li>
<li>CONNECT：要求在与代理服务器通信时建立隧道<ul>
<li>使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输</li>
</ul>
</li>
<li>TRACE：追踪路径<ul>
<li>服务器会将通信路径返回给客户端</li>
<li>发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输</li>
<li>通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）</li>
</ul>
</li>
</ul>
<h4 id="19-如何理解HTTP协议是无状态的"><a href="#19-如何理解HTTP协议是无状态的" class="headerlink" title="19. 如何理解HTTP协议是无状态的"></a><font color=DarkOrange>19. 如何理解HTTP协议是无状态的</font></h4><ul>
<li>HTTP协议是无状态的（stateless），指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系</li>
<li>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）</li>
<li>缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快</li>
</ul>
<h4 id="20-HTTP2-0特性"><a href="#20-HTTP2-0特性" class="headerlink" title="20. HTTP2.0特性"></a><font color=DarkOrange>20. HTTP2.0特性</font></h4><p>HTTP&#x2F;2的通过支持请求与响应的多路复用来减少延迟，通过压缩HTTP首部字段将协议开销降至最低，同时增加对请求优先级和服务器端推送的支持</p>
<h4 id="21-什么是短连接和长连接"><a href="#21-什么是短连接和长连接" class="headerlink" title="21. 什么是短连接和长连接"></a><font color=DarkOrange>21. 什么是短连接和长连接</font></h4><p>在HTTP&#x2F;1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话</p>
<p>而从HTTP&#x2F;1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure>

<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接</p>
<p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接</p>
<h4 id="22-Client如何实现长连接"><a href="#22-Client如何实现长连接" class="headerlink" title="22. Client如何实现长连接"></a><font color=DarkOrange>22. Client如何实现长连接</font></h4><p>使用TCP协议的<strong>KeepAlive</strong>机制与<strong>HeartBeat</strong>心跳包</p>
<ul>
<li><code>HeartBeat</code>心跳包</li>
<li>TCP协议的<code>KeepAlive</code>机制</li>
</ul>
<h4 id="23-Quic有什么优点相比Http2"><a href="#23-Quic有什么优点相比Http2" class="headerlink" title="23. Quic有什么优点相比Http2"></a><font color=DarkOrange>23. Quic有什么优点相比Http2</font></h4><ul>
<li><strong>HTTP1：</strong> 有连接无法复用、队头阻塞、协议开销大和安全因素等多个缺陷</li>
<li><strong>HTTP2：</strong> 通过多路复用、二进制流、Header 压缩等等技术，极大地提高了性能，但是还是存在着问题的</li>
<li><strong>Quic：</strong> 基于 UDP 实现，是 HTTP3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议.quic中加密认证的报文(TCP 协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改，注入和窃听。比如修改序列号、滑动窗口。这些行为有可能是出于性能优化，也有可能是主动攻击)。这样只要对 QUIC 报文任何修改，接收端都能够及时发现，有效地降低了安全风险</li>
</ul>
<p>此外quic还有向前纠错的能力，QUIC 协议有一个非常独特的特性，称为向前纠错 (Forward Error Correction，FEC)，每个数据包除了它本身的内容之外，还包括了部分其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传。向前纠错牺牲了每个数据包可以发送数据的上限，但是减少了因为丢包导致的数据重传，因为数据重传将会消耗更多的时间(包括确认数据包丢失、请求重传、等待新数据包等步骤的时间消耗)</p>
<h4 id="24-Grpc的优缺点"><a href="#24-Grpc的优缺点" class="headerlink" title="24. Grpc的优缺点"></a><font color=DarkOrange>24. Grpc的优缺点</font></h4><p>gRPC是Google公司基于Protobuf开发的跨语言的开源RPC框架。gRPC基于HTTP&#x2F;2协议设计，可以基于一个HTTP&#x2F;2链接提供多个服务，对于移动设备更加友好</p>
<p>最底层为TCP或Unix Socket协议，在此之上是HTTP&#x2F;2协议的实现，然后在HTTP&#x2F;2协议之上又构建了针对Go语言的gRPC核心库。应用程序通过gRPC插件生产的Stub代码和gRPC核心库通信，也可以直接和gRPC核心库通信</p>
<p><strong>优点：</strong></p>
<ul>
<li>protobuf二进制消息，性能好&#x2F;效率高（空间和时间效率都很不错）</li>
<li>proto文件生成目标代码，简单易用</li>
<li>序列化反序列化直接对应程序中的数据类，不需要解析后在进行映射(XML,JSON都是这种方式)</li>
<li>支持向前兼容（新加字段采用默认值）和向后兼容（忽略新加字段），简化升级</li>
<li>支持多种语言（可以把proto文件看做IDL文件）</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>GRPC尚未提供连接池，需要自行实现</li>
<li>尚未提供“服务发现”、“负载均衡”机制</li>
<li>因为基于HTTP2，绝大部多数<code>HTTP Server、Nginx</code>都尚不支持，即Nginx不能将GRPC请求作为HTTP请求来负载均衡，而是作为普通的TCP请求（nginx1.9版本已支持）</li>
<li>Protobuf二进制可读性差（貌似提供了Text_Fromat功能）默认不具备动态特性（可以通过动态定义生成消息类型或者动态编译支持）</li>
</ul>
<h4 id="25-Http1和Http2和Grpc之间的区别是什么"><a href="#25-Http1和Http2和Grpc之间的区别是什么" class="headerlink" title="25. Http1和Http2和Grpc之间的区别是什么"></a><font color=DarkOrange>25. Http1和Http2和Grpc之间的区别是什么</font></h4><p>在互联网流量传输只使用了几个网络协议。使用 <code>IPv4</code> 进行路由，使用 <code>TCP</code> 进行连接层面的流量控制，使用 <code>SSL/TLS</code> 协议实现传输安全，使用 <code>DNS</code> 进行域名解析，使用 <code>HTTP</code> 进行应用数据的传输</p>
<p><strong>HTTP2和HTTP1相比的新特性包括：</strong></p>
<ul>
<li><p>新的二进制格式（Binary Format）</p>
<ul>
<li>HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮</li>
</ul>
</li>
<li><p>多路复用（MultiPlexing）</p>
<ul>
<li>连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面</li>
</ul>
</li>
<li><p>Header压缩</p>
<p>Header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小</p>
</li>
<li><p>服务端推送（server push）</p>
<ul>
<li>服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能</li>
</ul>
</li>
</ul>
<hr>
<p>Grpc的设计目标是在任何环境下运行，支持可插拔的负载均衡，跟踪，运行状况检查和身份验证。它不仅支持数据中心内部和跨数据中心的服务调用，它也适用于分布式计算的最后一公里，将设备，移动应用程序和浏览器连接到后端服务，同时，它也是高性能的，而 HTTP2 恰好支持这些</p>
<p><strong>Grpc是基于http2的</strong></p>
<ul>
<li>HTTP2天然的通用性满足各种设备，场景</li>
<li>HTTP2的性能相对来说也是很好的，除非你需要极致的性能</li>
<li>HTTP2的安全性非常好，天然支持 SSL</li>
<li>HTTP2的鉴权也非常成熟</li>
<li>Grpc基于 HTTP2 多语言实现也更容易</li>
</ul>
<h4 id="26-数字签名、数字证书、SSL、https是什么关系"><a href="#26-数字签名、数字证书、SSL、https是什么关系" class="headerlink" title="26. 数字签名、数字证书、SSL、https是什么关系"></a><font color=DarkOrange>26. 数字签名、数字证书、SSL、https是什么关系</font></h4><p>HTTPS 是建立在密码学基础之上的一种安全通信协议，严格来说是基于 HTTP 协议和 SSL&#x2F;TLS 的组合</p>
<h4 id="27-Cookie"><a href="#27-Cookie" class="headerlink" title="27. Cookie"></a><font color=DarkOrange>27. Cookie</font></h4><p>HTTP协议是无状态的，主要是为了让HTTP协议尽可能简单，使得它能够处理大量事务。HTTP&#x2F;1.1引入Cookie来保存状态信息</p>
<p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。它用于告知服务端两个请求是否来自同一浏览器，并保持用户的登录状态</p>
<ul>
<li><p>用途</p>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
</li>
<li><p>创建过程</p>
<ul>
<li>服务器发送的响应报文包含Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中</li>
<li>客户端之后对同一个服务器发送请求时，会从浏览器中读出 Cookie 信息通过 Cookie 请求首部字段发送给服务器</li>
</ul>
</li>
<li><p>分类</p>
<ul>
<li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效</li>
<li>持久性 Cookie：指定一个特定的过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie</li>
</ul>
</li>
<li><p>JavaScript 获取 Cookie</p>
<ul>
<li>通过 <code>Document.cookie</code> 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie</li>
</ul>
</li>
<li><p>Secure 和 HttpOnly</p>
<ul>
<li>标记为 Secure 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障</li>
<li>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。因为跨域脚本 (XSS) 攻击常常使用 JavaScript 的 <code>Document.cookie</code>API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击</li>
</ul>
</li>
<li><p>作用域</p>
<ul>
<li>Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain&#x3D;mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）</li>
<li>Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (“&#x2F;“) 作为路径分隔符，子路径也会被匹配</li>
</ul>
</li>
</ul>
<h4 id="28-Session"><a href="#28-Session" class="headerlink" title="28. Session"></a><font color=DarkOrange>28. Session</font></h4><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全</p>
<p>Session 可以存储在服务器上的文件、数据库或者内存中，现在最常见的是将 Session 存储在内存型数据库中，比如 Redis</p>
<p>使用 Session 维护用户登录的过程如下：</p>
<ul>
<li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li>
<li>服务器验证该用户名和密码</li>
<li>如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 ID 称为 Session ID</li>
<li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中</li>
<li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之后的业务操作</li>
</ul>
<p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式</p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7mdikcs2aj31d80jr11b.jpg" alt="86.jpg" style="zoom:100%;" /></div>

<h4 id="29-Cookie与Session异同"><a href="#29-Cookie与Session异同" class="headerlink" title="29. Cookie与Session异同"></a><font color=DarkOrange>29. Cookie与Session异同</font></h4><p>Cookie 和 Session 都为了用来保存状态信息，都是保存客户端状态的机制，它们都是为了解决HTTP无状态的问题而所做的努力</p>
<ul>
<li>作用范围不同：Cookie 保存在客户端(浏览器)，Session 保存在服务器端</li>
<li>存取方式的不同：Cookie只能保存 ASCII，Session可以存任意数据类型，比如UserId等</li>
<li>有效期不同：Cookie可设置为长时间保持，比如默认登录功能功能，Session一般有效时间较短，客户端关闭或者Session超时都会失效</li>
<li>隐私策略不同：Cookie存储在客户端，信息容易被窃取;Session存储在服务端，相对安全一些</li>
<li>存储大小不同： 单个Cookie 保存的数据不能超过 4K，Session可存储数据远高于Cookie</li>
</ul>
<h4 id="30-浏览器禁用Cookie"><a href="#30-浏览器禁用Cookie" class="headerlink" title="30. 浏览器禁用Cookie"></a><font color=DarkOrange>30. 浏览器禁用Cookie</font></h4><p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递</p>
<h4 id="31-Cookie与Session选择"><a href="#31-Cookie与Session选择" class="headerlink" title="31. Cookie与Session选择"></a><font color=DarkOrange>31. Cookie与Session选择</font></h4><ul>
<li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存取任何类型的数据，因此在考虑数据复杂性时首选 Session</li>
<li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密</li>
<li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中</li>
</ul>
<h4 id="32-Unicode和ASCII以及Utf8的区别"><a href="#32-Unicode和ASCII以及Utf8的区别" class="headerlink" title="32. Unicode和ASCII以及Utf8的区别"></a><font color=DarkOrange>32. Unicode和ASCII以及Utf8的区别</font></h4><ul>
<li>Unicode 是字符集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储</li>
<li>ASCII 码一共规定了128个字符的编码，比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）</li>
<li>UTF-8 是编码规则</li>
</ul>
<h4 id="33-TFO的原理是什么"><a href="#33-TFO的原理是什么" class="headerlink" title="33. TFO的原理是什么"></a><font color=DarkOrange>33. TFO的原理是什么</font></h4><p>TCP快速打开（TCP Fast Open，TFO）是对TCP的一种简化握手手续的拓展，用于提高两端点间连接的打开速度</p>
<p>简而言之，就是在TCP的三次握手过程中传输实际有用的数据。这个扩展最初在Linux系统实现，Linux服务器，Linux系统上的Chrome浏览器，或运行在Linux上的其他支持的软件</p>
<p>它通过握手开始时的SYN包中的TFO cookie来验证一个之前连接过的客户端。如果验证成功，它可以在三次握手最终的ACK包收到之前就开始发送数据，这样便跳过了一个绕路的行为，更在传输开始时就降低了延迟</p>
<p>这个加密的Cookie被存储在客户端，在一开始的连接时被设定好。然后每当客户端连接时，这个Cookie被重复返回</p>
<p>请求Tcp Fast Open Cookie：</p>
<ul>
<li>客户端发送SYN数据包，该数据包包含Fast Open选项，且该选项的Cookie为空，这表明客户端请求Fast Open Cookie</li>
<li>支持TCP Fast Open的服务器生成Cookie，并将其置于SYN-ACK数据包中的Fast Open选项以发回客户端</li>
<li>客户端收到SYN-ACK后，缓存Fast Open选项中的Cookie</li>
</ul>
<h4 id="34-TIME-WAIT的作用"><a href="#34-TIME-WAIT的作用" class="headerlink" title="34. TIME_WAIT的作用"></a><font color=DarkOrange>34. TIME_WAIT的作用</font></h4><p>主动关闭的Socket端会进入TIME_WAIT状态，并且持续2MSL时间长度，MSL就是maximum segment lifetime(最大分节生命期），这是一个IP数据包能在互联网上生存的最长时间，超过这个时间将在网络中消失。MSL在RFC 1122上建议是2分钟，而源自berkeley的TCP实现传统上使用30秒，因而，TIME_WAIT状态一般维持在1-4分钟</p>
<ul>
<li>可靠地实现TCP全双工连接的终止</li>
<li>允许老的重复分节在网络中消逝</li>
</ul>
<h4 id="35-网络的性能指标有哪些"><a href="#35-网络的性能指标有哪些" class="headerlink" title="35. 网络的性能指标有哪些"></a><font color=DarkOrange>35. 网络的性能指标有哪些</font></h4><p>通常是以4个指标来衡量网络的性能，分别是带宽、延时、吞吐率、PPS（Packet Per Second），它们表示的意义如下：</p>
<ul>
<li>带宽：表示链路的最大传输速率，单位是 <code>b/s</code> （比特 &#x2F; 秒），带宽越大，其传输能力就越强</li>
<li>延时：表示请求数据包发送后，收到对端响应，所需要的时间延迟。不同的场景有着不同的含义，比如可以表示建立 <code>TCP</code> 连接所需的时间延迟，或一个数据包往返所需的时间延迟</li>
<li>吞吐率：表示单位时间内成功传输的数据量，单位是 <code>b/s</code>（比特 &#x2F; 秒）或者 <code>B/s</code>（字节 &#x2F; 秒），吞吐受带宽限制，带宽越大，吞吐率的上限才可能越高</li>
<li>PPS：全称是 <code>Packet Per Second</code>（包 &#x2F; 秒），表示以网络包为单位的传输速率，一般用来评估系统对于网络的转发能</li>
</ul>
<p>除了以上这四种基本的指标，还有一些其他常用的性能指标，比如：</p>
<ul>
<li>网络的可用性：表示网络能否正常通信</li>
<li>并发连接数：表示 TCP 连接数量</li>
<li>丢包率：表示所丢失数据包数量占所发送数据组的比率</li>
<li>重传率：表示重传网络包的比例</li>
</ul>
<h4 id="36-如何区分流量控制和拥塞控制"><a href="#36-如何区分流量控制和拥塞控制" class="headerlink" title="36. 如何区分流量控制和拥塞控制"></a><font color=DarkOrange>36. 如何区分流量控制和拥塞控制</font></h4><ul>
<li>拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷</li>
<li>拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素</li>
<li>流量控制往往指在给定的发送端和接收端之间的点对点通信量的控制</li>
<li>流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收</li>
<li>流量控制属于通信双方协商；拥塞控制涉及通信链路全局</li>
<li>流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整</li>
<li>实际最终发送窗口 &#x3D; min{流控发送窗口，拥塞窗口}</li>
</ul>
<h4 id="37-解释RTO，RTT和超时重传"><a href="#37-解释RTO，RTT和超时重传" class="headerlink" title="37. 解释RTO，RTT和超时重传"></a><font color=DarkOrange>37. 解释RTO，RTT和超时重传</font></h4><ul>
<li><strong>超时重传</strong>：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况：<ul>
<li>发送的数据没能到达接收端，所以对方没有响应。</li>
<li>接收端接收到数据，但是ACK报文在返回过程中丢失</li>
<li>接收端拒绝或丢弃数据</li>
</ul>
</li>
<li><strong>RTO</strong>：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间。就是重传间隔<ul>
<li>通常每次重传RTO是前一次重传间隔的两倍，计量单位通常是RTT。例：1RTT，2RTT，4RTT，8RTT……</li>
<li>重传次数到达上限之后停止重传</li>
</ul>
</li>
<li><strong>RTT</strong>：数据从发送到接收到对方响应之间的时间间隔，即数据报在网络中一个往返用时。大小不稳定</li>
</ul>
<h4 id="38-停止等待和超时重传"><a href="#38-停止等待和超时重传" class="headerlink" title="38. 停止等待和超时重传"></a><font color=DarkOrange>38. 停止等待和超时重传</font></h4><ul>
<li>停止等待：通常我们说如果A和B双方建立好tcp连接后就可以相互发送数据了，A为发送方，B为接收方。因为这里讨论可靠传输原理，所以把传输的数据单元称为分组。“停止等待”就是每发送完一个分组就停止发送，等待对方确认后再发送下一个分组。停止等待协议考虑了数据在网络中传输出现的几种情况来提供有效措施保障数据的可靠传输，下面我们就一一来介绍这几种情况</li>
<li>超时重传：原理是在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的ACK报文，那么就重新发送数据，直到发送成功为止。影响超时重传机制协议效率的一个关键参数是重传超时时间（RTO，Retransmission TimeOut）</li>
</ul>
<h4 id="39-交换机和路由器的区别"><a href="#39-交换机和路由器的区别" class="headerlink" title="39. 交换机和路由器的区别"></a><font color=DarkOrange>39. 交换机和路由器的区别</font></h4><ul>
<li>交换机是一根网线上网，但是大家上网是分别拨号，各自使用自己的宽带，大家上网没有影响。而路由器比交换机多了一个虚拟拨号功能，通过同一台路由器上网的电脑是共用一个宽带账号，大家上网要相互影响</li>
<li>交换机工作在中继层，交换机根据MAC地址寻址。路由器工作在网络层，根据IP地址寻址，路由器可以处理TCP&#x2F;IP协议，而交换机不可以</li>
<li>交换机可以使连接它的多台电脑组成局域网，如果还有代理服务器的话还可以实现同时上网功能而且局域网所有电脑是共享它的带宽速率的，但是交换机没有路由器的自动识别数据包发送和到达地址的功能。路由器可以自动识别数据包发送和到达的地址，路由器相当于马路上的警察，负责交通疏导和指路的</li>
<li>举几个例子,路由器是小邮局，就一个地址(IP)，负责一个地方的收发(个人电脑，某个服务器，所以你家上网要这个东西)，交换机是省里的大邮政中心，负责由一个地址给各个小地方的联系。简单的说路由器专管入网，交换机只管配送，路由路由就是给你找路让你上网的，交换机只负责开门，交换机上面要没有路由你是上不了网的</li>
<li>路由器提供了防火墙的服务。路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包传送和未知目标网络数据包的传送，从而可以防止广播风暴</li>
</ul>
<h4 id="40-子网掩码的作用"><a href="#40-子网掩码的作用" class="headerlink" title="40. 子网掩码的作用"></a><font color=DarkOrange>40. 子网掩码的作用</font></h4><p>内网中192.168.1.199的前三组是网络号，后一组是主机号，子网掩码就是255.255.255.0</p>
<p><strong>首先要说明的是</strong>：不是某个IP的网络号和主机号决定子网掩码是什么，而是子网掩码决定了某个IP地址的网络号与主机号是什么，IP地址是要搭配子网掩码使用的。例如上面的子网掩码决定了192.168.1.199的前三段192.168.1是网络号，最后一段199是主机号</p>
<p>我们再来理解子网掩码的作用，先举个例子，市面上的两个厂家都生产电子秤，每个厂家都坚称他们的秤最准，那你是怎么知道他们的秤到底准不准？很简单，你去找一个 1KG 的国际千克原器，各放到他们的秤上测量，如果秤的测量值是1KG，那这把秤就是准的，<strong>子网掩码的作用</strong>就相当于这个大家公认的国际千克原器，是我们测量两个IP是否属于同一个网段的一个工具（应该说是让你知道某个IP地址的网络号与主机号分别是什么） </p>
<h4 id="41-WebSocket是什么"><a href="#41-WebSocket是什么" class="headerlink" title="41. WebSocket是什么"></a><font color=DarkOrange>41. WebSocket是什么</font></h4><p>WebSocket 是一种在单个TCP连接上进行全双工通信的协议。WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据</p>
<p>在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输</p>
<p>WebSocket本质上一种计算机网络应用层的协议，用来弥补http协议在持久通信能力上的不足</p>
<p>WebSocket 协议在2008年诞生，2011年成为国际标准。现在最新版本浏览器都已经支持了</p>
<p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种</p>
<p>WebSocket 的其他特点包括：</p>
<ul>
<li>建立在 TCP 协议之上，服务器端的实现比较容易</li>
<li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器</li>
<li>数据格式比较轻量，性能开销小，通信高效</li>
<li>可以发送文本，也可以发送二进制数据</li>
<li>没有同源限制，客户端可以与任意服务器通信</li>
<li>协议标识符是<code>ws</code>（如果加密，则为<code>wss</code>），服务器网址就是 URL</li>
</ul>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h86wdeuto8j30bm08ogmr.jpg" alt="image.png" style="zoom:100%;" /></div>

<h5 id="41-1-为什么需要WebSocket"><a href="#41-1-为什么需要WebSocket" class="headerlink" title="41.1 为什么需要WebSocket"></a><font color=DarkOrange>41.1 为什么需要WebSocket</font></h5><p>我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？</p>
<p>因为 HTTP 协议有一个缺陷：通信只能由客户端发起，不具备服务器推送能力</p>
<p>举例来说，我们想了解查询今天的实时数据，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息</p>
<p>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用”轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）</p>
<p>在 WebSocket 协议出现以前，创建一个和服务端进双通道通信的 web 应用，需要依赖HTTP协议，进行不停的轮询，这会导致一些问题：</p>
<ul>
<li>服务端被迫维持来自每个客户端的大量不同的连接</li>
<li>大量的轮询请求会造成高开销，比如会带上多余的header，造成了无用的数据传输</li>
</ul>
<p>http协议本身是没有持久通信能力的，但是我们在实际的应用中，是很需要这种能力的，所以，为了解决这些问题，WebSocket协议由此而生。并且在HTML5标准中增加了有关WebSocket协议的相关api，所以只要实现了HTML5标准的客户端，就可以与支持WebSocket协议的服务器进行全双工的持久通信了</p>
<h5 id="41-2-WebSocket与HTTP的区别"><a href="#41-2-WebSocket与HTTP的区别" class="headerlink" title="41.2 WebSocket与HTTP的区别"></a><font color=DarkOrange>41.2 WebSocket与HTTP的区别</font></h5><ul>
<li><strong>相同点：</strong> 都是一样基于TCP的，都是可靠性传输协议。都是应用层协议</li>
<li><strong>联系：</strong> WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的</li>
<li>WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息，而HTTP是单向的</li>
<li>WebSocket是需要浏览器和服务器握手进行建立连接的，而http是浏览器发起向服务器的连接</li>
<li><strong>注意：</strong> 虽然HTTP&#x2F;2也具备服务器推送功能，但HTTP&#x2F;2 只能推送静态资源，无法推送指定的信息</li>
</ul>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h86xbj214qj30hg0e7djz.jpg" alt="image.png" style="zoom:80%;" /></div>

<h5 id="41-3-WebSocket和Socket的区别"><a href="#41-3-WebSocket和Socket的区别" class="headerlink" title="41.3 WebSocket和Socket的区别"></a><font color=DarkOrange>41.3 WebSocket和Socket的区别</font></h5><p>Socket是应用层与TCP&#x2F;IP协议通信的中间软件抽象层，它是一组接口。而WebSocket协议是一个完整的应用层协议，拥有一套完整的API</p>
<h4 id="42-WebSocket协议的原理"><a href="#42-WebSocket协议的原理" class="headerlink" title="42. WebSocket协议的原理"></a><font color=DarkOrange>42. WebSocket协议的原理</font></h4><p>与http协议一样，WebSocket协议也需要通过已建立的TCP连接来传输数据。具体实现上是通过http协议建立通道，然后在此基础上用真正的WebSocket协议进行通信，所以WebSocket协议和http协议是有一定的交叉关系的</p>
<p>首先，WebSocket 是一个持久化的协议，相对于 HTTP 这种非持久的协议来说。简单的举个例子吧，用目前应用比较广泛的 PHP 生命周期来解释</p>
<p>HTTP 的生命周期通过 Request 来界定，也就是一个 Request 一个 Response ，那么在 HTTP1.0 中，这次 HTTP 请求就结束了</p>
<p>在 HTTP1.1 中进行了改进，使得有一个 keep-alive，也就是说，在一个 HTTP 连接中，可以发送多个 Request，接收多个 Response。但是请记住 Request &#x3D; Response， 在 HTTP 中永远是这样，也就是说一个 Request 只能有一个 Response。而且这个 Response 也是被动的，不能主动发起</p>
<p>首先 WebSocket 是基于 HTTP 协议的，或者说借用了 HTTP 协议来完成一部分握手</p>
<p>首先我们来看个典型的 WebSocket 握手</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /chat <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Host</span>: server.<span class="property">example</span>.<span class="property">com</span></span><br><span class="line"><span class="title class_">Upgrade</span>: websocket</span><br><span class="line"><span class="title class_">Connection</span>: <span class="title class_">Upgrade</span></span><br><span class="line"><span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Key</span>: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line"><span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Protocol</span>: chat, superchat</span><br><span class="line"><span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Version</span>: <span class="number">13</span></span><br><span class="line"><span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//example.com</span></span><br></pre></td></tr></table></figure>

<p>熟悉 HTTP 的童鞋可能发现了，这段类似 HTTP 协议的握手请求中，多了这么几个东西。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Upgrade</span>: websocket</span><br><span class="line"><span class="title class_">Connection</span>: <span class="title class_">Upgrade</span></span><br></pre></td></tr></table></figure>

<p>这个就是 WebSocket 的核心了，告诉 Apache 、 Nginx 等服务器：注意啦，我发起的请求要用 WebSocket 协议，快点帮我找到对应的助理处理~而不是那个老土的 HTTP。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Key</span>: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line"><span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Protocol</span>: chat, superchat</span><br><span class="line"><span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Version</span>: <span class="number">13</span></span><br></pre></td></tr></table></figure>

<p>首先， Sec-WebSocket-Key 是一个 Base64 encode 的值，这个是浏览器随机生成的，告诉服务器：泥煤，不要忽悠我，我要验证你是不是真的是 WebSocket 助理</p>
<p>然后， Sec_WebSocket-Protocol 是一个用户定义的字符串，用来区分同 URL 下，不同的服务所需要的协议。简单理解：今晚我要服务A，别搞错啦~</p>
<p>最后， Sec-WebSocket-Version 是告诉服务器所使用的 WebSocket Draft （协议版本），在最初的时候，WebSocket 协议还在 Draft 阶段，各种奇奇怪怪的协议都有，而且还有很多期奇奇怪怪不同的东西，什么 Firefox 和 Chrome 用的不是一个版本之类的，当初 WebSocket 协议太多可是一个大难题。。不过现在还好，已经定下来啦~大家都使用同一个版本： 服务员，我要的是13岁的噢→_→</p>
<p>然后服务器会返回下列东西，表示已经接受到请求， 成功建立 WebSocket 啦</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">101</span> <span class="title class_">Switching</span> <span class="title class_">Protocols</span></span><br><span class="line"><span class="title class_">Upgrade</span>: websocket</span><br><span class="line"><span class="title class_">Connection</span>: <span class="title class_">Upgrade</span></span><br><span class="line"><span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Accept</span>: <span class="title class_">HSmrc0</span>sMlYUkAGmm5OPpG2HaGWk=</span><br><span class="line"><span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Protocol</span>: chat</span><br></pre></td></tr></table></figure>

<p>这里开始就是 HTTP 最后负责的区域了，告诉客户，我已经成功切换协议啦~</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Upgrade</span>: websocket</span><br><span class="line"><span class="title class_">Connection</span>: <span class="title class_">Upgrade</span></span><br></pre></td></tr></table></figure>

<p>依然是固定的，告诉客户端即将升级的是 WebSocket 协议，而不是 mozillasocket，lurnarsocket 或者 shitsocket</p>
<p>然后， Sec-WebSocket-Accept 这个则是经过服务器确认，并且加密过后的 Sec-WebSocket-Key 。 服务器：好啦好啦，知道啦，给你看我的 ID CARD 来证明行了吧</p>
<p>后面的， Sec-WebSocket-Protocol 则是表示最终使用的协议</p>
<p>至此，HTTP 已经完成它所有工作了，接下来就是完全按照 WebSocket 协议进行了</p>
<p><strong>WebSocket连接的过程：</strong></p>
<ul>
<li>首先，客户端发起http请求，经过3次握手后，建立起TCP连接；http请求里存放WebSocket支持的版本号等信息，如：Upgrade、Connection、WebSocket-Version等</li>
<li>然后，服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据</li>
<li>最后，客户端收到连接成功的消息后，开始借助于TCP传输信道进行全双工通信</li>
</ul>
<h4 id="43-Websocket的优缺点"><a href="#43-Websocket的优缺点" class="headerlink" title="43. Websocket的优缺点"></a><font color=DarkOrange>43. Websocket的优缺点</font></h4><ul>
<li><strong>优点：</strong> WebSocket协议一旦建议后，互相沟通所消耗的请求头是很小的；服务器可以向客户端推送消息了</li>
<li><strong>缺点：</strong> 少部分浏览器不支持，浏览器支持的程度与方式有区别（IE10）</li>
</ul>
<h4 id="44-WebSocket应用场景"><a href="#44-WebSocket应用场景" class="headerlink" title="44. WebSocket应用场景"></a><font color=DarkOrange>44. WebSocket应用场景</font></h4><ul>
<li>即时聊天通信</li>
<li>多玩家游戏</li>
<li>在线协同编辑&#x2F;编辑</li>
<li>实时数据流的拉取与推送</li>
<li>体育&#x2F;游戏实况</li>
<li>实时地图位置</li>
<li>即时<code>Web</code>应用程序：即时<code>Web</code>应用程序使用一个<code>Web</code>套接字在客户端显示数据，这些数据由后端服务器连续发送。在<code>WebSocke</code>t中，数据被连续推送&#x2F;传输到已经打开的同一连接中，这就是为什么<code>WebSocket</code>更快并提高了应用程序性能的原因。 例如在交易网站或比特币交易中，这是最不稳定的事情，它用于显示价格波动，数据被后端服务器使用Web套接字通道连续推送到客户端</li>
<li>游戏应用程序：在游戏应用程序中，你可能会注意到，服务器会持续接收数据，而不会刷新用户界面。屏幕上的用户界面会自动刷新，而且不需要建立新的连接，因此在<code>WebSocket</code>游戏应用程序中非常有帮助</li>
<li>聊天应用程序：聊天应用程序仅使用<code>WebSocket</code>建立一次连接，便能在订阅户之间交换，发布和广播消息。它重复使用相同的<code>WebSocket</code>连接，用于发送和接收消息以及一对一的消息传输</li>
</ul>
<h5 id="44-1-不能使用WebSocket的场景"><a href="#44-1-不能使用WebSocket的场景" class="headerlink" title="44.1 不能使用WebSocket的场景"></a><font color=DarkOrange>44.1 不能使用WebSocket的场景</font></h5><p>如果我们需要通过网络传输的任何实时更新或连续数据流，则可以使用<code>WebSocket</code>。如果我们要获取旧数据，或者只想获取一次数据供应用程序使用，则应该使用<code>HTTP</code>协议，不需要很频繁或仅获取一次的数据可以通过简单的<code>HTTP</code>请求查询，因此在这种情况下最好不要使用<code>WebSocket</code></p>
<p><strong>注意：</strong> 如果仅加载一次数据，则<code>RESTful</code> <code>Web</code>服务足以从服务器获取数据</p>
<h4 id="45-WebSocket断线重连"><a href="#45-WebSocket断线重连" class="headerlink" title="45. WebSocket断线重连"></a><font color=DarkOrange>45. WebSocket断线重连</font></h4><p>心跳就是客户端定时的给服务端发送消息，证明客户端是在线的， 如果超过一定的时间没有发送则就是离线了</p>
<h5 id="45-1-如何判断在线或离线"><a href="#45-1-如何判断在线或离线" class="headerlink" title="45.1 如何判断在线或离线"></a><font color=DarkOrange>45.1 如何判断在线或离线</font></h5><p>当客户端第一次发送请求至服务端时会携带唯一标识、以及时间戳，服务端到db或者缓存去查询改请求的唯一标识，如果不存在就存入db或者缓存中</p>
<p>第二次客户端定时再次发送请求依旧携带唯一标识、以及时间戳，服务端到db或者缓存去查询改请求的唯一标识，如果存在就把上次的时间戳拿取出来，使用当前时间戳减去上次的时间</p>
<p>得出的毫秒秒数判断是否大于指定的时间，若小于的话就是在线，否则就是离线</p>
<h5 id="45-2-如何解决断线问题"><a href="#45-2-如何解决断线问题" class="headerlink" title="45.2 如何解决断线问题"></a><font color=DarkOrange>45.2 如何解决断线问题</font></h5><p>通过查阅资料了解到 nginx 代理的 websocket 转发，无消息连接会出现超时断开问题。网上资料提到解决方案两种，一种是修改nginx配置信息，第二种是websocket发送心跳包</p>
<ul>
<li>断线的可能原因1：websocket超时没有消息自动断开连接<ul>
<li>解决方案：这时候我们就需要知道服务端设置的超时时长是多少，在小于超时时间内发送心跳包，有2中方案:一种是客户端主动发送上行心跳包，另一种方案是服务端主动发送下行心跳包</li>
</ul>
</li>
<li>断线的可能原因2：websocket异常包括服务端出现中断，交互切屏等等客户端异常中断等<ul>
<li>当若服务端宕机了，客户端怎么做、服务端再次上线时怎么做？</li>
<li>客户端则需要断开连接，通过onclose 关闭连接，服务端再次上线时则需要清除之间存的数据，若不清除 则会造成只要请求到服务端的都会被视为离线</li>
<li>针对这种异常的中断解决方案就是处理重连，下面我们给出的重连方案是使用js库处理：引入reconnecting-websocket.min.js，ws建立链接方法使用js库api方法</li>
</ul>
</li>
</ul>
<h4 id="46-WebSocket总结"><a href="#46-WebSocket总结" class="headerlink" title="46. WebSocket总结"></a><font color=DarkOrange>46. WebSocket总结</font></h4><ul>
<li>WebSocket 是为了在 web 应用上进行双通道通信而产生的协议，相比于轮询HTTP请求的方式，WebSocket 有节省服务器资源，效率高等优点</li>
<li>WebSocket 中的掩码是为了防止早期版本中存在中间缓存污染攻击等问题而设置的，客户端向服务端发送数据需要掩码，服务端向客户端发送数据不需要掩码</li>
<li>WebSocket 中 Sec-WebSocket-Key 的生成算法是拼接服务端和客户端生成的字符串，进行SHA1哈希算法，再用base64编码</li>
<li>WebSocket 协议握手是依靠 HTTP 协议的，依靠于 HTTP 响应101进行协议升级转换</li>
</ul>
<p>WebSocket相关知识参考链接：<a href="https://juejin.cn/post/7020964728386093093#heading-4">点击跳转</a></p>
<hr>
<h4 id="47-内网穿透"><a href="#47-内网穿透" class="headerlink" title="47. 内网穿透"></a><font color=DarkOrange>47. 内网穿透</font></h4><h5 id="47-1-什么是内网穿透"><a href="#47-1-什么是内网穿透" class="headerlink" title="47.1 什么是内网穿透"></a><font color=DarkOrange>47.1 什么是内网穿透</font></h5><p>内网穿透，也就是 NAT 穿透，进行 NAT 穿透是为了使具有某一个特定源 IP 地址和源端口号的数据包不被 NAT 设备屏蔽而正确路由到内网主机</p>
<p><strong>用一句话将就是：通过公网IP的端口映射实现能访问内网服务器的资源</strong></p>
<h5 id="47-2-实现方式"><a href="#47-2-实现方式" class="headerlink" title="47.2 实现方式"></a><font color=DarkOrange>47.2 实现方式</font></h5><p><strong>通过FRP开源方式实现</strong></p>
<p>FRP使用 Go 语言开发，可以支持 Windows、Linux、macOS、ARM 等多平台部署。frp内网穿透无需多复杂的配置就可以达到比较好的穿透效果，具有较强的扩展性，支持tcp, udp, http, https 协议，并且 web 服务支持根据域名进行路由转发。此外，<strong>FRP 提供了一种新的代理类型 XTCP ，可以在传输大量数据时让流量不经过服务器中转，用于实现点对点穿透，</strong>当然，此功能并不能保证在你的网络环境 100% 可用，成功率较低，而且还要求访问端也得运行 FRP 客户端 (目前手机端ios没有frp客户端软件)。由于实现条件较多，所以有文件传输需求的朋友但必须用frp的朋友还是建议买带宽稍大一点的 VPS 会比较省心。<strong>frp适合有linux基础的个人，且需要自购一个云主机做中转，企业追求稳定可以考虑其他方式</strong></p>
<p>FRP实现内网穿透，就在于使用反向代理，使得真实的服务端得以隐藏。当外部用户（client）请求访问服务端VPS的时候，服务端VPS是客户端的反向代理服务器，反向代理服务器会帮我们把请求转发到真实的服务器那里去。这样就实现了内网穿透。即：</p>
<ul>
<li>Client &#x3D; 外部用户</li>
<li>proxy &#x3D; 公网服务器（需要在服务器上搭建FRP服务端）</li>
<li>Server &#x3D; 内网服务器（需要在服务器上搭建FRP客户端）</li>
</ul>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h8abwwqcesj30zq06kju4.jpg" alt="image.png" style="zoom:50%;" /></div>



<hr>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
