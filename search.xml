<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CodeTop算法题</title>
    <url>/2022/11/14/CodeTop%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    <content><![CDATA[<p>面试LeetCode算法题整理，按照出现的频率依次递减排序，题目类型包含：简单、中等、困难</p>
<p>CodeTop地址：<a href="https://codetop.cc/home">点击跳转</a></p>
<p><strong>备注：</strong>出现的频率会随时间变化而变化，具体以CodeTop出现频率为准</p>
<h4 id="1-无重复字符的最长子串-中等"><a href="#1-无重复字符的最长子串-中等" class="headerlink" title="1. 无重复字符的最长子串-中等"></a>1. 无重复字符的最长子串-中等</h4><h4 id="2-反转链表-容易"><a href="#2-反转链表-容易" class="headerlink" title="2. 反转链表-容易"></a>2. 反转链表-容易</h4><h4 id="3-LRU缓存-中等"><a href="#3-LRU缓存-中等" class="headerlink" title="3. LRU缓存-中等"></a>3. LRU缓存-中等</h4><h4 id="4-数组中的第K个最大元素-中等"><a href="#4-数组中的第K个最大元素-中等" class="headerlink" title="4. 数组中的第K个最大元素-中等"></a>4. 数组中的第K个最大元素-中等</h4><h4 id="5-K个一组翻转链表-困难"><a href="#5-K个一组翻转链表-困难" class="headerlink" title="5. K个一组翻转链表-困难"></a>5. K个一组翻转链表-困难</h4><h4 id="6-三数之和-中等"><a href="#6-三数之和-中等" class="headerlink" title="6. 三数之和-中等"></a>6. 三数之和-中等</h4><h4 id="7-最大子数组和-中等"><a href="#7-最大子数组和-中等" class="headerlink" title="7. 最大子数组和-中等"></a>7. 最大子数组和-中等</h4><h4 id="8-排序数组-快排-中等"><a href="#8-排序数组-快排-中等" class="headerlink" title="8. 排序数组-快排-中等"></a>8. 排序数组-快排-中等</h4><h4 id="9-合并两个有序链表-简单"><a href="#9-合并两个有序链表-简单" class="headerlink" title="9. 合并两个有序链表-简单"></a>9. 合并两个有序链表-简单</h4><h4 id="10-两数之和-简单"><a href="#10-两数之和-简单" class="headerlink" title="10. 两数之和-简单"></a>10. 两数之和-简单</h4><h4 id="11-二叉树的层序遍历-中等"><a href="#11-二叉树的层序遍历-中等" class="headerlink" title="11. 二叉树的层序遍历-中等"></a>11. 二叉树的层序遍历-中等</h4><h4 id="12-搜索旋转排序数组-中等"><a href="#12-搜索旋转排序数组-中等" class="headerlink" title="12. 搜索旋转排序数组-中等"></a>12. 搜索旋转排序数组-中等</h4><h4 id="13-买卖股票的最佳时机-简单"><a href="#13-买卖股票的最佳时机-简单" class="headerlink" title="13. 买卖股票的最佳时机-简单"></a>13. 买卖股票的最佳时机-简单</h4><h4 id="14-有效的括号-简单"><a href="#14-有效的括号-简单" class="headerlink" title="14. 有效的括号-简单"></a>14. 有效的括号-简单</h4><h4 id="15-岛屿数量-中等"><a href="#15-岛屿数量-中等" class="headerlink" title="15. 岛屿数量-中等"></a>15. 岛屿数量-中等</h4><h4 id="16-环形链表-简单"><a href="#16-环形链表-简单" class="headerlink" title="16. 环形链表-简单"></a>16. 环形链表-简单</h4><h4 id="17-最长回文子串-中等"><a href="#17-最长回文子串-中等" class="headerlink" title="17. 最长回文子串-中等"></a>17. 最长回文子串-中等</h4><h4 id="18-叉树的锯齿形层序遍历-中等"><a href="#18-叉树的锯齿形层序遍历-中等" class="headerlink" title="18. 叉树的锯齿形层序遍历-中等"></a>18. 叉树的锯齿形层序遍历-中等</h4><h4 id="19-合并两个有序数组-简单"><a href="#19-合并两个有序数组-简单" class="headerlink" title="19. 合并两个有序数组-简单"></a>19. 合并两个有序数组-简单</h4><h4 id="20-二叉树的最近公共祖先-中等"><a href="#20-二叉树的最近公共祖先-中等" class="headerlink" title="20. 二叉树的最近公共祖先-中等"></a>20. 二叉树的最近公共祖先-中等</h4><h4 id="21-全排列-中等"><a href="#21-全排列-中等" class="headerlink" title="21. 全排列-中等"></a>21. 全排列-中等</h4><h4 id="22-相交链表-简单"><a href="#22-相交链表-简单" class="headerlink" title="22. 相交链表-简单"></a>22. 相交链表-简单</h4><h4 id="23-螺旋矩阵-中等"><a href="#23-螺旋矩阵-中等" class="headerlink" title="23. 螺旋矩阵-中等"></a>23. 螺旋矩阵-中等</h4><h4 id="24-合并K个升序链表-困难"><a href="#24-合并K个升序链表-困难" class="headerlink" title="24. 合并K个升序链表-困难"></a>24. 合并K个升序链表-困难</h4><h4 id="25-反转链表-II-中等"><a href="#25-反转链表-II-中等" class="headerlink" title="25. 反转链表 II-中等"></a>25. 反转链表 II-中等</h4><h4 id="26-字符串相加-简单"><a href="#26-字符串相加-简单" class="headerlink" title="26. 字符串相加-简单"></a>26. 字符串相加-简单</h4><h4 id="27-环形链表-II-中等"><a href="#27-环形链表-II-中等" class="headerlink" title="27. 环形链表 II-中等"></a>27. 环形链表 II-中等</h4><h4 id="28-长递增子序列-中等"><a href="#28-长递增子序列-中等" class="headerlink" title="28. 长递增子序列-中等"></a>28. 长递增子序列-中等</h4><h4 id="29-接雨水-困难"><a href="#29-接雨水-困难" class="headerlink" title="29. 接雨水-困难"></a>29. 接雨水-困难</h4><h4 id="30-二叉树中的最大路径和-困难"><a href="#30-二叉树中的最大路径和-困难" class="headerlink" title="30. 二叉树中的最大路径和-困难"></a>30. 二叉树中的最大路径和-困难</h4><h4 id="31-重排链表-中等"><a href="#31-重排链表-中等" class="headerlink" title="31. 重排链表-中等"></a>31. 重排链表-中等</h4><h4 id="32-二叉树的中序遍历-简单"><a href="#32-二叉树的中序遍历-简单" class="headerlink" title="32. 二叉树的中序遍历-简单"></a>32. 二叉树的中序遍历-简单</h4><h4 id="33-二分查找-简单"><a href="#33-二分查找-简单" class="headerlink" title="33. 二分查找-简单"></a>33. 二分查找-简单</h4><h4 id="34-编辑距离-困难"><a href="#34-编辑距离-困难" class="headerlink" title="34. 编辑距离-困难"></a>34. 编辑距离-困难</h4><h4 id="35-用栈实现队列-简单"><a href="#35-用栈实现队列-简单" class="headerlink" title="35. 用栈实现队列-简单"></a>35. 用栈实现队列-简单</h4><h4 id="36-寻找两个正序数组的中位数-困难"><a href="#36-寻找两个正序数组的中位数-困难" class="headerlink" title="36. 寻找两个正序数组的中位数-困难"></a>36. 寻找两个正序数组的中位数-困难</h4><h4 id="37-二叉树的右视图-中等"><a href="#37-二叉树的右视图-中等" class="headerlink" title="37. 二叉树的右视图-中等"></a>37. 二叉树的右视图-中等</h4><h4 id="38-除链表的倒数第N个结点-中等"><a href="#38-除链表的倒数第N个结点-中等" class="headerlink" title="38. 除链表的倒数第N个结点-中等"></a>38. 除链表的倒数第N个结点-中等</h4><h4 id="39-爬楼梯-简单"><a href="#39-爬楼梯-简单" class="headerlink" title="39. 爬楼梯-简单"></a>39. 爬楼梯-简单</h4><h4 id="40-合并区间-中等"><a href="#40-合并区间-中等" class="headerlink" title="40. 合并区间-中等"></a>40. 合并区间-中等</h4><hr>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang面试题</title>
    <url>/2022/10/28/Golang%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>Golang常见面试题分享，涵盖了常见的Golang面试八股文</p>
<h4 id="1-无缓冲Chan的发送和接收是否同步"><a href="#1-无缓冲Chan的发送和接收是否同步" class="headerlink" title="1. 无缓冲Chan的发送和接收是否同步"></a>1. 无缓冲Chan的发送和接收是否同步</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ch := make(chan int)    无缓冲的channel由于没有缓冲发送和接收需要同步</span><br><span class="line">ch := make(chan int, 2) 有缓冲channel不要求发送和接收操作同步</span><br></pre></td></tr></table></figure>

<ul>
<li>channel无缓冲时，发送阻塞直到数据被接收，接收阻塞直到读到数据</li>
<li>channel有缓冲时，当缓冲满时发送阻塞，当缓冲空时接收阻塞</li>
</ul>
<h4 id="2-什么是channel，为什么它可以做到线程安全"><a href="#2-什么是channel，为什么它可以做到线程安全" class="headerlink" title="2. 什么是channel，为什么它可以做到线程安全"></a>2. 什么是channel，为什么它可以做到线程安全</h4><ul>
<li>Channel是Go中的一个核心类型，可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication)，Channel也可以理解是一个先进先出的队列，通过管道进行通信</li>
<li>Golang的Channel，发送一个数据到Channel和从Channel接收一个数据都是原子性的</li>
<li>Go的设计思想就是，不要通过共享内存来通信，而是通过通信来共享内存，前者就是传统的加锁，后者就是Channel</li>
<li>设计Channel的主要目的就是在多任务间传递数据的，本身就是安全的</li>
</ul>
<h4 id="3-Goroutine和Channel的作用分别是什么"><a href="#3-Goroutine和Channel的作用分别是什么" class="headerlink" title="3. Goroutine和Channel的作用分别是什么"></a>3. Goroutine和Channel的作用分别是什么</h4><p>进程是内存资源管理和cpu调度的执行单元。为了有效利用多核处理器的优势，将进程进一步细分，允许一个进程里存在多个线程，这多个线程还是共享同一片内存空间，但cpu调度的最小单元变成了线程</p>
<p>协程，可以看作是轻量级的线程。但与线程不同的是，线程的切换是由操作系统控制的，而协程的切换则是由用户控制的</p>
<p>Go中的goroutinue就是协程，可以实现并行，多个协程可以在多个处理器同时跑。而协程同一时刻只能在一个处理器上跑（可以把宿主语言想象成单线程的就好了）</p>
<p>多个goroutine之间的通信是通过channel，在Golang中channel则是goroutinues之间进行通信的渠道。可以把channel形象比喻为工厂里的传送带，一头的生产者goroutine往传输带放东西，另一头的消费者goroutinue则从输送带取东西。channel实际上是一个有类型的消息队列，遵循先进先出的特点</p>
<h4 id="4-Channel是同步的还是异步的"><a href="#4-Channel是同步的还是异步的" class="headerlink" title="4. Channel是同步的还是异步的"></a>4. Channel是同步的还是异步的</h4><p>Channel是异步进行的，channel存在3种状态：</p>
<ul>
<li>nil，未初始化的状态，只进行了声明，或者手动赋值为nil</li>
<li>active，正常的channel，可读或者可写</li>
<li>closed，已关闭，千万不要误认为关闭channel后，channel的值是nil</li>
</ul>
<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">一个零值nil通道</th>
<th align="left">一个非零值但已关闭的通道</th>
<th align="left">一个非零值且尚未关闭的通道</th>
</tr>
</thead>
<tbody><tr>
<td align="left">关闭</td>
<td align="left">产生恐慌</td>
<td align="left">产生恐慌</td>
<td align="left">成功关闭</td>
</tr>
<tr>
<td align="left">发送数据</td>
<td align="left">永久阻塞</td>
<td align="left">产生恐慌</td>
<td align="left">阻塞或者成功发送</td>
</tr>
<tr>
<td align="left">接收数据</td>
<td align="left">永久阻塞</td>
<td align="left">永不阻塞</td>
<td align="left">阻塞或者成功接收</td>
</tr>
</tbody></table>
<h4 id="5-Go中的channel的实现"><a href="#5-Go中的channel的实现" class="headerlink" title="5. Go中的channel的实现"></a>5. Go中的channel的实现</h4><p>在Go中最常见的就是通信顺序进程（Communicating sequential processes，CSP）的并发模型，通过共享通信，来实现共享内存，这里就提到了channel。Goroutine 和 Channel 分别对应 CSP 中的实体和传递信息的媒介，Go 语言中的 Goroutine 会通过 Channel 传递数据</p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7no7xmdcgj313c0b0jtt.jpg" alt="image.png" style="zoom:25%;" /></div>

<p>Goroutine通过使用channel传递数据，一个会向 Channel 中发送数据，另一个会从 Channel 中接收数据，它们两者能够独立运行并不存在直接关联，但是能通过 Channel 间接完成通信</p>
<p>Channel 收发操作均遵循了先入先出（FIFO）的设计，具体规则如下：</p>
<ul>
<li>先从 Channel 读取数据的 Goroutine 会先接收到数据</li>
<li>先向 Channel 发送数据的 Goroutine 会得到先发送数据的权利</li>
</ul>
<p>Channel 通常会有以下三种类型：</p>
<ul>
<li>同步 Channel — 不需要缓冲区，发送方会直接将数据交给（Handoff）接收方</li>
<li>异步 Channel：基于环形缓存的传统生产者消费者模型</li>
<li><code>chan struct&#123;&#125;</code> 类型的异步 <code>Channel</code> 的 <code>struct&#123;&#125;</code> 类型不占用内存空间，不需要实现缓冲区和直接发送（Handoff）的语义</li>
</ul>
<p>Channel 在运行时使用 <code>runtime.hchan</code> 结构体表示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="type">uint</span>           <span class="comment">// 当前队列里还剩余元素个数</span></span><br><span class="line">    dataqsiz <span class="type">uint</span>           <span class="comment">// 环形队列长度，即缓冲区的大小，即make(chan T,N) 中的N</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// 环形队列指针</span></span><br><span class="line">    elemsize <span class="type">uint16</span>         <span class="comment">// 每个元素的大小</span></span><br><span class="line">    closed   <span class="type">uint32</span>         <span class="comment">// 标识当前通道是否处于关闭状态，创建通道后，该字段设置0，即打开通道；通道调用close将其设置为1，通道关闭</span></span><br><span class="line">    elemtype *_type         <span class="comment">// 元素类型，用于数据传递过程中的赋值</span></span><br><span class="line">    sendx    <span class="type">uint</span>           <span class="comment">// 环形缓冲区的状态字段，它只是缓冲区的当前索引-支持数组，它可以从中发送数据</span></span><br><span class="line">    recvx    <span class="type">uint</span>          <span class="comment">// 环形缓冲区的状态字段，它只是缓冲区当前索引-支持数组，它可以从中接受数据</span></span><br><span class="line">    recvq    waitq         <span class="comment">// 等待读消息的goroutine队列</span></span><br><span class="line">    sendq    waitq         <span class="comment">// 等待写消息的goroutine队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">    <span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line">    <span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">    <span class="comment">// with stack shrinking.</span></span><br><span class="line">    lock mutex           <span class="comment">// 互斥锁，为每个读写操作锁定通道，因为发送和接受必须是互斥操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">    first *sudog</span><br><span class="line">    last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中hchan结构体中有五个字段是构建底层的循环队列：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">qcount：Channel中的元素个数</span><br><span class="line">dataqsiz：Channel中的循环队列的长度</span><br><span class="line">buf：Channel的缓冲区数据指针</span><br><span class="line">sendx：Channel的发送操作处理到的位置</span><br><span class="line">recvx：Channel的接收操作处理到的位置</span><br></pre></td></tr></table></figure>

<h4 id="6-Golang并发机制以及它所使用的CSP并发模型"><a href="#6-Golang并发机制以及它所使用的CSP并发模型" class="headerlink" title="6. Golang并发机制以及它所使用的CSP并发模型"></a>6. Golang并发机制以及它所使用的CSP并发模型</h4><p>在计算机科学中，通信顺序过程（communicating sequential processes，CSP）是一种描述并发系统中交互模式的正式语言，它是并发数学理论家族中的一个成员，被称为过程算法（process algebras），或者说过程计算（process calculate），是基于消息的通道传递的数学理论</p>
<p>Golang中的Goroutine的特性：</p>
<p>Golang内部有三个对象： P对象(processor) 代表上下文（或者可以认为是cpu），M(work thread)代表工作线程，G对象（goroutine）</p>
<p>正常情况下一个cpu对象启一个工作线程对象，线程去检查并执行goroutine对象。碰到goroutine对象阻塞的时候，会启动一个新的工作线程，以充分利用cpu资源。所以有时候线程对象会比处理器对象多很多</p>
<ul>
<li>G（Goroutine） ：我们所说的协程，为用户级的轻量级线程，每个Goroutine对象中的sched保存着其上下文信息</li>
<li>M（Machine） ：对Os内核级线程的封装，数量对应真实的CPU数（真正干活的对象）</li>
<li>P（Processor） ：逻辑处理器,即为G和M的调度对象，用来调度G和M之间的关联关系，其数量可通过GOMAXPROCS()来设置，默认为核心数</li>
</ul>
<p>在单核情况下，所有Goroutine运行在同一个线程（M0）中，每一个线程维护一个上下文（P），任何时刻，一个上下文中只有一个Goroutine，其他Goroutine在runqueue中等待。一个Goroutine运行完自己的时间片后，让出上下文，自己回到runqueue中（如下图所示）</p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7nojprq3uj30ns0kgdi9.jpg" alt="image.png" style="zoom:38%;" /></div>

<p>当正在运行的G0阻塞的时候（可以需要IO），会再创建一个线程（M1），P转到新的线程中去运行</p>
<p>当M0返回时，它会尝试从其他线程中“偷”一个上下文过来，如果没有偷到，会把Goroutine放到Global runqueue中去，然后把自己放入线程缓存中。上下文会定时检查Global runqueue</p>
<p>Golang的CSP并发模型，是通过Goroutine和Channel来实现的</p>
<p>因此，GPM的简要概括即为：事件循环，线程池，工作队列</p>
<h4 id="7-Go的GPM如何调度"><a href="#7-Go的GPM如何调度" class="headerlink" title="7. Go的GPM如何调度"></a>7. Go的GPM如何调度</h4><p>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此，协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置</p>
<p>线程和进程的操作是由程序触发系统接口，最后的执行者是系统；协程的操作执行者则是用户自身程序，goroutine也是协程</p>
<p>groutine能拥有强大的并发实现是通过GPM调度模型实现</p>
<p>Go的调度器内部有四个重要的结构：M，G，P，Sched：</p>
<ul>
<li>M：M代表内核级线程，一个M就是一个线程，goroutine就是跑在M之上的；M是一个很大的结构，里面维护小对象内存cache（mcache）、当前执行的goroutine、随机数发生器等等非常多的信息</li>
<li>G：代表一个goroutine，它有自己的栈，instruction pointer和其他信息（正在等待的channel等等），用于调度</li>
<li>P：P全称是Processor，逻辑处理器，它的主要用途就是用来执行goroutine的，所以它也维护了一个goroutine队列，里面存储了所有需要它来执行的goroutine</li>
<li>Sched：代表调度器，它维护有存储M和G的队列以及调度器的一些状态信息等</li>
</ul>
<hr>
<ol>
<li>新创建的Goroutine会先存放在Global全局队列中，等待Go调度器进行调度，随后Goroutine被分配给其中的一个逻辑处理器P，并放到这个逻辑处理器对应的Local本地运行队列中，最终等待被逻辑处理器P执行即可</li>
<li>在M与P绑定后，M会不断从P的Local队列中无锁地取出G，并切换到G的堆栈执行，当P的Local队列中没有G时，再从Global队列中获取一个G，当Global队列中也没有待运行的G时，则尝试从其它的P窃取部分G来执行相当于P之间的负载均衡</li>
<li>每一个M都拥有一个处理器P，每一个也都有一个正在运行的goroutine。P的数量可以通过GOMAXPROCS()来设置，它其实也就代表了真正的并发度，即有多少个goroutine可以同时运行</li>
<li>对于没有运行的goroutine，而是出于ready的就绪态，正在等待被调度。P维护着这个队列（称之为runqueue），Go语言里，启动一个goroutine很容易：go function 就行，所以每有一个go语句被执行，runqueue队列就在其末尾加入一个goroutine，在下一个调度点，就从runqueue中取出（如何决定取哪个goroutine？）一个goroutine执行</li>
<li>当一个OS线程M0陷入阻塞时，P转而在运行M1，图中的M1可能是正被创建，或者从线程缓存中取出</li>
<li>当MO返回时，它必须尝试取得一个P来运行goroutine，一般情况下，它会从其他的OS线程那里拿一个P过来，如果没有拿到的话，它就把goroutine放在一个<code>global runqueue</code>里，然后自己睡眠（放入线程缓存里）。所有的P也会周期性的检查<code>global runqueue</code>并运行其中的goroutine，否则<code>global runqueue</code>上的goroutine永远无法执行</li>
<li>另一种情况是P所分配的任务G很快就执行完了（分配不均），这就导致了这个处理器P处于空闲的状态，但是此时其他的P还有任务，此时如果global runqueue没有任务G了，那么这个P就会从其他的P里偷取一些G来执行。通常来说，如果P从其他的P那里要拿任务的话，一般就拿<code>run queue</code>的一半，这就确保了每个OS线程都能充分的使用</li>
</ol>
<h4 id="8-Golang中常用的并发模型"><a href="#8-Golang中常用的并发模型" class="headerlink" title="8. Golang中常用的并发模型"></a>8. Golang中常用的并发模型</h4><p>Golang中常用的并发模型有三种:</p>
<ul>
<li>通过channel通知实现并发控制</li>
<li>通过sync包中的WaitGroup实现并发控制</li>
<li>在Go1.7以后引进的强大的Context上下文，实现并发控制</li>
</ul>
<ol>
<li><p>通过channel通知实现并发控制</p>
<p>无缓冲的通道指的是通道的大小为0，也就是说，这种类型的通道在接收前没有能力保存任何值，它要求发送 goroutine 和接收 goroutine 同时准备好，才可以完成发送和接收操作</p>
<p>发送 goroutine 和接收 gouroutine 必须是同步的，同时准备后，如果没有同时准备好的话，先执行的操作就会阻塞等待，直到另一个相对应的操作准备好为止</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;start working&quot;</span>)</span><br><span class="line">        time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">        ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;-ch</span><br><span class="line">    fmt.Println(<span class="string">&quot;finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当主 goroutine 运行到 <code>&lt;-ch</code> 接受 channel 的值的时候，如果该 channel 中没有数据，就会一直阻塞等待，直到有值。 这样就可以简单实现并发控制</p>
<hr>
</li>
<li><p>通过sync包中的WaitGroup实现并发控制</p>
<p>Goroutine是异步执行的，有的时候为了防止在结束main函数的时候结束掉Goroutine，所以需要同步等待，这个时候就需要用 WaitGroup了，在sync包中，提供了WaitGroup，它会等待它收集的所有Goroutine任务全部完成。在WaitGroup里主要有三个方法:</p>
<ul>
<li>Add，可以添加或减少Goroutine的数量</li>
<li>Done，相当于Add(-1)</li>
<li>Wait，执行后会堵塞主线程，直到WaitGroup里的值减至0</li>
</ul>
<p>在主 goroutine 中 Add(delta int) 索要等待goroutine 的数量。在每一个 goroutine 完成后 Done() 表示这一个goroutine 已经完成，当所有的 goroutine 都完成后，在主 goroutine 中 WaitGroup 返回</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">var</span> urls = []<span class="type">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;http://www.golang.org/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://www.google.com/&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            http.Get(url)</span><br><span class="line">        &#125;(url)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Golang官网中对于WaitGroup介绍是<code>A WaitGroup must not be copied after first use</code>,在 WaitGroup第一次使用后，不能被拷贝</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(wg sync.WaitGroup, i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;i:%d&quot;</span>, i)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(wg, i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;exit&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之后会报错：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">i:1i:3i:2i:0i:4fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine 1 [semacquire]:</span><br><span class="line">sync.runtime_Semacquire(0xc000094018)</span><br><span class="line">        /home/keke/soft/go/src/runtime/sema.go:56 +0x39</span><br><span class="line"><span class="built_in">sync</span>.(*WaitGroup).Wait(0xc000094010)</span><br><span class="line">        /home/keke/soft/go/src/sync/waitgroup.go:130 +0x64</span><br><span class="line">main.main()</span><br><span class="line">        /home/keke/go/Test/wait.go:17 +0xab</span><br><span class="line"><span class="built_in">exit</span> status 2</span><br></pre></td></tr></table></figure>

<p>它提示所有的 <code>goroutine</code> 都已经睡眠了，出现了死锁。这是因为wg给拷贝传递到了goroutine中，导致只有Add操作，其实Done操作是在wg的副本执行的，因此 Wait 就会死锁</p>
<ul>
<li><p>这个第一个修改方式：将匿名函数中wg的传入类型改为 <code>*sync.WaitGroup，</code>这样就能引用到正确的<code>WaitGroup</code>了</p>
</li>
<li><p>这个第二个修改方式：将匿名函数中的wg的传入参数去掉，因为Go支持闭包类型，在匿名函数中可以直接使用外面的wg变量</p>
</li>
</ul>
<hr>
</li>
<li><p>Context上下文实现并发控制</p>
<p>通常，在一些简单场景下使用channel和WaitGroup已经足够了，但是当面临一些复杂多变的网络并发场景下channel和WaitGroup显得有些力不从心了，比如一个网络请求Request，每个Request都需要开启一个goroutine做一些事情，这些goroutine又可能会开启其他的goroutine，比如数据库和RPC服务</p>
<p>所以我们需要一种可以跟踪goroutine的方案，才可以达到控制他们的目的，这就是Go语言为我们提供的Context，称之为上下文非常贴切，它就是goroutine的上下文，它是包括一个程序的运行环境、现场和快照等。每个程序要运行时，都需要知道当前程序的运行状态，通常Go将这些封装在一个 Context里，再将它传给要执行的goroutine ，context包主要是用来处理多个goroutine之间共享数据，及多个goroutine的管理</p>
<p>context包的核心是struct Context，接口声明如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Context carries a deadline, cancelation signal, and request-scoped values</span></span><br><span class="line"><span class="comment">// across API boundaries. Its methods are safe for simultaneous use by multiple</span></span><br><span class="line"><span class="comment">// goroutines.</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Done returns a channel that is closed when this `Context` is canceled</span></span><br><span class="line">    <span class="comment">// or times out.</span></span><br><span class="line">    <span class="comment">// Done() 返回一个只能接受数据的channel类型，当该context关闭或者超时时间到了的时候，该channel就会有一个取消信号</span></span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Err indicates why this Context was canceled, after the Done channel</span></span><br><span class="line">    <span class="comment">// is closed.</span></span><br><span class="line">    <span class="comment">// Err() 在Done() 之后，返回context 取消的原因。</span></span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deadline returns the time when this Context will be canceled, if any.</span></span><br><span class="line">    <span class="comment">// Deadline() 设置该context cancel的时间点</span></span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Value returns the value associated with key or nil if none.</span></span><br><span class="line">    <span class="comment">// Value() 方法允许 Context 对象携带request作用域的数据，该数据必须是线程安全的。</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Context对象是线程安全的，你可以把一个Context对象传递给任意个数的gorotuine，对它执行 取消 操作时，所有goroutine都会接收到取消信号。一个Context不能拥有Cancel方法，同时我们也只能Done channel接收数据。其中的原因是一致的：接收取消信号的函数和发送信号的函数通常不是一个。典型的场景是：父操作为子操作操作启动goroutine，子操作也就不能取消父操作</p>
</li>
</ol>
<h4 id="9-并发编程概念是什么"><a href="#9-并发编程概念是什么" class="headerlink" title="9. 并发编程概念是什么"></a>9. 并发编程概念是什么</h4><ul>
<li>并行是指两个或者多个事件在同一时刻发生；并发是指两个或多个事件在同一时间间隔发生</li>
<li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群</li>
<li>并发偏重于多个任务交替执行，而多个任务之间有可能还是串行的。而并行是真正意义上的“同时执行”</li>
<li>并发编程是指在一台处理器上“同时”处理多个任务。并发是在同一实体上的多个事件。多个事件在同一时间间隔发生。并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能</li>
</ul>
<h4 id="10-怎么查看Goroutine的数量"><a href="#10-怎么查看Goroutine的数量" class="headerlink" title="10. 怎么查看Goroutine的数量"></a>10. 怎么查看Goroutine的数量</h4><p>在Golang中，<code>GOMAXPROCS</code>中控制的是未被阻塞的所有Goroutine，可以被 <code>Multiplex</code> 到多少个线程上运行，通过<code>GOMAXPROCS</code>可以查看Goroutine的数量</p>
<h4 id="11-怎么限制Goroutine的数量"><a href="#11-怎么限制Goroutine的数量" class="headerlink" title="11. 怎么限制Goroutine的数量"></a>11. 怎么限制Goroutine的数量</h4><p>在Golang中，Goroutine虽然很好，但是数量太多了，往往会带来很多麻烦，比如耗尽系统资源导致程序崩溃，或者CPU使用率过高导致系统忙不过来。所以我们可以限制下Goroutine的数量，这样就需要在每一次执行go之前判断goroutine的数量，如果数量超了，就要阻塞go的执行</p>
<ul>
<li>使用通道，每次执行的go之前向通道写入值，直到通道满的时候就阻塞了</li>
<li>但是新的问题于是就出现了，因为并不是所有的goroutine都执行完了，在main函数退出之后，还有一些goroutine没有执行完就被强制结束了。这个时候我们就需要用到sync.WaitGroup。使用WaitGroup等待所有的goroutine退出</li>
<li>Go的GOMAXPROCS默认值已经设置为CPU的核数， 这里允许我们的Go程序充分使用机器的每一个CPU，最大程度的提高我们程序的并发性能。<code>runtime.NumGoroutine</code>函数在被调用后，会返回系统中的处于特定状态的Goroutine的数量。这里的特指是指<code>Grunnable\Gruning\Gsyscall\Gwaition</code>。处于这些状态的Groutine即被看做是活跃的或者说正在被调度</li>
<li><strong>注意：</strong> 垃圾回收所在Groutine的状态也处于这个范围内的话，也会被纳入该计数器</li>
</ul>
<h4 id="12-Goroutine和线程的区别"><a href="#12-Goroutine和线程的区别" class="headerlink" title="12. Goroutine和线程的区别"></a>12. Goroutine和线程的区别</h4><p>从调度上看，goroutine的调度开销远远小于线程调度开销</p>
<ul>
<li>线程：OS的线程由OS内核调度，每隔几毫秒，一个硬件时钟中断发到CPU，CPU调用一个调度器内核函数。这个函数暂停当前正在运行的线程，把他的寄存器信息保存到内存中，查看线程列表并决定接下来运行哪一个线程，再从内存中恢复线程的注册表信息，最后继续执行选中的线程。这种线程切换需要一个完整的上下文切换：即保存一个线程的状态到内存，再恢复另外一个线程的状态，最后更新调度器的数据结构。某种意义上，这种操作还是很慢的</li>
<li>goroutine：Go运行的时候包涵一个自己的调度器，这个调度器使用一个称为一个M:N调度技术，m个goroutine到n个os线程（可以用GOMAXPROCS来控制n的数量），Go的调度器不是由硬件时钟来定期触发的，而是由特定的go语言结构来触发的，他不需要切换到内核语境，所以调度一个goroutine比调度一个线程的成本低很多</li>
</ul>
<p>从栈空间上，goroutine的栈空间更加动态灵活</p>
<p>每个OS的线程都有一个固定大小的栈内存，通常是2MB，栈内存用于保存在其他函数调用期间哪些正在执行或者临时暂停的函数的局部变量。这个固定的栈大小，如果对于goroutine来说，可能是一种巨大的浪费。作为对比goroutine在生命周期开始只有一个很小的栈，典型情况是2KB, 在go程序中，一次创建十万左右的goroutine也不罕见（2KB*100,000&#x3D;200MB）。而且goroutine的栈不是固定大小，它可以按需增大和缩小，最大限制可以到1GB</p>
<p>goroutine没有一个特定的标识</p>
<p>在大部分支持多线程的操作系统和编程语言中，线程有一个独特的标识，通常是一个整数或者指针，这个特性可以让我们构建一个线程的局部存储，本质是一个全局的map，以线程的标识作为键，这样每个线程可以独立使用这个map存储和获取值，不受其他线程干扰</p>
<p>goroutine中没有可供程序员访问的标识，原因是一种纯函数的理念，不希望滥用线程局部存储导致一个不健康的超距作用，即函数的行为不仅取决于它的参数，还取决于运行它的线程标识</p>
<h4 id="13-在Go函数中为什么会发生内存泄露，Goroutine发生了泄漏如何检测"><a href="#13-在Go函数中为什么会发生内存泄露，Goroutine发生了泄漏如何检测" class="headerlink" title="13. 在Go函数中为什么会发生内存泄露，Goroutine发生了泄漏如何检测"></a>13. 在Go函数中为什么会发生内存泄露，Goroutine发生了泄漏如何检测</h4><p>内存泄漏，指的是能够预期的能很快被释放的内存由于附着在了长期存活的内存上、或生命期意外地被延长，导致预计能够立即回收的内存而长时间得不到回收</p>
<ul>
<li>预期能被快速释放的内存因被根对象引用而没有得到迅速释放；当有一个全局对象时，可能不经意间将某个变量附着在其上，且忽略的将其进行释放，则该内存永远不会得到释放</li>
<li>Goroutine泄漏；Goroutine作为一种逻辑上理解的轻量级线程，需要维护执行用户代码的上下文信息。在运行过程中也需要消耗一定的内存来保存这类信息，而这些内存在目前版本的 Go 中是不会被释放的。因此，如果一个程序持续不断地产生新的 goroutine、且不结束已经创建的goroutine并复用这部分内存，就会造成内存泄漏的现象</li>
<li>检测方法：通过Go自带的工具pprof或者使用Gops去检测诊断当前在系统上运行的Go进程的占用的资源</li>
</ul>
<hr>
<h5 id="13-1-PProf是什么"><a href="#13-1-PProf是什么" class="headerlink" title="13.1 PProf是什么"></a>13.1 PProf是什么</h5><ol>
<li><code>PProf</code>是一个<code>Go</code>程序性能分析工具，可以分析<code>CPU</code>，内存等性能</li>
<li><code>Go</code>在语言层面上集成了<code>profile</code>采样工具，只需要在代码中简单的引入<code>runtime/ppro</code>或者<code>net/http/pprof</code>包即可获取程序的<code>profile</code>文件，并通过该文件来进行性能分析</li>
<li><code>runtime/pprof</code>还可以为控制台程序或者测试程序产生<code>pprof</code>数据</li>
<li>其实<code>net/http/pprof</code>中只是使用<code>runtime/pprof</code>包来进行封装了一下，并在<code>HTTP</code>端口上暴露出来</li>
</ol>
<h5 id="13-2-PProf使用"><a href="#13-2-PProf使用" class="headerlink" title="13.2 PProf使用"></a>13.2 PProf使用</h5><p>在<code>gin</code>的路由中注册<code>pprof</code>的路由</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pprof router</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-contrib/pprof&quot;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">	Router = gin.New()</span><br><span class="line">	pprof.Register(Router)</span><br></pre></td></tr></table></figure>

<p>通过<code>go tool pprof http://127.0.0.1/debug/pprof/profile</code>可以获取<code>profile</code>采集信息并分析</p>
<p>也可以直接在浏览器访问<code>http://localhost:8080/debug/pprof</code>来查看当前<code>API</code>服务的状态，包括<code>CPU</code>占用情况和内存使用情况等</p>
<p>通过<code>topN</code>的输出可以分析出哪些函数占用<code>CPU</code>时间片最多，这些函数可能存在性能问题。此命名用于显示<code>profile</code>文件中的最靠前的N个样本（默认前10个<code>sample</code>），它的输出格式字段的含义依次是：</p>
<ul>
<li>采样点落在该函数中的总时间</li>
<li>采样点落在该函数中的百分比</li>
<li>上一项的累积百分比</li>
<li>采样点落在该函数，以及被它调用的函数中的总时间</li>
<li>采样点落在该函数，以及被它调用的函数中的总次数百分比</li>
<li>函数名</li>
</ul>
<p>如果觉得不直观，可以直接再生成函数调用图，通过调用图来判断哪些函数耗时最久，在<code>pprof</code>交互界面，执行<code>svg</code>生成<code>svg</code>文件</p>
<p>但是需要确保系统已经安装<code>graphviz</code>命令（<code>Mac OS:brew install graphviz; CentOS: yum -y install graphviz.x86_64</code>）</p>
<h4 id="14-Goroutine和内核线程（KernelThread）之间是什么关系"><a href="#14-Goroutine和内核线程（KernelThread）之间是什么关系" class="headerlink" title="14. Goroutine和内核线程（KernelThread）之间是什么关系"></a>14. Goroutine和内核线程（KernelThread）之间是什么关系</h4><p>进程、线程、协程的关系和区别：</p>
<ul>
<li>进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度</li>
<li>线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)</li>
<li>协程和线程一样共享堆，不共享栈，协程由程序开发者在协程的代码里显示调度</li>
</ul>
<p>为什么协程比线程轻量？</p>
<ul>
<li>go协程调用跟切换比线程效率高<ul>
<li>线程并发执行流程: 线程是内核对外提供的服务，应用程序可以通过系统调用让内核启动线程，由内核来负责线程调度和切换。线程在等待IO操作时线程变为unrunnable状态会触发上下文切换。现代操作系统一般都采用抢占式调度，上下文切换一般发生在时钟中断和系统调用返回前，调度器计算当前线程的时间片，如果需要切换就从运行队列中选出一个目标线程，保存当前线程的环境，并且恢复目标线程的运行环境，最典型的就是切换ESP指向目标线程内核堆栈，将EIP指向目标线程上次被调度出时的指令地址</li>
<li>go协程并发执行流程：不依赖操作系统和其提供的线程，golang自己实现的CSP并发模型实现：M, P, G .go协程也叫用户态线程，协程之间的切换发生在用户态。在用户态没有时钟中断，系统调用等机制,因此效率高</li>
</ul>
</li>
<li>go协程占用内存少<ul>
<li>执行go协程只需要极少的栈内存（大概是4～5KB），默认情况下，线程栈的大小为1MB。goroutine就是一段代码，一个函数入口，以及在堆上为其分配的一个堆栈。所以它非常廉价，我们可以很轻松的创建上万个goroutine，但它们并不是被操作系统所调度执行</li>
<li>因此协程和线程一样共享堆，不共享栈，协程由用户态下面的轻量级线程</li>
</ul>
</li>
</ul>
<h4 id="15-协程和线程和进程的区别"><a href="#15-协程和线程和进程的区别" class="headerlink" title="15. 协程和线程和进程的区别"></a>15. 协程和线程和进程的区别</h4><ul>
<li>进程：是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。<br>每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全</li>
<li>线程：是进程的一个实体，线程是内核态，而且是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据</li>
<li>协程：是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快</li>
</ul>
<h4 id="16-G0的作用"><a href="#16-G0的作用" class="headerlink" title="16. G0的作用"></a>16. G0的作用</h4><ul>
<li>在Go中g0作为一个特殊的goroutine，为scheduler执行调度循环提供了场地（栈）。对于一个线程来说，g0总是它第一个创建的 goroutine。之后，它会不断地寻找其他普通的goroutine来执行，直到进程退出</li>
<li>当需要执行一些任务，且不想扩栈时，就可以用到 g0了，因为g0的栈比较大</li>
<li>g0 其他的一些“职责”有：创建 <code>goroutine</code>、<code>deferproc</code> 函数里新建 <code>_defer</code>、垃圾回收相关的工作（例如stw、扫描goroutine的执行栈、一些标识清扫的工作、栈增长）等等</li>
</ul>
<h4 id="17-Golang的内存模型中为什么小对象多了会造成GC压力"><a href="#17-Golang的内存模型中为什么小对象多了会造成GC压力" class="headerlink" title="17. Golang的内存模型中为什么小对象多了会造成GC压力"></a>17. Golang的内存模型中为什么小对象多了会造成GC压力</h4><p>通常小对象过多会导致GC三色法消耗过多的CPU。优化思路：减少对象分配</p>
<h4 id="18-Go的对象在内存中是怎样分配的"><a href="#18-Go的对象在内存中是怎样分配的" class="headerlink" title="18. Go的对象在内存中是怎样分配的"></a>18. Go的对象在内存中是怎样分配的</h4><p>Go中的内存分类并不像TCMalloc那样分成小、中、大对象，但是它的小对象里又细分了一个Tiny对象，Tiny对象指大小在1Byte到16Byte之间并且不包含指针的对象。小对象和大对象只用大小划定，无其他区分</p>
<p>大对象指大小大于32kb，小对象是在mcache中分配的，而大对象是直接从mheap分配的，从小对象的内存分配看起</p>
<p>Go的内存分配原则：</p>
<ul>
<li>Go在程序启动的时候，会先向操作系统申请一块内存（注意这时还只是一段虚拟的地址空间，并不会真正地分配内存），切成小块后自己进行管理</li>
<li>申请到的内存块被分配了三个区域，在X64上分别是512MB，16GB，512GB大小</li>
<li>arena区域就是我们所谓的堆区，Go动态分配的内存都是在这个区域，它把内存分割成8KB大小的页，一些页组合起来称为mspan</li>
<li>bitmap区域标识arena区域哪些地址保存了对象，并且用4bit标志位表示对象是否包含指针、GC标记信息。bitmap中一个byte大小的内存对应arena区域中4个指针大小（指针大小为 8B ）的内存，所以bitmap区域的大小是<code>512GB/(4*8B)=16GB</code></li>
<li>bitmap的高地址部分指向arena区域的低地址部分，这里bitmap的地址是由高地址向低地址增长的</li>
<li>spans区域存放mspan（是一些arena分割的页组合起来的内存管理基本单元，后文会再讲）的指针，每个指针对应一页，所以spans区域的大小就是<code>512GB/8KB*8B=512MB</code></li>
<li>除以8KB是计算arena区域的页数，而最后乘以8是计算spans区域所有指针的大小。创建mspan的时候，按页填充对应的spans区域，在回收object时，根据地址很容易就能找到它所属的mspan</li>
</ul>
<h4 id="19-栈的内存是怎么分配的"><a href="#19-栈的内存是怎么分配的" class="headerlink" title="19. 栈的内存是怎么分配的"></a>19. 栈的内存是怎么分配的</h4><p>栈和堆只是虚拟内存上2块不同功能的内存区域：</p>
<ul>
<li>栈在高地址，从高地址向低地址增长</li>
<li>堆在低地址，从低地址向高地址增长</li>
</ul>
<p>栈和堆相比优势：</p>
<ul>
<li>栈的内存管理简单，分配比堆上快。</li>
<li>栈的内存不需要回收，而堆需要，无论是主动free，还是被动的垃圾回收，这都需要花费额外的CPU。</li>
<li>栈上的内存有更好的局部性，堆上内存访问就不那么友好了，CPU访问的2块数据可能在不同的页上，CPU访问数据的时间可能就上去了</li>
</ul>
<h4 id="20-堆内存管理怎么分配的"><a href="#20-堆内存管理怎么分配的" class="headerlink" title="20. 堆内存管理怎么分配的"></a>20. 堆内存管理怎么分配的</h4><ul>
<li>通常在Golang中，当我们谈论内存管理的时候，主要是指堆内存的管理，因为栈的内存管理不需要程序去操心</li>
<li>堆内存管理中主要是三部分, 1.分配内存块，2.回收内存块, 3.组织内存块</li>
<li>一个内存块包含了3类信息：元数据、用户数据和对齐字段，内存对齐是为了提高访问效率。申请内存的时候，就需要进行内存对齐</li>
<li>释放内存实质是把使用的内存块从链表中取出来，然后标记为未使用，当分配内存块的时候，可以从未使用内存块中有先查找大小相近的内存块，如果找不到，再从未分配的内存中分配内存</li>
<li>因为随着内存不断的申请和释放，内存上会存在大量的碎片，降低内存的使用率。为了解决内存碎片，可以将2个连续的未使用的内存块合并，减少碎片</li>
</ul>
<h4 id="21-在Go函数中为什么会发生内存泄露"><a href="#21-在Go函数中为什么会发生内存泄露" class="headerlink" title="21. 在Go函数中为什么会发生内存泄露"></a>21. 在Go函数中为什么会发生内存泄露</h4><p>同上13</p>
<h4 id="22-Go语言的栈空间管理是怎么样的"><a href="#22-Go语言的栈空间管理是怎么样的" class="headerlink" title="22. Go语言的栈空间管理是怎么样的"></a>22. Go语言的栈空间管理是怎么样的</h4><p>Go语言的运行环境（runtime）会在goroutine需要的时候动态地分配栈空间，而不是给每个goroutine分配固定大小的内存空间。这样就避免了需要程序员来决定栈的大小</p>
<p>分块式的栈是最初Go语言组织栈的方式。当创建一个goroutine的时候，它会分配一个8KB的内存空间来给goroutine的栈使用。我们可能会考虑当这8KB的栈空间被用完的时候该怎么办？</p>
<p>为了处理这种情况，每个Go函数的开头都有一小段检测代码。这段代码会检查我们是否已经用完了分配的栈空间。如果是的话，它会调用<code>morestack</code>函数。<code>morestack</code>函数分配一块新的内存作为栈空间，并且在这块栈空间的底部填入各种信息（包括之前的那块栈地址）。在分配了这块新的栈空间之后，它会重试刚才造成栈空间不足的函数。这个过程叫做栈分裂（stack split）</p>
<p>在新分配的栈底部，还插入了一个叫做<code>lessstack</code>的函数指针。这个函数还没有被调用。这样设置是为了从刚才造成栈空间不足的那个函数返回时做准备的。当我们从那个函数返回时，它会跳转到<code>lessstack</code>。<code>lessstack</code>函数会查看在栈底部存放的数据结构里的信息，然后调整栈指针（stack pointer）。这样就完成了从新的栈块到老的栈块的跳转。接下来，新分配的这个块栈空间就可以被释放掉了</p>
<h4 id="23-Go中的逃逸分析是什么"><a href="#23-Go中的逃逸分析是什么" class="headerlink" title="23. Go中的逃逸分析是什么"></a>23. Go中的逃逸分析是什么</h4><p>在Go中逃逸分析是一种确定指针动态范围的方法，可以分析在程序的哪些地方可以访问到指针。它涉及到指针分析和形状分析</p>
<p>当一个变量(或对象)在子程序中被分配时，一个指向变量的指针可能逃逸到其它执行线程中，或者去调用子程序。如果使用尾递归优化（通常在函数编程语言中是需要的），对象也可能逃逸到被调用的子程序中。 如果一个子程序分配一个对象并返回一个该对象的指针，该对象可能在程序中的任何一个地方被访问到——这样指针就成功“逃逸”了</p>
<p>如果指针存储在全局变量或者其它数据结构中，它们也可能发生逃逸，这种情况是当前程序中的指针逃逸。 逃逸分析需要确定指针所有可以存储的地方，保证指针的生命周期只在当前进程或线程中</p>
<p>导致内存逃逸的情况比较多，有些可能还是官方未能够实现精确的分析逃逸情况的 bug，通常来讲就是如果变量的作用域不会扩大并且其行为或者大小能够在编译的时候确定，一般情况下都是分配到栈上，否则就可能发生内存逃逸分配到堆上</p>
<p>内存逃逸的五种情况：</p>
<ol>
<li>发送指针的指针或值包含了指针到<code>channel</code> 中，由于在编译阶段无法确定其作用域与传递的路径，所以一般都会逃逸到堆上分配</li>
<li>slices 中的值是指针的指针或包含指针字段。一个例子是类似<code>[]*string</code> 的类型。这总是导致 slice 的逃逸。即使切片的底层存储数组仍可能位于堆栈上，数据的引用也会转移到堆中。</li>
<li>slice 由于 append 操作超出其容量，因此会导致 slice 重新分配。这种情况下，由于在编译时 slice 的初始大小的已知情况下，将会在栈上分配。如果 slice 的底层存储必须基于仅在运行时数据进行扩展，则它将分配在堆上</li>
<li>调用接口类型的方法。接口类型的方法调用是动态调度，实际使用的具体实现只能在运行时确定。考虑一个接口类型为 io.Reader 的变量 r。对 r.Read(b) 的调用将导致 r 的值和字节片b的后续转义并因此分配到堆上</li>
<li>尽管能够符合分配到栈的场景，但是其大小不能够在在编译时候确定的情况，也会分配到堆上</li>
</ol>
<p>有效的避免上述的五种逃逸的情况，就可以避免内存逃逸</p>
<h4 id="24-Go函数返回局部变量的指针是否安全"><a href="#24-Go函数返回局部变量的指针是否安全" class="headerlink" title="24. Go函数返回局部变量的指针是否安全"></a>24. Go函数返回局部变量的指针是否安全</h4><p>在Go中是安全的，Go编译器将会对每个局部变量进行逃逸分析。如果发现局部变量的作用域超出该函数，则不会将内存分配在栈上，而是分配在堆上</p>
<h4 id="25-Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量"><a href="#25-Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量" class="headerlink" title="25. Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量"></a>25. Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量</h4><p>Golang中Goroutine可以通过Channel进行安全读写共享变量，还可以通过原子性操作进行</p>
<h4 id="26-Go中的锁有哪些"><a href="#26-Go中的锁有哪些" class="headerlink" title="26. Go中的锁有哪些"></a>26. Go中的锁有哪些</h4><p>Go中的三种锁包括：</p>
<ul>
<li>互斥锁</li>
<li>读写锁</li>
<li>sync.Map安全锁</li>
</ul>
<ol>
<li><p>互斥锁</p>
<p>Go并发程序对共享资源进行访问控制的主要手段，由标准库代码包中sync中的Mutex结构体表示，sync.Mutex包中的类型只有两个公开的指针方法Lock和Unlock</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Locker表示可以锁定和解锁的对象。</span></span><br><span class="line"> <span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 锁定当前的互斥量</span></span><br><span class="line"> <span class="comment">// 如果锁已被使用，则调用goroutine</span></span><br><span class="line"> <span class="comment">// 阻塞直到互斥锁可用。</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() </span><br><span class="line"></span><br><span class="line"> <span class="comment">// 对当前互斥量进行解锁</span></span><br><span class="line"> <span class="comment">// 如果在进入解锁时未锁定m，则为运行时错误。</span></span><br><span class="line"> <span class="comment">// 锁定的互斥锁与特定的goroutine无关。</span></span><br><span class="line"> <span class="comment">// 允许一个goroutine锁定Mutex然后安排另一个goroutine来解锁它。</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock()</span><br></pre></td></tr></table></figure>

<p>如果对一个已经上锁的对象再次上锁，那么就会导致该锁定操作被阻塞，直到该互斥锁回到被解锁状态。互斥锁锁定操作的逆操作并不会导致协程阻塞，但是有可能导致引发一个无法恢复的运行时的panic，比如对一个未锁定的互斥锁进行解锁时就会发生panic。避免这种情况的最有效方式就是使用defer</p>
<hr>
</li>
<li><p>读写锁</p>
<p>读写锁是针对读写操作的互斥锁，可以分别针对读操作与写操作进行锁定和解锁操作 。读写锁的访问控制规则如下：</p>
<ul>
<li>多个写操作之间是互斥的</li>
<li>写操作与读操作之间也是互斥的</li>
<li>多个读操作之间不是互斥的</li>
</ul>
<p>在这样的控制规则下，读写锁可以大大降低性能损耗。sync中的RWMutex有以下几种方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对读操作的锁定</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//对读操作的解锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//对写操作的锁定</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//对写操作的解锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个实现了sync.Locker接口类型的值，实际上是回调rw.RLock and rw.RUnlock.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLocker() Locker</span><br></pre></td></tr></table></figure>

<ul>
<li>若对一个未被写锁定的读写锁进行写解锁，就会引发一个不可恢复的panic，同理对一个未被读锁定的读写锁进行读写锁也会如此。</li>
<li>由于读写锁控制下的多个读操作之间不是互斥的，因此对于读解锁更容易被忽视。对于同一个读写锁，添加多少个读锁定，就必要有等量的读解锁，这样才能其他协程有机会进行操作</li>
<li>因此Go中读写锁，在多个读线程可以同时访问共享数据,写线程必须等待所有读线程都释放锁以后，才能取得锁</li>
<li>同样的，读线程必须等待写线程释放锁后，才能取得锁，也就是说读写锁要确保的是如下互斥关系，可以同时读，但是读-写，写-写都是互斥的</li>
</ul>
<hr>
</li>
<li><p>sync.Map安全锁</p>
<p>golang中的sync.Map是并发安全的，其实也就是sync包中golang自定义的一个名叫Map的结构体</p>
<ul>
<li>Delete 方法</li>
<li>Store 方法</li>
<li>Load方法</li>
</ul>
<p>sync.Map是通过冗余的两个数据结构(read、dirty)，实现性能的提升。为了提升性能，load、delete、store等操作尽量使用只读的read；为了提高read的key击中概率，采用动态调整，将dirty数据提升为read；对于数据的删除，采用延迟标记删除法，只有在提升dirty的时候才删除</p>
</li>
</ol>
<h4 id="27-Go中的锁如何实现"><a href="#27-Go中的锁如何实现" class="headerlink" title="27. Go中的锁如何实现"></a>27. Go中的锁如何实现</h4><p>锁是一种同步机制，用于在多任务环境中限制资源的访问，以满足互斥需求</p>
<p>go源码sync包中经常用于同步操作的方式：</p>
<ul>
<li>原子操作</li>
<li>互斥锁</li>
<li>读写锁</li>
<li>waitgroup</li>
</ul>
<p>互斥锁的数据结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Mutex is a mutual exclusion lock.</span></span><br><span class="line"><span class="comment">// The zero value for a Mutex is an unlocked mutex.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A Mutex must not be copied after first use.</span></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    state <span class="type">int32</span>   <span class="comment">// 互斥锁上锁状态枚举值如下所示</span></span><br><span class="line">    sema  <span class="type">uint32</span>  <span class="comment">// 信号量，向处于Gwaitting的G发送信号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// 值为1，表示在state中由低向高第1位，意义：锁是否可用,0可用，1不可用,锁定中</span></span><br><span class="line">    mutexWoken   <span class="comment">// 值为2，表示在state中由低向高第2位，意义：mutex是否被唤醒</span></span><br><span class="line">    mutexStarving <span class="comment">// 当前的互斥锁进入饥饿状态；</span></span><br><span class="line">    mutexWaiterShift = <span class="literal">iota</span>  <span class="comment">//值为2，表示state中统计阻塞在此mutex上goroutine的数目需要位移的偏移量</span></span><br><span class="line">    starvationThresholdNs = <span class="number">1e6</span> </span><br></pre></td></tr></table></figure>

<p>state和sema两个加起来只占 8 字节空间的结构体表示了 Go 语言中的互斥锁</p>
<p>在默认情况下，互斥锁的所有状态位都是 0，int32 中的不同位分别表示了不同的状态：</p>
<ul>
<li>mutexLocked 表示互斥锁的锁定状态；</li>
<li>mutexWoken 表示从正常模式被从唤醒；</li>
<li>mutexStarving 当前的互斥锁进入饥饿状态</li>
<li>waitersCount 当前互斥锁上等待的 Goroutine 个数</li>
</ul>
<p>sync.Mutex 有两种模式，正常模式和饥饿模式：</p>
<ul>
<li>正常模式：锁的等待者会按照先进先出的顺序获取锁。但是刚被唤起的 <code>Goroutine</code> 与新创建的 <code>Goroutine</code> 竞争时，大概率会获取不到锁，为了减少这种情况的出现，一旦 Goroutine 超过 1ms 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止部分 Goroutine 被饿死</li>
<li>饥饿模式：饥饿模式是在 Go 语言 1.9 版本引入的优化的，引入的目的是保证互斥锁的公平性（Fairness）。在饥饿模式中，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会被切换回正常模式</li>
</ul>
<p>相比于饥饿模式，正常模式下的互斥锁能够提供更好地性能，饥饿模式的能避免 Goroutine 由于陷入等待无法获取锁而造成的高尾延时</p>
<h4 id="28-Go中数据竞争问题怎么解决"><a href="#28-Go中数据竞争问题怎么解决" class="headerlink" title="28. Go中数据竞争问题怎么解决"></a>28. Go中数据竞争问题怎么解决</h4><ul>
<li>数据竞争问题可以使用互斥锁sync.Mutex，或者也可以通过CAS无锁并发解决</li>
<li>其中使用同步访问共享数据或者CAS无锁并发是处理数据竞争的一种有效的方法</li>
<li>golang在1.1之后引入了竞争检测机制，可以使用 <code>go run -race</code> 或者 <code>go build -race</code>来进行静态检测。其在内部的实现是，开启多个协程执行同一个命令， 并且记录下每个变量的状态</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> test -race mypkg    <span class="comment">// 测试包</span></span><br><span class="line"><span class="keyword">go</span> run -race mysrc.<span class="keyword">go</span>  <span class="comment">// 编译和运行程序</span></span><br><span class="line"><span class="keyword">go</span> build -race mycmd   <span class="comment">// 构建程序</span></span><br><span class="line"><span class="keyword">go</span> install -race mypkg <span class="comment">// 安装程序</span></span><br></pre></td></tr></table></figure>

<h4 id="29-Go中CAS是怎么回事"><a href="#29-Go中CAS是怎么回事" class="headerlink" title="29. Go中CAS是怎么回事"></a>29. Go中CAS是怎么回事</h4><p>CAS算法（Compare And Swap），是原子操作的一种，CAS算法是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题</p>
<p>该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值</p>
<p>Go中的CAS操作是借用了CPU提供的原子性指令来实现。CAS操作修改共享变量时候不需要对共享变量加锁，而是通过类似乐观锁的方式进行检查，本质还是不断的占用CPU 资源换取加锁带来的开销（比如上下文切换开销）</p>
<p>Go中CAS操作可以有效的减少使用锁所带来的开销，但是需要注意在高并发下这是使用cpu资源做交换的</p>
<h4 id="30-Go主协程如何等其余协程完再操作"><a href="#30-Go主协程如何等其余协程完再操作" class="headerlink" title="30. Go主协程如何等其余协程完再操作"></a>30. Go主协程如何等其余协程完再操作</h4><ul>
<li>Go提供了更简单的方法——使用<code>sync.WaitGroup</code>。<code>WaitGroup</code>，就是用来等待一组操作完成的。<code>WaitGroup</code>内部实现了一个计数器，用来记录未完成的操作个数</li>
<li>它提供了三个方法，<code>Add()</code>用来添加计数。<code>Done()</code>用来在操作结束时调用，使计数减一。<code>Wait()</code>用来等待所有的操作结束，即计数变为0，该函数会在计数不为0时等待，在计数为0时立即返回</li>
</ul>
<h4 id="31-Context包的用途是什么"><a href="#31-Context包的用途是什么" class="headerlink" title="31. Context包的用途是什么"></a>31. Context包的用途是什么</h4><p>在 Go http包的Server中，每一个请求在都有一个对应的 goroutine 去处理。请求处理函数通常会启动额外的 goroutine 用来访问后端服务，比如数据库和RPC服务。用来处理一个请求的 goroutine 通常需要访问一些与请求特定的数据，比如终端用户的身份认证信息、验证相关的token、请求的截止时间。 当一个请求被取消或超时时，所有用来处理该请求的 goroutine 都应该迅速退出，然后系统才能释放这些 goroutine 占用的资源</p>
<p>在Google 内部，我们开发了 Context 包，专门用来简化 对于处理单个请求的多个 goroutine 之间与请求域的数据、取消信号、截止时间等相关操作，这些操作可能涉及多个 API 调用</p>
<p>Context中的方法：</p>
<ul>
<li>Done会返回一个channel，当该context被取消的时候，该channel会被关闭，同时对应的使用该context的routine也应该结束并返回</li>
<li>Context中的方法是协程安全的，这也就代表了在父routine中创建的context，可以传递给任意数量的routine并让他们同时访问</li>
<li>Deadline会返回一个超时时间，routine获得了超时时间后，可以对某些io操作设定超时时间</li>
<li>Value可以让routine共享一些数据，当然获得数据是协程安全的</li>
</ul>
<p>这里需要注意一点的是在goroutine中使用context包的时候，通常我们需要在goroutine中新创建一个上下文的context，原因是：如果直接传递外部context到协层中，一个请求可能在主函数中已经结束，在goroutine中如果还没有结束的话，会直接导致goroutine中的运行的被取消</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">   _, ctx, _ := log.FromContextOrNew(context.Background(), <span class="literal">nil</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>context.Background函数的返回值是一个空的context，经常作为树的根结点，它一般由接收请求的第一个routine创建，不能被取消、没有值、也没有过期时间</p>
<p>Context上下文数据的存储就像一个树，每个结点只存储一个<code>key/value</code>对。WithValue()保存一个<code>key/value</code>对，它将父context嵌入到新的子context，并在节点中保存了<code>key/value</code>数据。Value()查询key对应的value数据，会从当前context中查询，如果查不到，会递归查询父context中的数据</p>
<p>值得注意的是，context中的上下文数据并不是全局的，它只查询本节点及父节点们的数据，不能查询兄弟节点的数据</p>
<p>Context 使用原则：</p>
<ul>
<li>不要把Context放在结构体中，要以参数的方式传递</li>
<li>以Context作为参数的函数方法，应该把Context作为第一个参数，放在第一位</li>
<li>给一个函数方法传递Context的时候，不要传递nil，如果不知道传递什么，就使用context.TODO</li>
<li>Context的Value相关方法应该传递必须的数据，不要什么数据都使用这个传递</li>
<li>Context是线程安全的，可以放心的在多个goroutine中传递</li>
</ul>
<h4 id="32-Go中对nil的Slice和空Slice的处理是一致的吗"><a href="#32-Go中对nil的Slice和空Slice的处理是一致的吗" class="headerlink" title="32. Go中对nil的Slice和空Slice的处理是一致的吗"></a>32. Go中对nil的Slice和空Slice的处理是一致的吗</h4><p>首先Go的JSON 标准库对 <code>nil slice</code> 和 空 <code>slice</code> 的处理是不一致</p>
<p>通常错误的用法，会报数组越界的错误，因为只是声明了slice，却没有给实例化的对象。nil的slice定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>此时slice的值是nil，这种情况可以用于需要返回slice的函数，当函数出现异常的时候，保证函数依然会有nil的返回值</p>
<hr>
<p>空的slice是指slice不为nil，但是slice没有值，slice的底层的空间是空的，空的slice定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>）</span><br><span class="line">slice := []<span class="type">int</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>当我们查询或者处理一个空的列表的时候，这非常有用，它会告诉我们返回的是一个列表，但是列表内没有任何值</p>
<p><strong>总结：</strong> nil的slice和空的slice是不同的东西，需要我们加以区分</p>
<h4 id="33-Go的Slice如何扩容"><a href="#33-Go的Slice如何扩容" class="headerlink" title="33. Go的Slice如何扩容"></a>33. Go的Slice如何扩容</h4><h5 id="33-1-数组Array和切片Slice"><a href="#33-1-数组Array和切片Slice" class="headerlink" title="33.1 数组Array和切片Slice"></a>33.1 数组Array和切片Slice</h5><ol>
<li>数组和切片都是用来存储相同数据类型的数据结构</li>
<li>数组在初始化或者是定义的时候就必须指明长度，或者初始化的时候使用…自动推导其数组的长度，数组初始化后其长度就是固定不变的；切片在初始化或定义的时候无需声明其长度，可以往切片里追加元素，追加元素可能导致切片扩容</li>
<li>数组和切片都可以通过内置函数<code>len</code>求元素个数，都可以通过下标索引获取相对应的元素值，都可以通过<code>for range</code>进行遍历</li>
<li>函数参数：<strong>数组</strong>作为函数参数时，必须指定参数数组的大小，且传入的数组大小必须与指定的大小一致，数组为按值传递的，函数内对数组的值的改变不影响初始数组；<strong>切片</strong>作为函数参数传递时为按引用传递的，函数内对切片内元素的修改将导致函数外的值也发生改变，不过由于传入函数的是一个指针的副本，所以对该指针的修改不会导致原来的指针的变化（例如append函数不会改变原来的切片的值）</li>
</ol>
<hr>
<ul>
<li>slice是Go中的一种基本的数据结构，使用这种结构可以用来管理数据集合。但是slice本身并不是动态数据或者数组指针。slice常见的操作有 reslice、append、copy</li>
<li>slice自身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。slice本身是一个只读对象，其工作机制类似数组指针的一种封装</li>
<li>slice是对数组一个连续片段的引用，所以切片是一个引用类型。这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集</li>
<li>slice的结构体由3部分构成，Pointer 是指向一个数组的指针，len 代表当前切片的长度，cap 是当前切片的容量。cap 总是大于等于 len 的</li>
</ul>
<p>通常我们在对slice进行append等操作时，可能会造成slice的自动扩容</p>
<ul>
<li><strong>1.18版本之前：</strong> 当原slice容量小于1024的时候，新slice容量变成原来的2倍；原slice容量超过1024，新slice容量变成原来的1.25倍</li>
<li><strong>1.18版本之后：</strong> 当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的2倍；原slice容量超过256，新slice容量newcap &#x3D; oldcap+(oldcap+3*256)&#x2F;4</li>
<li><strong>最后：</strong> 扩容后的容量并不一定就是按照以上公式计算的结果，容量可能会存在小的差异，主要原因是扩容后会有内存对齐，导致容量不是百分百按照公式计算的结果。如果扩容之后，还没有触及原数组的容量，那么，切片中的指针指向的位置，就还是原数组，如果扩容之后，超过了原数组的容量，那么，Go就会开辟一块新的内存，把原来的值拷贝过来，这种情况丝毫不会影响到原数组</li>
</ul>
<h4 id="34-Go的Struct能不能比较"><a href="#34-Go的Struct能不能比较" class="headerlink" title="34. Go的Struct能不能比较"></a>34. Go的Struct能不能比较</h4><ul>
<li>相同struct类型的可以比较</li>
<li>不同struct类型的不可以比较，编译都不过，类型不匹配</li>
</ul>
<h4 id="35-Go中的map的实现"><a href="#35-Go中的map的实现" class="headerlink" title="35. Go中的map的实现"></a>35. Go中的map的实现</h4><p>Go中Map是一个KV对集合。底层使用<code>hash table</code>，用链表来解决冲突 ，出现冲突时，不是每一个Key都申请一个结构通过链表串起来，而是以bmap为最小粒度挂载，一个bmap可以放8个kv</p>
<p>在哈希函数的选择上，会在程序启动时，检测 cpu 是否支持 <code>aes</code>，如果支持，则使用<code>aes hash</code>，否则使用<code>memhash</code></p>
<p>每个map的底层结构是hmap，是有若干个结构为bmap的bucket组成的数组。每个bucket底层都采用链表结构</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count     <span class="type">int</span>    <span class="comment">// 元素个数</span></span><br><span class="line">    flags     <span class="type">uint8</span>  <span class="comment">// 用来标记状态</span></span><br><span class="line">    B         <span class="type">uint8</span>  <span class="comment">// 扩容常量相关字段B是buckets数组的长度的对数 2^B</span></span><br><span class="line">    noverflow <span class="type">uint16</span> <span class="comment">// noverflow是溢出桶的数量，当B&lt;16时，为精确值,当B&gt;=16时，为估计值                       </span></span><br><span class="line">    hash0     <span class="type">uint32</span> <span class="comment">// 是哈希的种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定，并在调用哈希函数时作为参数传入</span></span><br><span class="line"></span><br><span class="line">    buckets    unsafe.Pointer <span class="comment">// 桶的地址 </span></span><br><span class="line">    oldbuckets unsafe.Pointer <span class="comment">// 旧桶的地址，用于扩容 </span></span><br><span class="line">    nevacuate  <span class="type">uintptr</span>        <span class="comment">// 搬迁进度，扩容需要将旧数据搬迁至新数据，这里是利用指针来比较判断有没有迁移 </span></span><br><span class="line"></span><br><span class="line">    extra *mapextra <span class="comment">// 用于扩容的指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">    overflow    *[]*bmap</span><br><span class="line">    oldoverflow *[]*bmap</span><br><span class="line">    <span class="comment">// nextOverflow holds a pointer to a free overflow bucket.</span></span><br><span class="line">    nextOverflow *bmap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A bucket for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    tophash [bucketCnt]<span class="type">uint8</span>  <span class="comment">// tophash用于记录8个key哈希值的高8位，这样在寻找对应key的时候可以更快，不必每次都对key做全等判断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际上编辑期间会动态生成一个新的结构体</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    topbits  [<span class="number">8</span>]<span class="type">uint8</span></span><br><span class="line">    keys     [<span class="number">8</span>]keytype</span><br><span class="line">    values   [<span class="number">8</span>]valuetype</span><br><span class="line">    pad      <span class="type">uintptr</span></span><br><span class="line">    overflow <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bmap 就是我们常说的“桶”，桶里面会最多装 8 个 key，这些 key之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果是“一类”的，关于key的定位我们在map的查询和赋值中详细说明</p>
<p>在桶内，又会根据key计算出来的hash值的高8位来决定 key到底落入桶内的哪个位置（一个桶内最多有8个位置)</p>
<p>当map的key和value都不是指针，并且 size都小于128字节的情况下，会把bmap标记为不含指针，这样可以避免gc时扫描整个hmap</p>
<p>bmap其实有一个overflow的字段，是指针类型的，破坏了 bmap 不含指针的设想，这时会把overflow移动到 hmap的extra 字段来</p>
<p>这样随着哈希表存储的数据逐渐增多，我们会扩容哈希表或者使用额外的桶存储溢出的数据，不会让单个桶中的数据超过 8 个，不过溢出桶只是临时的解决方案，创建过多的溢出桶最终也会导致哈希的扩容</p>
<h4 id="36-Go中的map如何实现顺序读取"><a href="#36-Go中的map如何实现顺序读取" class="headerlink" title="36. Go中的map如何实现顺序读取"></a>36. Go中的map如何实现顺序读取</h4><p>Go中map如果要实现顺序读取的话，先把map中的key添加到数组（array）或切片（slice）中，然后通过sort包对数组或切片进行排序，最后在遍历数组或切片的时候将map中key以及对应的value取出来</p>
<h4 id="37-Go中new和make的区别"><a href="#37-Go中new和make的区别" class="headerlink" title="37. Go中new和make的区别"></a>37. Go中new和make的区别</h4><ul>
<li>值类型：int，float，bool，string，struct和array。变量直接存储值，分配栈区的内存空间，这些变量所占据的空间在函数被调用完后会自动释放</li>
<li>引用类型：slice，map，chan和值类型对应的指针。变量存储的是一个地址（或者理解为指针），指针指向内存中真正存储数据的首地址。内存通常在堆上分配，通过GC回收</li>
<li><strong>注意：</strong> 对于引用类型的变量，我们不仅要声明变量，更重要的是，我们得手动为它分配空间</li>
</ul>
<ol>
<li>new该方法的参数要求传入一个类型，而不是一个值，它会申请一个该类型大小的内存空间，并会初始化为对应的零值，返回指向该内存空间的一个指针。new只用于分配内存，返回一个指向地址的<strong>指针</strong>。它为每个新类型分配一片内存，初始化为0且返回类型*T的内存地址，它相当于&amp;T{}</li>
<li>make也是用于内存分配，但是和new不同，只用来引用对象slice、map和channel的内存创建，它返回的类型就是类型本身，而不是它们的指针类型。make只可用于<strong>slice</strong>，<strong>map</strong>，<strong>channel</strong>的初始化,返回的是<strong>引用</strong></li>
</ol>
<h4 id="38-Go的defer原理是什么"><a href="#38-Go的defer原理是什么" class="headerlink" title="38. Go的defer原理是什么"></a>38. Go的defer原理是什么</h4><p>defer意为延迟，在 golang 中用于延迟执行一个函数。它可以帮助我们处理容易忽略的问题，如资源释放、连接关闭等。但在实际使用过程中，有一些需要注意的地方：</p>
<ul>
<li>若函数中有多个 defer，其执行顺序为 先进后出，可以理解为栈</li>
<li>return 会做什么？Go 的函数返回值是通过堆栈返回的, return 语句不是原子操作，而是被拆成了两步<ul>
<li>给返回值赋值 (rval)</li>
<li>调用 defer 表达式</li>
<li>返回给调用函数(ret)</li>
</ul>
</li>
<li>若 defer 表达式有返回值，将会被丢弃。在实际开发中，defer 的使用经常伴随着闭包与匿名函数的使用</li>
</ul>
<h4 id="39-Go的select可以用于什么"><a href="#39-Go的select可以用于什么" class="headerlink" title="39. Go的select可以用于什么"></a>39. Go的select可以用于什么</h4><p>Golang 的 select 机制可以理解为是在语言层面实现了和 select, poll, epoll 相似的功能：监听多个描述符的读&#x2F;写等事件，一旦某个描述符就绪（一般是读或者写事件发生了），就能够将发生的事件通知给关心的应用程序去处理该事件。 golang 的 select 机制是，监听多个channel，每一个 case 是一个事件，可以是读事件也可以是写事件，随机选择一个执行，可以设置default，它的作用是：当监听的多个事件都阻塞住会执行default的逻辑</p>
<p>使用select case ,ok实现goroutine的优雅退出</p>
<ul>
<li>使用for-range退出</li>
<li>使用select case ,ok退出</li>
<li>使用退出通道退出</li>
</ul>
<h4 id="40-Go值接收者和指针接收者的区别"><a href="#40-Go值接收者和指针接收者的区别" class="headerlink" title="40. Go值接收者和指针接收者的区别"></a>40. Go值接收者和指针接收者的区别</h4><p>Go中的方法能给用户自定义的类型添加新的行为。它和函数的区别在于方法有一个接收者，给一个函数添加一个接收者，那么它就变成了方法。接收者可以是值接收者，也可以是指针接收者</p>
<p>在调用方法的时候，值类型既可以调用值接收者的方法，也可以调用指针接收者的方法；指针类型既可以调用指针接收者的方法，也可以调用值接收者的方法。也就是说，不管方法的接收者是什么类型，该类型的值和指针都可以调用，不必严格符合接收者的类型</p>
<table>
<thead>
<tr>
<th align="left">函数和方法</th>
<th align="left">值接收者</th>
<th align="left">指针接收者</th>
</tr>
</thead>
<tbody><tr>
<td align="left">值类型调用者</td>
<td align="left">方法会使用调用者的一个副本，类似于“传值”</td>
<td align="left">使用值的引用来调用方法，上例中，p1.GetAge() 实际上是 (&amp;p1).GetAge()</td>
</tr>
<tr>
<td align="left">指针类型调用者</td>
<td align="left">指针被解引用为值，上例中，p2.GetAge()实际上是 (*p1).GetAge()</td>
<td align="left">实际上也是“传值”，方法里的操作会影响到调用者，类似于指针传参，拷贝了一份指针</td>
</tr>
</tbody></table>
<p>如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法</p>
<p>如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身</p>
<p>通常我们使用指针作为方法的接收者的理由：</p>
<ul>
<li>使用指针方法能够修改接收者指向的值。</li>
<li>可以避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效</li>
</ul>
<p>因而，我们是使用值接收者还是指针接收者，不是由该方法是否修改了调用者（也就是接收者）来决定，而是应该基于该类型的本质</p>
<h4 id="41-Go中两个Nil可能不相等吗"><a href="#41-Go中两个Nil可能不相等吗" class="headerlink" title="41. Go中两个Nil可能不相等吗"></a>41. Go中两个Nil可能不相等吗</h4><p>Go中两个Nil可能不相等</p>
<p>接口(interface) 是对非接口值(例如指针，struct等)的封装，内部实现包含 2 个字段，类型 T 和 值 V。一个接口等于 nil，当且仅当 T 和 V 处于 unset 状态（T&#x3D;nil，V is unset）。两个接口值比较时，会先比较 T，再比较 V。接口值与非接口值比较时，会先将非接口值尝试转换为接口值，再比较</p>
<h4 id="42-Golang垃圾回收算法"><a href="#42-Golang垃圾回收算法" class="headerlink" title="42. Golang垃圾回收算法"></a>42. Golang垃圾回收算法</h4><p>Golang1.5版本后，采取的是“非分代的、非移动的、并发的、三色的”标记清除垃圾回收算法</p>
<p>垃圾回收算法分类：</p>
<ul>
<li>引用计数</li>
<li>标记-清除</li>
<li>分代回收</li>
</ul>
<p>golang的垃圾回收是基于标记清扫算法，这种算法需要进行 STW（stop the world)，这个过程就会导致程序是卡顿的，频繁的 GC 会严重影响程序性能，golang在此基础上进行了改进，通过三色标记清扫法与写屏障来减少STW的时间</p>
<p>gc的过程一共分为四个阶段：</p>
<ol>
<li>栈扫描（开始时STW） 所有对象最开始都是白色</li>
<li>从 root 开始找到所有可达对象，标记为灰色，放入待处理队列</li>
<li>遍历灰色对象队列，将其引用对象标记为灰色放入待处理队列，自身标记为黑色</li>
<li>清除（并发） 循环步骤3直到灰色队列为空为止，此时所有引用对象都被标记为黑色，所有不可达的对象依然为白色，白色的就是需要进行回收的对象</li>
</ol>
<p>三色标记法相对于普通标记清扫，减少了STW时间. 这主要得益于标记过程是 “on-the-fly” 的，在标记过程中是不需要STW的，它与程序是并发执行的，这就大大缩短了STW的时间</p>
<p>写屏障：</p>
<ul>
<li>当标记和程序是并发执行的，这就会造成一个问题. 在标记过程中，有新的引用产生，可能会导致误清扫</li>
<li>清扫开始前，标记为黑色的对象引用了一个新申请的对象，它肯定是白色的，而黑色对象不会被再次扫描，那么这个白色对象无法被扫描变成灰色、黑色，它就会最终被清扫，而实际它不应该被清扫</li>
<li>golang采用了写屏障，其作用就是为了避免这类误清扫问题. 写屏障即在内存写操作前，维护一个约束，从而确保清扫开始前，黑色的对象不能引用白色对象</li>
</ul>
<h4 id="43-GC的触发条件"><a href="#43-GC的触发条件" class="headerlink" title="43. GC的触发条件"></a>43. GC的触发条件</h4><ul>
<li>主动触发(手动触发)，通过调用<code>runtime.GC</code> 来触发<code>GC</code>，此调用阻塞式地等待当前<code>GC</code>运行完毕.</li>
<li>被动触发，分为两种方式：<ul>
<li>使用系统监控，当超过两分钟没有产生任何<code>GC</code>时，强制触发 <code>GC</code></li>
<li>使用步调（Pacing）算法，其核心思想是控制内存增长的比例,当前内存分配达到一定比例则触发</li>
</ul>
</li>
</ul>
<h4 id="44-Go中的http包的实现原理"><a href="#44-Go中的http包的实现原理" class="headerlink" title="44. Go中的http包的实现原理"></a>44. Go中的http包的实现原理</h4><p>Golang中http包中处理 HTTP 请求主要跟两个东西相关：ServeMux 和 Handler</p>
<p>ServeMux 本质上是一个 HTTP 请求路由器（或者叫多路复用器，Multiplexor）。它把收到的请求与一组预先定义的 URL 路径列表做对比，然后在匹配到路径的时候调用关联的处理器（Handler）</p>
<p>处理器（Handler）负责输出HTTP响应的头和正文。任何满足了http.Handler接口的对象都可作为一个处理器。通俗的说，对象只要有个如下签名的ServeHTTP方法即可</p>
<p>Go 语言的 HTTP 包自带了几个函数用作常用处理器，比如<code>FileServer</code>，<code>NotFoundHandler</code> 和 <code>RedirectHandler</code></p>
<h4 id="45-Go中的defer函数使用下面的两种情况下结果是什么"><a href="#45-Go中的defer函数使用下面的两种情况下结果是什么" class="headerlink" title="45. Go中的defer函数使用下面的两种情况下结果是什么"></a>45. Go中的defer函数使用下面的两种情况下结果是什么</h4><p>无</p>
<hr>
<h4 id="1-Go项目性能测试、压测"><a href="#1-Go项目性能测试、压测" class="headerlink" title="1. Go项目性能测试、压测"></a>1. Go项目性能测试、压测</h4><ol>
<li>单元测试，以<code>Test</code>开头，在需要测试的包路径内执行<code>go test</code>对该包进行测试</li>
<li>性能测试，以<code>Benchmark</code>开头，<code>go test</code>默认不会执行压力测试函数，需要通过指定参数<code>-test.bench</code>来运行压力测试函数，<code>-test.bench</code>后跟正则表达式，如：<code>go -test.bench=&quot;.*&quot;</code>表示执行所有的压力测试函数</li>
<li>测试覆盖率，<code>cover</code>工具，<code>go test -coverprofile=cover.out</code>，在测试文件目录下运行并统计测试覆盖率</li>
<li>性能分析，<code>pprof</code>进行性能分析</li>
<li>使用<code>Jmeter</code>做<code>Web</code>性能测试</li>
</ol>
<p>API性能测试指标，主要有3个：</p>
<ol>
<li>并发数（<code>Concurrent</code>），是指某个时间范围内，同时正在使用系统的用户数</li>
<li>每秒查询数（<code>QPS</code>），是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，<code>QPS</code>&#x3D;并发数&#x2F;平均请求响应时间，在说<code>QPS</code>时需要指明多少并发数下的<code>QPS</code>，因为不同并发数下<code>QPS</code>是不同的</li>
<li>请求响应时间（<code>TTLB</code>），是从客户端发出请求到得到响应的整个时间</li>
</ol>
<hr>
<h4 id="2-下面2个函数分别输出什么结果"><a href="#2-下面2个函数分别输出什么结果" class="headerlink" title="2. 下面2个函数分别输出什么结果"></a>2. 下面2个函数分别输出什么结果</h4><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h82o60shgaj312i0x2wn7.jpg" alt="image.png" style="zoom:55%;" /></div>

<h4 id="3-Go面向对象"><a href="#3-Go面向对象" class="headerlink" title="3. Go面向对象"></a>3. Go面向对象</h4><p>面向对象的三大基本特性：<strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong></p>
<ul>
<li>封装<ul>
<li>面向对象中的 “封装” 指的是可以隐藏对象的内部属性和实现细节，仅对外提供公开接口调用，这样子用户就不需要关注你内部是怎么实现的</li>
<li>在 Go 语言中的属性访问权限，通过首字母大小写来控制：<ul>
<li>首字母大写，代表是公共的、可被外部访问的</li>
<li>首字母小写，代表是私有的，不可以被外部访问</li>
</ul>
</li>
</ul>
</li>
<li>继承<ul>
<li>面向对象中的 “继承” 指的是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为</li>
<li>继承是编译时特征，在<code>struct</code>内加入所需要继承的类即可</li>
</ul>
</li>
<li>多态<ul>
<li>面向对象中的 “多态” 指的同一个行为具有多种不同表现形式或形态的能力，具体是指一个类实例（对象）的相同方法在不同情形有不同表现形式</li>
<li>多态也使得不同内部结构的对象可以共享相同的外部接口，也就是都是一套外部模板，内部实际是什么，只要符合规格就可以</li>
<li>多态是运行时特征，在 Go 语言中，多态是通过接口<code>interface</code>来实现的，类型和接口是松耦合的，某个类型的实例可以赋给它所实现的任意接口类型的变量</li>
</ul>
</li>
</ul>
<hr>
<p>知乎Golang面试题总结链接：<a href="https://zhuanlan.zhihu.com/p/471490292">点击跳转</a></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Go面试复习应该有所侧重，关注切片，通道，异常处理，Goroutine，GMP模型，字符串高效拼接，指针，反射，接口，sync。对于比较难懂的部分，GMP模型和GC和内存管理，应该主动去看<strong>源码</strong>，然后慢慢理解。业务代码写多了，自然就有理解了</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka面试题</title>
    <url>/2022/10/30/Kafka%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>Kafka面试题</p>
<h4 id="1-Kafka都有哪些特点"><a href="#1-Kafka都有哪些特点" class="headerlink" title="1. Kafka都有哪些特点"></a>1. Kafka都有哪些特点</h4><ul>
<li>高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒，每个topic可以分多个partition, consumer group 对partition进行consume操作</li>
<li>可扩展性：kafka集群支持热扩展</li>
<li>持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</li>
<li>容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）</li>
<li>高并发：支持数千个客户端同时读写</li>
</ul>
<h4 id="2-请简述下你在哪些场景下会选择Kafka"><a href="#2-请简述下你在哪些场景下会选择Kafka" class="headerlink" title="2. 请简述下你在哪些场景下会选择Kafka"></a>2. 请简述下你在哪些场景下会选择Kafka</h4><ul>
<li>日志收集：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、HBase、Solr等</li>
<li>消息系统：解耦和生产者和消费者、缓存消息等</li>
<li>用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘</li>
<li>运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告</li>
<li>流式处理：比如spark streaming和 Flink</li>
</ul>
<h4 id="3-Kafka的设计架构你知道吗"><a href="#3-Kafka的设计架构你知道吗" class="headerlink" title="3. Kafka的设计架构你知道吗"></a>3. Kafka的设计架构你知道吗</h4><p>Kafka架构分为以下几个部分：</p>
<ul>
<li>Producer ：消息生产者，就是向 kafka broker 发消息的客户端</li>
<li>Consumer ：消息消费者，向 kafka broker 取消息的客户端</li>
<li>Topic ：可以理解为一个队列，一个 Topic 又分为一个或多个分区</li>
<li>Consumer Group：这是 kafka 用来实现一个 topic 消息的广播（发给所有的 consumer）和单播（发给任意一个 consumer）的手段。一个 topic 可以有多个 Consumer Group</li>
<li>Broker ：一台 kafka 服务器就是一个 broker。一个集群由多个 broker 组成。一个 broker 可以容纳多个 topic</li>
<li>Partition：为了实现扩展性，一个非常大的 topic 可以分布到多个 broker上，每个 partition 是一个有序的队列。partition 中的每条消息都会被分配一个有序的id（offset）。将消息发给 consumer，kafka 只保证按一个 partition 中的消息的顺序，不保证一个 topic 的整体（多个 partition 间）的顺序</li>
<li>Offset：kafka 的存储文件都是按照 offset.kafka 来命名，用 offset 做名字的好处是方便查找。例如你想找位于 2049 的位置，只要找到 2048.kafka 的文件即可。当然 the first offset 就是 00000000000.kafka</li>
</ul>
<h4 id="4-Kafka分区的目的"><a href="#4-Kafka分区的目的" class="headerlink" title="4. Kafka分区的目的"></a>4. Kafka分区的目的</h4><p>分区对于 Kafka 集群的好处是：实现负载均衡。分区对于消费者来说，可以提高并发度，提高效率</p>
<h4 id="5-你知道Kafka是如何做到消息的有序性"><a href="#5-你知道Kafka是如何做到消息的有序性" class="headerlink" title="5. 你知道Kafka是如何做到消息的有序性"></a>5. 你知道Kafka是如何做到消息的有序性</h4><p>kafka 中的每个 partition 中的消息在写入时都是有序的，而且单独一个 partition 只能由一个消费者去消费，可以在里面保证消息的顺序性。但是分区之间的消息是不保证有序的</p>
<h4 id="6-Kafka的高可靠性是怎么实现的"><a href="#6-Kafka的高可靠性是怎么实现的" class="headerlink" title="6. Kafka的高可靠性是怎么实现的"></a>6. Kafka的高可靠性是怎么实现的</h4><p>参考：Kafka 是如何保证数据可靠性和一致性</p>
<h4 id="7-请谈一谈Kafka数据一致性原理"><a href="#7-请谈一谈Kafka数据一致性原理" class="headerlink" title="7. 请谈一谈Kafka数据一致性原理"></a>7. 请谈一谈Kafka数据一致性原理</h4><h4 id="8-ISR、OSR、AR-是什么"><a href="#8-ISR、OSR、AR-是什么" class="headerlink" title="8. ISR、OSR、AR 是什么"></a>8. ISR、OSR、AR 是什么</h4><ul>
<li>SR：In-Sync Replicas 副本同步队列</li>
<li>OSR：Out-of-Sync Replicas</li>
<li>AR：Assigned Replicas 所有副本</li>
</ul>
<p>ISR是由leader维护，follower从leader同步数据有一些延迟，超过相应的阈值会把 follower 剔除出 ISR, 存入OSR（Out-of-Sync Replicas ）列表，新加入的follower也会先存放在OSR中。AR&#x3D;ISR+OSR</p>
<h4 id="9-LEO、HW、LSO、LW等分别代表什么"><a href="#9-LEO、HW、LSO、LW等分别代表什么" class="headerlink" title="9. LEO、HW、LSO、LW等分别代表什么"></a>9. LEO、HW、LSO、LW等分别代表什么</h4><ul>
<li>LEO：是 LogEndOffset 的简称，代表当前日志文件中下一条</li>
<li>HW：水位或水印（watermark）一词，也可称为高水位(high watermark)，通常被用在流式处理领域（比如Apache Flink、Apache Spark等），以表征元素或事件在基于时间层面上的进度。在Kafka中，水位的概念反而与时间无关，而是与位置信息相关。严格来说，它表示的就是位置信息，即位移（offset）。取 partition 对应的 ISR中 最小的 LEO 作为 HW，consumer 最多只能消费到 HW 所在的位置上一条信息</li>
<li>LSO：是 LastStableOffset 的简称，对未完成的事务而言，LSO 的值等于事务中第一条消息的位置(firstUnstableOffset)，对已完成的事务而言，它的值同 HW 相同</li>
<li>LW：Low Watermark 低水位, 代表 AR 集合中最小的 logStartOffset 值</li>
</ul>
<h4 id="10-Kafka在什么情况下会出现消息丢失"><a href="#10-Kafka在什么情况下会出现消息丢失" class="headerlink" title="10. Kafka在什么情况下会出现消息丢失"></a>10. Kafka在什么情况下会出现消息丢失</h4><p>参考：Kafka 是如何保证数据可靠性和一致性</p>
<h4 id="11-怎么尽可能保证Kafka的可靠性"><a href="#11-怎么尽可能保证Kafka的可靠性" class="headerlink" title="11. 怎么尽可能保证Kafka的可靠性"></a>11. 怎么尽可能保证Kafka的可靠性</h4><p>参考：Kafka 是如何保证数据可靠性和一致性</p>
<h4 id="12-消费者和消费者组有什么关系"><a href="#12-消费者和消费者组有什么关系" class="headerlink" title="12. 消费者和消费者组有什么关系"></a>12. 消费者和消费者组有什么关系</h4><h4 id="13-Kafka的每个分区只能被一个消费者线程，如何做到多个线程同时消费一个分区"><a href="#13-Kafka的每个分区只能被一个消费者线程，如何做到多个线程同时消费一个分区" class="headerlink" title="13. Kafka的每个分区只能被一个消费者线程，如何做到多个线程同时消费一个分区"></a>13. Kafka的每个分区只能被一个消费者线程，如何做到多个线程同时消费一个分区</h4><h4 id="14-数据传输的事务有几种"><a href="#14-数据传输的事务有几种" class="headerlink" title="14. 数据传输的事务有几种"></a>14. 数据传输的事务有几种</h4><p>数据传输的事务定义通常有以下三种级别：</p>
<ul>
<li>最多一次：消息不会被重复发送，最多被传输一次，但也有可能一次不传输</li>
<li>最少一次：消息不会被漏发送，最少被传输一次，但也有可能被重复传输</li>
<li>精确的一次（Exactly once）：不会漏传输也不会重复传输，每个消息都传输被</li>
</ul>
<h4 id="15-Kafka消费者是否可以消费指定分区消息"><a href="#15-Kafka消费者是否可以消费指定分区消息" class="headerlink" title="15. Kafka消费者是否可以消费指定分区消息"></a>15. Kafka消费者是否可以消费指定分区消息</h4><p>Kafa consumer消费消息时，向broker发出fetch请求去消费特定分区的消息，consumer指定消息在日志中的偏移量（offset），就可以消费从这个位置开始的消息，customer拥有了offset的控制权，可以向后回滚去重新消费之前的消息，这是很有意义的</p>
<h4 id="16-Kafka消息是采用Pull模式，还是Push模式"><a href="#16-Kafka消息是采用Pull模式，还是Push模式" class="headerlink" title="16. Kafka消息是采用Pull模式，还是Push模式"></a>16. Kafka消息是采用Pull模式，还是Push模式</h4><p>Kafka最初考虑的问题是，customer应该从brokes拉取消息还是brokers将消息推送到consumer，也就是pull还push。在这方面，Kafka遵循了一种大部分消息系统共同的传统的设计：producer将消息推送到broker，consumer从broker拉取消息</p>
<p>一些消息系统比如Scribe和Apache Flume采用了push模式，将消息推送到下游的consumer。这样做有好处也有坏处：由broker决定消息推送的速率，对于不同消费速率的consumer就不太好处理了。消息系统都致力于让consumer以最大的速率最快速的消费消息，但不幸的是，push模式下，当broker推送的速率远大于consumer消费的速率时，consumer恐怕就要崩溃了。最终Kafka还是选取了传统的pull模式</p>
<p>Pull模式的另外一个好处是consumer可以自主决定是否批量的从broker拉取数据。Push模式必须在不知道下游consumer消费能力和消费策略的情况下决定是立即推送每条消息还是缓存之后批量推送。如果为了避免consumer崩溃而采用较低的推送速率，将可能导致一次只推送较少的消息而造成浪费。Pull模式下，consumer就可以根据自己的消费能力去决定这些策略</p>
<p>Pull有个缺点是，如果broker没有可供消费的消息，将导致consumer不断在循环中轮询，直到新消息到t达。为了避免这点，Kafka有个参数可以让consumer阻塞知道新消息到达(当然也可以阻塞知道消息的数量达到某个特定的量这样就可以批量发</p>
<h4 id="17-Kafka-消息格式的演变清楚吗"><a href="#17-Kafka-消息格式的演变清楚吗" class="headerlink" title="17. Kafka 消息格式的演变清楚吗"></a>17. Kafka 消息格式的演变清楚吗</h4><h4 id="18-Kafka-偏移量的演变清楚吗"><a href="#18-Kafka-偏移量的演变清楚吗" class="headerlink" title="18. Kafka 偏移量的演变清楚吗"></a>18. Kafka 偏移量的演变清楚吗</h4><h4 id="19-Kafka高效文件存储设计特点"><a href="#19-Kafka高效文件存储设计特点" class="headerlink" title="19. Kafka高效文件存储设计特点"></a>19. Kafka高效文件存储设计特点</h4><ul>
<li>Kafka把topic中一个parition大文件分成多个小文件段，通过多个小文件段，就容易定期清除或删除已经消费完文件，减少磁盘占用</li>
<li>通过索引信息可以快速定位message和确定response的最大大小</li>
<li>通过index元数据全部映射到memory，可以避免segment file的IO磁盘操作</li>
<li>通过索引文件稀疏存储，可以大幅降低index文件元数据占用空间大小</li>
</ul>
<h4 id="20-Kafka创建Topic时如何将分区放置到不同的Broker中"><a href="#20-Kafka创建Topic时如何将分区放置到不同的Broker中" class="headerlink" title="20. Kafka创建Topic时如何将分区放置到不同的Broker中"></a>20. Kafka创建Topic时如何将分区放置到不同的Broker中</h4><h4 id="21-Kafka新建的分区会在哪个目录下创建"><a href="#21-Kafka新建的分区会在哪个目录下创建" class="headerlink" title="21. Kafka新建的分区会在哪个目录下创建"></a>21. Kafka新建的分区会在哪个目录下创建</h4><h4 id="22-谈一谈Kafka的再均衡"><a href="#22-谈一谈Kafka的再均衡" class="headerlink" title="22. 谈一谈Kafka的再均衡"></a>22. 谈一谈Kafka的再均衡</h4><p>在Kafka中，当有新消费者加入或者订阅的topic数发生变化时，会触发Rebalance(再均衡：在同一个消费者组当中，分区的所有权从一个消费者转移到另外一个消费者)机制，Rebalance顾名思义就是重新均衡消费者消费。Rebalance的过程如下：</p>
<ul>
<li>第一步：所有成员都向coordinator发送请求，请求入组。一旦所有成员都发送了请求，coordinator会从中选择一个consumer担任leader的角色，并把组成员信息以及订阅信息发给leader</li>
<li>第二步：leader开始分配消费方案，指明具体哪个consumer负责消费哪些topic的哪些partition。一旦完成分配，leader会将这个方案发给coordinator。coordinator接收到分配方案之后会把方案发给各个consumer，这样组内的所有成员就都知道自己应该消费哪些分区了</li>
</ul>
<p>所以对于Rebalance来说，Coordinator起着至关重要的作用</p>
<h4 id="23-谈谈Kafka分区分配策略"><a href="#23-谈谈Kafka分区分配策略" class="headerlink" title="23. 谈谈Kafka分区分配策略"></a>23. 谈谈Kafka分区分配策略</h4><h4 id="24-Kafka-Producer是如何动态感知主题分区数变化的"><a href="#24-Kafka-Producer是如何动态感知主题分区数变化的" class="headerlink" title="24. Kafka Producer是如何动态感知主题分区数变化的"></a>24. Kafka Producer是如何动态感知主题分区数变化的</h4><h4 id="25-Kafka是如何实现高吞吐率的"><a href="#25-Kafka是如何实现高吞吐率的" class="headerlink" title="25. Kafka是如何实现高吞吐率的"></a>25. Kafka是如何实现高吞吐率的</h4><p>Kafka是分布式消息系统，需要处理海量的消息，Kafka的设计是把所有的消息都写入速度低容量大的硬盘，以此来换取更强的存储能力，但实际上，使用硬盘并没有带来过多的性能损失。kafka主要使用了以下几个方式实现了超高的吞吐率：</p>
<ul>
<li>顺序读写</li>
<li>零拷贝</li>
<li>文件分段</li>
<li>批量发送</li>
<li>数据压缩</li>
</ul>
<h4 id="26-Kafka监控都有哪些"><a href="#26-Kafka监控都有哪些" class="headerlink" title="26. Kafka监控都有哪些"></a>26. Kafka监控都有哪些</h4><h4 id="27-如何为Kafka集群选择合适的Topics-x2F-Partitions数量"><a href="#27-如何为Kafka集群选择合适的Topics-x2F-Partitions数量" class="headerlink" title="27. 如何为Kafka集群选择合适的Topics&#x2F;Partitions数量"></a>27. 如何为Kafka集群选择合适的Topics&#x2F;Partitions数量</h4><h4 id="28-谈谈你对Kafka事务的了解"><a href="#28-谈谈你对Kafka事务的了解" class="headerlink" title="28. 谈谈你对Kafka事务的了解"></a>28. 谈谈你对Kafka事务的了解</h4><h4 id="29-谈谈你对Kafka幂等的了解"><a href="#29-谈谈你对Kafka幂等的了解" class="headerlink" title="29. 谈谈你对Kafka幂等的了解"></a>29. 谈谈你对Kafka幂等的了解</h4><h4 id="30-Kafka缺点"><a href="#30-Kafka缺点" class="headerlink" title="30. Kafka缺点"></a>30. Kafka缺点</h4><ul>
<li>由于是批量发送，数据并非真正的实时</li>
<li>对于mqtt协议不支持</li>
<li>不支持物联网传感数据直接接入</li>
<li>仅支持统一分区内消息有序，无法实现全局消息有序</li>
<li>监控不完善，需要安装插件</li>
<li>依赖zookeeper进行元数据管理</li>
</ul>
<h4 id="31-Kafka新旧消费者的区别"><a href="#31-Kafka新旧消费者的区别" class="headerlink" title="31. Kafka新旧消费者的区别"></a>31. Kafka新旧消费者的区别</h4><p>旧的 Kafka 消费者 API 主要包括：SimpleConsumer（简单消费者） 和 ZookeeperConsumerConnectir（高级消费者）。SimpleConsumer 名字看起来是简单消费者，但是其实用起来很不简单，可以使用它从特定的分区和偏移量开始读取消息。高级消费者和现在新的消费者有点像，有消费者群组，有分区再均衡，不过它使用 ZK 来管理消费者群组，并不具备偏移量和再均衡的可操控性</p>
<h4 id="32-Kafka分区数可以增加或减少吗？为什么"><a href="#32-Kafka分区数可以增加或减少吗？为什么" class="headerlink" title="32. Kafka分区数可以增加或减少吗？为什么"></a>32. Kafka分区数可以增加或减少吗？为什么</h4><p>我们可以使用 bin&#x2F;kafka-topics.sh 命令对 Kafka 增加 Kafka 的分区数据，但是 Kafka 不支持减少分区数</p>
<p>Kafka 分区数据不支持减少是由很多原因的，比如减少的分区其数据放到哪里去？是删除，还是保留？删除的话，那么这些没消费的消息不就丢了。如果保留这些消息如何放到其他分区里面？追加到其他分区后面的话那么就破坏了 Kafka 单个分区的有序性。如果要保证删除分区数据插入到其他分区保证有序性，那么实现起来逻辑就会非常复杂</p>
<hr>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch面试题</title>
    <url>/2022/10/30/Elasticsearch%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>ES常见面试题</p>
<h4 id="1-ElasticSearch基础"><a href="#1-ElasticSearch基础" class="headerlink" title="1. ElasticSearch基础"></a>1. ElasticSearch基础</h4><h5 id="1-1-什么是Elasticsearch"><a href="#1-1-什么是Elasticsearch" class="headerlink" title="1.1 什么是Elasticsearch"></a>1.1 什么是Elasticsearch</h5><p>Elasticsearch 是基于 Lucene 的 Restful 的分布式实时全文搜索引擎，每个字段都被索引并可被搜索，可以快速存储、搜索、分析海量的数据</p>
<blockquote>
<p>全文检索是指对每一个词建立一个索引，指明该词在文章中出现的次数和位置。当查询时，根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。这个过程类似于通过字典中的检索字表查字的过程</p>
</blockquote>
<h5 id="1-2-Elasticsearch-的基本概念"><a href="#1-2-Elasticsearch-的基本概念" class="headerlink" title="1.2 Elasticsearch 的基本概念"></a>1.2 Elasticsearch 的基本概念</h5><ul>
<li>index 索引：索引类似于mysql 中的数据库，Elasticesearch 中的索引是存在数据的地方，包含了一堆有相似结构的文档数据</li>
<li>type 类型：类型是用来定义数据结构，可以认为是 mysql 中的一张表，type 是 index 中的一个逻辑数据分类</li>
<li>document 文档：类似于 MySQL 中的一行，不同之处在于 ES 中的每个文档可以有不同的字段，但是对于通用字段应该具有相同的数据类型，文档是es中的最小数据单元，可以认为一个文档就是一条记录</li>
<li>Field 字段：Field是Elasticsearch的最小单位，一个document里面有多个field</li>
<li>shard 分片：单台机器无法存储大量数据，es可以将一个索引中的数据切分为多个shard，分布在多台服务器上存储。有了shard就可以横向扩展，存储更多数据，让搜索和分析等操作分布到多台服务器上去执行，提升吞吐量和性能。shard 分片数量在建立索引时设置，设置后不能修改，默认5个；replica 副本数量默认1个，可随时修改数量</li>
<li>replica 副本：任何服务器随时可能故障或宕机，此时 shard 可能会丢失，通过创建 replica 副本，可以在 shard 故障时提供备用服务，保证数据不丢失，另外 replica 还可以提升搜索操作的吞吐量</li>
</ul>
<h5 id="1-3-什么是倒排索引"><a href="#1-3-什么是倒排索引" class="headerlink" title="1.3 什么是倒排索引"></a>1.3 什么是倒排索引</h5><p>在搜索引擎中，每个文档都有对应的文档 ID，文档内容可以表示为一系列关键词的集合，例如，某个文档经过分词，提取了 20 个关键词，而通过倒排索引，可以记录每个关键词在文档中出现的次数和出现位置。也就是说，倒排索引是 关键词到文档 ID 的映射，每个关键词都对应着一系列的文件，这些文件中都出现了该关键词</p>
<p><strong>要注意倒排索引的两个细节：</strong></p>
<ul>
<li>倒排索引中的所有词项对应一个或多个文档</li>
<li>倒排索引中的词项 根据字典顺序升序排列</li>
</ul>
<h5 id="1-4-doc-values-的作用"><a href="#1-4-doc-values-的作用" class="headerlink" title="1.4 doc_values 的作用"></a>1.4 doc_values 的作用</h5><p>倒排索引虽然可以提高搜索性能，但也存在缺陷，比如我们需要对数据做排序或聚合等操作时，lucene 会提取所有出现在文档集合的排序字段，然后构建一个排好序的文档集合，而这个步骤是基于内存的，如果排序数据量巨大的话，容易造成内存溢出和性能缓慢</p>
<p>doc_values 就是 es 在构建倒排索引的同时，会对开启 doc_values 的字段构建一个有序的 “document文档 &#x3D;&#x3D;&gt; field value” 的列式存储映射，可以看作是以文档维度，实现了根据指定字段进行排序和聚合的功能，降低对内存的依赖。另外 doc_values 保存在操作系统的磁盘中，当 doc_values 大于节点的可用内存，ES可以从操作系统页缓存中加载或弹出，从而避免发生内存溢出的异常，但如果 docValues 远小于节点的可用内存，操作系统就自然将所有 doc_values 存于内存中（堆外内存），有助于快速访问</p>
<h5 id="1-5-text-和-keyword类型的区别"><a href="#1-5-text-和-keyword类型的区别" class="headerlink" title="1.5 text 和 keyword类型的区别"></a>1.5 text 和 keyword类型的区别</h5><p>两个类型的区别主要是分词：keyword 类型是不会分词的，直接根据字符串内容建立倒排索引，所以keyword类型的字段只能通过精确值搜索到；Text 类型在存入 Elasticsearch 的时候，会先分词，然后根据分词后的内容建立倒排索引</p>
<h5 id="1-6-query-和-filter-的区别"><a href="#1-6-query-和-filter-的区别" class="headerlink" title="1.6 query 和 filter 的区别"></a>1.6 query 和 filter 的区别</h5><ul>
<li>query：查询操作不仅仅会进行查询，还会计算分值，用于确定相关度</li>
<li>filter：查询操作仅判断是否满足查询条件，不会计算任何分值，也不会关心返回的排序问题，同时，filter 查询的结果可以被缓存，提高性能</li>
</ul>
<h4 id="2-ES的写入流程"><a href="#2-ES的写入流程" class="headerlink" title="2. ES的写入流程"></a>2. ES的写入流程</h4><h5 id="2-1-ES写数据的整体流程"><a href="#2-1-ES写数据的整体流程" class="headerlink" title="2.1 ES写数据的整体流程"></a>2.1 ES写数据的整体流程</h5><p><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7ov3hao7ij30pr0bndhh.jpg" alt="image.png"></p>
<ul>
<li>客户端选择 ES 的某个 node 发送请求过去，这个 node 就是协调节点 coordinating node</li>
<li>coordinating node 对 document 进行路由，将请求转发给对应的 node（有 primary shard）</li>
<li>实际的 node 上的 primary shard 处理请求，然后将数据同步到 replica node</li>
<li>coordinating node 等到 primary node 和所有 replica node 都执行成功之后，最后返回响应结果给客户端</li>
</ul>
<h5 id="2-2-ES主分片写数据的详细流程"><a href="#2-2-ES主分片写数据的详细流程" class="headerlink" title="2.2 ES主分片写数据的详细流程"></a>2.2 ES主分片写数据的详细流程</h5><p><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7ov576wq8j30s20avjtl.jpg" alt="image.png"></p>
<ol>
<li><p>主分片先将数据写入ES的 memory buffer，然后定时（默认1s）将 memory buffer 中的数据写入一个新的 segment 文件中，并进入操作系统缓存 Filesystem cache（同时清空 memory buffer），这个过程就叫做 refresh；每个 segment 文件实际上是一些倒排索引的集合， 只有经历了 refresh 操作之后，这些数据才能变成可检索的</p>
<blockquote>
<p>ES 的近实时性：数据存在 memory buffer 时是搜索不到的，只有数据被 refresh 到  Filesystem cache 之后才能被搜索到，而 refresh 是每秒一次， 所以称 es 是近实时的；可以手动调用 es 的 api 触发一次 refresh 操作，让数据马上可以被搜索到</p>
</blockquote>
</li>
<li><p>由于 memory Buffer 和 Filesystem Cache 都是基于内存，假设服务器宕机，那么数据就会丢失，所以 ES 通过 translog 日志文件来保证数据的可靠性，在数据写入 memory buffer 的同时，将数据也写入 translog 日志文件中，当机器宕机重启时，es 会自动读取 translog 日志文件中的数据，恢复到 memory buffer 和 Filesystem cache 中去</p>
<blockquote>
<p>ES 数据丢失的问题：translog 也是先写入 Filesystem cache，然后默认每隔 5 秒刷一次到磁盘中，所以默认情况下，可能有 5 秒的数据会仅仅停留在 memory buffer 或者 translog 文件的 Filesystem cache中，而不在磁盘上，如果此时机器宕机，会丢失 5 秒钟的数据。也可以将 translog 设置成每次写操作必须是直接 fsync 到磁盘，但是性能会差很多</p>
</blockquote>
</li>
<li><p>flush 操作：不断重复上面的步骤，translog 会变得越来越大，不过 translog 文件默认每30分钟或者 阈值超过 512M 时，就会触发 commit 操作，即 flush操作，将 memory buffer 中所有的数据写入新的 segment 文件中， 并将内存中所有的 segment 文件全部落盘，最后清空 translog 事务日志</p>
<blockquote>
<ul>
<li>将 memory buffer 中的数据 refresh 到 Filesystem Cache 中去，清空 buffer</li>
<li>创建一个新的 commit point（提交点），同时强行将 Filesystem Cache 中目前所有的数据都 fsync 到磁盘文件中</li>
<li>删除旧的 translog 日志文件并创建一个新的 translog 日志文件，此时 commit 操作完成</li>
</ul>
</blockquote>
</li>
</ol>
<h4 id="3-ES的更新和删除流程"><a href="#3-ES的更新和删除流程" class="headerlink" title="3. ES的更新和删除流程"></a>3. ES的更新和删除流程</h4><p>删除和更新都是写操作，但是由于 Elasticsearch 中的文档是不可变的，因此不能被删除或者改动以展示其变更；所以 ES 利用 .del 文件 标记文档是否被删除，磁盘上的每个段都有一个相应的.del 文件</p>
<ul>
<li>如果是删除操作，文档其实并没有真的被删除，而是在 .del 文件中被标记为 deleted 状态。该文档依然能匹配查询，但是会在结果中被过滤掉</li>
<li>如果是更新操作，就是将旧的 doc 标识为 deleted 状态，然后创建一个新的 doc</li>
</ul>
<p>memory buffer 每 refresh 一次，就会产生一个 segment 文件 ，所以默认情况下是 1s 生成一个 segment 文件，这样下来 segment 文件会越来越多，此时会定期执行 merge。每次 merge 的时候，会将多个 segment 文件合并成一个，同时这里会将标识为 deleted 的 doc 给物理删除掉，不写入到新的 segment 中，然后将新的 segment 文件写入磁盘，这里会写一个 commit point ，标识所有新的 segment 文件，然后打开 segment 文件供搜索使用，同时删除旧的 segment 文件</p>
<h4 id="4-ES的搜索流程"><a href="#4-ES的搜索流程" class="headerlink" title="4. ES的搜索流程"></a>4. ES的搜索流程</h4><p>搜索被执行成一个两阶段过程，即 Query Then Fetch：</p>
<ul>
<li>Query阶段<ul>
<li>客户端发送请求到 coordinate node，协调节点将搜索请求广播到所有的 primary shard 或 replica，每个分片在本地执行搜索并构建一个匹配文档的大小为 from + size 的优先队列。接着每个分片返回各自优先队列中 所有 docId 和 打分值 给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果</li>
</ul>
</li>
<li>Fetch阶段<ul>
<li>协调节点根据 Query阶段产生的结果，去各个节点上查询 docId 实际的 document 内容，最后由协调节点返回结果给客户端</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>coordinate node 对 doc id 进行哈希路由，将请求转发到对应的 node，此时会使用 round-robin 随机轮询算法，在 primary shard 以及其所有 replica 中随机选择一个，让读请求负载均衡</li>
<li>接收请求的 node 返回 document 给 coordinate node</li>
<li>coordinate node 返回 document 给客户端</li>
</ul>
</blockquote>
<p>Query Then Fetch 的搜索类型在文档相关性打分的时候参考的是本分片的数据，这样在文档数量较少的时候可能不够准确，DFS Query Then Fetch 增加了一个预查询的处理，询问 Term 和 Document frequency，这个评分更准确，但是性能会变差</p>
<h4 id="5-ES在高并发下如何保证读写一致性"><a href="#5-ES在高并发下如何保证读写一致性" class="headerlink" title="5. ES在高并发下如何保证读写一致性"></a>5. ES在高并发下如何保证读写一致性</h4><ul>
<li>对于更新操作：可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖<ul>
<li>每个文档都有一个_version 版本号，这个版本号在文档被改变时加一。Elasticsearch使用这个 _version 保证所有修改都被正确排序，当一个旧版本出现在新版本之后，它会被简单的忽略</li>
<li>利用_version的这一优点确保数据不会因为修改冲突而丢失，比如指定文档的version来做更改，如果那个版本号不是现在的，我们的请求就失败了</li>
</ul>
</li>
<li>对于写操作，一致性级别支持 quorum&#x2F;one&#x2F;all，默认为 quorum，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，副本将会在一个不同的节点上重建<ul>
<li>one：写操作只要有一个primary shard是active活跃可用的，就可以执行</li>
<li>all：写操作必须所有的primary shard和replica shard都是活跃可用的，才可以执行</li>
<li>quorum：默认值，要求ES中大部分的shard是活跃可用的，才可以执行写操作</li>
</ul>
</li>
<li>对于读操作，可以设置 replication 为 sync(默认)，这使得操作在主分片和副本分片都完成后才会返回；如果设置replication 为 async 时，也可以通过设置搜索请求参数 _preference 为 primary 来查询主分片，确保文档是最新版本</li>
</ul>
<h4 id="6-ES集群如何选举Master节点"><a href="#6-ES集群如何选举Master节点" class="headerlink" title="6. ES集群如何选举Master节点"></a>6. ES集群如何选举Master节点</h4><h5 id="6-1-Elasticsearch的分布式原理"><a href="#6-1-Elasticsearch的分布式原理" class="headerlink" title="6.1 Elasticsearch的分布式原理"></a>6.1 Elasticsearch的分布式原理</h5><p>Elasticsearch 会对存储的数据进行切分，划分到不同的分片上，同时每一个分片会生成多个副本，从而保证分布式环境的高可用。ES集群中的节点是对等的，节点间会选出集群的 Master，由 Master 会负责维护集群状态信息，并同步给其他节点</p>
<p>Elasticsearch 的性能会不会很低：不会，ES只有建立 index 和 type 时需要经过 Master，而数据的写入有一个简单的 Routing 规则，可以路由到集群中的任意节点，所以数据写入压力是分散在整个集群的</p>
<h5 id="6-2-ES集群如何选举Master"><a href="#6-2-ES集群如何选举Master" class="headerlink" title="6.2 ES集群如何选举Master"></a>6.2 ES集群如何选举Master</h5><p>Elasticsearch 的选主是 ZenDiscovery 模块负责的，主要包含Ping（节点之间通过这个RPC来发现彼此）和 Unicast（单播模块包含一个主机列表以控制哪些节点需要ping通）这两部分</p>
<ul>
<li>确认候选主节点的最少投票通过数量（elasticsearch.yml 设置的值 discovery.zen.minimum_master_nodes）</li>
<li>选举时，集群中每个节点对所有 master候选节点（node.master: true）根据 nodeId 进行字典排序，然后选出第一个节点（第0位），暂且认为它是master节点</li>
<li>如果对某个节点的投票数达到阈值，并且该节点自己也选举自己，那这个节点就是master；否则重新选举一直到满足上述条件</li>
</ul>
<p><strong>补充：</strong> master节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理；data节点可以关闭http功能</p>
<h5 id="6-3-Elasticsearch是如何避免脑裂现象"><a href="#6-3-Elasticsearch是如何避免脑裂现象" class="headerlink" title="6.3 Elasticsearch是如何避免脑裂现象"></a>6.3 Elasticsearch是如何避免脑裂现象</h5><ul>
<li>当集群中 master 候选节点数量不小于3个时（node.master: true），可以通过设置最少投票通过数量（discovery.zen.minimum_master_nodes），设置超过所有候选节点一半以上来解决脑裂问题，即设置为 (N&#x2F;2)+1</li>
<li>当集群 master 候选节点 只有两个时，这种情况是不合理的，最好把另外一个node.master改成false。如果我们不改节点设置，还是套上面的(N&#x2F;2)+1公式，此时discovery.zen.minimum_master_nodes应该设置为2。这就出现一个问题，两个master备选节点，只要有一个挂，就选不出master了</li>
</ul>
<h4 id="7-建立索引阶段性能提升方法"><a href="#7-建立索引阶段性能提升方法" class="headerlink" title="7. 建立索引阶段性能提升方法"></a>7. 建立索引阶段性能提升方法</h4><ul>
<li>如果是大批量导入，可以设置 index.number_of_replicas: 0 关闭副本，等数据导入完成之后再开启副本</li>
<li>使用批量请求并调整其大小：每次批量数据 5–15 MB 大是个不错的起始点</li>
<li>如果搜索结果不需要近实时性，可以把每个索引的 index.refresh_interval 改到30s</li>
<li>增加 index.translog.flush_threshold_size 设置，从默认的 512 MB 到更大一些的值，比如 1 GB</li>
<li>使用 SSD 存储介质</li>
<li>段和合并：Elasticsearch 默认值是 20 MB&#x2F;s。但如果用的是 SSD，可以考虑提高到 100–200 MB&#x2F;s。如果你在做批量导入，完全不在意搜索，你可以彻底关掉合并限流</li>
</ul>
<h4 id="8-ES的深度分页与滚动搜索scroll"><a href="#8-ES的深度分页与滚动搜索scroll" class="headerlink" title="8. ES的深度分页与滚动搜索scroll"></a>8. ES的深度分页与滚动搜索scroll</h4><ul>
<li>深度分页<ul>
<li>深度分页其实就是搜索的深浅度，比如第1页，第2页，第10页，第20页，是比较浅的；第10000页，第20000页就是很深了。搜索得太深，就会造成性能问题，会耗费内存和占用cpu。而且es为了性能，他不支持超过一万条数据以上的分页查询。那么如何解决深度分页带来的问题，我们应该避免深度分页操作（限制分页页数），比如最多只能提供100页的展示，从第101页开始就没了，毕竟用户也不会搜的那么深</li>
</ul>
</li>
<li>滚动搜索<ul>
<li>一次性查询1万+数据，往往会造成性能影响，因为数据量太多了。这个时候可以使用滚动搜索，也就是 scroll。 滚动搜索可以先查询出一些数据，然后再紧接着依次往下查询。在第一次查询的时候会有一个滚动id，相当于一个锚标记 ，随后再次滚动搜索会需要上一次搜索滚动id，根据这个进行下一次的搜索请求。每次搜索都是基于一个历史的数据快照，查询数据的期间，如果有数据变更，那么和搜索是没有关系的</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux操作系统面试题</title>
    <url>/2022/10/28/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>Linux常见面试题整理</p>
<hr>
<p><strong>50个最常用的Unix&#x2F;Linux命令</strong></p>
<h4 id="1-tar"><a href="#1-tar" class="headerlink" title="1. tar"></a>1. tar</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar cvf archive_name.tar <span class="built_in">dirname</span>/ 创建一个新的tar文件</span><br><span class="line">tar xvf archive_name.tar 解压tar文件</span><br><span class="line">tar tvf archive_name.tar 查看tar文件</span><br></pre></td></tr></table></figure>

<h4 id="2-grep"><a href="#2-grep" class="headerlink" title="2. grep"></a>2. grep</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">grep -i <span class="string">&quot;the&quot;</span> demo_file 在文件中查找字符串(不区分大小写)</span><br><span class="line">grep -A 3 -i <span class="string">&quot;example&quot;</span> demo_text 输出成功匹配的行，以及该行之后的三行</span><br><span class="line">grep -r <span class="string">&quot;ramesh&quot;</span> * 在一个文件夹中递归查询包含指定字符串的文件</span><br></pre></td></tr></table></figure>

<h4 id="3-find"><a href="#3-find" class="headerlink" title="3. find"></a>3. find</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">find -iname <span class="string">&quot;MyProgram.c&quot;</span> 查找指定文件名的文件(不区分大小写)</span><br><span class="line">find -iname <span class="string">&quot;MyProgram.c&quot;</span> -<span class="built_in">exec</span> <span class="built_in">md5sum</span> &#123;&#125; \; 对找到的文件执行某个命令</span><br><span class="line">find ~ -empty 查找home目录下的所有空文件</span><br></pre></td></tr></table></figure>

<h4 id="4-ssh"><a href="#4-ssh" class="headerlink" title="4. ssh"></a>4. ssh</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh -l jsmith remotehost.example.com 登录到远程主机</span><br><span class="line">ssh -v -l jsmith remotehost.example.com 调试ssh客户端</span><br><span class="line">ssh -V 显示ssh客户端版本</span><br></pre></td></tr></table></figure>

<h4 id="5-sed"><a href="#5-sed" class="headerlink" title="5. sed"></a>5. sed</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/.$//&#x27;</span> filename 当你将Dos系统中的文件复制到Unix/Linux后，这个文件每行都会以\r\n结尾，sed可以轻易将其转换为Unix格式的文件，使用\n结尾的文件</span><br><span class="line">sed -n <span class="string">&#x27;1!G; h; p&#x27;</span> filename 反转文件内容并输出</span><br><span class="line">sed <span class="string">&#x27;/./=&#x27;</span> thegeekstuff.txt | sed <span class="string">&#x27;N; s/\n/ /&#x27;</span> 为非空行添加行号</span><br></pre></td></tr></table></figure>

<h4 id="6-awk"><a href="#6-awk" class="headerlink" title="6. awk"></a>6. awk</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;!($0 in array) &#123; array[$0]; print&#125;&#x27;</span> temp 删除重复行</span><br><span class="line">awk -F <span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;$3=$4&#x27;</span> /etc/passwd 打印/etc/passwd中所有包含同样的uid和gid的行</span><br><span class="line">awk <span class="string">&#x27;&#123;print $2,$5;&#125;&#x27;</span> employee.txt 打印文件中的指定部分的字段</span><br></pre></td></tr></table></figure>

<h4 id="7-vim"><a href="#7-vim" class="headerlink" title="7. vim"></a>7. vim</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim +10 filename.txt 打开文件并跳到第10行</span><br><span class="line">vim +/search-term filename.txt 打开文件跳到第一个匹配的行</span><br><span class="line">vim -R /etc/passwd 以只读模式打开文件</span><br></pre></td></tr></table></figure>

<h4 id="8-diff"><a href="#8-diff" class="headerlink" title="8. diff"></a>8. diff</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">diff -w name_list.txt name_list_new.txt 比较的时候忽略空白符</span><br></pre></td></tr></table></figure>

<h4 id="9-sort"><a href="#9-sort" class="headerlink" title="9. sort"></a>9. sort</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span> names.txt 以升序对文件内容排序</span><br><span class="line"><span class="built_in">sort</span> -r names.txt 以降序对文件内容排序</span><br><span class="line"><span class="built_in">sort</span> -t: -k 3n /etc/passwd | more 以第三个字段对/etc/passwd的内容排序</span><br></pre></td></tr></table></figure>

<h4 id="10-export"><a href="#10-export" class="headerlink" title="10. export"></a>10. export</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> | grep ORCALE 输出跟字符串oracle匹配的环境变量</span><br><span class="line"><span class="built_in">export</span> ORACLE_HOME=/u01/app/oracle/product/10.2.0 设置全局环境变量</span><br></pre></td></tr></table></figure>

<h4 id="11-xargs"><a href="#11-xargs" class="headerlink" title="11. xargs"></a>11. xargs</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> *.jpg | xargs -n1 -i <span class="built_in">cp</span> &#123;&#125; /external-hard-drive/directory 将所有图片文件拷贝到外部驱动器</span><br><span class="line">find / -name *.jpg -<span class="built_in">type</span> f -<span class="built_in">print</span> | xargs tar -cvzf images.tar.gz 将系统中所有jpd文件压缩打包</span><br><span class="line"><span class="built_in">cat</span> url-list.txt | xargs wget –c 下载文件中列出的所有url对应的页面</span><br></pre></td></tr></table></figure>

<h4 id="12-ls"><a href="#12-ls" class="headerlink" title="12. ls"></a>12. ls</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lh 以易读的方式显示文件大小(显示为MB,GB...)</span><br><span class="line"><span class="built_in">ls</span> -ltr 以最后修改时间升序列出文件</span><br><span class="line"><span class="built_in">ls</span> -F 在文件名后面显示文件类型</span><br></pre></td></tr></table></figure>

<h4 id="13-pwd"><a href="#13-pwd" class="headerlink" title="13. pwd"></a>13. pwd</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">输出当前工作目录</span><br></pre></td></tr></table></figure>

<h4 id="14-cd"><a href="#14-cd" class="headerlink" title="14. cd"></a>14. cd</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> 可以在最近工作的两个目录间切换</span><br><span class="line"><span class="built_in">cd</span> ../ 跳到上级目录</span><br><span class="line"><span class="built_in">cd</span> /opt 不管现在到那直接跳到指定的opt文件夹中</span><br><span class="line"><span class="built_in">cd</span> ~ 切换当前用户的家目录。root用户的家目录就是root目录</span><br></pre></td></tr></table></figure>

<h4 id="15-gzip"><a href="#15-gzip" class="headerlink" title="15. gzip"></a>15. gzip</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gzip test.txt 创建一个*.gz的压缩文件</span><br><span class="line">gzip -d test.txt.gz 解压*.gz文件</span><br><span class="line">gzip -l *.gz 显示压缩的比率</span><br></pre></td></tr></table></figure>

<h4 id="16-bzip2"><a href="#16-bzip2" class="headerlink" title="16. bzip2"></a>16. bzip2</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bzip2 test.txt 创建*.bz2压缩文件</span><br><span class="line">bzip2 -d test.txt.bz2 解压*.bz2文件</span><br></pre></td></tr></table></figure>

<h4 id="17-uzip"><a href="#17-uzip" class="headerlink" title="17. uzip"></a>17. uzip</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">unzip test.zip 解压*.zip文件</span><br><span class="line">unzip -l jasper.zip 查看*.zip文件的内容</span><br></pre></td></tr></table></figure>

<h4 id="18-shutdown"><a href="#18-shutdown" class="headerlink" title="18. shutdown"></a>18. shutdown</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">shutdown -h now 关闭系统并立即关机</span><br><span class="line">shutdown -h +10 10分钟后关机</span><br><span class="line">shutdown -r now 重启</span><br><span class="line">shutdown -Fr now 重启期间强制进行系统检查</span><br></pre></td></tr></table></figure>

<h4 id="19-ftp"><a href="#19-ftp" class="headerlink" title="19. ftp"></a>19. ftp</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ftp IP/hostname ftp命令和sftp命令的用法基本相似连接ftp服务器并下载多个文件</span><br><span class="line">ftp&gt; mls *.html - 显示远程主机上文件列表</span><br></pre></td></tr></table></figure>

<h4 id="20-crontab"><a href="#20-crontab" class="headerlink" title="20. crontab"></a>20. crontab</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">crontab -u john -l 查看某个用户的crontab入口</span><br><span class="line">*/10 * * * * /home/ramesh/check-disk-space 设置一个每十分钟执行一次的计划任务</span><br></pre></td></tr></table></figure>

<h4 id="21-service"><a href="#21-service" class="headerlink" title="21. service"></a>21. service</h4><p>service命令用于运行System V init脚本，这些脚本一般位于&#x2F;etc&#x2F;init.d文件下，这个命令可以直接运行这个文件夹里面的脚本，而不用加上路径</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">service ssh status 查看服务状态</span><br><span class="line">service --status-all 查看所有服务状态</span><br><span class="line">service ssh restart 重启服务</span><br></pre></td></tr></table></figure>

<h4 id="22-ps"><a href="#22-ps" class="headerlink" title="22. ps"></a>22. ps</h4><p>ps命令用于显示正在运行中的进程的信息，ps命令有很多选项，这里只列出了几个</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps -ef | more 查看当前正在运行的所有进程</span><br><span class="line">ps -efH | more 以树状结构显示当前正在运行的进程，H选项表示显示进程的层次结构</span><br></pre></td></tr></table></figure>

<h4 id="23-free"><a href="#23-free" class="headerlink" title="23. free"></a>23. free</h4><p>这个命令用于显示系统当前内存的使用情况，包括已用内存、可用内存和交换内存的情况</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">free 默认情况下free会以字节为单位输出内存的使用量</span><br><span class="line">free -g 如果你想以其他单位输出内存的使用量，需要加一个选项，-g为GB，-m为MB，-k为KB，-b为字节</span><br><span class="line">free -t 如果你想查看所有内存的汇总，请使用-t选项，使用这个选项会在输出中加一个汇总行</span><br></pre></td></tr></table></figure>

<h4 id="24-top"><a href="#24-top" class="headerlink" title="24. top"></a>24. top</h4><p>top命令会显示当前系统中占用资源最多的一些进程（默认以CPU占用率排序）如果你想改变排序方式，可以在结果列表中点击O（大写字母O）会显示所有可用于排序的列，这个时候你就可以选择你想排序的列</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">top -u oracle 如果只想显示某个特定用户的进程，可以使用-u选项</span><br></pre></td></tr></table></figure>

<h4 id="25-df"><a href="#25-df" class="headerlink" title="25. df"></a>25. df</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> -k 显示文件系统的磁盘使用情况，默认情况下<span class="built_in">df</span> -k 将以字节为单位输出磁盘的使用量</span><br><span class="line"><span class="built_in">df</span> -h 使用-h选项可以以更符合阅读习惯的方式显示磁盘使用量</span><br><span class="line"><span class="built_in">df</span> -T 使用-T选项显示文件系统类型</span><br></pre></td></tr></table></figure>

<h4 id="26-kill"><a href="#26-kill" class="headerlink" title="26. kill"></a>26. kill</h4><p>kill用于终止一个进程。一般我们会先用<code>ps -ef</code>查找某个进程得到它的进程号，然后再使用<code>kill -9 进程号</code>终止该进程。你还可以使用killall、pkill、xkill来终止进程</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps -ef | grep vim</span><br><span class="line">	ramesh    7243  7222  9 22:43 pts/2    00:00:00 vim</span><br><span class="line"><span class="built_in">kill</span> -9 7243</span><br></pre></td></tr></table></figure>

<h4 id="27-rm"><a href="#27-rm" class="headerlink" title="27. rm"></a>27. rm</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -i filename.txt 删除文件前先确认</span><br><span class="line"><span class="built_in">rm</span> -i file* 在文件名中使用shell的元字符会非常有用。删除文件前先打印文件名并进行确认</span><br><span class="line"><span class="built_in">rm</span> -r example 递归删除文件夹下所有文件，并删除该文件夹</span><br></pre></td></tr></table></figure>

<h4 id="28-cp"><a href="#28-cp" class="headerlink" title="28. cp"></a>28. cp</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> -p file1 file2 拷贝文件1到文件2，并保持文件的权限、属主和时间戳</span><br><span class="line"><span class="built_in">cp</span> -i file1 file2 拷贝file1到file2，如果file2存在会提示是否覆盖</span><br></pre></td></tr></table></figure>

<h4 id="29-mv"><a href="#29-mv" class="headerlink" title="29. mv"></a>29. mv</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">注意如果使用-f选项则不会进行提示</span><br><span class="line"><span class="built_in">mv</span> -i file1 file2 将文件名file1重命名为file2，如果file2存在则提示是否覆盖</span><br><span class="line"><span class="built_in">mv</span> -v file1 file2 -v会输出重命名的过程，当文件名中包含通配符时，这个选项会非常方便</span><br></pre></td></tr></table></figure>

<h4 id="30-cat"><a href="#30-cat" class="headerlink" title="30. cat"></a>30. cat</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> file1 file2 你可以一次查看多个文件的内容，下面的命令会先打印file1的内容，然后打印file2的内容</span><br><span class="line"><span class="built_in">cat</span> -n /etc/logrotate.conf -n命令可以在每行的前面加上行号</span><br></pre></td></tr></table></figure>

<h4 id="31-mount"><a href="#31-mount" class="headerlink" title="31. mount"></a>31. mount</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /u01</span><br><span class="line">mount /dev/sdb1 /u01 如果要挂载一个文件系统，需要先创建一个目录，然后将这个文件系统挂载到这个目录上</span><br><span class="line">/dev/sdb1 /u01 ext2 defaults 0 2 也可以把它添加到fstab中进行自动挂载，这样任何时候系统重启的时候，文件系统都会被加载</span><br></pre></td></tr></table></figure>

<h4 id="32-chmod"><a href="#32-chmod" class="headerlink" title="32. chmod"></a>32. chmod</h4><p>chmod用于改变文件和目录的权限</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> ug+rwx file.txt 给指定文件的属主和属组所有权限(包括读、写、执行)</span><br><span class="line"><span class="built_in">chmod</span> g-rwx file.txt 删除指定文件的属组的所有权限</span><br><span class="line"><span class="built_in">chmod</span> -R ug+rwx file.txt 修改目录的权限，以及递归修改目录下面所有文件和子目录的权限</span><br></pre></td></tr></table></figure>

<h4 id="33-chown"><a href="#33-chown" class="headerlink" title="33. chown"></a>33. chown</h4><p>chown用于改变文件属主和属组</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chown</span> oracle:dba dbora.sh 同时将某个文件的属主改为oracle，属组改为db</span><br><span class="line"><span class="built_in">chown</span> -R oracle:dba /home/oracle 使用-R选项对目录和目录下的文件进行递归修改</span><br></pre></td></tr></table></figure>

<h4 id="34-passwd"><a href="#34-passwd" class="headerlink" title="34. passwd"></a>34. passwd</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">passwd passwd用于在命令行修改密码，使用这个命令会要求你先输入旧密码，然后输入新密码</span><br><span class="line">passwd USERNAME 超级用户可以用这个命令修改其他用户的密码，这个时候不需要输入用户的密码</span><br><span class="line">passwd -d USERNAME passwd还可以删除某个用户的密码，这个命令只有root用户才能操作，删除密码后，这个用户不需要输入密码就可以登录到系统</span><br></pre></td></tr></table></figure>

<h4 id="35-mkdir"><a href="#35-mkdir" class="headerlink" title="35. mkdir"></a>35. mkdir</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/temp 在home目录下创建一个名为temp的目录</span><br><span class="line"><span class="built_in">mkdir</span> -p dir1/dir2/dir3/dir4/ 使用-p选项可以创建一个路径上所有不存在的目录</span><br></pre></td></tr></table></figure>

<h4 id="36-ifconfig"><a href="#36-ifconfig" class="headerlink" title="36. ifconfig"></a>36. ifconfig</h4><p>ifconfig用于查看和配置Linux系统的网络接口</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ifconfig -a 查看所有网络接口及其状态</span><br><span class="line">ifconfig eth0 up 使用up命令启动某个接口</span><br><span class="line">ifconfig eth0 down 使用down命令停止某个接口</span><br></pre></td></tr></table></figure>

<h4 id="37-uname"><a href="#37-uname" class="headerlink" title="37. uname"></a>37. uname</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a <span class="built_in">uname</span>可以显示一些重要的系统信息，例如内核名称、主机名、内核版本号、处理器类型之类的信息</span><br></pre></td></tr></table></figure>

<h4 id="38-whereis"><a href="#38-whereis" class="headerlink" title="38. whereis"></a>38. whereis</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">whereis <span class="built_in">ls</span> 当你不知道某个命令的位置时可以使用whereis命令，下面使用whereis查找<span class="built_in">ls</span>的位置</span><br><span class="line">whereis -u -B /tmp -f lsmk 当你想查找某个可执行程序的位置，但这个程序又不在whereis的默认目录下，你可以使用-B选项，并指定目录作为这个选项的参数。下面的命令在/tmp目录下查找lsmk命令</span><br></pre></td></tr></table></figure>

<h4 id="39-whatis"><a href="#39-whatis" class="headerlink" title="39. whatis"></a>39. whatis</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">whatis <span class="built_in">ls</span> wathis显示某个命令的描述信息</span><br><span class="line">whatis ifconfig wathis显示某个命令的描述信息</span><br></pre></td></tr></table></figure>

<h4 id="40-locate"><a href="#40-locate" class="headerlink" title="40. locate"></a>40. locate</h4><p>locate命名可以显示某个指定文件（或一组文件）的路径，它会使用由updatedb创建的数据库</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">locate crontab 命令会显示系统中所有包含crontab字符串的文件</span><br></pre></td></tr></table></figure>

<h4 id="41-man"><a href="#41-man" class="headerlink" title="41. man"></a>41. man</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">man crontab 显示某个命令的man页面</span><br><span class="line">man SECTION-NUMBER commandname 有些命令可能会有多个man页面，每个man页面对应一种命令类型</span><br></pre></td></tr></table></figure>

<h4 id="42-tail"><a href="#42-tail" class="headerlink" title="42. tail"></a>42. tail</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tail</span> filename.txt <span class="built_in">tail</span>命令默认显示文件最后的10行文本</span><br><span class="line"><span class="built_in">tail</span> -n N filename.txt 你可以使用-n选项指定要显示的行数</span><br><span class="line"><span class="built_in">tail</span> -f log-file 你也可以使用-f选项进行实时查看，这个命令执行后会等待，如果有新行添加到文件尾部，它会继续输出新的行，在查看日志时这个选项会非常有用。你可以通过CTRL-C终止命令的执行</span><br></pre></td></tr></table></figure>

<h4 id="43-less"><a href="#43-less" class="headerlink" title="43. less"></a>43. less</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">less huge-log-file.log 这个命名可以在不加载整个文件的前提下显示文件内容，在查看大型日志文件的时候这个命令会非常有用</span><br></pre></td></tr></table></figure>

<h4 id="44-su"><a href="#44-su" class="headerlink" title="44. su"></a>44. su</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">su - USERNAME su命令用于切换用户账号，超级用户使用这个命令可以切换到任何其他用户而不用输入密码</span><br><span class="line">su -s <span class="string">&#x27;SHELLNAME&#x27;</span> USERNAME 用指定用户登录，并且使用指定的shell程序，而不用默认的</span><br></pre></td></tr></table></figure>

<h4 id="45-mysql"><a href="#45-mysql" class="headerlink" title="45. mysql"></a>45. mysql</h4><p>mysql可能是Linux上使用最广泛的数据库，即使你没有在你的服务器上安装mysql，你也可以使用mysql客户端连接到远程的mysql服务器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql -u root -p -h 192.168.1.2 连接一个远程数据库，需要输入密码</span><br><span class="line">mysql -u root -p 连接本地数据库</span><br></pre></td></tr></table></figure>

<p>你也可以在命令行中输入数据库密码，只需要在-p后面加上密码作为参数，可以直接写在p后面而不用加空格</p>
<h4 id="46-yum"><a href="#46-yum" class="headerlink" title="46. yum"></a>46. yum</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install httpd 使用yum安装apache</span><br><span class="line">yum update httpd 更新apache</span><br><span class="line">yum remove httpd 卸载/删除apache</span><br></pre></td></tr></table></figure>

<h4 id="47-rpm"><a href="#47-rpm" class="headerlink" title="47. rpm"></a>47. rpm</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rpm -ivh httpd-2.2.3-22.0.1.el5.i386.rpm 使用rpm安装apache</span><br><span class="line">rpm -uvh httpd-2.2.3-22.0.1.el5.i386.rpm 更新apache</span><br><span class="line">rpm -ev httpd 卸载/删除apache</span><br></pre></td></tr></table></figure>

<h4 id="48-ping"><a href="#48-ping" class="headerlink" title="48. ping"></a>48. ping</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ping -c 5 gmail.com ping一个远程主机，只发5个数据包</span><br></pre></td></tr></table></figure>

<h4 id="49-date"><a href="#49-date" class="headerlink" title="49. date"></a>49. date</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">date</span> -s <span class="string">&quot;01/31/2010 23:59:53&quot;</span> 设置系统日期</span><br><span class="line">---</span><br><span class="line">当你修改了系统时间，你需要同步硬件时间和系统时间</span><br><span class="line">hwclock –systohc</span><br><span class="line">hwclock --systohc –utc</span><br></pre></td></tr></table></figure>

<h4 id="50-wget"><a href="#50-wget" class="headerlink" title="50. wget"></a>50. wget</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget http://prdownloads.sourceforge.net/sourceforge/nagios/nagios-3.2.1.tar.gz 使用wget从网上下载软件、音乐、视频</span><br><span class="line">wget -O taglist.zip http://www.vim.org/scripts/download_script.php?src_id=7701 下载文件并以指定的文件名保存文件</span><br></pre></td></tr></table></figure>

<h4 id="51-CPU100-怎么排查和处理"><a href="#51-CPU100-怎么排查和处理" class="headerlink" title="51. CPU100%怎么排查和处理"></a>51. CPU100%怎么排查和处理</h4><p>使用top命令定位进程，再用top命令定位线程，再打印线程堆栈查看运行情况</p>
<ol>
<li><code>top</code>命令显示进程运行列表，找到最耗<code>CPU</code>的进程<code>PID</code></li>
<li>找到最耗<code>CPU</code>的线程，<code>top -Hp 进程PID号</code>，显示进程的线程运行列表，找到最耗<code>CPU</code>的线程<code>PID</code></li>
<li>将线程<code>PID</code>转化为16进制，<code>printf &quot;%x\n&quot; 线程PID号</code>，因为在堆栈里，线程<code>ID</code>是用16进制表示的</li>
<li>查看堆栈，找到线程在干嘛，<code>pstack/jstack/grep</code>，<code>jstack 进程PID | grep ‘线程PID的16进制数’ -C5 --color</code>打印进程堆栈，通过线程<code>ID</code>，过滤得到线程堆栈，根据线程<code>PID</code>的16进制数找到消耗<code>CPU</code>高的线程对应的线程的名称，以及看到了改线程正在执行代码的堆栈</li>
</ol>
<h4 id="52"><a href="#52" class="headerlink" title="52."></a>52.</h4><h4 id="53"><a href="#53" class="headerlink" title="53."></a>53.</h4><h4 id="54"><a href="#54" class="headerlink" title="54."></a>54.</h4><h4 id="55"><a href="#55" class="headerlink" title="55."></a>55.</h4><h4 id="56"><a href="#56" class="headerlink" title="56."></a>56.</h4><h4 id="57"><a href="#57" class="headerlink" title="57."></a>57.</h4><hr>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis面试题</title>
    <url>/2022/10/28/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>Redis面试常见问题汇总</p>
<h4 id="1-Redis的数据结构及使用场景"><a href="#1-Redis的数据结构及使用场景" class="headerlink" title="1. Redis的数据结构及使用场景"></a>1. Redis的数据结构及使用场景</h4><ul>
<li><p>String字符串</p>
<p>字符串类型是 Redis 最基础的数据结构，首先键都是字符串类型，而且 其他几种数据结构都是在字符串类型基础上构建的，我们常使用的 set key value 命令就是字符串。常用在缓存、计数、共享Session、限速等</p>
</li>
</ul>
<hr>
<ul>
<li><p>Hash哈希</p>
<p>在Redis中，哈希类型是指键值本身又是一个键值对结构，哈希可以用来存放用户信息，比如实现购物车</p>
</li>
</ul>
<hr>
<ul>
<li><p>List列表（双向链表）</p>
<p>列表（list）类型是用来存储多个有序的字符串。可以做简单的消息队列的功能</p>
</li>
</ul>
<hr>
<ul>
<li><p>Set集合</p>
<p>集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一 样的是，集合中不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素。利用 Set 的交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能</p>
</li>
</ul>
<hr>
<ul>
<li><p>Sorted Set有序集合（跳表实现）</p>
<p>Sorted Set 多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。可以做排行榜应用，取 TOP N 操作</p>
</li>
</ul>
<h4 id="2-Redis持久化的几种方式"><a href="#2-Redis持久化的几种方式" class="headerlink" title="2. Redis持久化的几种方式"></a>2. Redis持久化的几种方式</h4><p>Redis为了保证效率，数据缓存在了内存中，但是会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中，以保证数据的持久化。Redis的持久化策略有两种：</p>
<ul>
<li><strong>RDB：</strong> 快照形式是直接把内存中的数据保存到一个dump的文件中，定时保存，保存策略<ul>
<li>当Redis需要做持久化时，Redis会fork一个子进程，子进程将数据写到磁盘上一个临时RDB文件中。当子进程完成写临时文件后，将原来的RDB替换掉</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>AOF：</strong> 把所有的对Redis的服务器进行修改的命令都存到一个文件里，命令的集合<ul>
<li>使用AOF做持久化，每一个写命令都通过write函数追加到<code>appendonly.aof</code>中</li>
<li>aof的默认策略是每秒钟fsync一次，在这种配置下，就算发生故障停机，也最多丢失一秒钟的数据</li>
<li>缺点是对于相同的数据集来说，AOF的文件体积通常要大于RDB文件的体积。根据所使用的fsync策略，AOF的速度可能会慢于RDB</li>
</ul>
</li>
</ul>
<p>Redis默认是快照RDB的持久化方式。对于主从同步来说，主从刚刚连接的时候，进行全量同步（RDB），全同步结束后，进行增量同步(AOF)</p>
<h4 id="3-Redis的LRU具体实现"><a href="#3-Redis的LRU具体实现" class="headerlink" title="3. Redis的LRU具体实现"></a>3. Redis的LRU具体实现</h4><ul>
<li>传统的LRU是使用栈的形式，每次都将最新使用的移入栈顶，但是用栈的形式会导致执行<code>select *</code>的时候大量非热点数据占领头部数据，所以需要改进</li>
<li>Redis每次按key获取一个值的时候，都会更新value中的lru字段为当前秒级别的时间戳。Redis初始的实现算法很简单，随机从dict中取出五个key，淘汰一个lru字段值最小的</li>
<li>在3.0的时候，又改进了一版算法，首先第一次随机选取的key都会放入一个pool中(pool的大小为16)，pool中的key是按lru大小顺序排列的</li>
<li>接下来每次随机选取的keylru值必须小于pool中最小的lru才会继续放入，直到将pool放满。放满之后，每次如果有新的key需要放入，需要将pool中lru最大的一个key取出。淘汰的时候，直接从pool中选取一个lru最小的值然后将其淘汰</li>
</ul>
<h4 id="4-单线程的Redis为什么快"><a href="#4-单线程的Redis为什么快" class="headerlink" title="4. 单线程的Redis为什么快"></a>4. 单线程的Redis为什么快</h4><ul>
<li>纯内存操作</li>
<li>单线程操作，避免了频繁的上下文切换</li>
<li>合理高效的数据结构</li>
<li>采用了非阻塞I&#x2F;O多路复用机制</li>
</ul>
<h4 id="5-Redis的数据过期策略"><a href="#5-Redis的数据过期策略" class="headerlink" title="5. Redis的数据过期策略"></a>5. Redis的数据过期策略</h4><p>Redis 中数据过期策略采用<strong>定期删除</strong>和<strong>惰性删除</strong>策略：</p>
<ul>
<li>定期删除策略<ul>
<li>Redis 启用一个定时器定时监视所有的 key，判断key是否过期，过期的话就删除</li>
<li>这种策略可以保证过期的 key 最终都会被删除，但是也存在严重的缺点：每次都遍历内存中所有的数据，非常消耗 CPU资源，并且当 key 已过期，但是定时器还处于未唤起状态，这段时间内 key 仍然可以用</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>惰性删除策略<ul>
<li>在获取 key 时，先判断 key 是否过期，如果过期则删除</li>
<li>这种方式存在一个缺点：如果这个 key一直未被使用，那么它一直在内存中，其实它已经过期了，会浪费大量的空间</li>
</ul>
</li>
</ul>
<p>这两种策略天然的互补，结合起来之后，定时删除策略就发生了一些改变，不在是每次扫描全部的 key 了，而是随机抽取一部分 key 进行检查，这样就降低了对 CPU 资源的损耗，惰性删除策略互补了为检查到的key，基本上满足了所有要求</p>
<p>但是有时候就是那么的巧，既没有被定时器抽取到，又没有被使用，这些数据又如何从内存中消失？这个时候就需要用到了，内存淘汰机制</p>
<h5 id="5-1-内存淘汰机制"><a href="#5-1-内存淘汰机制" class="headerlink" title="5.1 内存淘汰机制"></a>5.1 内存淘汰机制</h5><ul>
<li>当内存不足以容纳新写入数据时，新写入操作会报错。（Redis 默认策略）</li>
<li>当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。（LRU推荐使用）</li>
<li>当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key</li>
<li>当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用</li>
<li>当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key</li>
<li>当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除</li>
</ul>
<h4 id="6-如何解决Redis缓存雪崩问题"><a href="#6-如何解决Redis缓存雪崩问题" class="headerlink" title="6. 如何解决Redis缓存雪崩问题"></a>6. 如何解决Redis缓存雪崩问题</h4><ul>
<li>使用 Redis 高可用架构：使用 Redis 集群来保证 Redis 服务不会挂掉</li>
<li>缓存时间不一致，给缓存的失效时间，加上一个随机值，避免集体失效</li>
<li>限流降级策略：有一定的备案，比如个性推荐服务不可用了，换成热点数据推荐服务</li>
</ul>
<h4 id="7-如何解决Redis缓存穿透问题"><a href="#7-如何解决Redis缓存穿透问题" class="headerlink" title="7. 如何解决Redis缓存穿透问题"></a>7. 如何解决Redis缓存穿透问题</h4><ul>
<li>在接口层做校验</li>
<li>存null值（缓存击穿加锁）</li>
<li>布隆过滤器拦截：将所有可能的查询key 先映射到布隆过滤器中，查询时先判断key是否存在布隆过滤器中，存在才继续向下执行，如果不存在，则直接返回<br>布隆过滤器将值进行多次哈希bit存储，布隆过滤器说某个元素在，可能会被误判。布隆过滤器说某个元素不在，那么一定不在</li>
</ul>
<h4 id="8-Redis并发竞争key如何解决"><a href="#8-Redis并发竞争key如何解决" class="headerlink" title="8. Redis并发竞争key如何解决"></a>8. Redis并发竞争key如何解决</h4><ul>
<li>可以利用分布式锁和时间戳来解决</li>
<li>利用消息队列解决</li>
</ul>
<h4 id="9-Redis的主从模式和哨兵模式和集群模式区别"><a href="#9-Redis的主从模式和哨兵模式和集群模式区别" class="headerlink" title="9. Redis的主从模式和哨兵模式和集群模式区别"></a>9. Redis的主从模式和哨兵模式和集群模式区别</h4><p>Redis集群方式共有三种：<strong>主从模式</strong>，<strong>哨兵模式</strong>，<strong>集群(cluster)模式</strong></p>
<ul>
<li><p>主从模式</p>
<p>主从模式是三种集群方式里最简单的。它主要是基于Redis的主从复制特性架构的。通常我们会设置一个主节点，N个从节点;默认情况下，主节点负责处理使用者的IO操作，而从节点则会对主节点的数据进行备份，并且也会对外提供读操作的处理。主要的特点如下：</p>
<ul>
<li>主从模式下，当某一节点损坏时，因为其会将数据备份到其它Redis实例上，这样做在很大程度上可以恢复丢失的数据</li>
<li>主从模式下，可以保证负载均衡.</li>
<li>主从模式下，主节点和从节点是读写分离的。使用者不仅可以从主节点上读取数据，还可以很方便的从从节点上读取到数据，这在一定程度上缓解了主机的压力</li>
</ul>
<p>从节点也是能够支持写入数据的，只不过从从节点写入的数据不会同步到主节点以及其它的从节点下。从以上，我们不难看出Redis在主从模式下，必须保证主节点不会宕机——一旦主节点宕机，其它节点不会竞争称为主节点，此时，Redis将丧失写的能力。这点在生产环境中，是致命的</p>
</li>
</ul>
<hr>
<ul>
<li><p>哨兵模式</p>
<p>哨兵模式是基于主从模式做的一定变化，它能够为Redis提供了高可用性</p>
<p>在实际生产中，服务器难免不会遇到一些突发状况：服务器宕机，停电，硬件损坏等。这些情况一旦发生，其后果往往是不可估量的</p>
<p>而哨兵模式在一定程度上能够帮我们规避掉这些意外导致的灾难性后果。其实，哨兵模式的核心还是主从复制</p>
<p>只不过相对于主从模式在主节点宕机导致不可写的情况下，多了一个竞选机制——从所有的从节点竞选出新的主节点。竞选机制的实现，是依赖于在系统中启动一个sentinel进程。sentinel特点：</p>
<ul>
<li>监控：它会监听主服务器和从服务器之间是否在正常工作</li>
<li>通知：它能够通过API告诉系统管理员或者程序，集群中某个实例出了问题。</li>
<li>故障转移：它在主节点出了问题的情况下，会在所有的从节点中竞选出一个节点，并将其作为新的主节点。</li>
<li>提供主服务器地址：它还能够向使用者提供当前主节点的地址。这在故障转移后，使用者不用做任何修改就可以知道当前主节点地址</li>
</ul>
<p>sentinel，也可以集群，部署多个哨兵，sentinel可以通过发布与订阅来自动发现Redis集群上的其它sentinel。sentinel在发现其它sentinel进程后，会将其放入一个列表中，这个列表存储了所有已被发现的sentinel</p>
<p>集群中的所有sentinel不会并发着去对同一个主节点进行故障转移。故障转移只会从第一个sentinel开始，当第一个故障转移失败后，才会尝试下一个</p>
<p>当选择一个从节点作为新的主节点后，故障转移即成功了(而不会等到所有的从节点配置了新的主节点后)。这过程中，如果重启了旧的主节点，那么就会出现无主节点的情况，这种情况下，只能重启集群</p>
<p>当竞选出新的主节点后，被选为新的主节点的从节点的配置信息会被sentinel改写为旧的主节点的配置信息。完成改写后，再将新主节点的配置广播给所有的从节点</p>
</li>
</ul>
<hr>
<ul>
<li><p>集群模式</p>
<p>Redis 集群是一个提供在多个Redis间节点间共享数据的程序集， 其中Redis集群分为主节点和从节点。主节点用于处理槽，而从节点用于复制某个主节点，并在被复制的主节点下线时，代替下线的主节点继续处理命令请求</p>
<p>Redis集群并不支持处理多个keys的命令，因为这需要在不同的节点间移动数据，从而达不到像Redis那样的性能，在高负载的情况下可能会导致不可预料的错误</p>
<p>Redis 集群通过分区来提供一定程度的可用性，在实际环境中当某个节点宕机或者不可达的情况下继续处理命令. Redis 集群的优势：自动分割数据到不同的节点上</p>
<p>整个集群的部分节点失败或者不可达的情况下能够继续处理命令</p>
<p>Redis集群的数据分片 Redis 集群没有使用一致性hash， 而是引入了哈希槽的概念</p>
<p>Redis 集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽</p>
</li>
</ul>
<h4 id="10-Redis事物的了解CheckAndSet操作实现乐观锁"><a href="#10-Redis事物的了解CheckAndSet操作实现乐观锁" class="headerlink" title="10. Redis事物的了解CheckAndSet操作实现乐观锁"></a>10. Redis事物的了解CheckAndSet操作实现乐观锁</h4><p>和众多其它数据库一样，Redis作为NoSQL数据库也同样提供了事务机制。在Redis中，<code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code>，<code>WATCH</code>这四个命令是我们实现事务的基石。相信对有关系型数据库开发经验的开发者而言这一概念并不陌生，即便如此，我们还是会简要的列出 Redis中事务的实现特征 ：</p>
<ul>
<li>在事务中的所有命令都将会被串行化的顺序执行，事务执行期间，Redis不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行</li>
<li>和关系型数据库中的事务相比，在Redis事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行</li>
<li>我们可以通过MULTI命令开启一个事务，有关系型数据库开发经验的人可以将其理解为”BEGIN TRANSACTION”语句。在该语句之后执行的命令都将被视为事务之内的操作，最后我们可以通过执行<code>EXEC</code>，<code>DISCARD</code>命令来提交，回滚该事务内的所有操作。这两个Redis命令可被视为等同于关系型数据库中的COMMIT&#x2F;ROLLBACK语句</li>
<li>在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行</li>
<li>当使用<code>Append-Only</code>模式时，Redis会通过调用系统函数write将该事务内的所有写操作在本次调用中全部写入磁盘。然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。Redis服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用Redis工具包中提供的<code>redis-check-aof</code>工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了</li>
</ul>
<h4 id="11-Redis有序集合zset底层怎么实现的"><a href="#11-Redis有序集合zset底层怎么实现的" class="headerlink" title="11. Redis有序集合zset底层怎么实现的"></a>11. Redis有序集合zset底层怎么实现的</h4><ul>
<li>跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表</li>
<li>跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找</li>
<li>跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能</li>
</ul>
<hr>
<ul>
<li>跳表是可以实现二分查找的有序链表</li>
<li>每个元素插入时随机生成它的level</li>
<li>最低层包含所有的元素</li>
<li>如果一个元素出现在level(x)，那么它肯定出现在x以下的level中</li>
<li>每个索引节点包含两个指针，一个向下，一个向右</li>
<li>跳表查询、插入、删除的时间复杂度为O(log n)，与平衡二叉树接近</li>
</ul>
<hr>
<h5 id="11-1-为什么Redis选择使用跳表而不是红黑树来实现有序集合？-O-logN"><a href="#11-1-为什么Redis选择使用跳表而不是红黑树来实现有序集合？-O-logN" class="headerlink" title="11.1 为什么Redis选择使用跳表而不是红黑树来实现有序集合？(O(logN))"></a>11.1 为什么Redis选择使用跳表而不是红黑树来实现有序集合？(O(logN))</h5><p>首先，我们来分析下Redis的有序集合支持的操作：</p>
<ul>
<li>插入元素</li>
<li>删除元素</li>
<li>查找元素</li>
<li>有序输出所有元素</li>
<li>查找区间内所有元素</li>
</ul>
<p>其中，前4项红黑树都可以完成，且时间复杂度与跳表一致。但是，最后一项，红黑树的效率就没有跳表高了。在跳表中，要查找区间的元素，我们只要定位到两个区间端点在最低层级的位置，然后按顺序遍历元素就可以了，非常高效</p>
<p>而红黑树只能定位到端点后，再从首位置开始每次都要查找后继节点，相对来说是比较耗时的。此外，跳表实现起来很容易且易读，红黑树实现起来相对困难，所以Redis选择使用跳表来实现有序集合</p>
<h4 id="12-跳表的查询过程是怎么样的，查询和插入的时间复杂度"><a href="#12-跳表的查询过程是怎么样的，查询和插入的时间复杂度" class="headerlink" title="12. 跳表的查询过程是怎么样的，查询和插入的时间复杂度"></a>12. 跳表的查询过程是怎么样的，查询和插入的时间复杂度</h4><p>先从第一层查找，不满足就下沉到第二层找，因为每一层都是有序的，写入和插入的时间复杂度都是O(logN)</p>
<hr>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生训练营课程大纲</title>
    <url>/2022/11/06/%E4%BA%91%E5%8E%9F%E7%94%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E8%AF%BE%E7%A8%8B%E5%A4%A7%E7%BA%B2/</url>
    <content><![CDATA[<h4 id="第一部分：Go-语言基础"><a href="#第一部分：Go-语言基础" class="headerlink" title="第一部分：Go 语言基础"></a>第一部分：Go 语言基础</h4><h5 id="模块一：Go-语言特性"><a href="#模块一：Go-语言特性" class="headerlink" title="模块一：Go 语言特性"></a>模块一：Go 语言特性</h5><p><strong>教学目标：</strong></p>
<ol>
<li><p>理解 Go 语言基本语法</p>
</li>
<li><p>理解 Go 语言常用数据类型</p>
</li>
<li><p>理解 Go 语言常用小技巧</p>
</li>
<li><p>深入理解 Go 语言的多线程编程</p>
</li>
</ol>
<p><strong>针对的用户痛点：</strong></p>
<ol>
<li><p>云原生从业者因为未熟练掌握 Go 语言，在阅读 Docker、containerd、Kubernetes 代码时有困难</p>
</li>
<li><p>未熟练掌握 Go 语言，在需要编写云原生组件时无法高效率高质量交付</p>
</li>
</ol>
<p><strong>通过学习掌握的核心能力：</strong></p>
<ol>
<li><p>阅读 Go 语言代码的能力</p>
</li>
<li><p>用 Go 语言编写应用程序的基本能力</p>
</li>
<li><p>用 Go 语言编写一个 Kubernetes 中最常见的生产者消费者小程序</p>
</li>
</ol>
<p><strong>详细内容：</strong></p>
<ol>
<li><p>Go 语言编译环境设置</p>
</li>
<li><p>Go 语言常用数据结构</p>
</li>
<li><p>Go 语言函数调用，深入理解 Channel 并基于 Channel 编写一个生产者消费者程序</p>
</li>
</ol>
<hr>
<h5 id="模块二：使用-Go-语言编写一个小-Demo"><a href="#模块二：使用-Go-语言编写一个小-Demo" class="headerlink" title="模块二：使用 Go 语言编写一个小 Demo"></a>模块二：使用 Go 语言编写一个小 Demo</h5><p><strong>教学目标：</strong></p>
<ol>
<li><p>理解 Go 语言的调度原理</p>
</li>
<li><p>理解 Go 语言的内存管理</p>
</li>
<li><p>Go 语言依赖管理</p>
</li>
<li><p>Go 语言调试和问题分析 pprof</p>
</li>
</ol>
<p><strong>针对的用户痛点：</strong></p>
<ol>
<li><p>对 Goroutine 无深入理解，无法利用 Go 语言强大的并发能力</p>
</li>
<li><p>面对众多的 Go 语言项目包依赖管理工具无所适从，不知道该用哪一个工具</p>
</li>
<li><p>针对 Go 语言编写的程序，不知道如何调试</p>
</li>
</ol>
<p><strong>通过学习掌握的核心能力：</strong></p>
<ol>
<li><p>了解 Go 语言的高级话题，如线程调度原理，内存管理等，使得学员有能力编写高效程序</p>
</li>
<li><p>理解 Go 语言的依赖管理方法，以便能够正确地管理项目依赖</p>
</li>
<li><p>学会用 pprof 对应用运行时的调用栈、内存等进行分析</p>
</li>
<li><p>学会用 Go 语言编写一个简单的 HTTP 服务器供后续云原生应用使用</p>
</li>
</ol>
<p><strong>详细内容：</strong></p>
<ol>
<li><p>Goroutine 的调度</p>
</li>
<li><p>内存管理</p>
</li>
<li><p>学会用 Go 语言编写一个简单的 HTTP 服务器</p>
</li>
</ol>
<hr>
<h4 id="第二部分：云原生技术栈"><a href="#第二部分：云原生技术栈" class="headerlink" title="第二部分：云原生技术栈"></a>第二部分：云原生技术栈</h4><h5 id="模块三：Docker-核心技术"><a href="#模块三：Docker-核心技术" class="headerlink" title="模块三：Docker 核心技术"></a>模块三：Docker 核心技术</h5><p><strong>教学目标：</strong></p>
<ol>
<li><p>理解容器特性以及相比虚拟化技术所具备的优势</p>
</li>
<li><p>了解容器技术的实现细节：Namespace、cgroup、文件系统</p>
</li>
</ol>
<p><strong>针对的用户痛点：</strong></p>
<ol>
<li><p>分不清容器技术和虚拟化技术的差异，在做技术决策时没有理论支撑</p>
</li>
<li><p>因为不了解技术原理，排查容器问题时毫无头绪</p>
</li>
</ol>
<p><strong>通过学习掌握的核心能力：</strong></p>
<ol>
<li><p>了解 Namespace 技术的原理以及基于 Namespace 的问题排查方法</p>
</li>
<li><p>理解 cgroup 控制资源限额的方法，查看 cgroup 配置并临时调整 cgroup 配置</p>
</li>
<li><p>理解容器文件系统如何高效管理运行时和数据</p>
</li>
<li><p>理解容器网络，为进一步理解 Kubernetes 网络插件奠定基础</p>
</li>
<li><p>基于 Dockerfile 将应用程序打包成容器镜像</p>
</li>
</ol>
<p><strong>详细内容：</strong></p>
<ol>
<li><p>容器技术的本质以及技术优势，Namespace、cgroup、文件系统、网络连通</p>
</li>
<li><p>容器镜像与镜像仓库</p>
</li>
<li><p>将 Go 语言编写的 HTTP 服务器打包成容器镜像</p>
</li>
</ol>
<hr>
<h5 id="模块四：Kubernetes-架构原则和对象设计"><a href="#模块四：Kubernetes-架构原则和对象设计" class="headerlink" title="模块四：Kubernetes 架构原则和对象设计"></a>模块四：Kubernetes 架构原则和对象设计</h5><p><strong>教学目标：</strong></p>
<ol>
<li><p>理解 Kubenretes 架构原则</p>
</li>
<li><p>理解 Kubernetes 的对象设计与 API 定义</p>
</li>
<li><p>理解 Kubernetes 控制器模式与多组件联动机制</p>
</li>
</ol>
<p><strong>针对的用户痛点：</strong></p>
<ol>
<li><p>对 Kubernetes 有简单认知，但无法编写出高效的、符合云原生规范和最佳实践的组件</p>
</li>
<li><p>对组件和基本对象只有浅层次的理解，对 API 的统一性和差异性无深入理解</p>
</li>
<li><p>不了解 Kubernetes 的控制器原理，对 Kubernetes 控制面板组件如何运作无深入理解</p>
</li>
</ol>
<p><strong>通过学习掌握的核心能力：</strong></p>
<ol>
<li><p>动手搭建 Kubernetes 环境</p>
</li>
<li><p>理解 Kubernetes 架构原则</p>
</li>
<li><p>理解 Kubernetes API 定义的设计原则，理解 Kubernetes 对象中的重要属性</p>
</li>
<li><p>理解 Kubernetes 控制器的联动机制</p>
</li>
</ol>
<p><strong>详细内容：</strong></p>
<ol>
<li><p>环境搭建</p>
</li>
<li><p>Kubernetes 架构优势及架构原则</p>
</li>
<li><p>Kubernetes 核心组件</p>
</li>
<li><p>Kubernetes 对象设计与 API 定义</p>
</li>
<li><p>Kubernetes 控制器模式</p>
</li>
</ol>
<hr>
<h5 id="模块五：Kubernetes-控制平面组件：etcd"><a href="#模块五：Kubernetes-控制平面组件：etcd" class="headerlink" title="模块五：Kubernetes 控制平面组件：etcd"></a>模块五：Kubernetes 控制平面组件：etcd</h5><p><strong>教学目标：</strong></p>
<ol>
<li><p>深入理解 Kubernetes 的唯一数据存储组件 etcd</p>
</li>
<li><p>掌握构建生产系统中 etcd 集群的方法</p>
</li>
<li><p>熟悉 etcd 的优化管理，了解灾备方案</p>
</li>
</ol>
<p><strong>针对的用户痛点：</strong></p>
<ol>
<li><p>对 etcd 的实现机制不了解，不知道在生产化应用过程中可能遇到的问题</p>
</li>
<li><p>不知道应该如何构建生产系统中的 etcd 集群</p>
</li>
<li><p>不知道如何进行数据的备份和灾难恢复</p>
</li>
</ol>
<p><strong>通过学习掌握的核心能力：</strong></p>
<ol>
<li><p>理解 Raft 协议的工作机制和 etcd 的实现原理，针对 etcd 生产系统的配置优化以及数据灾备</p>
</li>
<li><p>深入理解 API Server 的实现机制，包括与企业认证系统整合、鉴权、准入插件的实现等等</p>
</li>
<li><p>深入理解 Kubernetes 的对象实现</p>
</li>
<li><p>如何构建高可用的 etcd 和 API Server 控制平面</p>
</li>
</ol>
<p><strong>详细内容：</strong></p>
<ol>
<li><p>深入理解 Kubernetes 的数据存储 etcd</p>
</li>
<li><p>了解 Raft 协议</p>
</li>
<li><p>生产系统中 etcd 的配置</p>
</li>
<li><p>etcd operator</p>
</li>
<li><p>etcd 的灾备方案</p>
</li>
<li><p>生产系统中常见问题解析</p>
</li>
</ol>
<hr>
<h5 id="模块六：Kubernetes-控制平面组件：API-Server"><a href="#模块六：Kubernetes-控制平面组件：API-Server" class="headerlink" title="模块六：Kubernetes 控制平面组件：API Server"></a>模块六：Kubernetes 控制平面组件：API Server</h5><p><strong>教学目标：</strong></p>
<ol>
<li><p>深入理解 Kubernetes API Server 的实现机制</p>
</li>
<li><p>掌握基于 API Server Webhook 的整合方案</p>
</li>
</ol>
<p><strong>针对的用户痛点：</strong></p>
<ol>
<li><p>缺乏对 Kubernetes 对象实现方法的理解</p>
</li>
<li><p>对 API Server 缺乏理解，不知道如何与企业认证系统整合，不会基于鉴权准入等机制打造多租户 Kubernetes 平台</p>
</li>
</ol>
<p><strong>通过学习掌握的核心能力：</strong></p>
<ol>
<li><p>理解 Kubernetes 对象设计的实现机制</p>
</li>
<li><p>理解 API Server 缓存的工作机制</p>
</li>
<li><p>掌握生产系统中 API Server 的常用配置</p>
</li>
<li><p>掌握 API Server 与企业生态系统的整合方法</p>
</li>
</ol>
<p><strong>详细内容：</strong></p>
<ol>
<li><p>深入理解 Kubernetes API Server</p>
</li>
<li><p>API Server 代码走读</p>
</li>
<li><p>理解 internalVersion、externalVersion 和 storageVersion</p>
</li>
<li><p>理解 conversion</p>
</li>
<li><p>基于 client-go 生成 Kubernetes 框架代码</p>
</li>
<li><p>理解 lister 和 informer 框架</p>
</li>
<li><p>理解 API Server 缓存</p>
</li>
<li><p>API Server 与企业生态系统的整合：认证接入、鉴权、准入控制</p>
</li>
<li><p>API Server 常用配置与常见问题解析</p>
</li>
</ol>
<hr>
<h5 id="模块七：Kubernetes-控制平面组件：调度器和控制器"><a href="#模块七：Kubernetes-控制平面组件：调度器和控制器" class="headerlink" title="模块七：Kubernetes 控制平面组件：调度器和控制器"></a>模块七：Kubernetes 控制平面组件：调度器和控制器</h5><p><strong>教学目标：</strong></p>
<ol>
<li><p>理解 Kubernetes 调度器原理以及常用调度插件</p>
</li>
<li><p>理解 Kubernetes 调度的常用技巧，利用亲和性与反亲和性进行调度</p>
</li>
<li><p>理解 Kubernetes 的常见控制器</p>
</li>
<li><p>深入理解 Kubelet 对 Pod 声明周期的管理</p>
</li>
</ol>
<p><strong>针对的用户痛点：</strong></p>
<ol>
<li><p>对 Kubernetes 调度器无深入理解，在 Pod 无法调度时，不知道如何排查问题</p>
</li>
<li><p>不会利用 Kubernetes 调度器实现应用的高效、高可用部署</p>
</li>
<li><p>对 Kubernetes 控制器缺乏全面认知</p>
</li>
<li><p>对 Kubernetes 如何管理 Pod 生命周期缺乏认知</p>
</li>
</ol>
<p><strong>通过学习掌握的核心能力：</strong></p>
<ol>
<li><p>排查调度故障，利用调度器实现应用的高可用部署</p>
</li>
<li><p>扩展对 Kubernetes 控制器的认知，理解更多的 Kubernetes 控制平面行为</p>
</li>
<li><p>深入理解 CRI、CNI 和 CSI</p>
</li>
</ol>
<p><strong>详细内容：</strong></p>
<ol>
<li><p>深入理解 Kubernetes 调度器</p>
</li>
<li><p>深入理解 Kubenretes 控制器</p>
</li>
<li><p>深入理解 Kubelet</p>
</li>
<li><p>如何运行你的 Pod（CRI、CNI、CSI）</p>
</li>
<li><p>Kubelet Pod 代码走读</p>
</li>
<li><p>containerd 代码走读</p>
</li>
<li><p>CNI 代码走读</p>
</li>
<li><p>全方位的 CSI 一站式解决方案：Rook</p>
</li>
</ol>
<hr>
<h5 id="模块八：Kubernetes-控制平面组件：生命周期管理和服务发现"><a href="#模块八：Kubernetes-控制平面组件：生命周期管理和服务发现" class="headerlink" title="模块八：Kubernetes 控制平面组件：生命周期管理和服务发现"></a>模块八：Kubernetes 控制平面组件：生命周期管理和服务发现</h5><p><strong>教学目标：</strong></p>
<ol>
<li><p>深入理解 Pod 的完整生命周期和就绪状态控制</p>
</li>
<li><p>深入理解 Pod 状态控制对应用可用性的影响</p>
</li>
<li><p>深入理解 Kubernetes 中的服务发现机制，包括负载均衡配置和域名服务</p>
</li>
</ol>
<p><strong>针对的用户痛点：</strong></p>
<ol>
<li><p>解决日常运维的困扰，比如，在 Pod 初始化或故障转移时或者版本发布时，如何不影响业务？</p>
</li>
<li><p>我发布的服务经常出现服务中断，是缺了什么配置吗？</p>
</li>
</ol>
<p><strong>通过学习掌握的核心能力：</strong></p>
<ol>
<li><p>理解 Pod 的完整生命周期，如何初始化、如何控制就绪状态、如何探活、如何优雅终止</p>
</li>
<li><p>如何发布服务，如何剔出异常实例</p>
</li>
</ol>
<p><strong>详细内容：</strong></p>
<ol>
<li><p>深入理解 Kubernetes 的服务实例对象 Pod：Pod 生命周期详解、健康探针、ReadinessGate</p>
</li>
<li><p>深入理解 Kube-Proxy：如何发布你的服务、代码走读、负载均衡配置</p>
</li>
<li><p>域名管理</p>
</li>
<li><p>基于 Ingress 以及 Service API 的入站流量管理</p>
</li>
</ol>
<hr>
<h5 id="模块九：生产化集群的管理"><a href="#模块九：生产化集群的管理" class="headerlink" title="模块九：生产化集群的管理"></a>模块九：生产化集群的管理</h5><p><strong>教学目标：</strong></p>
<ol>
<li><p>掌握生产化集群的搭建技术</p>
</li>
<li><p>掌握生产化集群持续运维过程中最重要的节点管理能力</p>
</li>
<li><p>如何在不影响业务的前提下完成 Kubernetes 升级</p>
</li>
</ol>
<p><strong>针对的用户痛点：</strong></p>
<ol>
<li><p>不知道如何快速构建本地集群供研发测试使用</p>
</li>
<li><p>未掌握构建生产化集群的方法，缺少对集群节点的管控，节点出现故障以后需要人为介入</p>
</li>
<li><p>如何实现生产化集群的管理，比如计算节点的监控与管理</p>
</li>
<li><p>不了解完成了集群搭建以后离生产化还有多远</p>
</li>
</ol>
<p><strong>通过学习掌握的核心能力：</strong></p>
<p>快速构建本地集群的能力</p>
<p>理解 Kubernetes 集群构建的原理，掌握搭建 Kubernetes 集群的能力</p>
<p>基于 Cluster API 完成生产化集群的构建和持续运维</p>
<p><strong>详细内容：</strong></p>
<ol>
<li><p>利用 kind 构建本地集群</p>
</li>
<li><p>利用 kubeadm 构建基于虚拟机的集群</p>
</li>
<li><p>利用 Cluster API 完成生产化集群的搭建</p>
</li>
<li><p>持续运维的考量：节点健康检查、Kubernetes 升级、主机操作系统升级</p>
</li>
</ol>
<hr>
<h5 id="模块十：Kubernetes-的生产化运维"><a href="#模块十：Kubernetes-的生产化运维" class="headerlink" title="模块十：Kubernetes 的生产化运维"></a>模块十：Kubernetes 的生产化运维</h5><p><strong>教学目标：</strong></p>
<ol>
<li><p>如何实现基于 Kubernetes 的 CI&#x2F;CD</p>
</li>
<li><p>如何实现生产化集群的监控</p>
</li>
</ol>
<p><strong>针对的用户痛点：</strong></p>
<ol>
<li><p>缺少企业统一的镜像仓库</p>
</li>
<li><p>镜像安全应该如何保证</p>
</li>
<li><p>企业缺少持续集成持续部署能力</p>
</li>
<li><p>缺少对整个集群的监控，希望实现无人值守</p>
</li>
</ol>
<p><strong>通过学习掌握的核心能力：</strong></p>
<ol>
<li><p>打造持续集成平台</p>
</li>
<li><p>基于自动化管理生产化集群</p>
</li>
<li><p>实现对集群控制面板以及重要应用的监控和告警</p>
</li>
</ol>
<p><strong>详细内容：</strong></p>
<ol>
<li><p>镜像仓库和容器镜像缓存</p>
</li>
<li><p>镜像扫描和镜像安全保证</p>
</li>
<li><p>基于 Kubernetes、Jenkins、Tekton 打造 CI&#x2F;CD Pipeline</p>
</li>
<li><p>集群监控：日志收集和分析，事件、指标和告警（Event、Metrics 和 Alert）</p>
</li>
</ol>
<hr>
<h5 id="模块十一：将应用迁移至-Kubernetes-平台"><a href="#模块十一：将应用迁移至-Kubernetes-平台" class="headerlink" title="模块十一：将应用迁移至 Kubernetes 平台"></a>模块十一：将应用迁移至 Kubernetes 平台</h5><p><strong>教学目标：</strong></p>
<ol>
<li><p>如何将无状态应用发布到 Kubernetes 平台</p>
</li>
<li><p>如何基于 Kubernetes 原生能力将有状态应用发布到 Kubernetes 平台</p>
</li>
<li><p>基于 Kubernetes 对象扩展，将更复杂的应用发布到 Kubernetes 平台</p>
</li>
</ol>
<p><strong>针对的用户痛点：</strong></p>
<ol>
<li><p>缺少将应用发布到 Kubernetes 平台上的理论指导</p>
</li>
<li><p>对于有状态应用，更不知道如何借助 Kubernetes 平台的优势进行处理</p>
</li>
</ol>
<p><strong>通过学习掌握的核心能力：</strong></p>
<ol>
<li><p>掌握 Kubernetes 提供的应用管理框架，包括有状态应用和无状态应用</p>
</li>
<li><p>掌握 Operator 模式，具备通过 Kubebuilder 构建自己的 CRD，并且基于 CRD 编写控制器的能力</p>
</li>
<li><p>利用 Kubebuilder 完成控制器的测试和发布</p>
</li>
<li><p>借助 Helm 完成复杂的应用模板管理</p>
</li>
</ol>
<p><strong>详细内容：</strong></p>
<ol>
<li><p>应用容器化</p>
</li>
<li><p>无状态应用移植到 Kubernetes 平台的考量</p>
</li>
<li><p>有状态应用移植到 Kubernetes 平台的考量</p>
</li>
<li><p>理解 Operator</p>
</li>
<li><p>借助 Kubebuilder 开发一个 Operator</p>
</li>
<li><p>借助 Helm 管理应用发布</p>
</li>
</ol>
<hr>
<h5 id="模块十二：基于-Istio-的高级流量管理"><a href="#模块十二：基于-Istio-的高级流量管理" class="headerlink" title="模块十二：基于 Istio 的高级流量管理"></a>模块十二：基于 Istio 的高级流量管理</h5><p><strong>教学目标：</strong></p>
<ol>
<li><p>理解基于 TCP&#x2F;UDP 协议的 Kubernetes Service 的局限性</p>
</li>
<li><p>理解 Kubernetes 入站流量管理的场景和原生方案</p>
</li>
<li><p>理解原生方案的局限性和社区的方向</p>
</li>
<li><p>深入理解 Envoy 的服务发现机制、线程模型以及扩展机制</p>
</li>
<li><p>理解如何基于 Istio 实现入站、出站流量管理以及服务网格管理</p>
</li>
</ol>
<p><strong>针对的用户痛点：</strong></p>
<ol>
<li><p>社区的 Ingress 对象无法毕业，为支持生产化应用，应该用什么方案提供入站流量支撑</p>
</li>
<li><p>Envoy 为什么变成了 Kubernetes 中七层代理的首选</p>
</li>
<li><p>社区爆火的 Istio 背后的技术驱动力是什么，我应该选 Istio 作为入站流量管理平面组件吗</p>
</li>
</ol>
<p><strong>通过学习掌握的核心能力：</strong></p>
<ol>
<li><p>深入理解 Envoy 的实现机制</p>
</li>
<li><p>深入理解 Istio 的实现机制，了解为什么 Istio 会成为服务网格的标准</p>
</li>
</ol>
<p><strong>详细内容：</strong></p>
<ol>
<li><p>入站流量管理 Ingress 和 Service API</p>
</li>
<li><p>Istio 和 Envoy</p>
</li>
<li><p>深入理解 Envoy：发现机制、线程模型、filter 机制、高级特性</p>
</li>
<li><p>深入理解 Isito：入站流量、出站流量、Service Mesh（服务网格）、Istio 服务发现代码走读</p>
</li>
<li><p>安全保证</p>
</li>
</ol>
<hr>
<h5 id="模块十三：Kubernetes-集群联邦和-Istio-多集群管理"><a href="#模块十三：Kubernetes-集群联邦和-Istio-多集群管理" class="headerlink" title="模块十三：Kubernetes 集群联邦和 Istio 多集群管理"></a>模块十三：Kubernetes 集群联邦和 Istio 多集群管理</h5><p><strong>教学目标：</strong></p>
<ol>
<li><p>如何通过集群联邦的统一控制平面管理多个集群</p>
</li>
<li><p>如何部署跨地域的高可用应用</p>
</li>
<li><p>如何通过 Istio 多集群方案管理跨集群的 Service Mesh（服务网格）</p>
</li>
</ol>
<p><strong>针对的用户痛点：</strong></p>
<ol>
<li><p>针对真正的生产化应用，跨地域部署是确保应用高可用的一个强需求，那么如何管理多个 Kubernetes 集群</p>
</li>
<li><p>针对跨集群部署的应用，如何确保其接入流量高可用，如何借助 Istio 实现这一目的</p>
</li>
</ol>
<p><strong>通过学习掌握的核心能力：</strong></p>
<ol>
<li><p>Kubernetes 集群联邦的实现原理和配置方法</p>
</li>
<li><p>Istio 多集群实现原理和配置方法</p>
</li>
</ol>
<p><strong>详细内容：</strong></p>
<ol>
<li><p>Kubernetes 集群联邦</p>
</li>
<li><p>基于集群联邦的跨地域高可用部署</p>
</li>
<li><p>基于 Istio 多集群的流量高可用方案</p>
</li>
</ol>
<hr>
<h5 id="模块十四：基于-Kubernetes-和-Istio-的安全保证"><a href="#模块十四：基于-Kubernetes-和-Istio-的安全保证" class="headerlink" title="模块十四：基于 Kubernetes 和 Istio 的安全保证"></a>模块十四：基于 Kubernetes 和 Istio 的安全保证</h5><p><strong>教学目标：</strong></p>
<ol>
<li><p>理解传统安全架构的挑战</p>
</li>
<li><p>掌握零信任架构的意义和机遇</p>
</li>
<li><p>掌握 Kubernetes 平台本身的安全保证手段</p>
</li>
<li><p>学习如何基于 Kubernetes 和 Istio 实现对应用的隔离和安全保证</p>
</li>
</ol>
<p><strong>针对的用户痛点：</strong></p>
<ol>
<li><p>如何确保 Kubernetes 平台的安全性</p>
</li>
<li><p>如何确保 Kubernetes 中数据保存的安全性</p>
</li>
<li><p>如何确保 Kubernetes 上运行应用的安全性</p>
</li>
</ol>
<p><strong>通过学习掌握的核心能力：</strong></p>
<ol>
<li><p>如何保证 etcd 中保存的数据安全性</p>
</li>
<li><p>如何保证 Kubernetes 控制面板的安全性</p>
</li>
<li><p>如何确保 API 网关的安全性</p>
</li>
<li><p>对应用进行安全隔离</p>
</li>
<li><p>如何基于零信任架构完成应用的认证和授权</p>
</li>
</ol>
<p><strong>详细内容：</strong></p>
<ol>
<li><p>理解 etcd 的加密方法</p>
</li>
<li><p>掌握 Kubernetes 控制面板的安全配置</p>
</li>
<li><p>掌握应用隔离的常规手段以及在 Kubernetes 中配置的方式</p>
</li>
<li><p>掌握 API 网关的安全配置</p>
</li>
<li><p>了解基于 Istio 的认证鉴权机制</p>
</li>
</ol>
<hr>
<h4 id="第三部分：云原生项目实战"><a href="#第三部分：云原生项目实战" class="headerlink" title="第三部分：云原生项目实战"></a>第三部分：云原生项目实战</h4><h5 id="模块十五：微服务项目的开发和部署案例"><a href="#模块十五：微服务项目的开发和部署案例" class="headerlink" title="模块十五：微服务项目的开发和部署案例"></a>模块十五：微服务项目的开发和部署案例</h5><p><strong>教学目标：</strong></p>
<p>完成一个复杂的异构的微服务系统在 Kubernetes 平台上的部署，以 Istio 的 Bookinfo 为例</p>
<p><strong>针对的用户痛点：</strong></p>
<ol>
<li><p>随着业务复杂度的增加，微服务的部署和运维变得越来越有挑战性，如何保证微服务应用部署的高性能是一个复杂问题</p>
</li>
<li><p>如何基于熔断、限流等手段保护核心业务</p>
</li>
<li><p>如何基于基础架构平台确保应用安全</p>
</li>
</ol>
<p><strong>通过学习掌握的核心能力：</strong></p>
<ol>
<li><p>基于微服务架构的复杂应用部署</p>
</li>
<li><p>熔断、限流、故障注入</p>
</li>
<li><p>应用的安全保证</p>
</li>
</ol>
<p><strong>详细内容：</strong></p>
<p>本模块是之前所有模块的综合复习模块，希望借助本模块完成基于 Kubernetes 框架下面微服务治理这一重要命题的回顾和总结</p>
<hr>
<h4 id="石墨文档"><a href="#石墨文档" class="headerlink" title="石墨文档"></a>石墨文档</h4><p>石墨文档的链接可能会更新，在此附上原地址链接</p>
<p>云原生训练营课程大纲：<a href="https://shimo.im/docs/6VdchtKxdjrCqDdY/read">点击跳转</a></p>
<p>云原生训练营实战项目：<a href="https://shimo.im/docs/RKAWV8xgZ7tKWXk8/read">点击跳转</a></p>
<hr>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>云原生</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL面试题</title>
    <url>/2022/10/28/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>MySQL常见面试题、八股文</p>
<h4 id="1-Mysql索引用的是什么算法"><a href="#1-Mysql索引用的是什么算法" class="headerlink" title="1. Mysql索引用的是什么算法"></a>1. Mysql索引用的是什么算法</h4><ul>
<li>Mysql索引选用的是B+树，平衡二叉树的高度太高，查找可能需要较多的磁盘IO。B树索引占用内存较高(非叶子节点存储数据)</li>
<li>B+树，主要是查询效率高，O(logN)，可以充分利用磁盘预读的特性，多叉树，深度小，叶子结点有序且存储数据</li>
</ul>
<h4 id="2-Mysql事务的基本要素"><a href="#2-Mysql事务的基本要素" class="headerlink" title="2. Mysql事务的基本要素"></a>2. Mysql事务的基本要素</h4><ul>
<li>原子性：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行</li>
<li>一致性：事务开始前和结束后，数据库的完整性约束没有被破坏</li>
<li>隔离性：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰</li>
<li>持久性：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚</li>
</ul>
<h4 id="3-Mysql的存储引擎"><a href="#3-Mysql的存储引擎" class="headerlink" title="3. Mysql的存储引擎"></a>3. Mysql的存储引擎</h4><ul>
<li>InnoDB存储引擎<ul>
<li>InnoDB存储引擎支持事务，其设计目标主要面向在线事务处理（OLTP）的应用</li>
<li>其特点是行锁设计，支持外键，并支持非锁定锁，即默认读取操作不会产生锁。从Mysql5.5.8版本开始，InnoDB存储引擎是默认的存储引擎</li>
</ul>
</li>
<li>MyISAM存储引擎<ul>
<li>MyISAM存储引擎不支持事务、表锁设计，支持全文索引，主要面向一些OLAP数据库应用</li>
<li>InnoDB的数据文件本身就是主索引文件，而MyISAM的主索引和数据是分开的</li>
</ul>
</li>
<li>NDB存储引擎<ul>
<li>NDB存储引擎是一个集群存储引擎，其结构是share nothing的集群架构，能提供更高的可用性</li>
<li>NDB的特点是数据全部放在内存中（从MySQL 5.1版本开始，可以将非索引数据放在磁盘上），因此主键查找的速度极快，并且通过添加NDB数据存储节点可以线性地提高数据库性能，是高可用、高性能的集群系统</li>
<li>NDB存储引擎的连接操作是在MySQL数据库层完成的，而不是在存储引擎层完成的。这意味着，复杂的连接操作需要巨大的网络开销，因此查询速度很慢。如果解决了这个问题，NDB存储引擎的市场应该是非常巨大的</li>
</ul>
</li>
<li>Memory存储引擎<ul>
<li>Memory存储引擎（之前称HEAP存储引擎）将表中的数据存放在内存中，如果数据库重启或发生崩溃，表中的数据都将消失</li>
<li>它非常适合用于存储临时数据的临时表，以及数据仓库中的纬度表。Memory存储引擎默认使用哈希索引，而不是我们熟悉的B+树索引</li>
<li>虽然Memory存储引擎速度非常快，但在使用上还是有一定的限制。比如，只支持表锁，并发性能较差，并且不支持TEXT和BLOB列类型。最重要的是，存储变长字段时是按照定常字段的方式进行的，因此会浪费内存</li>
</ul>
</li>
<li>Archive存储引擎<ul>
<li>Archive存储引擎只支持INSERT和SELECT操作，从MySQL 5.1开始支持索引</li>
<li>Archive存储引擎使用zlib算法将数据行（row）进行压缩后存储，压缩比一般可达1∶10。正如其名字所示，Archive存储引擎非常适合存储归档数据，如日志信息</li>
<li>Archive存储引擎使用行锁来实现高并发的插入操作，但是其本身并不是事务安全的存储引擎，其设计目标主要是提供高速的插入和压缩功能</li>
</ul>
</li>
<li>Maria存储引擎<ul>
<li>Maria存储引擎是新开发的引擎，设计目标主要是用来取代原有的MyISAM存储引擎，从而成为MySQL的默认存储引擎。它可以看做是MyISAM的后续版本</li>
<li>Maria存储引擎的特点是：支持缓存数据和索引文件，应用了行锁设计，提供了MVCC功能，支持事务和非事务安全的选项，以及更好的BLOB字符类型的处理性能</li>
</ul>
</li>
</ul>
<h4 id="4-Mysql事务隔离级别"><a href="#4-Mysql事务隔离级别" class="headerlink" title="4. Mysql事务隔离级别"></a>4. Mysql事务隔离级别</h4><p>Mysql有四种事务隔离级别，默认的是可重复读</p>
<table>
<thead>
<tr>
<th align="left">事务隔离级别</th>
<th align="left">脏读</th>
<th align="left">不可重复读</th>
<th align="left">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="left">读未提交</td>
<td align="left">是</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">读已提交</td>
<td align="left">否</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">可重复读</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">串行</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">否</td>
</tr>
</tbody></table>
<ul>
<li><p>读未提交(Read uncommitted)</p>
<p>一个事务可以读取另一个未提交事务的数据，最低级别，任何情况都无法保证</p>
<ul>
<li>所有事务都可以看到其他未提交事务的执行结果</li>
<li>本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少</li>
<li>该级别引发的问题是——脏读(Dirty Read)：读取到了未提交的数据</li>
</ul>
</li>
<li><p>读已提交(Read committed)</p>
<p>一个事务要等另一个事务提交后才能读取数据，可避免脏读的发生</p>
<ul>
<li>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）</li>
<li>它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变</li>
<li>这种隔离级别出现的问题是——不可重复读(Nonrepeatable Read)，不可重复读意味着我们在同一个事务中执行完全相同的select语句时可能看到不一样的结果</li>
</ul>
<p>导致这种情况的原因可能有：</p>
<ul>
<li>有一个交叉的事务有新的commit，导致了数据的改变</li>
<li>一个数据库被多个实例操作时，同一事务的其他实例在该实例处理其间可能会有新的commit</li>
</ul>
</li>
<li><p>可重复读(Repeatable read)</p>
<p>就是在开始读取数据（事务开启）时，不再允许修改操作，可避免脏读、不可重复读的发生</p>
<ul>
<li>这是MySQL的默认事务隔离级别</li>
<li>它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行</li>
<li>此级别可能出现的问题——幻读(Phantom Read)：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行</li>
<li>InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了该问题.InnoDB采用MVCC来支持高并发，实现了四个标准隔离级别。默认基本是可重复读，并且提供间隙锁（next-key locks）策略防止幻读出现</li>
</ul>
</li>
<li><p>串行(Serializable)</p>
<p>串行(Serializable)，是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。Mysql的默认隔离级别是Repeatable read</p>
<ul>
<li>这是最高的隔离级别</li>
<li>它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁</li>
<li>在这个级别，可能导致大量的超时现象和锁竞争</li>
</ul>
</li>
</ul>
<h4 id="5-Mysql高可用方案有哪些"><a href="#5-Mysql高可用方案有哪些" class="headerlink" title="5. Mysql高可用方案有哪些"></a>5. Mysql高可用方案有哪些</h4><ul>
<li>主从复制方案<ul>
<li>这是MySQL自身提供的一种高可用解决方案，数据同步方法采用的是<code>MySQL replication</code>技术。<code>MySQL replication</code>就是从服务器到主服务器拉取二进制日志文件，然后再将日志文件解析成相应的SQL在从服务器上重新执行一遍主服务器的操作，通过这种方式保证数据的一致性</li>
<li>为了达到更高的可用性，在实际的应用环境中，一般都是采用<code>MySQL replication</code>技术配合高可用集群软件<code>keepalived</code>来实现自动<code>failover</code>，这种方式可以实现95.000%的SLA</li>
</ul>
</li>
<li>MMM&#x2F;MHA高可用方案<ul>
<li>MMM提供了MySQL主主复制配置的监控、故障转移和管理的一套可伸缩的脚本套件。在MMM高可用方案中，典型的应用是双主多从架构，通过MySQL replication技术可以实现两个服务器互为主从，且在任何时候只有一个节点可以被写入，避免了多点写入的数据冲突</li>
<li>同时，当可写的主节点故障时，MMM套件可以立刻监控到，然后将服务自动切换到另一个主节点，继续提供服务，从而实现MySQL的高可用</li>
</ul>
</li>
<li>Heartbeat&#x2F;SAN高可用方案<ul>
<li>在这个方案中，处理failover的方式是高可用集群软件Heartbeat，它监控和管理各个节点间连接的网络，并监控集群服务，当节点出现故障或者服务不可用时，自动在其他节点启动集群服务</li>
<li>在数据共享方面，通过SAN（Storage Area Network）存储来共享数据，这种方案可以实现99.990%的SLA</li>
</ul>
</li>
<li>Heartbeat&#x2F;DRBD高可用方案<ul>
<li>这个方案处理failover的方式上依旧采用Heartbeat，不同的是，在数据共享方面，采用了基于块级别的数据同步软件DRBD来实现</li>
<li>DRBD是一个用软件实现的、无共享的、服务器之间镜像块设备内容的存储复制解决方案。和SAN网络不同，它并不共享存储，而是通过服务器之间的网络复制数据</li>
</ul>
</li>
<li>NDB CLUSTER高可用方案<ul>
<li>国内用NDB集群的公司非常少，貌似有些银行有用。NDB集群不需要依赖第三方组件，全部都使用官方组件，能保证数据的一致性，某个数据节点挂掉，其他数据节点依然可以提供服务，管理节点需要做冗余以防挂掉</li>
<li>缺点是：管理和配置都很复杂，而且某些SQL语句例如join语句需要避免</li>
</ul>
</li>
</ul>
<h4 id="6-Mysql中utf8和utf8mb4区别"><a href="#6-Mysql中utf8和utf8mb4区别" class="headerlink" title="6. Mysql中utf8和utf8mb4区别"></a>6. Mysql中utf8和utf8mb4区别</h4><ul>
<li>MySQL在5.5.3之后增加了这个utf8mb4的编码，mb4就是most bytes 4的意思，专门用来兼容四字节的unicode。好在utf8mb4是utf8的超集，除了将编码改为utf8mb4外不需要做其他转换。当然，为了节省空间，一般情况下使用utf8也就可以了</li>
<li>Mysql支持的utf8编码最大字符长度为3字节，如果遇到4字节的宽字符就会插入异常了。三个字节的UTF-8最大能编码的Unicode字符是0xffff，也就是Unicode中的基本多文种平面(BMP)。任何不在基本多文本平面的Unicode字符，都无法使用Mysql的utf8字符集存储</li>
<li>包括 Emoji 表情(Emoji是一种特殊的Unicode编码，常见于ios和android手机上)，和很多不常用的汉字，以及任何新增的Unicode字符等等</li>
<li>Mysql中保存4字节长度的UTF-8字符，需要使用utf8mb4字符集，但只有5.5.3版本以后的才支持(查看版本： select version();)。因此呢，为了获取更好的兼容性，应该总是使用utf8mb4而非utf8</li>
<li>对于CHAR类型数据，utf8mb4会多消耗一些空间，根据Mysql官方建议，使用VARCHAR替代CHAR</li>
</ul>
<h4 id="7-Mysql中乐观锁和悲观锁区别"><a href="#7-Mysql中乐观锁和悲观锁区别" class="headerlink" title="7. Mysql中乐观锁和悲观锁区别"></a>7. Mysql中乐观锁和悲观锁区别</h4><ul>
<li><p>悲观锁(Pessimistic Lock)</p>
<ul>
<li>悲观锁顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁</li>
<li>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁</li>
</ul>
</li>
<li><p>乐观锁(Optimistic Lock)</p>
<ul>
<li>乐观锁顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制</li>
<li>乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于<code>write_condition</code>机制的其实都是提供的乐观锁</li>
<li>乐观锁的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好</li>
</ul>
</li>
<li><p>两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适</p>
</li>
</ul>
<h4 id="8-Mysql索引主要是哪些"><a href="#8-Mysql索引主要是哪些" class="headerlink" title="8. Mysql索引主要是哪些"></a>8. Mysql索引主要是哪些</h4><p>索引的目的在于提高查询效率</p>
<ul>
<li>UNIQUE(唯一索引)：不可以出现相同的值，可以有NULL值</li>
<li>INDEX(普通索引)：允许出现相同的索引内容</li>
<li>PROMARY KEY(主键索引)：不允许出现相同的值</li>
<li>fulltext index(全文索引)：可以针对值中的某个单词，但效率确实不敢恭维</li>
<li>组合索引：实质上是将多个字段建到一个索引里，列值的组合必须唯一</li>
</ul>
<hr>
<h5 id="8-1-索引的缺点"><a href="#8-1-索引的缺点" class="headerlink" title="8.1 索引的缺点"></a>8.1 索引的缺点</h5><ul>
<li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT，UPDATE和DELETE。因为更新表时，mysql不仅要保存数据，还要保存一下索引文件</li>
<li>建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在要给大表上建了多种组合索引，索引文件会膨胀很宽， 索引只是提高效率的一个方式，如果mysql有大数据量的表，就要花时间研究建立最优的索引，或优化查询语句</li>
</ul>
<hr>
<h5 id="8-2-索引使用技巧"><a href="#8-2-索引使用技巧" class="headerlink" title="8.2 索引使用技巧"></a>8.2 索引使用技巧</h5><ul>
<li><strong>索引不会包含有NULL的列：</strong> 只要列中包含有NULL值，都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此符合索引就是无效的</li>
<li><strong>使用短索引：</strong> 对串列进行索引，如果可以就应该指定一个前缀长度。例如，如果有一个char（255）的列，如果在前10个或20个字符内，多数值是唯一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I&#x2F;O操作</li>
<li><strong>索引列排序：</strong>mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作，尽量不要包含多个列的排序，如果需要最好给这些列建复合索引</li>
<li><strong>like语句操作：</strong>一般情况下不鼓励使用like操作，如果非使用不可，注意正确的使用方式。<code>like ‘%aaa%’</code>不会使用索引，而<code>like ‘aaa%’</code>可以使用索引</li>
<li>不要在列上进行运算</li>
<li>不使用<code>NOT IN</code> 、<code>&lt;&gt;</code>、<code>！=</code>操作，但<code>&lt;</code>，<code>&lt;=</code>，<code>=</code>，<code>&gt;</code>，<code>&gt;=</code>，BETWEEN，IN是可以用到索引的</li>
<li>索引要建立在经常进行select操作的字段上。这是因为，如果这些列很少用到，那么有无索引并不能明显改变查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求</li>
<li>索引要建立在值比较唯一的字段上。</li>
<li>对于那些定义为text、image和bit数据类型的列不应该增加索引。因为这些列的数据量要么相当大，要么取值很少</li>
<li>在where和join中出现的列需要建立索引。</li>
<li>where的查询条件里有不等号(where column !&#x3D; …)，mysql将无法使用索引。</li>
<li>如果where字句的查询条件里使用了函数(如：where DAY(column)&#x3D;…)，mysql将无法使用索引</li>
<li>在join操作中(需要从多个数据表提取数据时)，mysql只有在主键和外键的数据类型相同时才能使用索引，否则及时建立了索引也不会使用</li>
</ul>
<hr>
<h5 id="8-3-组合索引的作用"><a href="#8-3-组合索引的作用" class="headerlink" title="8.3 组合索引的作用"></a>8.3 组合索引的作用</h5><ul>
<li>减少开销<ul>
<li>建一个组合索引(col1，col2，col3)，实际相当于建了(col1)，(col1，col2)，(col1，col2，col3)三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用组合索引会大大的减少开销</li>
</ul>
</li>
<li>覆盖索引<ul>
<li>通常指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖</li>
<li>对组合索引(col1，col2，col3)，如果有如下的<code>sql: select col1，col2，col3 from test where col1=1 and col2=2</code></li>
<li>那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一</li>
</ul>
</li>
<li>效率高<ul>
<li>索引列越多，通过索引筛选出的数据越快</li>
</ul>
</li>
</ul>
<h4 id="9-Mysql联合索引最左匹配原则"><a href="#9-Mysql联合索引最左匹配原则" class="headerlink" title="9. Mysql联合索引最左匹配原则"></a>9. Mysql联合索引最左匹配原则</h4><ul>
<li>在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先<ul>
<li>在检索数据时从联合索引的最左边开始匹配，Mysql会一直向右匹配直到遇到范围查询（<code>&gt;、&lt;、between、like</code>）就停止匹配了</li>
<li>就比如 <code>a=3 and b=4 and c&gt;5 and d=6</code>如果建立(abcd)顺序的索引，d就用不到索引了，如果建立(abdc)的索引则都可以用到索引，其中abd的顺序可以任意调整，因为查询优化器会重新编排（即使是c&gt;5 and b&#x3D;4 and d&#x3D;6 and a&#x3D;3也会全部用到 abdc索引 ）</li>
</ul>
</li>
<li><code>=</code>和<code>in</code>可以乱序，比如<code>a=1 and b=2 and c=3</code> 建立(abc)索引可以任意顺序，mysql查询优化器会优化顺序<ul>
<li>这里需要注意下，比如abc索引 那么只要查询条件有a即可用到abc索引（如abc ab ac a），没有a就用不到</li>
<li>最左前缀匹配成因：Mysql是创建复合索引的规则是根据索引最左边的字段进行排序，在第一个字段排序的基础上再进行第二个字段排序，类似于order by col1，col2… 所以第一个字段是绝对有序的 第二个字段就是无序的了，所以Mysql强调最左前缀匹配</li>
</ul>
</li>
</ul>
<h4 id="10-聚簇索引和非聚簇索引区别"><a href="#10-聚簇索引和非聚簇索引区别" class="headerlink" title="10. 聚簇索引和非聚簇索引区别"></a>10. 聚簇索引和非聚簇索引区别</h4><ul>
<li>聚簇索引与非聚簇索引的区别是：叶子节点是否存放一整行记录</li>
<li>InnoDB 主键使用的是聚簇索引，MyISAM 不管是主键索引，还是二级索引使用的都是非聚簇索引</li>
<li>对于聚簇索引表来说（左图），表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值。使用的是B+树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)</li>
<li>对于非聚簇索引表来说（右图），表数据和索引是分成两部分存储的，主键索引和二级索引存储上没有任何区别。使用的是B+树作为索引的存储结构，所有的节点都是索引，叶子节点存储的是索引+索引对应的记录的数据</li>
<li>因此，聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针</li>
</ul>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7lczbhkshj318611ik0y.jpg" alt="image.png" style="zoom: 20%;" /></div>

<h4 id="11-如何查询一个字段是否命中了索引"><a href="#11-如何查询一个字段是否命中了索引" class="headerlink" title="11. 如何查询一个字段是否命中了索引"></a>11. 如何查询一个字段是否命中了索引</h4><ul>
<li>通过explain sql可看下SQL是否走了索引，很快对比出来 </li>
<li>当一个sql中索引字段为int类型时，例如搜索条件<code>where num=&quot;111&quot;</code>与<code>where num=111</code>都可以使用该字段的索引。当一个中索引字段为varchar类型时，例如搜索条件<code>where num=&quot;111&quot;</code>可以使用索引，<code>where num=111</code>不可以使用索引</li>
</ul>
<h4 id="12-Mysql中查询数据什么情况下不会命中索引"><a href="#12-Mysql中查询数据什么情况下不会命中索引" class="headerlink" title="12. Mysql中查询数据什么情况下不会命中索引"></a>12. Mysql中查询数据什么情况下不会命中索引</h4><ul>
<li>索引规范不合理，sql解析器不命中索引</li>
<li>表中索引是以表中数据量字段最多的建立的索引，sql解析器不命中索引(实际就是索引没用，最后全局查找了)</li>
<li>bool的字段做索引，sql选择器不命中索引</li>
<li>模糊查询 %like</li>
<li>索引列参与计算，使用了函数</li>
<li>非最左前缀顺序</li>
<li>where对null判断</li>
<li>where不等于</li>
<li>or操作有至少一个字段没有索引</li>
<li>需要回表的查询结果集过大（超过配置的范围）</li>
</ul>
<h4 id="13-Mysql中的MVCC是什么"><a href="#13-Mysql中的MVCC是什么" class="headerlink" title="13. Mysql中的MVCC是什么"></a>13. Mysql中的MVCC是什么</h4><p>数据库并发控制——锁:Multiversion (version) concurrency control (MCC or MVCC) 多版本并发控制 ，它是数据库管理系统一种常见的并发控制</p>
<p>并发控制常用的是锁，当线程要对一个共享资源进行操作的时候，加锁是一种非常简单粗暴的方法(事务开始时给 DQL 加读锁，给 DML 加写锁)，这种锁是一种 悲观 的实现方式，也就是说这会给其他事务造成堵塞，从而影响数据库性能</p>
<p>其中在数据库中最常见的就是悲观锁和乐观锁：</p>
<ul>
<li>悲观锁：当一个线程需要对共享资源进行操作的时候，首先对共享资源进行加锁，当该线程持有该资源的锁的时候，其他线程对该资源进行操作的时候会被阻塞.</li>
<li>乐观锁：当一个线程需要对一个共享资源进行操作的时候，不对它进行加锁，而是在操作完成之后进行判断。比如乐观锁会通过一个版本号控制，如果操作完成后通过版本号进行判断在该线程操作过程中是否有其他线程已经对该共享资源进行操作了，如果有则通知操作失败，如果没有则操作成功，当然除了版本号还有CAS，如果不了解的可以去学习一下，这里不做过多涉及</li>
</ul>
<p>MVCC的两种读形式：</p>
<ul>
<li>快照读：读取的只是当前事务的可见版本，不用加锁。而你只要记住 简单的 <code>select</code>操作就是快照读(select * from table where id &#x3D; xxx)</li>
<li>当前读：读取的是当前版本，比如 特殊的读操作，更新&#x2F;插入&#x2F;删除操作</li>
</ul>
<p>MVCC的实现原理：</p>
<p>MVCC 使用了“三个隐藏字段”来实现版本并发控制，MySQL在创建建表的时候 innoDB 创建的真正的三个隐藏列吧</p>
<table>
<thead>
<tr>
<th align="left">RowID</th>
<th align="left">DB_TRX_ID</th>
<th align="left">DB_ROLL_PTR</th>
<th align="left">id</th>
<th align="left">name</th>
<th align="left">password</th>
</tr>
</thead>
<tbody><tr>
<td align="left">自动创建的id</td>
<td align="left">事务id</td>
<td align="left">回滚指针</td>
<td align="left">id</td>
<td align="left">name</td>
<td align="left">password</td>
</tr>
</tbody></table>
<ul>
<li>RowID：隐藏的自增ID，当建表没有指定主键，InnoDB会使用该RowID创建一个聚簇索引</li>
<li>DB_TRX_ID：最近修改（更新&#x2F;删除&#x2F;插入）该记录的事务ID</li>
<li>DB_ROLL_PTR：回滚指针，指向这条记录的上一个版本</li>
</ul>
<p>其实还有一个删除的flag字段，用来判断该行记录是否已经被删除。而 MVCC 使用的是其中的 事务字段，回滚指针字段，是否删除字段</p>
<h4 id="14-Mvcc和Redolog和Undolog以及Binlog有什么不同"><a href="#14-Mvcc和Redolog和Undolog以及Binlog有什么不同" class="headerlink" title="14. Mvcc和Redolog和Undolog以及Binlog有什么不同"></a>14. Mvcc和Redolog和Undolog以及Binlog有什么不同</h4><ul>
<li>Mvcc<ul>
<li>MVCC多版本并发控制是MySQL中基于乐观锁理论实现隔离级别的方式，用于读已提交和可重复读取隔离级别的实现</li>
<li>在MySQL中，会在表中每一条数据后面添加两个字段，最近修改该行数据的事务ID，指向该行（undolog表中）回滚段的指针</li>
<li>Read View判断行的可见性，创建一个新事务时，copy一份当前系统中的活跃事务列表。意思是，当前不应该被本事务看到的其他事务id列表</li>
</ul>
</li>
<li>UndoLog<ul>
<li>UndoLog也就是我们常说的回滚日志文件 主要用于事务中执行失败，进行回滚，以及MVCC中对于数据历史版本的查看</li>
<li>由引擎层的InnoDB引擎实现，是逻辑日志，记录数据修改被修改前的值，比如”把id&#x3D;’B’ 修改为id &#x3D; ‘B2’ ，那么undo日志就会用来存放id &#x3D;’B’的记录”</li>
<li>当一条数据需要更新前，会先把修改前的记录存储在undolog中，如果这个修改出现异常，则会使用undo日志来实现回滚操作，保证事务的一致性</li>
<li>当事务提交之后，undo log并不能立马被删除，而是会被放到待清理链表中，待判断没有事物用到该版本的信息时才可以清理相应undolog。它保存了事务发生之前的数据的一个版本，用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读</li>
</ul>
</li>
<li>Redolog<ul>
<li>Redolog是重做日志文件是记录数据修改之后的值，用于持久化到磁盘中</li>
<li>Redolog包括两部分：一：是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二：是磁盘上的重做日志文件(redo log file)，该部分日志是持久的</li>
<li>由引擎层的InnoDB引擎实现，是物理日志，记录的是物理数据页修改的信息，比如“某个数据页上内容发生了哪些改动”。当一条数据需要更新时，InnoDB会先将数据更新，然后记录redoLog 在内存中，然后找个时间将redoLog的操作执行到磁盘上的文件上</li>
<li>不管是否提交成功我都记录，你要是回滚了，那我连回滚的修改也记录。它确保了事务的持久性</li>
</ul>
</li>
<li>Binlog<ul>
<li>Binlog由Mysql的Server层实现，是逻辑日志，记录的是sql语句的原始逻辑，比如”把id&#x3D;’B’ 修改为id &#x3D; ‘B2’</li>
<li>Binlog会写入指定大小的物理文件中，是追加写入的，当前文件写满则会创建新的文件写入</li>
<li>产生:事务提交的时候，一次性将事务中的sql语句，按照一定的格式记录到binlog中</li>
<li>用于复制和恢复在主从复制中，从库利用主库上的binlog进行重播(执行日志中记录的修改逻辑)，实现主从同步。业务数据不一致或者错了，用binlog恢复</li>
</ul>
</li>
</ul>
<h4 id="15-Mysql读写分离以及主从同步"><a href="#15-Mysql读写分离以及主从同步" class="headerlink" title="15. Mysql读写分离以及主从同步"></a>15. Mysql读写分离以及主从同步</h4><ul>
<li>原理：主库将变更写binlog日志，然后从库连接到主库后，从库有一个IO线程，将主库的binlog日志拷贝到自己本地，写入一个中继日志中，接着从库中有一个sql线程会从中继日志读取binlog，然后执行binlog日志中的内容，也就是在自己本地再执行一遍sql，这样就可以保证自己跟主库的数据一致</li>
<li>问题：这里有很重要一点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行操作，在从库上会串行化执行，由于从库从主库拷贝日志以及串行化执行sql特点，在高并发情况下，从库数据一定比主库慢一点，是有延时的，所以经常出现，刚写入主库的数据可能读不到了，要过几十毫秒，甚至几百毫秒才能读取到。还有一个问题，如果突然主库宕机了，然后恰巧数据还没有同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。所以mysql实际上有两个机制，一个是半同步复制，用来解决主库数据丢失问题，一个是并行复制，用来解决主从同步延时问题</li>
<li>半同步复制：semi-sync复制，指的就是主库写入binlog日志后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的relay log之后，接着会返回一个ack给主库，主库接收到至少一个从库ack之后才会认为写完成</li>
<li>并发复制：指的是从库开启多个线程，并行读取relay log中不同库的日志，然后并行重放不同库的日志，这样库级别的并行。（将主库分库也可缓解延迟问题）</li>
</ul>
<h4 id="16-InnoDB的关键特性"><a href="#16-InnoDB的关键特性" class="headerlink" title="16. InnoDB的关键特性"></a>16. InnoDB的关键特性</h4><ul>
<li>插入缓冲：对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个Insert Buffer对象中。然后再以一定的频率和情况进行Insert Buffer和辅助索引页子节点的merge（合并）操作，这时通常能将多个插入合并到一个操作中（因为在一个索引页中），这就大大提高了对于非聚集索引插入的性能</li>
<li>两次写：两次写带给InnoDB存储引擎的是数据页的可靠性，有经验的DBA也许会想，如果发生写失效，可以通过重做日志进行恢复。这是一个办法。但是必须清楚地认识到，如果这个页本身已经发生了损坏（物理到page页的物理日志成功页内逻辑日志失败），再对其进行重做是没有意义的。这就是说，在应用（apply）重做日志前，用户需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做。在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是会通过memcpy函数将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，这就是doublewrite</li>
<li>自适应哈希索引：InnoDB存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引</li>
<li>异步IO：为了提高磁盘操作性能，当前的数据库系统都采用异步IO（AIO）的方式来处理磁盘操作。AIO的另一个优势是可以进行IO Merge操作，也就是将多个IO合并为1个IO，这样可以提高IOPS的性能</li>
<li>刷新邻接页：当刷新一个脏页时，InnoDB存储引擎会检测该页所在区（extent）的所有页，如果是脏页，那么一起进行刷新。这样做的好处显而易见，通过AIO可以将多个IO写入操作合并为一个IO操作，故该工作机制在传统机械磁盘下有着显著的优势</li>
</ul>
<h4 id="17-Mysql如何保证一致性和持久性"><a href="#17-Mysql如何保证一致性和持久性" class="headerlink" title="17. Mysql如何保证一致性和持久性"></a>17. Mysql如何保证一致性和持久性</h4><ul>
<li>Mysql为了保证<code>ACID</code>中的一致性和持久性，使用了WAL(<code>Write-Ahead Logging</code>，先写日志再写磁盘)。<code>Redo log</code>就是一种WAL的应用</li>
<li>当数据库忽然掉电，再重新启动时，Mysql可以通过<code>Redo log</code>还原数据。也就是说，每次事务提交时，不用同步刷新磁盘数据文件，只需要同步刷新<code>Redo log</code>就足够了</li>
</ul>
<h4 id="18-为什么选择B-树作为索引结构"><a href="#18-为什么选择B-树作为索引结构" class="headerlink" title="18. 为什么选择B+树作为索引结构"></a>18. 为什么选择B+树作为索引结构</h4><ul>
<li>Hash索引：Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描</li>
<li>二叉查找树：解决了排序的基本问题，但是由于无法保证平衡，可能退化为链表</li>
<li>平衡二叉树：通过旋转解决了平衡的问题，但是旋转操作效率太低</li>
<li>红黑树：通过舍弃严格的平衡和引入红黑节点，解决了AVL旋转效率过低的问题，但是在磁盘等场景下，树仍然太高，IO次数太多</li>
<li>B+树：在B树的基础上，将非叶节点改造为不存储数据纯索引节点，进一步降低了树的高度；此外将叶节点使用指针连接成链表，范围查询更加高效。此外，B+树，主要是查询效率高，O(logN)，可以充分利用磁盘预读的特性，多叉树，深度小，叶子结点有序且存储数据</li>
</ul>
<h4 id="19-InnoDB的行锁模式"><a href="#19-InnoDB的行锁模式" class="headerlink" title="19. InnoDB的行锁模式"></a>19. InnoDB的行锁模式</h4><ul>
<li>共享锁(S)：用法lock in share mode，又称读锁，允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁<ul>
<li>若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改</li>
</ul>
</li>
<li>排他锁(X)：用法for update，又称写锁，允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁<ul>
<li>若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。在没有索引的情况下，InnoDB只能使用表锁</li>
</ul>
</li>
</ul>
<h4 id="20-哈希-hash-比树-tree-更快，索引结构为什么要设计成树型"><a href="#20-哈希-hash-比树-tree-更快，索引结构为什么要设计成树型" class="headerlink" title="20. 哈希(hash)比树(tree)更快，索引结构为什么要设计成树型"></a>20. 哈希(hash)比树(tree)更快，索引结构为什么要设计成树型</h4><p>加速查找速度的数据结构，常见的有两类：</p>
<ul>
<li>哈希，例如HashMap，查询&#x2F;插入&#x2F;修改&#x2F;删除的平均时间复杂度都是O(1)</li>
<li>树，例如平衡二叉搜索树，查询&#x2F;插入&#x2F;修改&#x2F;删除的平均时间复杂度都是O(lg(n))</li>
</ul>
<p>哈希只能满足等值查询，不满足范围和大小查询，其次哈希不可以排序。Mysql是用等值查询，用树的话，等值查询只需要顺序遍历即可。但是对于排序查询的sql需求：分组：<code>group by</code> ，排序：<code>order by</code> ，比较：<code>&lt;、&gt;</code>等，哈希型的索引，时间复杂度会退化为O(n)，而树型的“有序”特性，依然能够保持O(log(n)) 的高效率</p>
<h4 id="21-为什么索引的key长度不能太长"><a href="#21-为什么索引的key长度不能太长" class="headerlink" title="21. 为什么索引的key长度不能太长"></a>21. 为什么索引的key长度不能太长</h4><p>key 太长会导致一个页当中能够存放的 key 的数目变少，间接导致索引树的页数目变多，索引层次增加，从而影响整体查询变更的效率</p>
<h4 id="22-Mysql的数据如何恢复到任意时间点"><a href="#22-Mysql的数据如何恢复到任意时间点" class="headerlink" title="22. Mysql的数据如何恢复到任意时间点"></a>22. Mysql的数据如何恢复到任意时间点</h4><p>恢复到任意时间点以定时的做全量备份，以及备份增量的 binlog 日志为前提。恢复到任意时间点首先将全量备份恢复之后，再此基础上回放增加的 binlog 直至指定的时间点</p>
<h4 id="23-Mysql为什么加了索引可以加快查询"><a href="#23-Mysql为什么加了索引可以加快查询" class="headerlink" title="23. Mysql为什么加了索引可以加快查询"></a>23. Mysql为什么加了索引可以加快查询</h4><p>在数据十分庞大的时候，索引可以大大加快查询的速度，这是因为使用索引后可以不用扫描全表来定位某行的数据，而是先通过索引表找到该行数据对应的物理地址然后访问相应的数据</p>
<ul>
<li>优势：可以快速检索，减少I&#x2F;O次数，加快检索速度；根据索引分组和排序，可以加快分组和排序</li>
<li>劣势：索引本身也是表，因此会占用存储空间，一般来说，索引表占用的空间的数据表的1.5倍；索引表的维护和创建需要时间成本，这个成本随着数据量增大而增大；构建索引会降低数据表的修改操作（删除，添加，修改）的效率，因为在修改数据表的同时还需要修改索引表</li>
</ul>
<h4 id="24-Explain命令有什么用"><a href="#24-Explain命令有什么用" class="headerlink" title="24. Explain命令有什么用"></a>24. Explain命令有什么用</h4><p>在开发的过程中，我们有时会用<strong>慢查询</strong>去记录一些执行时间比较久的Sql语句，找出这些Sql语句并不意味着完事了，这个时候我们就需要用到explain这个命令来查看一个这些Sql语句的执行计划，查看该Sql语句有没有使用上了索引，有没有做全表扫描，这些都可以通过explain命令来查看</p>
<p>expain出来的信息有10列，分别是<code>id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">- <span class="built_in">id</span>：select选择标识符</span><br><span class="line">- select_type：表示查询的类型</span><br><span class="line">- table：输出结果集的表</span><br><span class="line">- partitions：匹配的分区</span><br><span class="line">- <span class="built_in">type</span>：表示表的连接类型</span><br><span class="line">- possible_keys：表示查询时，可能使用的索引</span><br><span class="line">- key：表示实际使用的索引</span><br><span class="line">- key_len：索引字段的长度</span><br><span class="line">- ref：列与索引的比较</span><br><span class="line">- rows：扫描出的行数(估算的行数)</span><br><span class="line">- filtered：按表条件过滤的行百分比</span><br><span class="line">- Extra：执行情况的描述和说明</span><br></pre></td></tr></table></figure>

<ul>
<li><p>id：select选择标识符</p>
<p>id是Sql执行的顺序的标识，Sql从大到小的执行</p>
<ul>
<li>id相同时，执行顺序由上至下</li>
<li>如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li>
<li>id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行</li>
</ul>
</li>
<li><p>select_type：表示查询的类型</p>
<p>查询中每个select子句的类型</p>
<ul>
<li>SIMPLE(简单SELECT，不使用UNION或子查询等)</li>
<li>PRIMARY(查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)</li>
<li>UNION(UNION中的第二个或后面的SELECT语句)</li>
<li>DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)</li>
<li>UNION RESULT(UNION的结果)</li>
<li>SUBQUERY(子查询中的第一个SELECT)</li>
<li>DEPENDENT SUBQUERY(子查询中的第一个SELECT，取决于外面的查询)</li>
<li>DERIVED(派生表的SELECT，FROM子句的子查询)</li>
<li>UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)</li>
</ul>
</li>
<li><p>table：输出结果集的表</p>
<ul>
<li>table显示这一行的数据是关于哪张表的，有时不是真实的表名字，看到的是derivedx</li>
</ul>
</li>
<li><p>partitions：匹配的分区</p>
</li>
<li><p>type：表示表的连接类型</p>
<p>type表示Mysql在表中找到所需行的方式，又称“访问类型”。常用的类型有： ALL， index， range， ref， eq_ref， const， system， NULL（从左到右，性能从差到好）</p>
<ul>
<li>ALL：Full Table Scan， Mysql将遍历全表以找到匹配的行</li>
<li>index：Full Index Scan，index与ALL区别为index类型只遍历索引树</li>
<li>range：只检索给定范围的行，使用一个索引来选择行</li>
<li>ref：表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</li>
<li>eq_ref：类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件</li>
<li>const、system：当Mysql对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，Mysql就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system</li>
<li>NULL：Mysql在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成</li>
</ul>
</li>
<li><p>possible_keys：表示查询时，可能使用的索引</p>
<ul>
<li>possible_keys指出Mysql能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用</li>
<li>该列完全独立于<code>EXPLAIN</code>输出所示的表的次序。这意味着在<code>possible_keys</code>中的某些键实际上不能按生成的表次序使用</li>
<li>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询</li>
</ul>
</li>
<li><p>key：表示实际使用的索引</p>
<ul>
<li>key列显示MySql实际决定使用的键（索引）</li>
<li>如果没有选择索引，键是NULL。要想强制Mysql使用或忽视<code>possible_keys</code>列中的索引，在查询中使用<code>FORCE INDEX、USE INDEX</code>或者<code>IGNORE INDEX</code></li>
</ul>
</li>
<li><p>key_len：索引字段的长度</p>
<ul>
<li>key_len表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）不损失精确性的情况下，长度越短越好</li>
</ul>
</li>
<li><p>ref：列与索引的比较</p>
<ul>
<li>ref表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</li>
</ul>
</li>
<li><p>rows：扫描出的行数(估算的行数)</p>
<ul>
<li>rows表示Mysql根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</li>
</ul>
</li>
<li><p>filtered：按表条件过滤的行百分比</p>
</li>
<li><p>Extra：执行情况的描述和说明</p>
<p>该列包含Mysql解决查询的详细信息，有以下几种情况：</p>
<ul>
<li>Using where：列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤</li>
<li>Using temporary：表示Mysql需要使用临时表来存储结果集，常见于排序和分组查询</li>
<li>Using filesort：Mysql中无法利用索引完成的排序操作称为“文件排序”</li>
<li>Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能</li>
<li>Impossible where：这个值强调了where语句会导致没有符合条件的行</li>
<li>Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行</li>
</ul>
</li>
</ul>
<h4 id="25-MySQL优化"><a href="#25-MySQL优化" class="headerlink" title="25. MySQL优化"></a>25. MySQL优化</h4><ul>
<li>避免不走索引的场景</li>
<li>select语句其他优化</li>
<li>增删改DML语句优化</li>
<li>查询条件优化</li>
<li>建表优化</li>
</ul>
<h5 id="25-1-避免不走索引的场景"><a href="#25-1-避免不走索引的场景" class="headerlink" title="25.1 避免不走索引的场景"></a>25.1 避免不走索引的场景</h5><ol>
<li>尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描</li>
<li>尽量避免使用<code>in</code>和<code>not in </code>，会导致引擎走全表扫描</li>
<li>尽量避免使用<code>or</code>，会导致数据库引擎放弃索引进行全表扫描</li>
<li>尽量避免进行<code>null</code>值的判断，会导致数据库引擎放弃索引进行全表扫描</li>
<li>尽量避免在<code>where</code>条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描</li>
<li>当数据量大时，避免使用<code>where 1=1</code>的条件，通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描</li>
<li>条件查询不能用<code>&lt;&gt;</code>或者<code>!=</code></li>
<li><code>where</code>条件仅包含复合索引非前置列</li>
<li>隐式类型转换造成不使用索引</li>
<li><code>order by</code>条件要与<code>where</code>中条件一致，否则<code>order by</code>不会利用索引进行排序</li>
<li>正确使用<code>hint</code>优化语句</li>
</ol>
<h5 id="25-2-select语句其他优化"><a href="#25-2-select语句其他优化" class="headerlink" title="25.2 select语句其他优化"></a>25.2 select语句其他优化</h5><ol>
<li>避免出现<code>select *</code></li>
<li>避免出现不确定结果的函数</li>
<li>多表关联查询时，小表在前，大表在后</li>
<li>使用表的别名</li>
<li>用<code>where</code>语句替换<code>HAVING</code>字句</li>
<li>调整<code>where</code>字句中的连接顺序</li>
</ol>
<h5 id="25-3-增删改DML语句优化"><a href="#25-3-增删改DML语句优化" class="headerlink" title="25.3 增删改DML语句优化"></a>25.3 增删改DML语句优化</h5><ol>
<li>大批量插入数据</li>
<li>适当使用<code>commit</code></li>
<li>避免重复查询更新的数据</li>
<li>查询优先还是更新<code>(insert、update、delete)</code>优先</li>
</ol>
<h5 id="25-4-查询条件优化"><a href="#25-4-查询条件优化" class="headerlink" title="25.4 查询条件优化"></a>25.4 查询条件优化</h5><ol>
<li>对于复杂的查询，可以使用中间临时表暂存数据</li>
<li>优化<code>group by</code>语句</li>
<li>优化<code>join</code>语句</li>
<li>优化<code>union</code>语句</li>
<li>拆分复杂<code>SQL</code>为多个小<code>SQL</code>，避免大事务</li>
<li>使用<code>truncate</code>代替<code>delete</code></li>
<li>使用合理的分页方式以提高分页效率</li>
</ol>
<h5 id="25-5-建表优化"><a href="#25-5-建表优化" class="headerlink" title="25.5 建表优化"></a>25.5 建表优化</h5><ol>
<li>在表中建立索引，优先考虑<code>where、order by</code>使用到的字段</li>
<li>尽量使用数字类型（性别：男：1，女：2），若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储的开销</li>
<li>查询数据量大的表，会造成查询缓慢。主要的原因是扫描行数过多，这个时候可以通过程序，分段分页进行查询，循环遍历，将结果合并处理进行展示</li>
<li>用<code>varchar/nvarchar</code>代替<code>char/nchar</code></li>
</ol>
<h4 id="26-SQL注入"><a href="#26-SQL注入" class="headerlink" title="26. SQL注入"></a>26. SQL注入</h4><p>Sql注入攻击是通过将恶意的Sql查询或添加语句插入到应用的输入参数中，再在后台Sql服务器上解析执行进行的攻击，它目前黑客对数据库进行攻击的最常用手段之一。</p>
<p><strong>避免SQL注入：</strong></p>
<ul>
<li>参数校验，校验数据的类型，长度，特殊字符，数据库关键词等</li>
<li>代码层面防止SQL注入攻击的最佳方案是SQL预编译，尽量不写SQL原生语句，使用ORM</li>
<li>严格限制数据库权限</li>
<li>避免直接响应一些SQL异常信息，SQL发生异常后，自定义异常进行响应</li>
</ul>
<h4 id="27-MySQL、MongoDB、Redis区别，适用场景"><a href="#27-MySQL、MongoDB、Redis区别，适用场景" class="headerlink" title="27. MySQL、MongoDB、Redis区别，适用场景"></a>27. MySQL、MongoDB、Redis区别，适用场景</h4><h5 id="27-1-MySQL"><a href="#27-1-MySQL" class="headerlink" title="27.1 MySQL"></a>27.1 MySQL</h5><ol>
<li>高度事务性系统。例如银行或会计系统，传统的关系型数据库目前还是更适用于需要大量原子性复杂事务的应用程序</li>
<li>传统的商业智能应用，针对特定问题的<code>BI</code>数据库会产生高度优化的查询方式，对于此类应用，数据仓库可能是更合适的选择</li>
</ol>
<h5 id="27-2-MongoDB"><a href="#27-2-MongoDB" class="headerlink" title="27.2 MongoDB"></a>27.2 MongoDB</h5><ol>
<li>网站数据：适合实时的插入，更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性</li>
<li>缓存：由于性能很高，也适合作为信息基础设施的缓存层，在系统重启之后，搭建的持久化缓存可以避免下层的数据源过载</li>
<li>大尺寸、低价值的数据也是<code>MongoDB</code>的最佳选择，使用传统的关系型数据库存储一些数据时可能会比较贵，在此之前很多程序员往往会选择传统的文件进行存储</li>
<li>高伸缩的场景，非常适合由数十台或数百台服务器组成的数据库</li>
<li>用于对象及<code>json</code>数据的存储，<code>MongoDB</code>的<code>bson</code>数据格式非常适合文档格式化的存储及查询</li>
</ol>
<h5 id="27-3-Redis"><a href="#27-3-Redis" class="headerlink" title="27.3 Redis"></a>27.3 Redis</h5><ol>
<li>用来做缓存：<code>Redis</code>的所有数据是存放在内存中的</li>
<li>可以在某些特定应用场景下替代传统数据库：比如社交类的应用</li>
<li>在一些大型系统中，巧妙的实现一些特定的功能：<code>session</code>共享、购物车</li>
<li><code>MongoDB</code>不支持<code>SQL</code>语句</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>关于博客</title>
    <url>/2022/10/27/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容">
  <script id="hbeData" type="hbeData" data-hmacdigest="ab4776d2f33dd789b78edba694d6cab85dbf3cc0bfa78cb2915fb9e33ab9fcfd">a17b4de793b95f7877066d2186f5861555e2d6b9cb5641947e36c8450a9062244141303af7f6ac122ca280e580e95da40c8ee95d99d2439c2f200eaab162cbb1875108085071c26de1a7a2252b96fcbe0f08370a21f14470abd2a2d2b018211a390d4a79c82cf2a64ae884fb7caded6082fa0005ef84e7ea431151015e2060bda837f3b622c77b40ee17a251d882f100278d00b9963489c074d217f528b9e8e054d830314c2ebd97fa3c76a53976dbdc3aa54c7b15ce70a5882de8489603f7173418c015d0ef7e8aa5ae4a33046644b0e563b4499cb8d0d6173282b0a21575c27f9144f5086203cb49e7bd9f84fa510fa7ca67502f97fdebb306ef8a69773c81e40bf148ee8b9d8ad2d1bdf194c6075caa40305d045fbb2a1c2119103f08f156ceaebc719357118924dd869dcd27372f3549487bee4f166e5c77adcb1ac7794dbe0a673ebfa66aa2595818250b9851cbcad400d4687e30b48667a8013245d51dce6aae77d5905b91f53b574fc443b1684c92af0bac92b0aacfa2311b89865521de7bc0054eeb9670d5568a2e98652854cf0ed9fc027967d196f3a30f8b2b14066b2b52b741727573fadde89b47e0d9fa69fed76a226477fc8a2f55fb32f9e4a53348a2747f494b15c8d7565c27afbb068f7ce813b4e1ddedada52692a9c6d917f278d17b970668263eeaaefcc44df89bcde5edc1ad4988985ab067b75e6cd1d6f6083dd6b1ce8e775db02a7d9533537b178a63ec573a5043bc15bbd2fc963c4f3aa122ec4f0b3fc30cca5257817db4bd4ffccc7a43fd006bc392e64e161e7b59542881b1b7db7805b0003d89224d2ef64a29bbcbd982ea90041c78c6f87bee6da444542e072c9c6786ea8101f8bf295aee03c0d6033a3e19116bae338e4be2520f564c69e09cabcbd5249b3c4c50d66ab39b30dd90f909ea126d2b48f8245d175a365531c939ef6e9a42c17a33a69c8b52de48e4757f5f25a4fef9493350305d558c5c0c806c0698893aaa568476e50e6079fe997df4194d8fb35a21ea8958bff697c158b049a30bd3bcd0e162772f352d83b202daafb229c098c33cda25c04e715a81f80f6673a1a70c6f17a033b3ddcd772068cce43302f1602f71d2b7a5e121056818a837126e27c0990955f13ad5ed1fe26d0e0aee808c0717a47a38999c20411f7ce53f8b1bc86018e5b9287eeaa3caf58b4244ae291f351667c000a7830273ef3d8a17f8c1254d819d16bcb2a2d9683972c91763ebbda2a379442d0b07437cfe123ac3be67f7318fb7803470146435bd3d593263e5e37c32705f6ad8b8d0decb68839c28c9a838f97b8613f4c483eee116afbea3097e72e0077f5a4ed396ad4c4be49ee36f3726809e0efa9aa8a9e0e3181b1126675c191b7b9a7fcf1ff115b2e87efd6ec64274d47cbdbd09c899a776819132d9566fea583fa1897209395d8dfb78cf6cdc2819d6c0e75da888e88ad236667388f965855fd7fc36d1249a1a1d24eab917be709ea423f9491f59038c726eac3ffed3707f0d3bdb8c90e1951f96ef89d1abfd2d4679259ea0d69c9a1f152594c71981fcc4dece41fa6dbc07cd2a1a3a0949396cebc5a8a3f13d0033e3ed78f7473fa5c9d6d5802e15232fa8b6bdd1feee2a12f22c2449c68bb1e7d8052c8ae42bfcc1f65444565986cbc63a4381f9bb0b27d0f5387f2f04a80432645dcd2a57c171892bdd3ffce03a5852a2768dfd5d53ac1fa5e321da9dba979819096a00897281370689f9e75e450560f86f506e598fff748d42ec26aab61b453561f9facad5af053d0c77652e200b75d59620b32899f0977b4d7f947cf1fd9beb68e8280f53cbfcdf2ef9ab67cdbb3bba405d77af100b02287ea616c931799fd7eb8c65b4843c926b2651e5d68b33e0e8cde998c763b06347c459de9fc8b6d5b10460a3388c750b194669523e2e6628d25d736b401ce307f71cc25241f4c82561bc6fa56eb3924f23148fbf518a80344233e7f71a3fe7150d9566a5b2d78802878628dcbe3aae5d400d10be685cf3015c07fa9981fe3645873b7089878cf1743cb0f6eb1796b83b00fe30bb78a6d55e94b4d4f0a2ededbfc36e8de15a8c68506befc43dc69e9abaaa7cd55a6b0f6e6792c45997a7acc30f602b783f1c2d9e0a430ab0a3fe4708ccebd7296c44cfbbed6e7cdf13078753bfd0f6d1866bcb3909c3a07cbdb5faa777ce9e8229c9f734f9bd4b8345ac641766ecb4180dff676c9eb4ac91e0330e530705671b54027ce8d3d33fc6fc9a01753866b28e5bcb8d028adb423edbaf834b45079379af6dbf75c379ec6cbe97f5acab496506713300ee2fa1d677ec006f8460d04a3a797a316a88ba832955f99e291cda035b1663c676618e95cc59dcd3414befa5426a4c35a12f9f95d1bf2fb1b12fe350b0b1b3bc504578eb3ab16aaff15505b218ec2b0fbc933d9034bea8be11ca2ace22f04b861883fd863a5ec6c16ab8ff90a72fbc89fe91f9c2b84601a8dd28de98bfe0d12ebbfbb14b201090325fbfdd352e276c6fbbdc989d94ee96b47b57a5aeff3af3e8bf9f7a0cafd74b8a28cf11b86ae485563e16bc071035388116b04012ae9d36e259252145eaf552be23a474c5c6069c29b15df7194f40734f61e4f0f9e7da86c08944a68a2b6e7768e608d01145a35e4973f948119045948996df2410aa5c019c24fbb7c8615d0409ea313ebeb78d6ee8c9ea6fabd9c504713c21c54b21e773fee2c29468af30e00839978e769b07780286f5ba0b35971772053de944880873743e8073f3ca90778c45d558733835666daba6285c05162bbf1873a03e9a29994cc53678aca15cddcc1d2d8ca360828c2dc48f9a536ab4d309b01814f0a7627862f3b718b4b95fad03b8299e80e08b96e73105d9198cefc55bf0a26c8e13906b900bebc96b87960b5763d31f03f411ef027006cdae44aef11472578447a913034088d6d861c71de18fb99a9ce6932e0072cfd030bb49c34cb8286c90aed1408f146dbc39e78b0ffe602096c078d6c92ca59e264608df236ad9ee41f99c24f97b379a8d06636842e2d54008152997c8beb6cb86971dbd8b476596e0fec9229e959c1ad4a20259b1d1580e789a16c5b860e447a97f6c6daa850e83715e9236f6fa882a6adf7daee4e66d54b0ddf0966b181098e9998014905ba6b79e76f0c7cb3a6ffc3bf6640b20551704fe94216a732df2642e8d1fa25aebe51b04b3eb634a9e00f307e266f3cf9271e3faab8a828182a0e514f37888a805a4d3cc60c3ce428e9db37be132155b55740d4f93b7addd70d38ba8ac286921ab9ca32690350d35098782c618a7a6aef460e67652366c7b919d0a0aac2646daf741e55bfc9c650539dd6d755574cad07af9359895132f201d2eda1229b7540487750ba60e705158636e473b1a7ecb944b98587de86c6eebfc6a7e64291374129bcd142da570765bdb65cbc046c0a07cee6a59d7153a389ff2c27e0ce590808f50429d5877bcf24e2f1e2a72d63b464ad6bb91eac128ee19d1ed8bd6143604eae097c485dbeb04c56de34f94d28846fd5621c08a6609e7d408b1fd03e36defa8d59dc0cb9400a4a7e614d4aace51ebd7252c40a67ce237573a934fdeb1b9e0e127f5718fe4315a5026a455e2dacd45ae5e352aac9a03e56e8aba77b182194d330a5e68dda7b4202a9ccaf2864a34814a2cb060cfec55b655b899e7f66f11348acf51964d5603025054b1be35317c7de9a4941b5ed3fc3c3038be497bd3762134b9e892b01fe7791b0037cd8a6d15476c3b22aed3e7276c5ff1f8fdb1a7ae77715a81f0dd955e18fc54c6d1d28e4a6779546eb93449b288da309947a747dfed8c497520513b1bc7d271cbae4bf199355f37b5964535f0be92998aea448384e17cf990b8b339c8301edf9ac37219ebf580e1c60a7d2b7719d0856e8dc8c1e56141c0abd47916b1cf6a9f735b60278b3bd02567a54d01ccc1926134111fe7184a54d872ce230aca60f6625700d5bfc925d2d178b3251a1a5dfa97d824b585dbdfdd24303f1af300c79882c82ac677764761dbf2497fc2692ef13eabf8f75914376ae2d870c272f8d50828f1ad29d5f39d2d17a5f40b62d01cc10f9067e72fbf8a64abf11db7a154fcfdc2a246a074cf4fad6058df30d63893581dd4e643a4067a26cf9ad99dc00a2428d4fc1ea6269371358a98ac96075883b5afb47da32a16d1e710ca17171b9d9a672106c8ffd65a3d736314ef7f7565d9b5a5167b09b964647bb16d64acca1f5fb4e4d7c77d7231b2ffd44f49b26114450ff399482595e7e4944fcd2aa8b51db1817d1c85672ffdd06128a6cea9979d6f5d21e0c776773bf98664fe200a1385f15fc747a5109614c79d8e5ddaea38beeae3df3dc66a9609ca51b4b77421c29e270f13b470fb9064eb2c7337f8b8cadd7f8f46db0e885d8a6c2fdadb226ccbcc963d128198eea37b72c738b0617ec7b706bf2e1319ced1c4bed6b9f89d4f9f8fce6253b8c0718eefa341caf689c11a3b7e9e2468c390141a75123a22a9778686b5fb9153a16ae9aaebcf1efe2e65097a27e392be7c40eef4f89a21ef027a2b02848cceabd148899cc00feef565c7ca4763ccf8df0cc725e504442b7762b816a28abf87cc691b04aff02609c24a3096f6cda6f10934092d210c80253b7ab0aa094f07b2bde74027c08628d4be8c0d1d694f4281a80942a0513c4bf7d69a5710da1bff7162f55481ebc01412afb661d4f15e9b852485209297a86917ae77f93da5dfb61f3c28caf621d2bb6b774e504b25e1cca8bc4fba4779b37fd53beb9e32702f607a3da09f36e4627a85c705326704f75fde436e9e0027506bff83a24ba9b9435d9996a20bc04f57af90ce584828fedd43668ce9edf082e80c9c0a5304f197cc2dc850438269c0ba4f59fce714ff2ad759aa04e0d269af9349539dd6637523a7cd0346623af4f10b3c9eee6b52243ec6645277a27a0b9b530c24c3edc9ba1329e8ec7af7760c9194d276264915df27ad0e40e0b2d4ba0ece0c256cacbe276f3194e7baa25fd5c3b24488f71a4351a3cda0d12f137f22dcb53b0505b4dc2480242ca0153b5e1a681cfe8650460984367b1d6d57adefd262fe260091dd41a4aa954d33742a76ea453feaf354be02c6ef52cb72a5a8d95bf83c57ae34722a45a9058138303aa098b2ee8cca5739b3f79d9529b047f3606a52cc396a159181aea8d341d332aa993ef449926b0608c5356ce90a9867cbcc409ad57c13d97687377876c95a82720dd6bcc77804a65e45a11f5628b8299ca1f4ea9fafc7991e7be9b4d85c9772604e6dcbee78cc0fe3ef7b7ce5d65a4d616c548b6dcf260e2c45e90122cad56a82cb877214e943a45da00a6d6ce6ff7bc36b41075f493ccd5ddc1ed24e1b29fa197e502ee6c10a2adfbff8e87aa0368e6b4ffce4473e4b06c534a48e6005b862a7b1c4904cc354a15b81328e8784e0d88fea417f3bbae96950897714d1b18b566ad8969919082522a2154502441c3c8934903296d249e57bc2d0fe910b429072fbfd644037ccd8f20a462b4d78aafd35b00288279cd49012099279759ddde53c64f36348b03f3eb9ca3ffa5d57c069d20d9c02014b3a5e070672d4084f71494c0e4017aeb6c80fa9f1504e50e566994efd59468621d27a50159a5be9f8273c1af878f8b3d27316ff01c0916259138c84bf87db48d65922edb92f3e5ff3e796dad9ad7acc1a8553f88166817330681804213f94285cd1b9a4a19880ffc0f5409d8051e09b4c38d484256d15b410f4bd85f398c9e5ea6fa06fe6f7c442015b12af608c083a9389fcc978c3b0b72be782ea75e558f9492ca03f42645cf4c84c30fe9b3e0d31ea7c96065a733ae5e71fccb1b41c78799f0953b7a97694c577c41f99666ab1b13606c59df11835b8ab5d60206cc9a029bf5030e59b851893dd77a9f3bef6f26ee1a0686501dcf07985e61b13c359f74f87729376c1566f335c4a8860eeb7acaf05ffd0a5dfdb3b807d6934c527de798ccbd600f16c8ce01839cce11c7e28fcad77948ac806d31ea896f6a6c5cdf157e0dc4ca98132faff947e3a6b740a64334ab4c6b6161c636420facfdd21a7aa9b19bf25333cb70ff558209a4cbb1fc56744ee509e2495ad8f6d3ecb663aba5c67b24a0fe69b97ae1567991c7071289e23d484a0d2cc45f5dfc6988d77a0c162913abc3a6bf3345be5e1812d90878048a1702fb5aa554d1d4b9710f319c27176b05ab25af699caebb5ec5b79e1bbb3c9bcd201090e7e66f4d34d2afc1531c9f7c3ca18616f5e24d5fec6bca4eb1b03ee93fb7a46190521e2af235009ba06c49fe8f1d166a91392be6553f0f07811eb93f18f750cefa7de45fb5261567019ed530e21e6acf06c9ba76fefbdb6fd620f1e859a18a1b5869d9c2762319207ce5cc40aa5019c213b376fa3cbd81b76e88db9f9abcb3de44d79f76c4279d1c73030755680206f5aac40d679120c2ec3ea388013efa5f0e9398f4f16e24dd15d62b2f6465aff5dae123073bbb70087866601dc0763541b4d4aefe46d97a68ec5982f83bbb85fdabc4f2389b928c817f5a3005294ddee20b4444dc8a803df86cdbe6031ea6b611538f72de52ad840d9aa90c7d0d38e9cc8410589007eaea63b55a6c07c5175a7531dba0534ac0fc67c18d824395d241a021b9a20b9509b8903c587a83b32d764ae561ad974ce1bbe9c2ff9ba2994b1cfb55dc40df9b30c6597d05c32a2232d67d6494d03051454f1d8a968a744e788902853073e3bd0d8557429d6d786c1bb4ad9f42f1c183f1c72da143d263bbfe9dc15a977ee45ada37712302e1f34850f113fda831c134266302481820b0be5b199f255f52cad9d9669610739019141af3156239786049af870977219d9149c6b1ff6accbfcddacb38735bc33ec98e66af7e6ef65e9e96c2b10aaee31c4f0aa272793e76b54b84b62c16b3668d3f1cac1c691fa1672b87beac3249457c3363544e630f466dd9e0dd17cb7b8c980c8d06db8a6ba861c87fc55de1b89d0841b7bc56ee4e57bcdaedd4ac739b6265db1c058100999a0298a462ebb10a839dcc46f00e9158e511110ecdd0b9429a3d850a0c30c752dff1d47660e96400b5f3289e8a179c02549c7b4fa193f9998be101c6ac8c20ff0517d75ec1960ed5cd7f3f9883598c264465f80cd685a5c1aa17060a7e7c33923397ce75397f3a7d98453300cbb28dd317f78d9a960ce185e400da5745741218e803d754ee2b7a0b3759cc3932c254896523cfd81d9919a493b5664b06ace45d9eb9dfdf2731bc7269f68db5833f6085cdc3d13a9e3373c91b9330dc6fd610b4245abf240366747c4284742cf42a40aae593136d1c89e82e5304fb47260e39865485e4e320d3749959dc8bc4b091633f0b9b02a61ef98d994669bf34c874ff8932e513f54648ae0502ab0f24ecfdae9063c01aa450356f71ea58dd6ce348e49ffef856dda4fc49689acda6c23e95b6599714ccf4c7d3e71706b5858cb2488d25e1f48cbde0410d846fde8859aed61730950f887d2d8c608f2388d222c830ce7fb07f3ce1684ac5a8c82514a9059f8bbdf8691aad2d5ae730493cb42e5dac5b649e920f871cad50ead9bb6975c813d0ad2ec2ebede2f4c5e8a3e13c5b799428b0d080c8153edceaf526dfb55c0234d063f1b7dd8069118cb75dc2d91da5e5e1f11a7668b05429080e02e27e0031f8c7f000716ebe81cdcd6610a4d77d12d196325015ea8bc7d217e599816a79fe9015b2d510f9225fc80d1d6deeba76c41cda7cc8805ef367af42f148dd0bd0b8234ef004220c6edcfd7c8f80cdb2395b4482cd9cc520f826471c20f740a817f55d49913ae569b80883b3c9643c9d55208b1dfb71537333ab4f84cae9064d2e5fb6b14140efa35cc35a0e05f0b050b2709a707e054895208b9021c28e39b3c61a78440c48d6433c40ff65c86e01571abafaf2bb40b94e48e5a9697480f39a3754af44fab9ede883d7c2924c7ec032ddf7fc847f15bd3f5dd7051ff9a3ff663caa641cf2c7c9bb9664efaab437c589e0baac0e2cd34d4ae282dd9f680c114b62925cb1d022064b2754958519b6641f390360216a0dd60783b7d034110cf8b4768d2e15c78e1c741a9e901cc9e83fb514d6d68769fb3822ffbbca1df4a53f01f38986cb02f4f4a308bba35243c6465d4433944785a84af4c131528775a6a458be946d9b91c6752ae65ae1b095310d8bc320f2589d7ce12e786a37b59ba9fb8ac830575b480ee7d2ffcf2b040a68280122bb6c641c1eb8c81e5079635d835280a7a5b0421f638d60ec2283376615cc52ab3fdcc2ff7e4c8668031ca3d6f4ff49b46e4cc1d087f085d73582e1b4d664e8f4280162afea7405e3224176ae2ba6e45af7c44fdd929c997895e99cf1f94209cde32605ba585aff2c40d5e30d3ae8867e2685e91a9d355cfc184b2caf0ea01d532834eb9ea6427bf96b5b7ee48cac7c0add109dead7752d14df43fe02d5622d445cb36ca34e9dd3af83af5c4858512560b047c0b0accf303b0ba840f95ad5bff96dfd1eb94203abc482d51976f8bb0b0f554b07908432c035bd470f2ba93f71a3976affea523205651407610208ab48366f5063bbe3c395c74cfef9110cf6fabfbb56b0c1b2811ec0c47840fc86351ac6e16b9618476586ea211005d781bb02d0d91ecc4e2915641bd7e31b8493eb12f7e0c919aac3aebbdb35bce3989b361a167316d94255ac93cb9e4c7640d648432a983b6b2d13610bafe3df56191117ab7b083ae9a2551264e40fb0041bf3b47a322cc047f9329590b18be5812ccf2b04166793a2045a3324035d35c65e997c97d67614a0e36e7f027857995bda085cb16d5427d1100ecd665090916108fd3d7021e9c43b9c008b8790339d0c7b4f097445a5087579b77a1ebb07490696830af5389b2e84b58568161d731ce53806a083d0f19f5ab25b660099db2f5f92c989656710b38a682ed9efcd42bb879b9a13c0ec5359299d165fcd7ad41b6fdc99c2037b97a6471d01e2e80c0282d818b0003f97b7307a480478e8c53f7eb55063c174738699d3994d24822951cdc29e72032b15e396d1cafd85072a1b1320005491d60f5b02397d60b50c4e696e6410cd647d2d4e6e207e71b1119cfe28210f800b7f26ec66b5bdeb48624779cd2d6d8edcd92aceb15e8b5fc7a31bcbb04a61f19615844155146084d2ae91e008342c4c2d6457c0b02eb29754eae9dd725edd39095e0f35c78a753c07b270624e5790aee8a9873b6c3144f9a9958c23e7321189dcd7ab382e55869f655388c1797230a990a4487e0f4623139ea9dad6552ca6f9a9003e7453a8307f3965670c4f72abc8d94d3bd8940e15a45ba56b7943d53c82c7877e833694f0b4fd5015fbd2d5e851082fd3d9167dc635cf277c1b80191ee05b0b8b136a62ed7e4a142c8952047cc72af6265e372b16634f4a3a3e6057ecb03cec0314a0339bac04bc23682571857efa25d8e093709e27e109fc46fef6c4da5de3b58f63321ec66bdd48696e84eb7d3d251da77fac86888f42b717aa29ef5ef0e441658d0ad39d21e139a9a1dbe3e46cd19c650720ddf4f83d7351b7d297b0445c792e4485f3280e1f824ba1fa6d41dbf018744f81e0ee3817b3e22db6114f8f7bad82d1ef8e9db13a6cf73003a86e8888a98d581f51c98f1d1f1a3214bc5e20797196fd3d168224c71607f71925e1b8ce6e6a810c725035d9d5d4a4efebd876340b87336b356d73d34b7f6ace135cc71157d816d97e58dc705597cbb3d7a35bf3a738254422b198e4c37710ebe727054d7d21dbe0263961300f32733b19150297dc2b142959b9236b7eda7a6185c746ea78b66ffd82f4e953c5d06244beec36c83a6c531a917c512e3c690ab520092f8ac9e9de1584174b327dbbe013a246cfdfeef6d3f6cda269c6cc9c51b486cad2ee3fbefea47e85b4cbe95acfe280689ad13a4ba9ff73d39519dcb2bb6582524317d05c6c041d87efcf628ca96fa4925b7fe17977f52e90685ec9920106b93bdf7a6976ebdd01fb4199ef55e571f5effd84ba958ccc056d3fb1da4d4ddb2496c100a230650ddf02c5487aa523ff6c465ef4d8549e7e174d09aa9e81cec1c2077b835bfcd989d57572488093ba280f314fc803ae75edcee7707ad32a50ea7480c679cc4f3161a9a6c73f51044de2195b1eb848cdd8425cf9facc9633b37dae08e40788a64d0bc3dc39d368b88fe77ef510810cdd9d7f2a0eabeb5545d20e2a7a67d715fc744649d443984bb547808830872c80e793fbfb9a620941f13f50508be1a590f15ee6603ff89555901fb3f6952edc788eef1012e63c840adca083cb34250a1ff6d37e683ab99f774fe4421e50eefd55a59af91862153ee3be580e8a147317dce06629fd6e9441fd8a8bcd56eeaab161e6797b63d6218d4b24c0158147f388398077ddcd06debf493fc8db393c410b64c5f9892fcdfa0314977db4d51489487c7cf14b8f7fd56405e4d5ca0de09744c6e948e8168b07824d1185397fc0af9f4bc773cfec4efe963d3b4c6a38817bc1c0937cc2dcb9a135f8079c5d052351be383441d9ce70b4a5da7b3ffb0db88e086648f08c476b679e9d0d29c6018343d6befcee7e38f5b326bc02c81eff7f24b038ac8fcbfd5623acfdc98e460abd68ee965d467dc0398e3ffd6a2f6cf4265034805ecca2460c8e97f7c6ec5ac65c4604cc9787052dd90a147254c078b4ec6891b635ffa23ebc16cfcba37074e8a2ab7902ee257caa31c0676a92d3ccc7168071705237e67f86cc32342505bc2936c7116b589398657e2d8b5ce0b8520c35070dff3a35ff72fb5576757a47a663f163670bfa9e159685fa68d3a551d4227e1b2cc8a849f284d41a109c1d63eaa5d555c9d2fcc4d2f844bce132865609abf5789614a0723facaba3a865c07fd4be383680ee075bb04e33e881ead4ede8229d94104c149e9bc89a5c01e4ffbd28f0ca746cd5c97a69070c0d12e56f4743acb214a9cb4c8157a818b4316188bf632d4d7b02a57cdf36f92f4239c6322c20a5ede2ecb24cb8850db4995dfbd0fa887342d20547947fd8abe222b365c3a4847287094d164f13392d47d6c6ae3dcbc8f44eaf62dde4c4477757de829b5a5731629dfd18205fe5bcc22bb5ee15fc8c22ad165a83fd3049313ed2dd3a05562c082278e54f6a9d88deb82ad8468ccc2aa8218db3ee2faaf4dd648a5130f40bde3a2ca321f69471f7df239c2580dc902c1447827d06cfe5e9e3477743abd8e07ed0046dd95edae16cca09b4e3eb7189dafb4fac1ee3818b15b0554c1acfd4e99d95fc7294c3efaa076936409d2c3b6b2f68c9c87888a1ff816f0314d6696496c1b2cdaea9b920a6631cdfc45d633cfc4dc98697ce0e33e7ad53eeb90f73fb74e994ab3c9ffe532302fc5ec132271603a894ba9e76b74740c12e779f138e273779e57ffd13891c53aa57a503f25601b9200fdb74ec6fa68ff437d53edbacd96e79bcd3b1d401af3b2a022d24b2a03c8ffb43d69e63e59fd82c8864871224e5122b0c1fe279c17a5d4517c675d3ada3f4f6efa8715b36ffb18f77b8a538d688c09fafa460c47a3123c90d44136ba74396ff8d6a282a96e741b5011e45c436ad09142c399085c133ebf039aedb3983d88d7fe9a3aea2826cab6b2496db9aece34ea01a5b7f5555d6f6991917e70eab6ab81bd852d2cd4a78236d6ce0a7f0775c4bd3fc43bee118eeb1be38f6b035c2b26b7708be8c6c2407fc38d8c34f9d6eac1e5d87892d25732cf9dcebffc4ca00c1d5654700cf3f087a3a21ce4b6ab5b406e5c8983c82ddbac3bfd32cb3681157efe923042b55c4d1d9589b654e55b568ea65f8867b8c1df242e06680d11a11c866a1b942fe05ebaef9052a660fb213dab5b2539f9935d7abb2e9f161bfc8cd5793f3bbfd4ac969c78cde682281a12b38ad5aac40982982d6429c12116cbf03f050f86bd9929777a10ca58f7fcfcc668b8edc56c6566ddcb6d3f02e642daa288c9a5f7a9f4b5eabf1b4c3ee0110d006581395ae65b56f66a6051243be934598eafffe79c849eba136033ceb8ec4e4643a44e33a74802bb6c0bcbb58b92a130d970e3fd675dcb92baa038f611eabfe8267bb529d357dda06232c102b96defc468f5138b4a8dcff55a790f6ffe6c9e38fe17cdbc9d4ef8562ac8b52d59b8ddf96c4730db8e68dae1b3fe0e4ec13ce3848b6c1780e9016da7db6d8863df07a3b96f5af9ba60beecf5af6840419b092752ee0efbe3ce83488cdb830003055b46ff9c5d3a6c1ba62ee7fbbfcaf082c3dfbf80d3bf23a323b07f6c16d4e9fde54ccf6801fd1829c2ed13d82f0db71fbb9acd6089f101ce8ceb9ccc60924783af78c19c9600afc69b4e98ad442a14ae87b0b29cea25cbde2231c6489e60889ebcfc68fe69abcc993d1a66e77f592ba68e1862c64e5e56761704c215f87793221b5f75db6fc7f3bba7114db2f68649ba38b9e42b8498f6530f90cd0d5a0836b64322e1464ad29dcbb20bb3cf7f3d30f6d8d236e92982681bc4ccd23811c43c442c4a82200fff22e37fc3c22e14aa1e4852555b43ada6702a2dfa0d80dcc525008604dcf316e4817a5d0b2e477d908ea4bd70b9aeb08209ef509b568211f868ed6399bab7641c197d2e5b04c8cd4712c3636ae0f697e0de6efb8ed9309571c71fafe8c0164906a49cb5932c69993d6a5d2b3b079b71724cc2bcd17356c7935d708f5adc8344ee9e213377a7d934e1597875bcd1f3e803a94499198849a69410123dabede4fe2a92f1f9c646b4c78219ccf4eb6738b546dcde12497715254d7797b93bbe63b0f780e83e5d410c45f74b2ecc60fe4f6a6a76acf8a19adb1d84b4b2b02c2231d7515c7220ab1c009603e5f4043f12dab834e1b566a196eb96473da42755e0b0ff89a2e97ca712eb4845db74274cfd235fc18122c6939b83f7f760f260b869fdc9adda0709d95d82a6afcccc0e48171087dd28ac0ff9d0ccda93729cc457253bf50e95f45806c51df773f6db941fc16617bb4e2432a0803376ff73001b3676d02834a5c37061c2dff17da3a802374395f8bae7d4676d8ca6095090337daa30032344ac051354e16aa1913ac8b06c826751aa5eb962658992dbb489f225e876eec781f2010e40b736e715fa31120349867155deb787672e1a3cfec9d7b31ac0abcea9cf65e89eeb4aeb927ffb418622ee79e56d6afb5f87e56944b4ac697c3c000857562c1d48989d3d9773881eb49251ebe826753f138f1a3c56bb026d7a92a0f23f3fe783b3985c9ee436f0a39562d973d879fa1132f34b111ed3f4e46480c19a407ef0f63d9748edd18f26ce4b5f74caa534927ce9d3abba57992bdd7a69f658498a0fdca325ea3429f32225729de8236cf03995fdb0f7f00ec645233453ef2e17b34566896e62b1aef95061e9df61ecfaff2c1a2b4c52277f0642fd06d4cb6afee2e64daf4de9066ada9cbcf7f927ce19bc3d604d7d5b94043228959206547ac31bc3b1542e68f99788fbc51ce4012e44f55d93b73f3df64526841af7b77fe57630ad3163eb06c2f435152420c22ca2d01cb789ff59d56ce5fdf6a03dbac1f170d608eaf7653d89f2f43fc632fa1f0cd826abfb7692b42add033c0e57da12c8d9222e5ddf2c7c3f4eae3bdd7ee7b93fe8f7506cb19ecffa</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 请输入密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>关于博客</tag>
      </tags>
  </entry>
  <entry>
    <title>系统设计与架构</title>
    <url>/2022/11/01/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>系统设计与架构常见题整理</p>
<h4 id="1-如何设计一个短链服务"><a href="#1-如何设计一个短链服务" class="headerlink" title="1. 如何设计一个短链服务"></a>1. 如何设计一个短链服务</h4><p>参考链接：<a href="https://mp.weixin.qq.com/s/33lcKX3bLUAC-Mj0VlXa6A">点击跳转</a></p>
<h5 id="1-1-短链的价值"><a href="#1-1-短链的价值" class="headerlink" title="1.1 短链的价值"></a>1.1 短链的价值</h5><ul>
<li><strong>更加简洁：</strong>比起一长串无意义的问题，只有差不多 10 个字符的字符串显然更加简洁</li>
<li><strong>便于使用：</strong>第一，有些平台对内容长度有限制（微博只能发 140 个字），此时短网址就可以输入更多内容。第二，我们将链接转为二维码时，短链接生成的二维码更容易识别。第三，有些平台无法识别特殊的长链参数，转为短链就没这个问题</li>
<li><strong>节省成本：</strong>当我们需要发短信的时候，短信是按照长度计费的，短网址可以节省成本</li>
</ul>
<h5 id="1-2-短链的原理"><a href="#1-2-短链的原理" class="headerlink" title="1.2 短链的原理"></a>1.2 短链的原理</h5><p>当我们输入短链时，其实访问的是短链服务器的地址。短链服务器获取到对应的长链地址之后，返回一个 302 的 HTTP 响应，在响应中包含了长链接地址。浏览器收到响应后，转而去请求长链接地址。 访问短链的整个流程如下图所示：</p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7qyiustgcj30e307zq3t.jpg" alt="image.png" style="zoom:90%;" /></div>

<p>从上面的流程中可以知道，短链涉及到的技术原理主要有两点，分别是：HTTP 重定向和短链服务的设计</p>
<p>对于 HTTP 重定向来说，301 和 302 都是重定向：</p>
<ul>
<li>301 代表永久重定向。它表示第一次拿到长链接之后，下次浏览器如果再去请求短链的话，不会再向短链服务器请求了，而是直接从浏览器的缓存中获取。</li>
<li>302 代表临时重定向。它表示每次请求短链都会去请求短链服务器，不会从浏览器缓存中获取</li>
</ul>
<p>如果我们希望统计短链接的点击次数信息，从而来分析活动的效果的话。那么我们就需要使用 302 重定向码，这样才能获取到每次的请求数据。 一般情况下，我们都是需要获取到请求的数据的，因此对于短链服务都是用 302 临时重定向</p>
<h5 id="1-3-实现思路"><a href="#1-3-实现思路" class="headerlink" title="1.3 实现思路"></a>1.3 实现思路</h5><p>系统的处理流程：</p>
<ol>
<li>用户访问短链生成页面，输入长链字符串，短链服务返回生成的短链</li>
<li>用户访问短链，短链服务返回 302 响应，用户浏览器跳转到长链地址</li>
</ol>
<p>如果我们要实现上面的系统流程，我们大致的处理思路是：</p>
<ol>
<li><strong>生成短链。</strong> 生成短链时，短链服务获取到长链，随后生成一个短链，并把短链与长链的映射关系保存下来，最后将短链返回给用户</li>
<li><strong>找到长链。</strong> 访问短链时，短链服务获取到短链，根据短链去获取到长链，返回返回 302 响应</li>
</ol>
<p>根据上面的分析，我们可以知道短链系统设计主要得解决如下两个问题：</p>
<ol>
<li>如何根据长链生成唯一短链？</li>
<li>如何保存短链与长链的映射关系</li>
</ol>
<p>对于第 1 点，我们有 2 个思路生成一个唯一短链，分别是：</p>
<ol>
<li>使用哈希算法生成唯一值</li>
<li>使用分布式唯一 ID 生成作为锻炼 ID</li>
</ol>
<p>对于第 2 点，保存短链与长链的映射关系，考虑到持久性的问题，我们肯定需要落库，所以使用 MySQL 表保存即可。如果有需要的话，可以在 MySQL 前做一层缓存。因此第 2 点相对来说比较简单</p>
<hr>
<h6 id="1-3-1-哈希算法生成短链"><a href="#1-3-1-哈希算法生成短链" class="headerlink" title="1.3.1 哈希算法生成短链"></a>1.3.1 哈希算法生成短链</h6><p>要生成一个短链，我们可以将原有的长链做一次哈希，然后就可以得到一个哈希值，计算哈希值会遇到如下2个问题：</p>
<p><strong>使用什么哈希算法</strong></p>
<p>我们都知道哈希算法是一种摘要算法，它的作用是：对任意一组输入数据进行计算，得到一个固定长度的输出摘要。我们常见的哈希算法有：MD5、SHA-1、SHA-256、SHA-512 算法等。但我们最好还是使用另一种叫做 MurmurHash 的哈希算法。为什么呢</p>
<p>因为 MD5 和 SHA 哈希算法，它们都是加密的哈希算法，也就是说我们无法从哈希值反向推导出原文，从而保证了原文的保密性</p>
<p>但对于我们这个场景而言，我们并不关心安全性，我们关注的是运算速度以及哈希冲突。而 MurmurHash 算法是一个非加密哈希算法，所以它的速度回更快</p>
<p><strong>哈希冲突</strong></p>
<p>学过 HashMap 的同学都知道，哈希冲突是哈希算法不可避免的问题。而解决哈希冲突的方式有两种，分别是：链表法和重哈希法。HashMap 使用了链表法，但我们这里使用的是重哈希法</p>
<p>所谓的重哈希法，指的是当发生哈希冲突的时候，我们在原有长链后面加上固定的特殊字符，后续拿出长链时再将其去掉，如下所示</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">原有长链：https://mp.weixin.qq.com/s1caec8eb1b81d6ee5dd7b</span><br><span class="line">              ↓↓  </span><br><span class="line">           发生哈希冲突</span><br><span class="line">              ↓↓  </span><br><span class="line">补上特殊字符：https://mp.weixin.qq.com/s1caec8eb1b81d6ee5dd7b[SPECIAL-CHARACTER]</span><br><span class="line">              ↓↓  </span><br><span class="line">           再次进行哈希</span><br></pre></td></tr></table></figure>

<p>通过这种办法，我们就可以解决哈希冲突的问题了。如果再次发生，那么就再进行哈希，一直到不冲突位置。一般来说，哈希冲突的可能性微乎其微</p>
<p>好了，现在我们通过哈希算法得到了一个哈希值：<code>29541341303115543223957290326355</code>，变成了这样：<code>http://dwz.com/29541341303115543223957290326355</code></p>
<p>有没有办法让网址变得再短一点呢</p>
<p>我们知道在网址 URL 中，常用的合法字符有 0～9、a～z、A～Z 这样 62 个字符。如果我们用哈希值与 62 取余，那么余数肯定是在 0-61 之间</p>
<p>这 62 个数字刚好与 62 个合法网址字符一一对应。接着，我们再用除 62 得到的值，再次与 62 取余，一直到位 0 为止。通过这样的处理，我们就可以得到一个字符为 62 个字符、长度很短的字符串了</p>
<p>上面讲有点晦涩难懂，我们来举个例子。假设我们得到的哈希值为 181338494，那么上面的处理流程为：</p>
<ol>
<li>将 181338494 除以 62，得到结果为 2924814，余数为 26，此时余数 26 对应字符为 q。</li>
<li>将 2924814 除以 62，得到结果为 47174，余数为 26，此时余数 26 对应字符为 q。</li>
<li>将 47174 除以 62，得到结果为 760，余数为 54，此时余数 54 对应字符为 S。</li>
<li>省略剩余步骤</li>
</ol>
<p>整个处理流程如下图所示：</p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7qyyjct7rj30ia0bk405.jpg" alt="image.png" style="zoom:90%;" /></div>

<p>可以看到，我们把 181338494 这个十进制数，转成了由合法网址字符组成的「62 进制数」—— <code>cgSqq</code></p>
<p>到这里，我们不仅生成了短链，还将短链的长度极大地缩短了</p>
<p>这就是使用哈希算法生成唯一锻炼的全部内容了，我们总结一下：<strong>首先，使用 MurmurHash 生成哈希值，并且用重哈希法解决哈希冲突的问题。接着，将 10 进制的哈希值转成 62 进制的合法网址字符，从而缩短网址长度</strong></p>
<h6 id="1-3-2-分布式-ID-生成短链"><a href="#1-3-2-分布式-ID-生成短链" class="headerlink" title="1.3.2 分布式 ID 生成短链"></a>1.3.2 分布式 ID 生成短链</h6><p>上面使用哈希算法生成唯一短链的方式，相对来说是比较形象的。但其实我们也可以用分布式 ID 的方式，来完成唯一短链的生成</p>
<p>例如第一次请求的长链，我们为其生成一个唯一 ID，将其长链与唯一 ID 对应起来。第二次请求，我们再为其生成一个唯一 ID，再次将长链与唯一 ID 对应起来，如下所示。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">第一次请求：https://mp.weixin.qq.com/s1caec8eb1b81d6ee5dd7b</span><br><span class="line">              ↓↓  </span><br><span class="line">生成短链：https://dwz.com/1021000001</span><br><span class="line"></span><br><span class="line">第一次请求：https://mp.weixin.qq.com/s1caec8eb1b81d6ee5ff7b</span><br><span class="line">              ↓↓  </span><br><span class="line">生成短链：https://dwz.com/1021000002</span><br></pre></td></tr></table></figure>

<p>因为生成的唯一 ID 也可能非常长，因此我们可以采用上面同样的方式，将 10 进制的唯一 ID 转成 62 进制的合法网址字符，从而缩短字符长度</p>
<p>那么接下来的问题就变成了：如何设计一个全局唯一 ID 发号器了</p>
<p>对于如何设计一个全局唯一的 ID 发号器，就属于另外一个话题，我们这里就不深入探讨了</p>
<h5 id="1-4-性能优化"><a href="#1-4-性能优化" class="headerlink" title="1.4 性能优化"></a>1.4 性能优化</h5><p>看到这里，我们基本上有了一个完整的思路：拿到长链地址后，可以用哈希算法或唯一 ID 分号器获取唯一字符串，从而建立长链与短链的映射关系。为了缩短短链长度，我们还可以将其用 62 进制数表示，整个短链生成过程如下图所示</p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7qz2vgn49j30f10d3gn7.jpg" alt="image.png" style="zoom:80%;" /></div>

<p>短链生成完，并且已经存到了数据库中，接下里该使用了。通常的做法是会根据请求的短链字符串，从数据库中找到数据，然后返回 HTTP 重定向原始地址。而在不断使用过程中，还有一些可能发现的优化点，这里简单讲讲</p>
<ul>
<li><p>索引优化</p>
<ul>
<li>如果使用关系型数据库的话，对于短链字段需要创建唯一索引，从而加快查询速度</li>
</ul>
</li>
<li><p>增加缓存</p>
<ul>
<li>并发量小的时候，我们都是直接访问数据库。但当并发量再次升高时，需要加上缓存抗住热点数据的访问</li>
</ul>
</li>
<li><p>读写分离</p>
<ul>
<li>短链服务肯定是读远大于写的，因此对于短链服务，可以做好读写分离</li>
</ul>
</li>
<li><p>分库分表</p>
<ul>
<li>如果是商用的短链服务，那么数据量上亿是很正常的，更不用说常年累月积累下的量了。这时候可以一开始就做好分库分表操作，避免后期再大动干戈</li>
<li>对于分库分表来说，最关键的便是根据哪个字段去作为分库分表的依据了。对于短链服务来说，当然是用转化后的 62 进制数字做分表依据了，因为它是唯一的嘛</li>
</ul>
</li>
<li><p>防止恶意攻击</p>
<ul>
<li><p>开放到公网的服务，什么事情都可能发生，其中一个可能的点就是被恶意攻击，不断循环调用</p>
</li>
<li><p>一开始我们可以做一下简单地限流操作，例如：</p>
<ol>
<li>没有授权的用户，根据 IP 进行判断，1 分钟最多只能请求 10 次</li>
<li>没有授权的用户，所有用户 1 分钟最多只能请求 4000 次，防止更换 IP 进行攻击</li>
</ol>
</li>
<li><p>简单地说，就是要不断提高攻击的成本，使得最坏情况下系统依然可以正常提供服务</p>
</li>
</ul>
</li>
</ul>
<h5 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h5><p>在短链服务的设计思路上，最重要是解决两个问题：根据长链生成短链、根据短链找到长链。在根据长链生成短链的思路上，有两种实现思路，分别是：哈希算法生成短链、分布式全局 ID 生成短链，其中哈希算法涉及到哈希算法的选择，以及哈希冲突的处理</p>
<p>最后还列举了一些短链服务后续可能的优化点，包括：如何让网址变得更短、索引优化、增加热点数据、读写分离、分库分表、防止恶意攻击等等</p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7qz95bl1zj30u00l77d9.jpg" alt="image.png" style="zoom:100%;" /></div>

<h4 id="2-如何设计一个秒杀系统"><a href="#2-如何设计一个秒杀系统" class="headerlink" title="2. 如何设计一个秒杀系统"></a>2. 如何设计一个秒杀系统</h4><p>参考链接：<a href="https://mp.weixin.qq.com/s/kWqgzMw4qKek7QUfkDSwNg">点击跳转</a></p>
<p>秒杀系统的设计是高级职位面试中非常高频的一道题目，它可以较好地考察候选人的知识体系情况。对于我们来说，学习秒杀系统的设计，能够让我们学以致用，设计系统的时候考虑得更加全面</p>
<p>活动一般出现在电商的促销活动中，一般是指定了很少数量的商品，以极低的价格，让大量的用户参与，从而造成大量用户在极短的时间内参与活动，进而造成系统在极短的时间内有极高的流量。系统设计的目的是使系统能够稳定地支撑活动的进行，因此其稳定性、高可用是我们考虑的第一位</p>
<p>要知道如何进行秒杀系统的优化，那我们需要先对请求的整个流程有个全局的认识。<strong>一般来说，秒杀活动请求以公网为划分点，可以分为：前端部分、后端部分。</strong> 前端部分指的是从用户端到进入后端服务前的部分，包括了移动端的处理、DNS 解析、公网的数据传递等</p>
<p>后端部分指的是经公网进入了后端的服务器网络里，包括了前置的负载均衡（Nginx 等）、应用服务器、数据库层等。秒杀活动的整个流程可以用下图来表示</p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7qzrdanrnj30r90bpn04.jpg" alt="image.png" style="zoom:80%;" /></div>

<p>我们要去设计一个秒杀系统，那自然也是从这两大部分来进行优化。整体思路是尽量将流量挡在前面，让尽量少的流量留到后端部分。因为越往后端，我们的处理逻辑就越重，其处理能力也越弱</p>
<h5 id="2-1-前端优化"><a href="#2-1-前端优化" class="headerlink" title="2.1 前端优化"></a>2.1 前端优化</h5><p>对于前端部分来说，常见的优化手段有：页面静态化 + CDN、请求频率限制</p>
<h6 id="2-1-1-页面静态化-CDN"><a href="#2-1-1-页面静态化-CDN" class="headerlink" title="2.1.1 页面静态化 + CDN"></a>2.1.1 页面静态化 + CDN</h6><p>一般来说，活动页面是流量最大的地方。活动页面上绝大部分内容都是固定的，比如：商品描述、图片等。这时候没有必要每次都去请求服务端，而是将这些静态的内容放到 CDN 上</p>
<p>每次打开页面的时候，直接去请求 CDN 服务器，能极大地减少后端的请求流量。加入了 CDN 之后，其请求过程如下：</p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7qzu0en0vj30k105ldh2.jpg" alt="image.png" style="zoom:100%;" /></div>

<p>所谓的 CDN 就是内容分发网络，它由非常多台分布在世界各地的缓存服务器组成。每次用户请求特定域名的时候，会转发到对应 CDN 的 DNS 解析服务器，随后会返回一台离用户地理位置最近的一台 CDN 服务器</p>
<p>随后，用户直接请求这台 CDN 服务器获取数据，从而极大地减少了长途网络传输的时间，并且也减少了后端服务器的压力</p>
<p><strong>因此，对于秒杀活动设计来说，我们可以将所有可以静态化的内容全部静态化，然后将其配置在 CDN 服务器上。这样既提高了用户打开页面的时间，又减少了后端服务器的压力</strong></p>
<h6 id="2-1-2-请求频率限制"><a href="#2-1-2-请求频率限制" class="headerlink" title="2.1.2 请求频率限制"></a>2.1.2 请求频率限制</h6><p>请求频率限制，指的是根据业务的特点，在前端做一些流量拦截，减少后端服务器的压力。常见的拦截方式有：</p>
<ol>
<li>设定一个请求概率，只允许 30% 的概率向后端发送接口请求。</li>
<li>设定一个请求频率，例如 10 秒钟只能请求 1 次，随后按钮置灰</li>
</ol>
<p>通过这种方式，我们可以减少很大一部分流量。但在具体实现的时候，可能需要考虑安全问题，预防某些用户直接调用后台接口，绕过前端的频率检查</p>
<p>常见的方法是在频率检查时生成一个参数，随后请求后端服务时携带上该参数。没有该参数的请求，都视为非法请求，直接拒绝该请求</p>
<h5 id="2-2-后端优化"><a href="#2-2-后端优化" class="headerlink" title="2.2 后端优化"></a>2.2 后端优化</h5><p>无论我们做多大的努力，始终还是会有不少流量会来到后端服务器这里。一般来说，后端的优化有如下几种方式：</p>
<ol>
<li>增加缓存层 + 预热数据</li>
<li>MQ 异步处理</li>
<li>限流、熔断、兜底</li>
<li>业务侧优化</li>
</ol>
<h6 id="2-2-1-增加缓存层-预热数据"><a href="#2-2-1-增加缓存层-预热数据" class="headerlink" title="2.2.1 增加缓存层 + 预热数据"></a>2.2.1 增加缓存层 + 预热数据</h6><p>如果我们所有数据都去读取数据库，数据库可能无法承受较大的流量，此时一个常见的优化就是增加缓存层</p>
<p>当我们需要查询数据库之前，我们先去查询缓存，这样可以减少绝大部分的数据库请求，减轻数据库压力。如果在缓存中找不到数据，我们再去请求数据库，随后再将数据缓存到缓存中</p>
<p>在引入缓存层的时候，我们需要考虑缓存击穿、缓存穿透的可能性，在写相关代码的时候就要做好这些优化。另外，我们在秒杀活动开始之前，可以手动将热点数据加载到缓存中，从而避免秒杀时去请求数据库</p>
<h6 id="2-2-2-MQ-异步处理"><a href="#2-2-2-MQ-异步处理" class="headerlink" title="2.2.2 MQ 异步处理"></a>2.2.2 MQ 异步处理</h6><p>我们知道秒杀活动一般涉及抢购、下单、支付、发货等阶段，而抢购与后续的几个阶段是可以异步执行的。为了避免对下单、支付、发货等阶段产生影响，我们可以将抢购阶段与后续阶段用 MQ 进行解耦处理。当用户抢购成功后，往消息队列中丢入一台消息，随后再由订单系统消费进行下单处理</p>
<p>通过各系统之间的解耦处理，我们可以将原本同步的处理方式变为异步处理，从而大大的减少了请求的处理时间，提高了系统的并发处理能力。其次，也能避免系统之间相互影响，提高了整体系统的稳定性</p>
<h6 id="2-2-3-限流、熔断、兜底"><a href="#2-2-3-限流、熔断、兜底" class="headerlink" title="2.2.3 限流、熔断、兜底"></a>2.2.3 限流、熔断、兜底</h6><p>我们可以在每个业务系统做限流操作，从而避免因为请求太多，导致整个系统都无法工作。当并发请求在正常范围内时，我们正常处理请求。当超过设置的限流阈值时，我们则直接拒绝该请求，提示用户抢购失败</p>
<p>如果没有限流操作，那么系统直接崩溃了，一个请求都处理不了。而通过限流这种方式，系统至少还可以保持正常工作，而不至于一个请求都处理不了。而超量的需求，本来就处理不了，因此提示失败也是情理之中</p>
<p>除了限流之外，不同的系统还可以采用熔断、降级的服务治理措施</p>
<p>熔断指的是请求的错误次数超过阈值时，不再到用后端服务，直接返回失败。同时每隔一定时间放几个请求去重试后端服务，看看是否正常。如果正常则关闭熔断状态，如果失败则继续快速失败。<strong>熔断的目的是避免因下游短暂的异常，导致上游不断重试，最终造成下游有太多请求，最终压垮下游系统</strong></p>
<p>降级指的是当服务失败或异常后，返回指定的默认信息。<strong>降级的目的是保证有基本的信息，当下游异常时，与其返回空信息，不如返回一个有业务含义的默认信息，可以提高用户体验</strong></p>
<h6 id="2-2-4-业务侧优化"><a href="#2-2-4-业务侧优化" class="headerlink" title="2.2.4 业务侧优化"></a>2.2.4 业务侧优化</h6><p>一般来说，经过上述的整体优化之后，系统已经能够比较稳当地应对秒杀活动了。如果此时还是流量比较大，那么或许应该从业务侧去进行优化了</p>
<p>例如 12306 刚开始的时候，购买时间都在同一时刻，这导致同一时刻并发量太大，系统经常支撑不住。后来 12306 将购票周期放长，可以提前 20 天购买火车票。通过业务侧的优化，我们将本来在 1 个小时的抢购分摊到了 20 天，服务器压力一下子降低了 480 倍</p>
<p><strong>因此从业务侧进行优化，是一个四两拨千斤的办法，可以极大地降低技术侧实现的难度</strong></p>
<h5 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h5><p>设计一个秒杀系统，整体而言可以从前端与后端进行优化。</p>
<p><strong>对于前端优化而言，可以从「页面静态化 + CDN」、请求频率限制进行优化</strong></p>
<p>其中「页面静态化 + CDN」指的是将不变的静态数据固定下来，然后放入 CDN 服务器，从而降低用户请求的响应速度，降低服务器的并发压力。请求频率限制，则是通过抢购概率与抢购频率限制，降低后端服务器的服务压力。</p>
<p><strong>对于后端优化而言，一般有「增加缓存层 + 预热数据」、「MQ 异步处理」、「限流、熔断、降级」、业务侧优化这 4 种优化方式</strong></p>
<p>其中「增加缓存层 + 预热数据」指的是将热点数据存入缓存，并在活动开始前提前加载到缓存中，降低数据库层的读取压力。「MQ 异步处理」指的是对于非必要的业务逻辑，通过 MQ 进行异步处理，降低请求处理延时，同时提高业务系统整体稳定性</p>
<p>「限流、熔断、降级」是对于整体微服务的保护，其中限流指的是对请求进行限制，当超过限流阈值时，直接拒绝请求，保护系统本身；熔断指的是保护下游系统，当请求下游系统连续错误超过阈值时，自动不去请求下游系统，避免因重试流量过大击垮下游系统。</p>
<p>降级指的是当请求失败时，自动返回默认数据，提高用户体验。业务侧优化，则是指从业务层面去进行逻辑优化，从而降低技术复杂度，使得业务与技术复杂度达到一个平衡的状态，有利于更好地实现秒杀系统的高可用与高并发。</p>
<p>上面说到的 6 个优化思路，是设计秒杀系统常见的优化思路。<strong>但在实际业务场景中，除了要保障正常的功能设计之外，还还考虑防刷、安全、黑产等问题</strong>，此时可能需要多考虑一些其他优化，例如：黄牛利用抢购工具抢购，导致正常用户无法抢到商品等</p>
<p>这时候可能需要考虑增加验证码，用 App 设备指纹等风控措施。<strong>此外，对于秒杀系统而言，做好业务指标和系统指标的埋点监控也是非常重要的</strong></p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7r06ob49vj30u00e145t.jpg" alt="image.png" style="zoom:100%;" /></div>



<hr>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>系统设计与架构</tag>
      </tags>
  </entry>
  <entry>
    <title>行为面试</title>
    <url>/2022/11/03/%E8%A1%8C%E4%B8%BA%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容">
  <script id="hbeData" type="hbeData" data-hmacdigest="42e2a17eaecf65140e042e1ac48b88c89615c9c4f8d7f5660bc992611a1f5e71">a17b4de793b95f7877066d2186f5861555e2d6b9cb5641947e36c8450a906224c08d548d079000bc6f30a7dca4e9b9768784f58ce2cede9cd16046bcdfa4170c5df29963de96439a4700b20fe1c6bd48e1c637e68b3d692bb82396ba2b8e61a27aeb472a4ece7462bedaa47e0166e0749e21353f25f72bf82a9824b593f85628e4d20442ce60027c8bce89475539974b9c51020911c708a58113bb3a15251aa99075cebef5c35d8c4e3140efef9653fdeb2b8b9940aac91bfcc34bdf9d2142ff4ba3ab30b8c39b93406b2dbfae1afde648f8c76fdbe0d1bf0434f159a6b67796677b2a974beb547068d42db91f3517c235c495ebde14cbd0b344a3ea2db3c5b89cbd0c674d9d5c5d5fcaee92631baf12f32b27bf304d0b48263ff8a9e834c865b9c62c11f7ba2da491085aae91580f6dc3014a7fa6dcc4734b64aa11bbd8bb17195111187d1c2838ef859ee9bc592dd4a43f6a8f7810ee58813800c7a778be697973eb2738e502606e268e1bf802189e37fb7b52747c3c855e038a5b1f585fb1feda1069ba4ec17f16f8220428557b22aa3c173e3f6f324780a126d52a979bb3f7af4b0e0f4a72dc552084933d8e998812a1e2adc03ca950a7ccdb98a2c14808ee8315183d64388e3c5610177a4c9a1418a6ef8f212661bfac2b47207efea91946ac54db34711a558fba0016fc3a9749b6a0a774017361ab2e86de8a1be9ac506c1511253dc04575030f580b6e5ecc6cfb3c8acc4cbaea1a460866bbbd49f6fea485c661039e1b7177614723d6ece30e879443697f978094ce3dec78b9695d5b3900dd788ae99e67c43a0313db681515c2c4dab59ef26f51c5c356e4f10dab2107b0d76ca4dfdfc7d9d6e34da2c39bdc85546d986a40cf2c3561b67cae12213c0cd10f534372cb21d7507698b1218bfef2038deff4bebb0c4e4f7c52a9d28456dcef03deeed897284ae2c85db347ab020b5413d8bef65d9619fd92779312c3484abe17dddb38123500bc60167f03cc574dd527efd4da7d21d15d52c67348b4daf02d73bb64f6e5f0f3d85aa1f2d0befe326997e9178d6744728c0bb7c7a32ea426475f7e6f45db6295590cde805104381183f4de3418ae9498be1adaadea7ba41dd26a49329a7775afa10503c1e6ad8d0063fe99fee7420376d7c61190bb9feaf12622739e91d58f9003f3e68a74364b9af39e47098eedd5f6109e233fc16816be076a2270936a7cd1ebd8a4ddd648eb2bd6344f06b70be07eb2482810a116069fe99ec990d25d23def51c2a186594c92ef1ef89d5ef36df9dba280cb2f95d18bcb12ec82b85a77305c4ba147354cd43b4bca7774badfac8efbc39a38c9cae2c983cf035992f495eb78b8400ae6399b0465be0f0bcd681dafe8dcd0f24d01d31ed68645cbbc55684dede03871ee54d628148d4eecdd2eb174cb236289b252c20dc48343776c238a441cc7639e4b313d29caf8e1779fc51a23506e8764989ffa5fa0644e92d5ff6e65c2329d79c50183d490f486093a020311907134b96630d86ae0476a9a38db3df01a4f02d10b98e043a728203c0537ed3972962593f40b326fd761a49211a7afef079e965fab6d07f592624d73353e9b390ce80c82d9aab91474e19f33642ad27f08968634006660a2e2944feae99e000b571df2a7bc4df0b8236506fb0dc41cfb8f3d5759880b3e7ec10b6693d4aca0b901c8d1b239bb2311941b89c68b341ef8918ab4de42c5bcbf63651a30a43305004ed7d4a7c9330c393c2ff483cfc881baa8e604510f3b57ec9edc9bcaa1b765ce5f9755de0a83d0212bdbc1340be783d95930df69c21386d834ad332252e8b56864358840fa57b1cba6543409b3eca46d10490fd53c998157ac69b46de1615f8aae440e3739969cd74b5c455fc923c12b652f907f8ab8c702cb7cb54ca67d204406e37a83e490349f619cd16715ee40d826c5f12618578774a07447a1a9e794f7a2f634bb4e4f396b4803729e7f717e0672d3c587b638d2160b7a53cc40a692b0cb50ea62796302f3a53d8e67336e8ebaff48862b710898b5a6ef8a2c755b662477fa579054c50e4eb8c7472e0a2fc80e2584fdcf028eb108652905dbabef0957469e73542b0aa0b45a6d676179cdf946fb34aed12be4bf33f519b0f289b7e8e4cbafbd04a59ff7a8e8f01d20d289e9ecb923e70888e117e4837a693c6520784cd03e4c130cec41260c8d752e05a825fdfb5941ba6836aa41a39788085a0c69447dbb13c9b24629851ffe1daafb1276dcaa53e7b6603422e5ce47fea9f7476ce63e9f6e440c5ae8b80b7b63f9bcfc4a3f3f4cd5bd6f49c4ac83109989d4956ada2f52838866d738b810b471766726f5ae8e3a43676eba9626be1c77d261b146bdf3fac9fcb1341757cdd8a4c9de2d12b61d973ab0b239c15559c029993f6d0c44973dc199d2b1f03532467aa70fb3b69f3b87df9d742a50818163f9de7e97166b0214e2b19d2c2effa0f77be1b5dfaac07d985d5d6f69d4b6feaf7a2bfcd3f1c31c11bca38c90e5249b5ed7b1396feb0dc9b310d9d65a331bf1bde02c3f9edfd4ae6e85b632fd97f4edce3c8167387701ac88e229c26316075b3e38aecdd80fc23d430a310103412c7c990aba0399a64217802a62eb73ad49111722909f7ea63a6acace31d612b482ff0441028eaf63b718c881c2337d0eeeed266db112db746b54f222da7de2f6306e92a708e9cca01f4434a711ef8069bf008f113a68ea50e58ea7663aa377d96e5760e9a457ef93f006442b3902f1464e27e4271e1cba8071b5e4d8de1203034db12556ba2aa958782c83446deeb326c5cc0287659539ba6c9a03b76d4eaef3611fc7cf15c780a4126fc15f3f0416783c5c5c94962032ae3f3c39a473d9704ecb977e8f83dc3d778d8b50f4f1899402b7de0930e20d043ab9c565e095b6be2c11bccea0b72ca16d79652c75eae60c1ba4c87547cd0d87196d88c75bf009dd92ade64ef8ca67bc85d9505565e1d19fdb6fa5168da45eb1e65e8763fbcf3f40de25459f48ef6bb87e4f1822e3a8382824ffe8f97814b8040e07127284d186c44c5d1d41a453695690a54436b4c6b6c81127fd62095fab9ff78b249ea93385435c6ea7e5762a13174af6477d0247e774d477f46cb2e576e04867b50e6377562fd9f87a8f2e4540df42d76d386ae849fa55365bf62bff47611365f8f715306d45ff420b323211a29b9e48f318b34da5666821521314e19bc82773b59f18ba634f3d3ddf6d567d6501d03ad66244b477e65db5367df6bf00946106c71a92c161d4ed12206871d5c653e1ee4bb6dbcaba1c43a91a06c1c73ab391dd661d238215ccd26d0c85ee5695b57e2141414a0a76fbaef726a6661277d134e6b00bc7b7172d5dda05c18f62f3f8028f2bbb1ea6cc8693571d00c63bcfc494415564e297928ec0131d3d6f9ee1490756b5d257b81fa2db6c39a8037ebd3943ad427afdc007103f9db22f4bcb8d4728da01e9a26a3f5094e8b3a2ea41224bcd612e1dba719805faa7af6876459863055aacee5a4bb5144691b0d803e6eebbc324cf67d10fa999b3a924125f8d9bc7e1fc5ea0d276b713a727c0c39b5a3ac5fd87082ec9ca490f121614a3d73235051296f963c4227d2ebe02bd341e8296bb07e767fa6487114fffb71cd5c71b1aa4e0ecc8352588d77235da820753b491d497df868b4be96bfd8ec754e1fee236123d626a203a8b93dfcf8707627fe9ec7619eb5ab381d4fe6c500ffd30116729bd5c1700c3c785101ec82b249d9c1848a60e0f2175301427196acb423a6d905ef7bee530d96140a7b5af7a3c8c33ab05f27d6043382bb568ae88086a6a84ee4b897ac56ee8e98717337e2c35b94ab2d5f87cf0b2e8cc58b25180a18f7721ff72bbf8dc1298f8385047b384d76b0795665ae51d2f89a6ea53ffd8df0a57e2e6fbbd153250b2af327675b3eec336a647090e63408448ef3dc82c2931b8ac5e1a92a23561487e2afa1ad7f6a62327472ebbbb6d1ed48b2cba0282f4a149bdf67cb695c36c61cb00f9f4850bb3523296394f6c339058712d990f482dd41e3be97422d07dc601607aa245f52eed255520035b5eb75664955ffa1e3072e74253b9182651d9195d6df6d14dab6d06b73f548bac74b995c7ac156c428535fd1b1bdfa8d992dc3ec609e586b5c2b52ecb72f5292a39d8cbfae809c5209faabaef9e17d9447a67f099ea89adcfdd118157fe348ec3cd0de5be4018edfb13a021cd730be37f3d09b8a167c58ff14c87eddee5b2e9512ea95814549edcc1248a046c46fbc1e2f6cee63decabbb05c50eca794b4e4b9e88ecaa7c85102406365b2e16de5ed0f21650f1702b6fb46b247fd4231937376e84875d6d7787662700792f141dd5b13e30e9501d33e78f902f89cd20b48427b4287ab3f00a7a4f3bd00e9797f08c208e37d75c17b6507113acbc011be75ce1a129d50319cac9d06827d031f46e0a2563dd774417ea0868b7931eb63377c22f2be8091793296483cf4c74269815b5b4588b3547ef24cf7457fb588cf022237b909aa09e3888202266b36732946061f28c75982c2ed18164e9cc65bf17cf93306f454acb0c3612e5165985b590b137d1066d4f6ab8d3a4ca3c47cf504b3871d28942624faf60a0db770b9bded8f9ad881b4c2b1d8c29172a86ab94e3f6a9c7780eac8582a50e08df420ab39016498be84af8e04005d227e985f74199c5cc532220c41785dd4fa6e5bc96969439de32fe4fa7ed034c447c939e8e35f4cacea118e923fe6ae930fc8a3f9c3d99a13f7b1c3f91911675a4205e1a3a8bf0eeaf6e7b2ae54b5c6f8d972d43b8e41145e48bfdc3a93bde0a6d4c7ba509c8e24c2759135afdfa28f57804be0db7e06e5b6e42c5411eafabad7ff65f421731b50aba11c584b2d4dcc7cff67dfaeb5623f94f2899d06987525bddb178f0e48a715d137c162131f29e1b681c95ae0a71dd42ac9b3c09f7dd7279a189877ae65d6cbfa7a49f2f1586a3052adc5196960fda8f2759a9d853411eb266771842774d7c5016b7fdacf58a91ec54c71f32f85cfc7549c15bca7ee6f920a542e2d2bd71880d20d6e3f3e7c5f307d7af8565693b7b696695327421db5c768c96712f976732cd17707efa6069ce61e280a9582908c83d05de75882c85761301023c274531502c28cb235c795de027ba91ff763749b8e65a8a3e37f53a1af158157f14a4a785ce00ab6568a8ffdd363b5b592c11c3f128a543c78ef3793b49a5922864d66b9acbeabf4babcc927671a26c143d9e3fa771dcbc1d12a69918ad3b68d1cdd800ec410b6432cdffa9fcd07662a8f5f31a47d524030cb82a927d031ecd877badacc4cb0a97a1535d956eb10d2e35a6ddf0234891f78ae68eeda897fe40047f20347e9102496d1975b94f3b8dfac344ce7ac82b5fdaf0f3941dd1838d53f9cb4fbc0453c19360fb38e73101cbb480218d0f01e9315a8b0fcf93365b142414a6ff5e7a2fb6bcfaa9671de5898d7bce726c3bdce851063f3b1749cb83f3aef50e8be52251f53053805b822f21b7a8ff645d7d8daddd16c092cc2b7024bf8190ae36e59b2de536757f5b23f1453ce06de0c3bfdedc308e07d750c723cb76542cf96d08dec7adb79d3a82783ce2ca7421a33ccecb85d622329882247c1fa8ef1278959e2680a7172438f081a242893a2f8f5ad302de9f2c4d39e029eb51b269364153ddbe7c59bc888ac119dd096a6fcd4cb2479ee3ef28b5517fc1a25817b66f3d7a86a44c21d1a2c6505c74b0fae891671035e10f46762590d7729774c71ee6612f3eeee5eb749ff206a4117d8199024a5105d231ae529532dcf2e14a90311971e71a4284b42cc9af3d4f5a5dd4e50ed56f1aaef1dd7b39a8cf8380ecb448f1ce1a0940a11f4c340b2be7346f3dc1d5cc2d201918587e37405225783f91828f51b4aa4c64e81c0ba686ad898c6c6b113f434f617f0b62f5a0cad75acc2bbea07a4a6b961f8e897335036f00d56ddcbdad5d0170412925041fb69b5220065a4068a90aba37a502d2acdb9a8a957413989bbe84cdde4f5f1b02af83784c0764eb0cfc8799a28e3d04df59a41ce69a168fcf311d5fca2fadc443ba33200d6431f42ce1f17f074e29fc0ab3c39d59507293d0262ad3714708b89514aa04ecaa634135268aede11e20b79c418bba0f3e92869d935141b0e7890b150e5f7184af9872244bfef9c6c6b86292342ecd70d8b5eeb3819b97980a401eb17519fd616e130ea67e925b1f41325726276971638c59837be30b16413961520d587a72fd4cad4bb4bf7e1fb17b505bf24b2ba8fced6f1c9ff03b345d5d93dce58cbbdce47018d209c1753d89aaf58216fad499998072177022f99eb772533cff9831f38609a1d535269138365168a4ab761493dec3e3eccc09213a02bbfd420ba5e44f675ff73c1825b226736d1c921fcd32492da731446dbf6221bdd2f03a419da90bc186baa0f33e37dda0615d28ee448a077a2400074c81bafa26068ab77e68047f9c4dd96f4a78834fccb1b469121c131da075d8490e0fa9c05b81370459fe48dbb1a5f1aedfcd15cb9f8136f6b986aab6f9f17cbf0fee20b862a2dfa9ab6a2a6273320481a23dd800fd119397bc8d5eb26ad83ad2df1ea7c4dacf661076939151d915a563812aa507b6bd7686526b354806bb42ec77b97ab0dc287d8c0aeeb4e25c09420d3d006b632c8b86c407dc8a391983c175d6440a49a1ab2607aee1521b055a3eb9b6d7346a3b4b7601fb11c3b15eb447cff56e55ded8363ce6bd6ed30eb9e4aeff63ee0c031e00095e80e5a98330f296e4b76837dfcbf8a902f3e9f2ccde49e66286ffd5ad4daeffec9e219f13603f9140d7990cf548cb3e4c60ee137db59c2984cf86c4e716c310bb095161a026103e1d88ff9ca2dc28bf2f330b2e32bb8d0865e4cbda9ee16e9cd712bbb767e0d4bb90bd5a11a5a3817a990b1d4f95855f1ad5bd5533764d568ac09f7417242f384b14d4312212249fa6a885346a8d68b1dc09b98aa942fe8fce4df37fc183c0c8af41278f216d0e8ca356a60a7021233f6fcf67d07d42d1d81313c6dade7f8e38b368a4c86a97a2e290d699c7d9086b495835035a01ae7c98dca00fdb794dd1d7b3473d047d4deceaf1edc9e733692a1a069ff2fd3dcc82bfab9b1a6158dc97e7922b4acbb6416eefbb3ca1c269ee8bface7f94b2d86f1da03f5a176b629e199ccdcd2e29b46277928f6bf554137e5ed0198d3dcbae80b02a28d097a7ab4a7890f59bb30573d121fec586185fc844f31d2bf4d7cb7e60be2f2a6f4a4edd996202b5f469d49775d9d896d8bead5ded7a2fe4bc38f179082032d7af8115263e705761a443aebaac3b50f9131e4d8640574ea3ae5733544ffb5e21fcd8cb0bd0b44a4c3847c58e96c941d6390dc1afcc1b51b769654420c1daa3a2a2f7839127e46fd6ae558583187302b470f034621a80ddaf91f9367a78f1c77e7323d3a1135d8f3bc4582a1e9aae53306a57317c6164e57f384f91e637659e2a37910981140e48cb4bc1599f6a5f623ec6adbb6bfe63e7558a1c65574cdde0021a5c8730b3c0887fb2a6a598082e46262f063ed6953e0aa3a113eb446d7b79c5c26f25a87fbbd3ddaa909fe2c704b9513ecf8b12e99d4a4cb155bbfbdaa53189d95d2d460a6074eadd8b06e70b223a4ae00fd19c7a95b42fbe78c82aa6fbf8fde3089d6b1586a7a8ea5b3a69acf5af4e40fa3a24cc768f9856ac1a274786d3ca3375e4372d8bace195512b10c7cd3539b9ee2ac8f49ceb9cfd63d9d9f47583fbfb9fe89ca82d8e73fe2ee2e8d257468c278227fa6866748306463c2de14c062472d226665f54468d04f7e0b0a7f939ef93b5129d79beacb78b836bdbbcf1830634f2b6ea4ddf1cae8f41352c117f05b5102d8912d0a4fa31b00c835a0b12153eb5aed45fd7e5d9b033346ad5ef113a2ee81c7dc4fb1eae83fbfe0694fce9bc320c373614cede26b4ff0669925586e3aafc06bebecdb10a1c0c7b974e61fe2f16f6bf58dcbf8f936e202029ab74a2fdfad4f703de27a96cb42c17eb9919719b2e8394e412500a1a8f0037994b4e704ea76bd9e44157411e68b1282c4bb3c6a5d425a0233c5b0bd885a9d13e7d0395aacb8acac150cfa5ba0c0a0aab0218c48f23b4fa1483718cc77819c3d370f12508d265ad4397e6d54e836b1a7b1e6af5636aab4d2b87a79d2fcfa9d222ceb7f517dfba03142ecc40bc30d5d448059313952a81d54b88f96c734255f23d1516ff59061ab9f7d6fe6ae49c380d8df6218f17dd3a772c755976008471cbd1bed3a545529e2c007874d24f63765852fa14eea2c9569779f68fcea22c330c30aa1939fbc07ae3a7b665e01262f61136beb1551ab50d90d3aef2a2e384b20ad423e827f63f93dc7edd61c1a42ddba788ed31d4c36b932061f50187657f16429107af501873f763ae1b8a89387e04e744a6108f042386b02761a6bdb227386485ee30763b80870d922959fd29ea0494c8078fe500128c34ccf41ff1122d62ea7ce7b2c213db831a94ce201e3db8076d57f61090e08e7a2bc0074ae823ed09f1a95fc726dd5aa24942e923fe0bf23dd2479e70c0dc174c95701fbff6aa2ca1ff8ae8a0976072af63187a43b8985c9e198f0f91a1e48a9537b92f5941f20d782fa3375ffd978ccab54c3098861e4970394197f7f49ad3dd0fb0a3e82407fa5b3b4cd343bd64849f7927e989fc277f74ed45279d287f9e171bc2b3f5417dd62bdd14d0472ba0787e19d005024cfa4023228bc43e458b2b929e88bbeffd7041e27b322e9d986aa979f4eeb433d18b2649bbc30c59eeb97ce06a79ffbd14c15f262e590b6ee54ba5248553924570845819b6124e08479a79355d05d43a7e48002bb490473f38e5d64f12e2638802616eccb44374b46401d898c0e77473b791547f4ca4e5980d075e28cd06be5459160c0004986f55ec3ea5316dd8a103c4a54312b0c8aa2eb84e6e96bacc66fd49defce1eab2acef84e2933354814d29567db8ebb87d39ffda56dea1f0a3f220548da5400ab5314b3515d0e993c9ce19457fd86fe08aa14633ce19ec471ae5f6b8a33ede3eddee2c4a2beb4861854cbf9dfd5c5fd4a5d92258b85e83c97c9f05fc61f54b121f9721ad0bd66cfbfe6114795ad287207133f9f20b43aca207c569ec5b7ac22cc45811a624870cd49301c4dcac60b9ecb6f930ae72155b7725ed390648a64418ccd895f3e2264844e097a55a0f0adc3e049772ab515dc0b95caf940888b07dba2f923e6434d27e80801bb5db561ab77308e8215b9574d01387549ab422d3d0c0a8260fcb0a95b1dec3856dfa20c891bb3fdbb20ee59e2c7de983acf58ad29fe59b2df636fa870f90c15a388f60f863c9ebfbe00bc6732d0609778d7e9688c49f7fe3a6a6dafd0e98dacc8d336940209e1e017bb1545419368166bded2a937f14eaa4b6eb5ef886e00d67f6993356219dc8f3016a51a187cb696ab156e28616a7f90f28a7db9c2317584f3bf166004a31ba002b03c6d3364f558d44fbe29189dcd4a60e840e38dd0b514b6553c098dafdf8eb3a7931b4a3192206b615b5fdbc956b6f3ec50f40dab03ff99a3c78107d79a566bb4887d7edcb788e27d42b312dc229e92f779cc6885cbdfd1768192bec48b9b013dc29cd604de8f800d4030d002fbc83855c8a37f4a6a754ee749e9e2b6fe549de542d2e084d7fe6e8b48605047be1d94973bdb001894043a975df7fbd2c6fbe93928a5689472cdf2c5aa9f9f25ca280da5ba2ce3921966c97902e486a56283273f5d49bc3987930b3ab395a3978d0074447fd7bceee850a0b314778ad8ce881165f1f140865f3c1c65b67a2537f06308c13548ad6c860c9caf51cdd7f06fc202bd568262360ecfe6c0ce7ba76764aac305fe532589b43c1c88f36a57b420edc9657e9f82443291833b10794a2e54990b7b1ff646545443819192dc9123aca942e1c7f52d2e6b39a4163b37fa9594e250f40825c64e07c5bcdc6e1597ae7df57cd0db94859568b2b9de1c6b8866203384e7fbf47fcf37b27a000f88e847d38abdd5a5ee5b50976cf8f1659cedf74843d050ec9590e6c329a0d146bf8e6a90b3478a0696a030e1aede9ed14e435e6146db7fcc9023f889caf469e177c93d8d3cd482fcb24c1111d906f98eb54952b41609555402d8a8849bf3a3848ad16b446b36b73136352ba0ad499fa4e692e19c4fc3679dd3cb59d5251781f7c3069f479b3c3afebb4e3322638af5eb8f7fb654b6de863cead382c36f85bcb8e5b5f91bc18c9b815eb0fa12a6fa24626cf40cf4c2415ecbac076bd4022c42cf846ac0b612735518869ac6fda1dfdc60c878323c55bf83ec7ead279dd89f81286958b91715d4d9b2197f26eee9e5fec7faa1eec58494df11b2170d5f502f60818f6d67ed6132d37132030b9c933101fb965d2fa688046fc49a3a1a7cd74124e6da53b53f8f8afc82d1cb229e38a32e36df65b018a6643162d2a03681046cedd1cb143fd850206c8602fcb0fad74d492c4b8afa7a898f80d19036b230042f9de5b437776e8be14f0f821c920dce6196755e47dd7606c500aed905a40dc3036347cb3baa82c34224a19d2ba70248d8bdd096a03759634c29ffaabb2844a4edc32ccd6bbbc63869786a52c498918fbc5de53b1acbd2697897b3547df67d7d90d53a257dc1cd8fe9bf6bc4c8cb2c5fdbf6d7adc5f9b5c3d53c3d539e5519bdb2aa7218179191fac7ce1d38e61c7b0a22e2fce4abc63f2a163daff6cac9a5bceb86b5173a116b134e297e2d03fd076496367ae81dc7ba8712ba1dd527efea7e88ec9545d2a33101ebb994fc6bbf17552b91df67bd8841ae1966cc73e236311fabe0eebc66b59543f1e11e441b592dfbf8a4f2620e36ddff40e7b544041521f42f1afdfaf8679bae169725622283c2794e0b74e9058ddbcc025e75c0189fd55541688f59f668c2114990565598f77dd0671a8e7c33e3ca5f39b4ec4dc350f2cdfedf1a77e8d547cf53cad469266a113faea8c2ad6a4770b3010054ae52577353074967eb66007c85d275334250d1d66d514f61d5522e5eacd809253ab8cf6794d86bf736b3e5a6f7764933d0e80e068500fe841aff3b2f3062e7cd44924ef0f58ae9a97a60e62e2225c4d33fcbcd581821b505082441c83615b896eb4e8817d9acbd034b346c26b5a041853609140a154a1a21fc6a3617b319c329e052f442b5bfa218ad27c425b6de7f5294c90bd8f1165ce1f65d31931374b2c42a511208ad23c0d2505313fd7e08b165c4ea1429748f642b95db82ce143754621485e642cca35d52fc90255647312157d038b16679a900bebfd312ddd8879bb14a334261588e24ca722ad4a684c5b82b6c1355e9085799b6008e9784824cedfcef47b37cbc28b623c1edd459f3028015cb5c816bf425a2931e9a7e929b066f3c47cea75b94b71afece1fbff9889463cd912cc6655f733e64ae7fbcf0b7598ab10f9dc85792d4b203db566115694f287184118424b8285283245f39c3a410e473509e2f6f02fed2d2d404543dbe05cb9d0f3fa8e871e6f610280837f847a87e13c808020db695a2fb93989c60f773d1d06efe904718830ed74a715533ae3d59183e8f26c60b1936695b09826257e143fc49a233976cb8f9ad6d6a34df5b2b040c9ad3a925e552b1c193343b0a46a3202068008a3bcc18923fd7bf920cebb4d525349552498c43ff94f3fbf96773b6795c17ee32728e9e70be9fc8188b293b6f2654f33dc77f27c0a2cc7f49fb673b2dfa6da214dbb7c48b5409574170ad87268fe247018549fd38fd5fe597c5b6ab41f8c39262f8a7cc82ce4f7151f741eb586cad06ca5d85729e9506c0ebf590b0b0624818c1a2177c2e234d1e5582272930144083412c593553135dfbe536d8b7414c2370de1b19235b0a7b372b24f018b67161a5c4d32bc1e2d9244aa7739ae95ed5d45e062ff8902e007658437657e59f4fafd54ca05469ad5262919505d6928046f759260f1293e46a66508686e52a955a366051bf874ccdc0e1964db063c3667c2f6e05903e3e8f9e271490a8d7839d9d8cfecd4fdc9833de5dadd6f9a8f84193205fa6cf2a814a7205d8d74a53605199b0324d38195a243de7fa13507f46af47c4af7940cfe5cf144e4f2fc5b1379da5524dc91c9c12b3fec2cb3a9bf57cbc2ba4d8d55386ea46ef336148260d41da2fc32a76c5b1ee85c6563181bf208ed8193595c3b4ac6af12c6ebbef425c2228bb507be5e986e1c37819b0777705f1f513cbcdf81fbcd8e36dfda7f7d0dfcda348bf682dfbd79a5ed5ef682abfc89ad27ee24532ca0967bdca95533bfb5547f4eb6ec2bcf51fbe8d54ab6a70485117e9cd0cf5c6369d76f7d6213199194c3cabdecef123b5e4645c09df05c537788862c499d65a48f2a53a8f86e54e50b821e42b614365d4277ad9ff3ee64261987a05e5912434cab9ed16516da49fe9bbc6f68c364c0d2b646f597ae8127a88459bdf6fcb2cf8fda43279bb3620cac57322e870b5652bffbadc58bff2dabac7ac8c6fdb553f68889282c100a45a0350dbe5e7cf4a2515a215497aa76704f36c0183ce86974d5cc13b4ab1ee0da69c8922d7de48d43b1be71040f6697ee86105016e1b466c957c9eadd4783da60c12ad235d1331f6173647847eee3df986eb968813f53582826c87b31e2bd4e853a1c6a82efebb696e92bfe936b8a27547ed891f0e531ffbddae084849560880b4dbadae05593a7b86b18b2ca98b2948d15a01fa3a25fb68e4027eb25113f08e4ce16a037ca8b7c0c32dd472046caa0b146c43bdd03d7d1b0fa101d4878d0d259056d873c9b5ae2f65cdf4e4c697c53c1f809e81f4328fd464685a120df050617167bb124bbf28baeb6e8919e0780824cb2c728f678854f933db6a64d0041f39e69924392795532036ed6ffa5a549b853ec7c7e63a486714478651482447187bbfdd20e6a822d3b5b01369f1f0d9baf8a235190c1cc2a097cf51269786ae44c208e005582849f5cd0ad24e6c99eb0bbe6a717a6b2a75013ede187fc48abcae53ca5f7b1dd9a74e48d2d45f22e59c069632132585495e30b49a0b6b2ea86d926ebad004621b6991a6af873fc022c2ad1611401a55d60536b74ef71aece324a39afae50552caa5120c7e3d0654b4c575fd5e5b658afee925718a2459660b3b50fc788b5efa4f5e0efd04bb3ac8a0bc10ba288a86f467a2519e61e217e707941d7f8b881df8ee2bbe11c3deb7630151295efccc195f2104dbba30170d871da9a256a1c98fae192285d38a7e586f218a4d31a23356f57ce511daebb37b10c97b71473eeac305f63bac7d0958f6932af81bad186e789125cca0c7783a24393b50229a7efa95021d9fe6cc2b1b3efba5f13016a4c95853c4f9ebaeec6ad62f3f0a2422583903726e9e5854e960b87cc34e148b6123c19f926fce670c8b2c089a1656d72def7487d56590eecb661a5878e9cd50a51abe98233455f625b44c1343ebcdbb4790b639a9623229d918d174f9b4eba9a33f7e1c91d60643a9b8a8d449433374f3c7c2d61b4c5da0d931549aaaf3275376cd96117218ed7ae448bde53e590dbb1a5a21042f374db591bb03f0bceef8a6e3dd4f22f1c953784b97342588b6468faa04ca2a6a8e83ca2bb4c051942cb8dfd59df7cc5333efb98e70da946a2581736d1203de9c1556e911642077034e8db989140efd3c11025b45e58ac607810178a353aa59ff4965483ae372497cf29c37adf84977e486de08fa309dac701f758550b37bdf0de63233cff85b789e5fdfa351e69c443b89b889b37537f61529e6f60659edb738295182eb546655a926ba7b4bcb7edecf67ccd3871e25292f351ae8a5a71826334ee9619ca8857a86301b9e83f46a469e345db13fb8f5f44047a6b35ca49256b771be453e8427effde48e991a8f2850ab2dda0eb944d79bc0677db8cc17293adf9cd630402f2264cf16a941622a2dddb43dfd3ea1ab4de6d5acbed1c59a3f56fda2a1b308fa563ff2ba826ec3235d5384e74b494359ac5114b099cb94b3f182b4d5a71116198a05b0650fc8d1c34b461952af903e503ec00a338cdf62fa0a0720600e7aae9d8a2664f4dfaecc084d5267135d3cf054a29b5505317665ab1c802eb0803d3686232213825f17bb10fe3d4fd2c85f352a229ba8cf954b0a042bbc73890c2ee5949f318a1def2d67ef4fce041b300ff18a8226372c5cd755ac7ea6feb74a55aad0045f275151d6a8d76d79e9e2f42e6d2565f1c01281e0a4983d7a3947abc94b13049b96a19c3aa6b17c5db2f83abe44ca320ba145849a9a316a0e6ffc3184f2027e6d4d450ebb847a3691280a52723c2d31a577873bcd6727c4eded48f1de8b6176e35016158a433ff9cad2328e8f22230dc5f0ade58ccbd4151f895c0892f7d4af96c669b02e5cc5ac847694b32bce048b0d8d24b37ddeef42a329f763af447019b6e81fda45a73aba28cacfac93c155ea05a6f9110335bd330e504395bf4d7521802235c819b38d5996e269c995400b3a50811009db9efa23878cc50a1910b20cd673cbb69b461ea0a31820bfd64b5e139c1674fac4167f0a8bc1cb8d395fac4e6d6652741935369602ba58a8608cef98205f460c9da05c048ac79f8fc541c2639cd7be395ce88c9f4710eaaea4fe08247561991c5bdeff22da406d9a95d4a4ee24a14cbd7d2b22ba389d5a1db495831952aef9884186541eacdd68af570fe0b8e63abf81bcc1b295d930f0f945dceb719b72b3fee91038abcd54e73c7f7ed1338ddc39c638cf591a745a88b210a575f8b332c68de4970e1b6303a47985b12353b8b5c5267480617b35def8f3be23eb761710d176f4c33156798e8fadf556cfa8a4f39696f6699c4707267d4d2b6cbaedd2028e7401b4c45c9379a5ab98a99e785ec9b20eb636bd475b3ca5165872f3d513ebd314e21c104f8d4585a8d4808e9d08d2afc9c6ee06a07114598e43ca8b713c5e3a5d7bad6ee5ab430c260f5e22c9b2ba52df82f78e13383129529c18c489820e153def87f2cd526b5869226e8fef62cd9ad5d54303bc8287cba6c712cce0befb9b19086b0f59cdf184db33b9c466424c919c1f894ee6778afaf7ca5834fa3920c1b263a420d5d267714ca1ed130c1ac90a00cff8c71d418806c04c226cd34d27b45fd28b39213240263508f0e896a7d5da6cd9fb60be517b6e2f6698dabc1b311e3b72990438c54612be9c6742aaae7836e2e8975ffa4f080959af07d870701d7c64fa72713ce8775b2dff5e2bacf89151b54255c7db503bdd83ca81ded846c765629c153ce863b610f566c062819ec69a72700d0729a21397a516151a3b15f8e194f09df41eee652f86b3827c148b1f019fa0912011590023079d94d8c649aac6dfc7731d7905cd536df5b736f029b70910a0610a1365fec1bb8f153a834f29800642e44fb354244c2b531eaf6a4259e404dbe0be3cb16cdacf930c44d9194686869c4e0712846df5a4f5c38910f639f234abba326ab8f7edaca83c82d23cd53f4f27b90521d79b610502c10b74e25f7f5510b2550291acc899a5c14b2dc1997d3ebb5cc2976995fdc31329c31507e3cb464a12e6819b6df1bcf8aa581e23f790621451e7568ff5caafb1d2bebed2a74e7a537c5d412989790fc5d2b50af461b0c212b2ee23c2e9c1cf559703e8f72a88eb2d728d81083c44ddf1275d2beb7dcb2963961411c3803816de48d7fb82797937427efe7c52b80fd08e9d25087b3cd51681cea0ba51963e7e3d74dff08d952e7b68ddd5911056e7b90c540a839c75d21231bd6db6c51d417ce2b9cea771b09484375a879c3cd8e1e0333372be9f6d24d7b595336e458f9cb7f49eb5c2eba23304f8eb5a93e2b9bf3fe79719bef472f2ddc883369ec05d775bb3499575dc9bca593e68ae86b893a8754b8a0f4bc6403b43064322352e28540a0a1cf30701185253126374a3e2c5dd3e8e3804e5cb14e0cdbf56d3187b42279d6f26e930e49990316123e009dd73aeef2abda124674a8fbdad514db01cb5c6869ef94db1082909dae1a3d49868cb8c7b65150eb5d2ba7f1c4c2649cd67863661499876863b4e1a6ad8efadced169eeb8718b176520ea490ed221efcb7fa624958ab8433bea203a70d1ddcdf8e07e657e092daf8dc9c9dd3c9f2b242ad22cb929c3a4b3b81843d9805dd837c69aac6d6ea42160f4453c9b9927d7182c0821fd1e32af81895bc9799aaf20d5b003cec46f8fd7ed4d9fa31584293fa4f69cd3ddc333ba55cc5627f8b788ce3acdf0112ffbb01c9a079b258c90c1b557eaf6d61e7d6dc121dedc1c02d5eff82870eaaab1807c9d273840ba3699b2c4b3ab3b885f582952a144ef1c4c29abf1341892845e1eb6fe3989f9887db8d6646e7665b6c07773dc02322335f27e12f8519dbbf79ad7d019c394e0deb26b2bf9d54bce6e3463d7b5d567fd5c6a1bef2a01f941f9cc9f9033ee7bad94317f9a45c5e48f9e202812175a614ab1af70b5d737c6fae06f351194b52f2d4a95227823b89ffb187bcb63f312ddd029abb76746413eb7e41402062f32ebf5cf7bbf0a403fa94efed260c4f8d33c475f0b2732c278f236cf123ee4596420069ec0ac3dce3927625cbbc0271c50ce3bc20d4ddebcc473b41878e78c4c467cb35d98dbf91a0f3ac04ec00c57482c78a9d4abee8a54cdff8eb9de548fc7038492e888fe4d22492da967aa30e3a68324aaf958857ed33eff599ea8248b860888a82b20b0dd10c4a67621ed3c6e2c5768936cf42a08ee517d1b2c877510dbc28e42b0c74e3fcf602da691fa3e8a8254ab7150db529e14cacf5609b2533112c66f205509cb25e01a4398fe63927bcedf0c28f1396a66449d3f368af5ff991bb5d473c21538baf484e6a223324de0c16ac42c9e24827c34622922e5f66c3b4a2012bbddd2c02ab55de7eda0e7f1f26f64de610a4dc83ac1e83e013d096999ded615cdd5a5edc21863a2487d1c6e9f3a4e81cbc84233b87e70111fcd518104a38576c91bb59f6975780249c41f8ec17ed0c3d11df8112dbeca3584bec45c22782e13fe0b0961849f560350335fbc20c9620c3d020834eebeec03b5782a07ddb1d6c6120837bf7361620610952b67032f1c4b667c4f5df993c23987e356ff1230478117efdbf2fe7d5711ee030adc733088134feb48dd8a27191870933568032a0d5b384e73c20e51a4b7e2a42c4b1da0ab9cf7e26103c1ac1cf78adc5b1c3051e0ce32a4f4590cb5d3ba8c518acc3a41eacc3ce3e8a9fa346e836a65ccb51d9bea2b660a11f10df9523b1f7c2d95cabe53633400cfadcf006f769a85485c8cb595b462f5915863a30f6392f7ee4d26a0e295f2ceb092ee44524e3cc32313a979b51cd1a6fb7c636142b30b21ff5692e8740b07bf33a6672fce75f66ad8e66e9970107382d1e6ae32b3712ccfd34cf917be6ec637919d16ce5418976d151ee3cb138a00018fdba33a8ce706fc3a48a9bfdf9a81962060adb4492723793309007397178e122360529735413ea7c0daeb190460c2b19362ad53086735955e7040430d553b3219630414c1390de1c35dd633e351731f9a42e97e39162a3f52e8f01d7cef6c7ab1b7e080c04b08057d01b78ddfc82384d696c60dda6c5bdf9dc5aa57b5b70f38e4de5d122832988debc352359276c04d1d1ec4ddbec71f6940033b3195e14d1483491f9f7406ef2af1cf49e1a5b5b4131d51706a81836c02487d69dd96f45630b87d6fcc647c387ec712018b06498a49f942f382dc7cc0d018ab14723eb0685e20c1d8696e86d76f9f566369f30ad144a2b54efc73817d4f7410b8cb24abd5f5ac06fc40a732397574d58f72f10214990e4eae71399777ce393365b1363daa835b40221707e1c6df68de28cc58c54e5b36082c8078f894d130e29b07b21e4b7cb051aa902ec86b177c3e240b79cb14b465503d5ccd10685e51403438e781545ca06dac6427e24fe2621edb9ff227207e3b3487a941a289edad0ee3324faf4a8cacf6920ba9ea1717f017724726f62890ca1d161f489332c2e5482a81462263f6802a726c55cb9a79628d55f2286cbb44e877d5c2ef6c117eec4a871bde2f89a1b2eddbab145750839cbad110ea37118f5d40486c88adadc7d76faddc10f1ee1ff97a67852dde2ac834b6782bd6288cfb1e995e7a0c73f39df03fb5b26e18af76732552d1eaf4ee9dbceb09acc04fdcafa8429666d4df3040c2404b8f3e8776ea89ce0e3909b813079b46eb064c4e97713cafc4d7dad52f2ff4fc98ce4f3df63d42cae3ede682c61fe588b1d3d0067b3be04ef0e417cd1dad3e345ab0cbc8462ff9d66ec967cfe1d1b3696587ce3b60f434ebe0424283f3d1c023ae3bb44c0d1b1ebadb6c5dac6fa7041fc9741cefce721b5559df2138a158b32b92cbf8ef3bcc8e8ff1a73edc6a4864983c88f12cbe1dbe56622006dd251873c1886055e2abdebc61cbdf580976270e1c9ce7e6e76b6817c9f9fca735804bccef2f1dd7fd83999f1068575afe7e9f24d4c79836ba0a22fdc1b4bbfeb6113c04852022f69e654150ef7753c3b739ec91fd4a4756edb160be10afc7db3fa29b56d37ec340609c882db660f1f023545dfba6ac5020e4aeec3e7e39f432274a0946621b755cd63b71c591bb124298e4d31624765fdbffa5e67eba6767c22701acf5042b36249cc99386928c7b4fcfd4519df51585eadc89315bf5f2e91bc0f1899aa3b98c54d86e2e811d6cde1e1135e9142ca406817379fe5e2005b994a969d79a12d6d9b3ca42953cd9b78173a7921e885789105344464628722ebe4949bb047cef8120b8c5e6a4daf421907f3b6b7cf9642263b7b8a9c79f8eb4d544952ac1c2b365fc4c21201112d5428b301b0267faf3694ee2c2eb79a11b31ec88f9744f71bd152a2f54856303b7eb62606f0f712231deeec58ed65e93746b272192d77ecadaf599364186bbc8d413ecbd56a9e010312e0f139650f452c38d702e8367660444e64437856de62d9c2310dfe5674de161b3672d2a9c934620688f37cfe27d473a75dcf1236670a0553611544dbbe3a13b5f06e02bb4a71b1a010fd0b2bfd047e3e9acd78c7b03b28830fbde94e9dfc1758312cfc232191d1ffdbe4bae90f58b917eeaf5e9959e2676f7bbf4cdb8f5b48560a3294be586ba9997d83dd75970af621bfeb8c84d6cd5d4d4b6657b4f5305f1352fbe932351b73c3354d560f8fce8237b144d5c23b0a1e86c5789607d242dcf5e22a6dea4a96bdb92d58bfbf1d6101e100f765ac6f2268d6db8be2b408d8855cee73fcc8900d2a8e610deaee72c501844967e4a623a5d26e83c7103b7a8b2c6b8fea0a9372422be13a2cc7cd3dd62ee76f995c94a73b2f2da0a39f6a5e20931d5106fc0b959f745da30662d27b4dbe111859ceb9f1f995d453d1dadc457f4e12ae3980757e94fe184725e0b4f67ec7193cc6260d67cd21150112ccd9ccb61e225f8bc819657213f78a7f173ff527c635fd97912c6739090f9014baaff5280a587cfc892377d855438f546f35c6fa9a4eaed2733c6d244fa853fc3bbd687c3044d8552872102602767b31ba9bdaa5dfedffbdb45127ccee1ea452b08f4d25eed49b7c62673441c6a0b00e4910db705daba4dea3b2fd231cc55f92b31a1c97d7e9c8b631670930714766806dd6a7c99181fa80f656b54be881744862be2f4935cc4235a4d6b169da55f462e9be868bee2acc3d51d768e6c573f06d288aa39c977e245b6573b8e97ede5f77039062f80f987c3863ff83dcb1cdae1c9f9b2af888c2ce46e034f1025c9bb9decf7abecf1acbdf938c6fae05dd21beb39ac71c416e0567cad97d9422339789f82ba5d30b2ff2fa09f129ba00714a1c270a13ba1ed9e48ec1581b63d1560e8f369d072206ecabd9bdcd4962744f1d6ea684b82de7711835135543c3c80173650a78db946b4a3d5130874461712d08d32fe1a3d2d7624f0715ae8784250dd89c4685c61264b091ea2f480b6786618b1271eb19eb0169122dd2456942b4bc9dd9021698e6eeb0d6952c91324963a896b67d4b3c519e76d934769f8b0966a6014d0d7673d8536eddbe88201b8616ccb3d66474acce09ab70cbd6d5bb3f019829b552674ab1a19f7da38933cbd38cd8e322e7e0dc33ded6134338b359004b5121a38c909809c2f731e58efe7dedf2de4941ecffbf7ba8659c4afac8c0dbebe4c73fbfc0af8e31cc6e5e1ab82614e886c4a1194ff129528bfb1ad51477a140b74298fafc2c7dfa064e30dc341044d8be230ced72389e47840a369ef8fd193646849d97564cb2597295537495b2c25335f841ebc4f707966ba056ceed180049f02cb66395842c12f03ad84a83a101beb157d70a477a216c3e98604ae6fad63b76ad68c7ac755171ba9485d059edec9becef236bf0507a484a6ec3cd543facf2aaf5df48ef699a23e3789527c59e24b3c0422ac5020a78b5bbfe32ed4711ee0514383064951be72795ef86dfe8f0c4693ffffd039ffd563cfc7a1ccdb6abaf3864d3150499860db522b80daa7e7f56243e32898369edbb82be92bcb9530889d3a4b7c1cde036fda4ead8b3aea1ee35d6f86a73c9cc42edd64443e172fed1b0e96a4f62130e47fb73b77322eaf04d688a0817495e9e428b5161ad9402caeaee704581f09bd06e575bbe124fad7000a2935635e17c0da1d4a0271f03952ee60fa6b995d009941716f2ab4e61b53989d681daaafcce46ebf2269efc707a1178b75abe75504623694c13b32bcd418c30e27e804d9176994a483486d89fd2e415be125bc136442883828bdfca1933033df51d7f201d721b32e038f6e05bd7e6e2a994b905f70d0dd6f48d208eb701b72ad64e389a4b65c06a3f7d86b69bd50b0048afa1ea19d209ab0f778f17a8396180ce20bcea9849eb25dd13b36bc88cc732118568169951445a9a5b0476b7b196ae99cf9adea5b26c18dcf4915cd6e15122b2ea4e85065b848d9300d3d7f8e7075a530b05a2fe931cb90bcf1fb0e0db4880f535705a66f0f536e04f986be6485568acf683995666e06020db574e3fb344d7ff32369f6a363db57e537c9a83d9305f234e19efa15984473df680c464f32cb95b27d19a59f3c68b7e22f18082bb395e01a1874db2ffb2d336fdd217ee5a39fe5b58a1f613c6b260565f78a6fbc5a555d6628299019f1ae1aec2f97153b29296e0aff3586c6be44bba53e74d9e8353defd05eef4a8ce3e158a11755815b7dace9d777346723b021822e632ca369a81436c8398867287bc64c12a5753ec39903adebd4554b715d191509b1594224952ff41b0ec82fac6f38ca164ae8ecd5578630f9f2dc3575206308a72f2f0222a7e34a5cb3ed90c1a46c51130b01f9b3041af56456a5313aafcfcc4ea44bd64f9810defde5be26b0e045c935b16a3a292a926a234fa510295d860c0eac0547651b9c511708385567c3cbda2adedb6f2f9ac7d9fda62967c83bc2ce111ac269df99b4ac50e4ab56972c381e10dc835d43e9cf2c82d5d3a66754b265919a4ed1d3e22c1ab8dd70a67ade31f15e8e986ee6f42a56d20653a9db5f5cb913ecb04b56ff7e0de43b696bcc1a6cfbf593c17d37d343b179e0df97448a375bf18b642eedf0c96c960e5fe56a10bb66df22f61b76902a263d43fb5ac86623e01fc07c35ea9735ddc6a08d53383fc92f56b9eff976708e0e1fcfbfa49870aeb181b826a80f399f762f5e6b4108386c63b2678b5e34af73459ca7147126cf9ab4352b66029cf217683dd2c019f47bf2c3bb688bb1ac0863932878ac28178c445805dfd2988e157078174c1bd024f17b9a306d4233be04e3e249ed78ca88caf576e9f4810d4e27768ac5fa376dbe9574d6ea95f3da0b1cfe99d4a64b5a49ee455c8222c4c188e0424e10d0f5a5c626920f88cf8a068e4d50ad7ef2b35d38a82ba7072cc4f9419a3f02feff15dd6d4ea6d87881eebebabc1e631a91e42eb8d71d5b80119ce51c93e564ae5f6a3f534d669bf5b0e51ebdaab09e33f3f3665a93dbddb90e5fd20932fecfa1689c9e5b2ecbf631d51e886fcbf0df7a18013e3b44f7b165c4c9cd8de225767afe3854cdee4ceaf0458a880cb4cc44c63bffb14c667a84ccd759f47b6569ec4e875071961daca2841e6a62d214d9b8fbfa7a26204d26773aa8d8fd7c806c6a4f1b90a8e62c65dbf2b92069f7cc173cea375352545d4e116bdf37965e28a50be0d7803ea625bd1730fa17d0ded3bfffa561972f5e0114563947b7290e4657edb8d9487072c31a05cbb6ed5be6eefb43b8bc2a4058887dc821e5b96ffd848d8fb07074235b478dbc3071940e7488817e875351bdbd0fe25f7c62f030c6cced8048535bbbf9471aff1eebe127aa6d4ba497dfedcd48a26e12cd8a0d15ece4397b5908f72953d088ab42afbb634718d9a3ee7ccc37bbf0dde644a0aa254cc16de9184e1a1022ed386404f97ceda13de9c91b006dcae4279e048466bc0ba462d3035b68e382a46e72155a5ed4db194e0cc50f5b38f40cd077bc5c34c8e5e5f28e966d29f3bbcb7eb39bf5e457fb77590fe34149054cca2a776d2d5484bf68bf17ed69b1f96578a176143a27fcbac4439e3d37065ccbb3f4405ab9883f2517e302b064bfa3cfcd0f6138f68aae3c1f82ca8b11914a802426bae0bfa43264412d0af7a70ce07d7eaded2a7d7e7e579371fb26f04972c693e79a2c7aadd0b255e5a2ab0eef3c8af7b687138fb1256615df4bbc5b6be4c03bff694390f6e31ea8292162e52ce7b1a0d7b4eb98d5a7d46e60fccbd36a02f3c9c99c97fe070f158a0c6faf8eccac12611cabe9ad86dcf694be922506708e58d2f16ea4f53f542fa748fca983d7fff3c0788c3c96028de21d3027bfda6b12fb2622a1c389fd02bf6897b737240c11cd382ba1e89d47dc2be10fe4e414815cf2dcebee657df285b8ce74ac381e41b45ab5751480b417d2e269007b5ec8c3d4d159c31c1eb096e1a6602a757f1072bd01698f6059ba48cfd0d62c99592024b865157a1dda031b4072b075cf02020333dc98804fb7681984dda7ff6de7f991edfb40377314f8ca0ca09a9833c065b1a8462502d7e95047df12f2bf564a2b64297dfbd01b5229d4943e074945df1824ab565fd75c14bc8213b4ccfbfd991a67a9e93a324b5fb48e0c40dea3c0b5b7305895a8bd185472125ec39fc615c75e876357e8c164d800540ba60fae2cd9edc412f11ac462b271c4df87dcdc09e130d20e9182a02faa21b4b53d128a93170870ea2ae311a266bb4b15b9c0267f8785dc20348a7207f209d4b7e250a555200292442d07829c104d8f1542985491cbe2ac5f2784a87bdf8435208f27286b7c6ea68caa66233a47e3a01a383f783a75d40b834fdb6735724d5e0511a20c9b41be4416f00c64552e145aea06e5a2171c977c077def52f1042b422980a9493801c62d267ceffe5f1a5150b18b4bbe7dee289267e641a869b3c059c6cc461ed5104a7aceb15f1a68c3b83c8b7727c1c0870f920442f290b04305c6074e90411b3768f6a8519984c1ac963e6a1a49730f5eaea6a26a3c030e3d39867f348f1d38bc375bba8ad837b5bc6f4159db57f68d525a5984d831060d0d068eca80d8b190eea9484a25cf9526b81f4c7f1fa4f467c48295917fb7d9b0ff7d1362100bfa7f1312eb8b4ce43386062fcc447c523baf3fb7606a221db913ff42cc065da0e6b681b06c6d1393592ac3943977f6789355ccc4446f989e1b5f88c96ffb9825bc32418a3dbeb4064d3e4eaf55927fdcd1fb03207ce1a633295fa377a601c86b4325e7a1dea9c03d38a1aef3de4afc4e8d292242452a3dfb659b54f4b1d89dc1bc3e36b40a16684bc5a09fbd26a450ef7e55a6c026506cf6c6b225392c27509ce84fc9ffa9e3031d807890ceffaf0fb4b9d53c019d36d70ca930e30f06eddcba7ac1bb02734b306517fe09a3fb90de2cd220eb3828da557c4654f7c7e3c4e4dac040ea79b75eedd0c77c9297fa36d8ca50ce031f5b46e1c0318795d3b5408e053b2b0af034b5e1ee54fc96ddbae181c49caec0504000921eeca183f29252b1c5dc01a1014955a8480a24fe4dc47992e9f9712213631ce9142e73308dc7fabf074b2417e932654433a55fba9c7a9be13a9ddb37663a282dc5926d93306760556f670aa3fe02026c4000dc9b312a35b3197d7fb55408e7a05da8b46ed33485fe0df649f65164e17d7999520c63ff50a2e7e0f0e50c239da26a27ba10ce9e1f83544cbd941043cb0a49ce0ec2ab15b741a03ee512b24879df7c7e48f6063eee0354e85fc4027fe4e09e41bdc7763e53b991e7ef6bb2824f21e1d4ba3c3f5efd69b487ba9020e23711e563972d61fc703b407083b3abf8be6deb6589059518709ba80af34414bf65f15dc8a2691724c6fc3fb5d5720de582395522bac6dfe0c16cc5055f5ceafbf10370c51857b86dca2604928e770993ff6073f31345e216dd09a6bf88523b2549da6279746d66cf01899971dc98ab4b9780f5adb6e9f08555291c87727c08addcd6b489d2dbc732ecc71eb6b056cec753283974852477d077bfd5180c7a1b6a955c1efb150e9059f9cc285355c68d81754a96fb8c22f8dbec0d98e460bd45423c5d37758f669cf8f05533e533076f82b1f91d1888b74dcffad667d74d90432b257ffa384749eb9a892a48dabd76a305b3b1f80992350b770ef12622f1af9a239b58b4d9b6903619e03aa808cb9c8ea83b526dcf1ddcb459aed0630b98bba707c8782f4e198503579589da4432070ac7625d68abeed4547eb9fe6895a1eac4a4c50a1da2f2aeca6fde15ad71aad9a8efa27a8e0cdf0108973e69337c62acc5eacafb5ff968d843fa92b56748bde9136d7c65f447fd3362f7fce0c1e6e8f17db9ec4bbaa599c9d3b1bee865bfbda993d3cedc531a9a82b83d9da9f8a52e25681e1dc933f5d049a57cc4bedd0b01be67340a463f6469cf3d787b871239b43dd6f62f72dafce15e98257fa0ca83ffb8ac10e29e1045250aa0d002a2c4169f4a7ae82cd120184da979377a58ad34cfb598b0c38b198325b0f71f458e4dc988e65896211265f41d91e0fc6bcef55b3ad303b7697eff8b510f1de45c1a0aac1bd1cebcc34e85e52dcd3f31257d0e2342f63002633792f103cb6bcb87bd12160ead071eef8eec855ad946c316e99f4e9ceaf59b452537907c12ba941ea9f89229f1cd0607c1febcbf59c28005f8ee4b981a401916e6589dd05dc5105b11cbefb2fe2c45c19c89883ec093a2bf4b9fd31f947fe7f408817f29dfc0e0c1a533092afffda34eb734631f683e8bd65aa8cfb9617dee40b842327c5e8e5dcb87b42d15de424773dc116f9b42dd1ef5798cbd164df069fd423d9f4bc6aab6341a794513f9b07ace12e0763c1ee3bfa40ccd07088e678fa97b21518bd0ca9b640512b5296e8b77471c3443a14b71f733ab34e3caaf4420c994a1e61ba464279033450b3bc8423f37aa3c8585ec8854b19c591514c984314226b1ad2b05f18cfcddb7fb26e3eb99f8af6d875c05e95f186a8fa38dfd4eb968eaac6725915ba1bc55c4e5d1f3273734636e0c436cce2b76379208f7e9308116ef76de6106e1d2e63d4018e40f37e0d2d3cc7646571e87aa3f4fef8ffb1bf3ab006991efcdbdda17ef1bb616d6036487369640e9075a8a778b32b3c5bd3fe3e9399ccca5a81d8e99206635fb69f472672c82cc22fe98e78b5f58c42291b311ea9d45217e0614249383ca00e9992cf86987e8f70a5a69f54d3352a0918f76ca158b45c16af54678afa0197f3cf9c9459ff1627be663af11f2266f84cd2cbf34a94f571c9a94615756768088c97294c115da9c015af3d5a7bb8c7be1c6bdd87e5d7dc1ab73c51cab806aea39007b15c3cd9805feba2d92cc51513a8134591fe0229102588e997ace55ff2613559cc5f11782401984af47dfbee53780e9f8a0d1a2f8b7c31845b3195a93638298e339b4706a237b38ca1be3f433c45b833788fd20d61fb3e85f4328fb4670e7b62e3485d944d53f4a51e84190be65025778d8cbb484b3d32407ad86dfc7f239904923949e58c4d191373254d9ef4b7783f1b7ee432744dbf3f33ba1f9135d88856bc84c1b67db7625c643945d161164a39a1ae2e9ce0cb79fda7f87ee00be6c08c3f36b80969b298723fb34f97191e674ec132ade3d8850465603879d8767eb31ef784af32d9374837cc7cc5f048626da89c02545f75f0d75c500d3a23c091eb22213e186801db1e6b67c</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 请输入密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法面试题</title>
    <url>/2022/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>常见高频面试数据结构与算法题</p>
<hr>
<p><strong>出现的频率从上到下依次递减</strong></p>
<h4 id="1-反转链表（Go）206-容易"><a href="#1-反转链表（Go）206-容易" class="headerlink" title="1. 反转链表（Go）206-容易"></a>1. 反转链表（Go）206-容易</h4><p><strong>题目：</strong></p>
<p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输入：head = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输入：head = <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：迭代<br>假设链表为 1→2→3→∅，我们想要把它改成∅←1←2←3</p>
<p>在遍历链表时，将当前节点的 <code>next</code> 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用</p>
<div align="center"><img src="https://i.bmp.ovh/imgs/2022/06/21/935d47f8204310d8.png" style="zoom:50%;" /></div>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 是链表的长度。需要遍历链表一次</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ListNode 定义单链表</span></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Value <span class="type">int</span></span><br><span class="line">	Next  *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Solution 反转单链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Solution</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">	<span class="keyword">var</span> prev *ListNode</span><br><span class="line">	curr := head</span><br><span class="line">	<span class="keyword">for</span> curr != <span class="literal">nil</span> &#123;</span><br><span class="line">		next := curr.Next</span><br><span class="line">		curr.Next = prev</span><br><span class="line">		prev = curr</span><br><span class="line">		curr = next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateListNode 使用slice生成单链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateListNode</span><span class="params">(nums []<span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">	<span class="keyword">var</span> head ListNode</span><br><span class="line">	<span class="keyword">var</span> pre ListNode</span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		node := ListNode&#123;Value: num, Next: <span class="literal">nil</span>&#125;</span><br><span class="line">		<span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">			head.Next = &amp;node</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> pre.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">			pre.Next = &amp;node</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			pre.Next.Next = &amp;node</span><br><span class="line">			pre = *pre.Next</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Traverse 遍历链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Traverse</span><span class="params">(t *ListNode)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;空链表&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> t != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d &quot;</span>, t.Value)</span><br><span class="line">		t = t.Next</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">10</span>&#125;</span><br><span class="line">	head := CreateListNode(nums)</span><br><span class="line">	<span class="comment">// 遍历链表</span></span><br><span class="line">	Traverse(head)</span><br><span class="line">	<span class="comment">// 反转链表</span></span><br><span class="line">	solution := Solution(head)</span><br><span class="line">	<span class="comment">// 遍历反转后的链表</span></span><br><span class="line">	Traverse(solution)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-LRU缓存（Go）146-中等"><a href="#2-LRU缓存（Go）146-中等" class="headerlink" title="2. LRU缓存（Go）146-中等"></a>2. LRU缓存（Go）146-中等</h4><p><strong>题目：</strong></p>
<p>请你设计并实现一个满足 <code>LRU (最近最少使用)</code> 缓存 约束的数据结构<br>实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以 正整数 作为容量 <code>capacity</code> 初始化 <code>LRU</code> 缓存</li>
<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 -1 </li>
<li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 逐出 最久未使用的关键字</li>
</ul>
<p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line"><span class="punctuation">[</span><span class="string">&quot;LRUCache&quot;</span><span class="punctuation">,</span> <span class="string">&quot;put&quot;</span><span class="punctuation">,</span> <span class="string">&quot;put&quot;</span><span class="punctuation">,</span> <span class="string">&quot;get&quot;</span><span class="punctuation">,</span> <span class="string">&quot;put&quot;</span><span class="punctuation">,</span> <span class="string">&quot;get&quot;</span><span class="punctuation">,</span> <span class="string">&quot;put&quot;</span><span class="punctuation">,</span> <span class="string">&quot;get&quot;</span><span class="punctuation">,</span> <span class="string">&quot;get&quot;</span><span class="punctuation">,</span> <span class="string">&quot;get&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">4</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">输出</span><br><span class="line"><span class="punctuation">[</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="number">-1</span><span class="punctuation">,</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="number">-1</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">LRUCache lRUCache = new LRUCache(<span class="number">2</span>);</span><br><span class="line">lRUCache.put(<span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span>); <span class="comment">// 缓存是 &#123;1=1&#125;</span></span><br><span class="line">lRUCache.put(<span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span>); <span class="comment">// 缓存是 &#123;1=1, 2=2&#125;</span></span><br><span class="line">lRUCache.get(<span class="number">1</span>);    <span class="comment">// 返回 1</span></span><br><span class="line">lRUCache.put(<span class="number">3</span><span class="punctuation">,</span> <span class="number">3</span>); <span class="comment">// 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span></span><br><span class="line">lRUCache.get(<span class="number">2</span>);    <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">lRUCache.put(<span class="number">4</span><span class="punctuation">,</span> <span class="number">4</span>); <span class="comment">// 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span></span><br><span class="line">lRUCache.get(<span class="number">1</span>);    <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">lRUCache.get(<span class="number">3</span>);    <span class="comment">// 返回 3</span></span><br><span class="line">lRUCache.get(<span class="number">4</span>);    <span class="comment">// 返回 4</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= capacity &lt;= 3000</code></li>
<li><code>0 &lt;= key &lt;= 10000</code></li>
<li><code>0 &lt;= value &lt;= 105</code></li>
<li>最多调用 <code>2 * 105</code> 次 <code>get</code> 和 <code>put</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：哈希表 + 双向链表</p>
<p>LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对</p>
<ul>
<li>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的</li>
<li>哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置</li>
</ul>
<p>这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 O(1) 的时间内完成 <code>get</code> 或者 <code>put</code> 操作。具体的方法如下：</p>
<ul>
<li><p>对于 <code>get</code> 操作，首先判断 <code>key</code> 是否存在：</p>
<ul>
<li>如果 <code>key</code> 不存在，则返回 −1</li>
<li>如果 <code>key</code> 存在，则 <code>key</code> 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值</li>
</ul>
</li>
<li><p>对于 <code>put</code> 操作，首先判断 <code>key</code> 是否存在：</p>
<ul>
<li>如果 <code>key</code> 不存在，使用 <code>key</code> 和 <code>value</code> 创建一个新的节点，在双向链表的头部添加该节点，并将 <code>key</code> 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项</li>
<li>如果 <code>key</code> 存在，则与 <code>get</code> 操作类似，先通过哈希表定位，再将对应的节点的值更新为 <code>value</code>，并将该节点移到双向链表的头部</li>
</ul>
</li>
</ul>
<p>上述各项操作中，访问哈希表的时间复杂度为 O(1)，在双向链表的头部添加节点、在双向链表的尾部删除节点的复杂度也为 O(1)。而将一个节点移到双向链表的头部，可以分成「删除该节点」和「在双向链表的头部添加节点」两步操作，都可以在 O(1) 时间内完成</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：对于 <code>put</code> 和 <code>get</code> 都是 O(1)</li>
<li>空间复杂度：O(capacity)，因为哈希表和双向链表最多存储 capacity+1 个元素</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    size <span class="type">int</span></span><br><span class="line">    capacity <span class="type">int</span></span><br><span class="line">    cache <span class="keyword">map</span>[<span class="type">int</span>]*DLinkedNode</span><br><span class="line">    head, tail *DLinkedNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DLinkedNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    key, value <span class="type">int</span></span><br><span class="line">    prev, next *DLinkedNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDLinkedNode</span><span class="params">(key, value <span class="type">int</span>)</span></span> *DLinkedNode &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;DLinkedNode&#123;</span><br><span class="line">        key: key,</span><br><span class="line">        value: value,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line">    lruCache := LRUCache&#123;</span><br><span class="line">        cache: <span class="keyword">map</span>[<span class="type">int</span>]*DLinkedNode&#123;&#125;,</span><br><span class="line">        head: initDLinkedNode(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        tail: initDLinkedNode(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        capacity: capacity,</span><br><span class="line">    &#125;</span><br><span class="line">    lruCache.head.next = lruCache.tail</span><br><span class="line">    lruCache.tail.prev = lruCache.head</span><br><span class="line">    <span class="keyword">return</span> lruCache</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    _, ok := this.cache[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    node := this.cache[key]</span><br><span class="line">    this.moveToHead(node)</span><br><span class="line">    <span class="keyword">return</span> node.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>)  &#123;</span><br><span class="line">    _, ok := this.cache[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        node := initDLinkedNode(key, value)</span><br><span class="line">        this.cache[key] = node</span><br><span class="line">        this.addToHead(node)</span><br><span class="line">        this.size++</span><br><span class="line">        <span class="keyword">if</span> this.size &gt; this.capacity &#123;</span><br><span class="line">            removeed :=this.removeTail()</span><br><span class="line">            <span class="built_in">delete</span>(this.cache, removeed.key)</span><br><span class="line">            this.size--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node := this.cache[key]</span><br><span class="line">        node.value = value</span><br><span class="line">        this.moveToHead(node)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> addToHead(node *DLinkedNode) &#123;</span><br><span class="line">    node.prev = this.head</span><br><span class="line">    node.next = this.head.next</span><br><span class="line">    this.head.next.prev = node</span><br><span class="line">    this.head.next = node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> removeNode(node *DLinkedNode) &#123;</span><br><span class="line">    node.prev.next = node.next</span><br><span class="line">    node.next.prev = node.prev</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> moveToHead(node *DLinkedNode) &#123;</span><br><span class="line">    this.removeNode(node)</span><br><span class="line">    this.addToHead(node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> removeTail() *DLinkedNode &#123;</span><br><span class="line">    node := this.tail.prev</span><br><span class="line">    this.removeNode(node)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-CodeTop补充题：手撕快速排序（Go）-排序数组-912-中等"><a href="#3-CodeTop补充题：手撕快速排序（Go）-排序数组-912-中等" class="headerlink" title="3. CodeTop补充题：手撕快速排序（Go） | 排序数组 912-中等"></a>3. CodeTop补充题：手撕快速排序（Go） | 排序数组 912-中等</h4><blockquote>
<p><font color=red><strong>10大排序算法： 1. 冒泡排序，2. 选择排序，3. 插入排序，4. 归并排序，5. 快速排序，6. 堆排序，8. 计数排序，9. 桶排序，10. 基数排序</strong></font></p>
</blockquote>
<p><strong>题目：</strong></p>
<p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 5 * 10^4</code></li>
<li><code>-5 * 10^4 &lt;= nums[i] &lt;= 5 * 10^4</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：快速排序<br>思路和算法</p>
<p>快速排序的主要思想是通过划分将待排序的序列分成前后两部分，其中前一部分的数据都比后一部分的数据要小，然后再递归调用函数对两部分的序列分别进行快速排序，以此使整个序列达到有序</p>
<p>我们定义函数 <code>randomized_quicksort(nums, l, r)</code> 为对 <code>nums</code> 数组里 [l,r]的部分进行排序，每次先调用 <code>randomized_partition</code> 函数对 <code>nums</code> 数组里 [l,r]的部分进行划分，并返回分界值的下标 <code>pos</code>，然后按上述将的递归调用 <code>randomized_quicksort(nums, l, pos - 1)</code> 和 <code>randomized_quicksort(nums, pos + 1, r)</code> 即可</p>
<p>那么核心就是划分函数的实现了，划分函数一开始需要确定一个分界值（我们称之为主元 <code>pivot</code>)，然后再进行划分。而主元的选取有很多种方式，这里我们采用随机的方式，对当前划分区间 [l,r] 里的数等概率随机一个作为我们的主元，再将主元放到区间末尾，进行划分</p>
<p>整个划分函数 <code>partition</code> 主要涉及两个指针 i 和 j，一开始 <code>i = l - 1</code>，<code>j = l</code>。我们需要实时维护两个指针使得任意时候，对于任意数组下标 k，我们有如下条件成立：</p>
<ol>
<li>l≤k≤i 时，nums[k]≤pivot</li>
<li>i+1≤k≤j−1 时，nums[k]&gt;pivot</li>
<li>k&#x3D;&#x3D;r 时，nums[k]&#x3D;pivot</li>
</ol>
<p>我们每次移动指针 j ，如果 nums[j]&gt;pivot，我们只需要继续移动指针 j ，即能使上述三个条件成立，否则我们需要将指针 i 加一，然后交换 nums[i] 和 nums[j]，再移动指针 j 才能使得三个条件成立</p>
<p>当 j 移动到 r−1 时结束循环，此时我们可以由上述三个条件知道 [l,i] 的数都小于等于主元 <code>pivot</code>，[i+1,r−1] 的数都大于主元 <code>pivot</code>，那么我们只要交换 nums[i+1] 和 nums[r] ，即能使得 [l,i+1] 区间的数都小于 [i+2,r] 区间的数，完成一次划分，且分界值下标为 i+1，返回即可</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：基于随机选取主元的快速排序时间复杂度为期望 O(nlogn)，其中 n 为数组的长度</li>
<li>空间复杂度：O(h)，其中 h 为快速排序递归调用的层数。我们需要额外的 O(h) 的递归调用的栈空间，由于划分的结果不同导致了快速排序递归调用的层数也会不同，最坏情况下需 O(n) 的空间，最优情况下每次都平衡，此时整个递归树高度为 logn，空间复杂度为 O(logn)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(initialSlice []<span class="type">int</span>, low, high <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 导致low位置值为空</span></span><br><span class="line">	pivot := initialSlice[low]</span><br><span class="line">	<span class="keyword">for</span> low &lt; high &#123;</span><br><span class="line">		<span class="comment">// high指针值 &gt;= pivot high指针左移</span></span><br><span class="line">		<span class="keyword">for</span> low &lt; high &amp;&amp; pivot &lt;= initialSlice[high] &#123;</span><br><span class="line">			high--</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 填补low位置空值</span></span><br><span class="line">		<span class="comment">// high指针值 &lt; pivot high值 移到low位置</span></span><br><span class="line">		<span class="comment">// high位置值空</span></span><br><span class="line">		initialSlice[low] = initialSlice[high]</span><br><span class="line">		<span class="comment">// low指针值 &lt;= pivot low指针右移</span></span><br><span class="line">		<span class="keyword">for</span> low &lt; high &amp;&amp; pivot &gt;= initialSlice[low] &#123;</span><br><span class="line">			low++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 填补high位置空值</span></span><br><span class="line">		<span class="comment">// low指针值 &gt; pivot low值 移到high位置</span></span><br><span class="line">		<span class="comment">// low位置值空</span></span><br><span class="line">		initialSlice[high] = initialSlice[low]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// pivot填补low位置的空值</span></span><br><span class="line">	initialSlice[low] = pivot</span><br><span class="line">	<span class="keyword">return</span> low</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort</span><span class="params">(initialSlice []<span class="type">int</span>, low, high <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> high &gt; low &#123;</span><br><span class="line">		<span class="comment">// 位置划分</span></span><br><span class="line">		pivot := partition(initialSlice, low, high)</span><br><span class="line">		<span class="comment">// 左边部分排序</span></span><br><span class="line">		QuickSort(initialSlice, low, pivot<span class="number">-1</span>)</span><br><span class="line">		<span class="comment">// 右边部分排序</span></span><br><span class="line">		QuickSort(initialSlice, pivot+<span class="number">1</span>, high)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	initialSlice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">19</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">56</span>&#125;</span><br><span class="line">	QuickSort(initialSlice, <span class="number">0</span>, <span class="built_in">len</span>(initialSlice)<span class="number">-1</span>)</span><br><span class="line">	fmt.Println(initialSlice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-合并两个有序链表（Go）-21-简单"><a href="#4-合并两个有序链表（Go）-21-简单" class="headerlink" title="4. 合并两个有序链表（Go） 21-简单"></a>4. 合并两个有序链表（Go） 21-简单</h4><p><strong>题目：</strong></p>
<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：l1 = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">,</span> l2 = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span></span><br><span class="line">输入：l1 = <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> l2 = <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">输入：l1 = <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> l2 = <span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>两个链表的节点数目范围是 <code>[0, 50]</code></li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：递归<br>思路</p>
<p>我们可以如下递归地定义两个链表里的 merge 操作（忽略边界情况，比如空链表等）：</p>
<p>list1[0] + merge(list1[1:], list2) list1[0] &lt; list2[0]</p>
<p>list2[0] + merge(list1, list2[1:]) otherwise </p>
<p>也就是说，两个链表头部值较小的一个节点与剩下元素的 <code>merge</code> 操作结果合并</p>
<p>算法：</p>
<p>我们直接将以上递归过程建模，同时需要考虑边界情况</p>
<p>如果 <code>l1</code> 或者 <code>l2</code> 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 <code>l1</code> 和 <code>l2</code> 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。因为每次调用递归都会去掉 <code>l1</code> 或者 <code>l2</code> 的头节点（直到至少有一个链表为空），函数 <code>mergeTwoList</code> 至多只会递归调用每个节点一次。因此，时间复杂度取决于合并后的链表长度，即 O(n+m)</li>
<li>空间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。递归调用 <code>mergeTwoLists</code> 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。结束递归调用时 mergeTwoLists 函数最多调用 n+m 次，因此空间复杂度为 O(n+m)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> ListNode struct &#123;</span><br><span class="line">	Value <span class="built_in">int</span></span><br><span class="line">	Next  *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// CreateListNode 使用<span class="built_in">slice</span>创建单链表</span><br><span class="line">func CreateListNode(nums []<span class="built_in">int</span>) *ListNode &#123;</span><br><span class="line">	var head ListNode</span><br><span class="line">	var pre ListNode</span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="built_in">range</span> nums &#123;</span><br><span class="line">		node := ListNode&#123;Value: num, Next: nil&#125;</span><br><span class="line">		<span class="keyword">if</span> head.Next == nil &#123;</span><br><span class="line">			head.Next = &amp;node</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> pre.Next == nil &#123;</span><br><span class="line">			pre.Next = &amp;node</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			pre.Next.Next = &amp;node</span><br><span class="line">			pre = *pre.Next</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Traverse 遍历链表</span><br><span class="line">func Traverse(t *ListNode) &#123;</span><br><span class="line">	<span class="keyword">if</span> t == nil &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;空链表&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> t != nil &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot; %d&quot;</span>, t.Value)</span><br><span class="line">		t = t.Next</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// MergeTwoListNode 合并<span class="number">2</span>个链表</span><br><span class="line">func MergeTwoListNode(List1, List2 *ListNode) *ListNode &#123;</span><br><span class="line">	// 如果有一条链表为nil，直接返回另一条链表</span><br><span class="line">	<span class="keyword">if</span> List1 == nil &#123;</span><br><span class="line">		<span class="keyword">return</span> List2</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> List2 == nil &#123;</span><br><span class="line">		<span class="keyword">return</span> List1</span><br><span class="line">	&#125;</span><br><span class="line">	// 定义一个节点</span><br><span class="line">	var result *ListNode</span><br><span class="line">	<span class="keyword">if</span> List1.Value &gt;= List2.Value &#123;</span><br><span class="line">		result = List2</span><br><span class="line">		result.Next = MergeTwoListNode(List1, List2.Next)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		result = List1</span><br><span class="line">		result.Next = MergeTwoListNode(List1.Next, List2)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	nums1 := []<span class="built_in">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;</span><br><span class="line">	nums2 := []<span class="built_in">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>&#125;</span><br><span class="line">	lis1 := CreateListNode(nums1)</span><br><span class="line">	lis2 := CreateListNode(nums2)</span><br><span class="line">	mergeTwoListNode := MergeTwoListNode(lis1, lis2)</span><br><span class="line">	Traverse(mergeTwoListNode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-最大子数组和（Go）53-简单"><a href="#5-最大子数组和（Go）53-简单" class="headerlink" title="5. 最大子数组和（Go）53-简单"></a>5. 最大子数组和（Go）53-简单</h4><p><strong>题目：</strong></p>
<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和</p>
<p><strong>子数组</strong> 是数组中的一个连续部分</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">-2</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">-3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">-1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">-5</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：连续子数组 <span class="punctuation">[</span><span class="number">4</span><span class="punctuation">,</span><span class="number">-1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span> 的和最大，为 <span class="number">6</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">-1</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">23</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：动态规划（核心：若前一个元素大于0，则将其加到当前元素上）<br>思路和算法</p>
<p>假设 nums 数组的长度是 n，下标从 0 到 n−1</p>
<p>我们用 f(i) 代表以第 i 个数结尾的「连续子数组的最大和」，那么很显然我们要求的答案就是：<br>0≤i的max≤n−1的{f(i)}</p>
<p>因此我们只需要求出每个位置的 f(i)，然后返回 f 数组中的最大值即可。那么我们如何求 f(i) 呢？我们可以考虑 nums[i] 单独成为一段还是加入 f(i−1) 对应的那一段，这取决于 nums[i] 和 f(i-1) +nums[i] 的大小，我们希望获得一个比较大的，于是可以写出这样的动态规划转移方程：<br>f(i)&#x3D;max{f(i−1)+nums[i],nums[i]}</p>
<p>不难给出一个时间复杂度 O(n)、空间复杂度 O(n) 的实现，即用一个 ff 数组来保存 f(i) 的值，用一个循环求出所有 f(i)。考虑到 f(i) 只和 f(i−1) 相关，于是我们可以只用一个变量 pre 来维护对于当前 f(i) 的 f(i−1) 的值是多少，从而让空间复杂度降低到 O(1)，这有点类似「滚动数组」的思想</p>
<div align="center"><img src="https://i.bmp.ovh/imgs/2022/06/21/2f768ff06b617809.png" style="zoom:50%;" /></div>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 为 nums 数组的长度。我们只需要遍历一遍数组即可求得答案</li>
<li>空间复杂度：O(1)。我们只需要常数空间存放若干变量</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    max := nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] + nums[i - <span class="number">1</span>] &gt; nums[i] &#123;</span><br><span class="line">            nums[i] += nums[i - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; max &#123;</span><br><span class="line">            max = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-字符串相加（Go）415-简单"><a href="#6-字符串相加（Go）415-简单" class="headerlink" title="6. 字符串相加（Go）415-简单"></a>6. 字符串相加（Go）415-简单</h4><p><strong>题目：</strong></p>
<p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回</p>
<p>你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：num1 = <span class="string">&quot;11&quot;</span><span class="punctuation">,</span> num2 = <span class="string">&quot;123&quot;</span></span><br><span class="line">输出：<span class="string">&quot;134&quot;</span></span><br><span class="line">输入：num1 = <span class="string">&quot;456&quot;</span><span class="punctuation">,</span> num2 = <span class="string">&quot;77&quot;</span></span><br><span class="line">输出：<span class="string">&quot;533&quot;</span></span><br><span class="line">输入：num1 = <span class="string">&quot;0&quot;</span><span class="punctuation">,</span> num2 = <span class="string">&quot;0&quot;</span></span><br><span class="line">输出：<span class="string">&quot;0&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= num1.length, num2.length &lt;= 10的4次方</code></li>
<li><code>num1</code> 和<code>num2</code> 都只包含数字 <code>0-9</code></li>
<li><code>num1</code> 和<code>num2</code> 都不包含任何前导零</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：模拟<br>思路与算法</p>
<p>本题我们只需要对两个大整数模拟「竖式加法」的过程。竖式加法就是我们平常学习生活中常用的对两个整数相加的方法，回想一下我们在纸上对两个整数相加的操作，是不是如下图将相同数位对齐，从低到高逐位相加，如果当前位和超过 1010，则向高位进一位？因此我们只要将这个过程用代码写出来即可</p>
<p>具体实现也不复杂，我们定义两个指针 i 和 j 分别指向 num1  和 num 2 的末尾，即最低位，同时定义一个变量 add 维护当前是否有进位，然后从末尾到开头逐位相加即可。你可能会想两个数字位数不同怎么处理，这里我们统一在指针当前下标处于负数的时候返回 0，等价于对位数较短的数字进行了补零操作，这样就可以除去两个数字位数不同情况的处理，具体可以看下面的代码</p>
<div align="center"><img src="https://i.bmp.ovh/imgs/2022/06/21/83dd1b48338dee5d.png" style="zoom:50%;" /></div>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(max(len1,len2))，其中 len1&#x3D;num1.length，len2&#x3D;num2.length。竖式加法的次数取决于较大数的位数</li>
<li>空间复杂度：O(1)。除答案外我们只需要常数空间存放若干变量。在 Java 解法中使用到了 <code>StringBuffer</code>，故 Java 解法的空间复杂度为O(n)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addStrings</span><span class="params">(num1 <span class="type">string</span>, num2 <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    add := <span class="number">0</span></span><br><span class="line">    ans := <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="built_in">len</span>(num1) - <span class="number">1</span>, <span class="built_in">len</span>(num2) - <span class="number">1</span>; i &gt;= <span class="number">0</span> ||</span><br><span class="line">    j &gt;= <span class="number">0</span> || add != <span class="number">0</span>; i, j = i - <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> x, y <span class="type">int</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            x = <span class="type">int</span>(num1[i] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> j &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            y = <span class="type">int</span>(num2[j] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        result := x + y + add</span><br><span class="line">        ans = strconv.Itoa(result % <span class="number">10</span>) + ans</span><br><span class="line">        add = result / <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-二分查找（Go）704-简单"><a href="#7-二分查找（Go）704-简单" class="headerlink" title="7. 二分查找（Go）704-简单"></a>7. 二分查找（Go）704-简单</h4><p><strong>题目：</strong></p>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 <code>target</code>  ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 -1</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入<span class="punctuation">:</span> nums = <span class="punctuation">[</span><span class="number">-1</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">12</span><span class="punctuation">]</span><span class="punctuation">,</span> target = <span class="number">9</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line">解释<span class="punctuation">:</span> <span class="number">9</span> 出现在 nums 中并且下标为 <span class="number">4</span></span><br><span class="line">输入<span class="punctuation">:</span> nums = <span class="punctuation">[</span><span class="number">-1</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">12</span><span class="punctuation">]</span><span class="punctuation">,</span> target = <span class="number">2</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="number">-1</span></span><br><span class="line">解释<span class="punctuation">:</span> <span class="number">2</span> 不存在 nums 中因此返回 <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li>你可以假设 <code>nums</code> 中的所有元素是不重复的</li>
<li><code>n</code> 将在 <code>[1, 10000]</code>之间</li>
<li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间</li>
</ol>
<p><strong>思路：</strong></p>
<p>方法一：二分查找<br>在升序数组 nums 中寻找目标值 target，对于特定下标 i，比较 nums[i] 和 target 的大小：</p>
<ul>
<li><p>如果 nums[i] &#x3D; target，则下标 i 即为要寻找的下标</p>
</li>
<li><p>如果 nums[i] &gt; target，则 target 只可能在下标 i 的左侧</p>
</li>
<li><p>如果 nums[i] &lt; target，则 target 只可能在下标 i 的右侧</p>
</li>
</ul>
<p>基于上述事实，可以在有序数组中使用二分查找寻找目标值<br>二分查找的做法是，定义查找的范围 [left,right]，初始查找范围是整个数组。每次取查找范围的中点 mid，比较 nums[mid] 和 target 的大小，如果相等则 mid 即为要寻找的下标，如果不相等则根据 nums[mid] 和 target 的大小关系将查找范围缩小一半</p>
<p>由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是 O(logn)，其中 n 是数组的长度</p>
<p>二分查找的条件是查找范围不为空，即 left &lt;&#x3D; right。如果 target 在数组中，二分查找可以保证找到 target，返回 target 在数组中的下标。如果 target 不在数组中，则当 left &gt; right 时结束查找，返回 -1</p>
<div align="center"><img src="https://i.bmp.ovh/imgs/2022/06/21/736001c2f7e7a333.png" style="zoom:50%;" /></div>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(logn)，其中 n 是数组的长度</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        mid := (right - left) / <span class="number">2</span> + left</span><br><span class="line">        num := nums[mid]</span><br><span class="line">        <span class="keyword">if</span> num == target &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> num &gt; target &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-无重复字符串的最长子串（Go）3-中等"><a href="#8-无重复字符串的最长子串（Go）3-中等" class="headerlink" title="8. 无重复字符串的最长子串（Go）3-中等"></a>8. 无重复字符串的最长子串（Go）3-中等</h4><p><strong>题目：</strong></p>
<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入<span class="punctuation">:</span> s = <span class="string">&quot;abcabcbb&quot;</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="number">3</span> </span><br><span class="line">解释<span class="punctuation">:</span> 因为无重复字符的最长子串是 <span class="string">&quot;abc&quot;</span>，所以其长度为 <span class="number">3</span></span><br><span class="line">输入<span class="punctuation">:</span> s = <span class="string">&quot;bbbbb&quot;</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">解释<span class="punctuation">:</span> 因为无重复字符的最长子串是 <span class="string">&quot;b&quot;</span>，所以其长度为 <span class="number">1</span></span><br><span class="line">输入<span class="punctuation">:</span> s = <span class="string">&quot;pwwkew&quot;</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="number">3</span></span><br><span class="line">解释<span class="punctuation">:</span> 因为无重复字符的最长子串是 <span class="string">&quot;wke&quot;</span>，所以其长度为 <span class="number">3</span></span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">&quot;pwke&quot;</span> 是一个子序列，不是子串</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 5 * 10^4</code></li>
<li><code>s</code> 由英文字母、数字、符号和空格组成</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：滑动窗口</p>
<p>思路和算法</p>
<p>我们先用一个例子考虑如何在较优的时间复杂度内通过本题</p>
<p>我们不妨以示例一中的字符串 abcabcbb 为例，找出从每一个字符开始的，不包含重复字符的最长子串，那么其中最长的那个字符串即为答案。对于示例一中的字符串，我们列举出这些结果，其中括号中表示选中的字符以及最长的字符串：</p>
<ul>
<li><p>以 (a)bcabcbb 开始的最长字符串为 (abc)abcbb</p>
</li>
<li><p>以 a(b)cabcbb 开始的最长字符串为 a(bca)bcbb</p>
</li>
<li><p>以 ab(c)abcbb 开始的最长字符串为 ab(cab)cbb</p>
</li>
<li><p>以 abc(a)bcbb 开始的最长字符串为 abc(abc)bb</p>
</li>
<li><p>以 abca(b)cbb 开始的最长字符串为 abca(bc)bb</p>
</li>
<li><p>以 abcab(c)bb 开始的最长字符串为 abcab(cb)b</p>
</li>
<li><p>以 abcabc(b)b 开始的最长字符串为 abcabc(b)b</p>
</li>
<li><p>以 abcabcb(b) 开始的最长字符串为 abcabcb(b)</p>
</li>
</ul>
<p>发现了什么？如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的！这里的原因在于，假设我们选择字符串中的第 k 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 tk 。那么当我们选择第 k+1 个字符作为起始位置时，首先从 k+1 到 tk  的字符显然是不重复的，并且由于少了原本的第 k 个字符，我们可以尝试继续增大 tk，直到右侧出现了重复字符为止</p>
<p>这样一来，我们就可以使用「滑动窗口」来解决这个问题了：</p>
<ul>
<li>我们使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的 rk</li>
<li>在每一步的操作中，我们会将左指针向右移动一格，表示 我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 以左指针开始的，不包含重复字符的最长子串。我们记录下这个子串的长度</li>
<li>在枚举结束后，我们找到的最长的子串的长度即为答案</li>
</ul>
<p>判断重复字符：</p>
<p>在上面的流程中，我们还需要使用一种数据结构来判断 是否有重复的字符，常用的数据结构为哈希集合（即 <code>C++</code>中的 <code>std::unordered_set</code>，<code>Java</code> 中的 <code>HashSet</code>，<code>Python</code> 中的 <code>set</code> , <code>JavaScript</code> 中的 <code>Set</code>）。在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，我们往哈希集合中添加一个字符</p>
<p>至此，我们就完美解决了本题</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N 是字符串的长度。左指针和右指针分别会遍历整个字符串一次</li>
<li>空间复杂度：O(∣Σ∣)，其中Σ 表示字符集（即字符串中可以出现的字符），∣Σ∣ 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 [0,128) 内的字符，即 ∣Σ∣&#x3D;128。我们需要用到哈希集合来存储出现过的字符，而字符最多有 ∣Σ∣ 个，因此空间复杂度为 O(∣Σ∣)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 哈希集合，记录每个字符串是否出现过</span></span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="comment">// 右指针，初始值为-1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">    rk, ans := <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 左指针向右移动一格，移除一个字符串</span></span><br><span class="line">            <span class="built_in">delete</span>(m, s[i - <span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> rk + <span class="number">1</span> &lt; n &amp;&amp; m[s[rk + <span class="number">1</span>]] == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 不断的移动右指针</span></span><br><span class="line">            m[s[rk + <span class="number">1</span>]]++</span><br><span class="line">            rk++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第i到rk个字符是一个极长的无重复字符子串</span></span><br><span class="line">        ans = max(ans, rk - i + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-数组中的第K个最大元素（Go）215-中等"><a href="#9-数组中的第K个最大元素（Go）215-中等" class="headerlink" title="9. 数组中的第K个最大元素（Go）215-中等"></a>9. 数组中的第K个最大元素（Go）215-中等</h4><p><strong>题目：</strong></p>
<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素</p>
<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入<span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span> 和 k = <span class="number">2</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="number">5</span></span><br><span class="line">输入<span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">]</span> 和 k = <span class="number">4</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= nums.length &lt;= 10的4次方</code></li>
<li><code>-10的4次方 &lt;= nums[i] &lt;= 10的4次方</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：基于快速排序的选择方法</p>
<p>思路和算法</p>
<p>我们可以用快速排序来解决这个问题，先对原数组排序，再返回倒数第 k 个位置，这样平均时间复杂度是 O(nlogn)，但其实我们可以做的更快</p>
<p>首先我们来回顾一下快速排序，这是一个典型的分治算法。我们对数组 a[l⋯r] 做快速排序的过程是（参考《算法导论》）：</p>
<ul>
<li>分解： 将数组 a[l⋯r] 「划分」成两个子数组 a[l⋯q−1]、a[q+1⋯r]，使得 a[l⋯q−1] 中的每个元素小于等于 a[q]，且 a[q] 小于等于 a[q+1⋯r] 中的每个元素。其中，计算下标 q 也是「划分」过程的一部分</li>
<li>解决： 通过递归调用快速排序，对子数组 a[l⋯q−1] 和 a[q+1⋯r] 进行排序</li>
<li>合并： 因为子数组都是原址排序的，所以不需要进行合并操作，a[l⋯r] 已经有序</li>
<li>上文中提到的 「划分」 过程是：从子数组 a[l⋯r] 中选择任意一个元素 x 作为主元，调整子数组的元素使得左边的元素都小于等于它，右边的元素都大于等于它， x 的最终位置就是 q</li>
</ul>
<p>由此可以发现每次经过「划分」操作后，我们一定可以确定一个元素的最终位置，即 x 的最终位置为 q，并且保证 a[l⋯q−1] 中的每个元素小于等于 a[q]，且 a[q] 小于等于 a[q+1⋯r] 中的每个元素。所以只要某次划分的 q 为倒数第 k 个下标的时候，我们就已经找到了答案。 我们只关心这一点，至于 a[l⋯q−1] 和 a[q+1⋯r] 是否是有序的，我们不关心</p>
<p>因此我们可以改进快速排序算法来解决这个问题：在分解的过程当中，我们会对子数组进行划分，如果划分得到的 q 正好就是我们需要的下标，就直接返回 a[q]；否则，如果 q 比目标下标小，就递归右子区间，否则递归左子区间。这样就可以把原来递归两个区间变成只递归一个区间，提高了时间效率。这就是「快速选择」算法</p>
<p>我们知道快速排序的性能和「划分」出的子数组的长度密切相关。直观地理解如果每次规模为 n 的问题我们都划分成 1 和 n−1，每次递归的时候又向 n−1 的集合中递归，这种情况是最坏的，时间代价是 O n的2次方。我们可以引入随机化来加速这个过程，它的时间代价的期望是 O(n)，证明过程可以参考「《算法导论》9.2：期望为线性的选择算法」</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)，如上文所述，证明过程可以参考「《算法导论》9.2：期望为线性的选择算法」</li>
<li>空间复杂度：O(logn)，递归使用栈空间的空间代价的期望为 O(logn)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthLargest</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>, <span class="built_in">len</span>(nums) - k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSelect</span><span class="params">(a []<span class="type">int</span>, l, r, index <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    q := randomPartition(a, l, r)</span><br><span class="line">    <span class="keyword">if</span> q == index &#123;</span><br><span class="line">        <span class="keyword">return</span> a[q]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> q &lt; index &#123;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(a, q + <span class="number">1</span>, r, index)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSelect(a, l, q - <span class="number">1</span>, index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomPartition</span><span class="params">(a []<span class="type">int</span>, l, r <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    i := rand.Int() % (r - l + <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">    a[i], a[r] = a[r], a[i]</span><br><span class="line">    <span class="keyword">return</span> partition(a, l, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(a []<span class="type">int</span>, l, r <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    x := a[r]</span><br><span class="line">    i := l - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; r; j ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> a[j] &lt;= x &#123;</span><br><span class="line">            i++</span><br><span class="line">            a[i], a[j] = a[j], a[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[i + <span class="number">1</span>], a[r] = a[r], a[i + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-字符串转换整数-8-中等"><a href="#10-字符串转换整数-8-中等" class="headerlink" title="10. 字符串转换整数 8-中等"></a>10. 字符串转换整数 8-中等</h4><p>题目：</p>
<p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C&#x2F;C++ 中的 <code>atoi</code> 函数</p>
<p>函数 <code>myAtoi(string s)</code> 的算法如下：</p>
<ol>
<li>读入字符串并丢弃无用的前导空格</li>
<li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正</li>
<li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略<br>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）</li>
<li>如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整</li>
<li>应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 </li>
<li>返回整数作为最终结果</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>本题中的空白字符只包括空格字符 <code>&#39; &#39;</code> </li>
<li>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong> 任何其他字符</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;42&quot;</span></span><br><span class="line">输出：<span class="number">42</span></span><br><span class="line">解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符</span><br><span class="line">第 <span class="number">1</span> 步：<span class="string">&quot;42&quot;</span>（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 <span class="number">2</span> 步：<span class="string">&quot;42&quot;</span>（当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;）</span><br><span class="line">         ^</span><br><span class="line">第 <span class="number">3</span> 步：<span class="string">&quot;42&quot;</span>（读入 <span class="string">&quot;42&quot;</span>）</span><br><span class="line">           ^</span><br><span class="line">解析得到整数 <span class="number">42</span></span><br><span class="line">由于 <span class="string">&quot;42&quot;</span> 在范围 <span class="punctuation">[</span><span class="number">-231</span><span class="punctuation">,</span> <span class="number">231</span> - <span class="number">1</span><span class="punctuation">]</span> 内，最终结果为 <span class="number">42</span></span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;   -42&quot;</span></span><br><span class="line">输出：<span class="number">-42</span></span><br><span class="line">解释：</span><br><span class="line">第 <span class="number">1</span> 步：<span class="string">&quot;   -42&quot;</span>（读入前导空格，但忽视掉）</span><br><span class="line">            ^</span><br><span class="line">第 <span class="number">2</span> 步：<span class="string">&quot;   -42&quot;</span>（读入 &#x27;-&#x27; 字符，所以结果应该是负数）</span><br><span class="line">             ^</span><br><span class="line">第 <span class="number">3</span> 步：<span class="string">&quot;   -42&quot;</span>（读入 <span class="string">&quot;42&quot;</span>）</span><br><span class="line">               ^</span><br><span class="line">解析得到整数 <span class="number">-42</span></span><br><span class="line">由于 <span class="string">&quot;-42&quot;</span> 在范围 <span class="punctuation">[</span><span class="number">-231</span><span class="punctuation">,</span> <span class="number">231</span> - <span class="number">1</span><span class="punctuation">]</span> 内，最终结果为 <span class="number">-42</span></span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;4193 with words&quot;</span></span><br><span class="line">输出：<span class="number">4193</span></span><br><span class="line">解释：</span><br><span class="line">第 <span class="number">1</span> 步：<span class="string">&quot;4193 with words&quot;</span>（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 <span class="number">2</span> 步：<span class="string">&quot;4193 with words&quot;</span>（当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;）</span><br><span class="line">         ^</span><br><span class="line">第 <span class="number">3</span> 步：<span class="string">&quot;4193 with words&quot;</span>（读入 <span class="string">&quot;4193&quot;</span>；由于下一个字符不是一个数字，所以读入停止）</span><br><span class="line">             ^</span><br><span class="line">解析得到整数 <span class="number">4193</span></span><br><span class="line">由于 <span class="string">&quot;4193&quot;</span> 在范围 <span class="punctuation">[</span><span class="number">-231</span><span class="punctuation">,</span> <span class="number">231</span> - <span class="number">1</span><span class="punctuation">]</span> 内，最终结果为 <span class="number">4193</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 200</code></li>
<li><code>s</code> 由英文字母（大写和小写）、数字（<code>0-9</code>）、<code>&#39; &#39;</code>、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code> 和 <code>&#39;.&#39;</code> 组成</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：自动机</p>
<p>思路</p>
<p>字符串处理的题目往往涉及复杂的流程以及条件情况，如果直接上手写程序，一不小心就会写出极其臃肿的代码</p>
<p>因此，为了有条理地分析每个输入字符的处理方法，我们可以使用自动机这个概念：</p>
<p>我们的程序在每个时刻有一个状态 <code>s</code>，每次从序列中输入一个字符 <code>c</code>，并根据字符 <code>c</code> 转移到下一个状态 <code>s</code>。这样，我们只需要建立一个覆盖所有情况的从 <code>s</code> 与 <code>c</code> 映射到 <code>s</code> 的表格即可解决题目中的问题</p>
<p>算法</p>
<p>本题可以建立如下图所示的自动机：</p>
<p>我们也可以用下面的表格来表示这个自动机：</p>
<p>接下来编程部分就非常简单了：我们只需要把上面这个状态转换表抄进代码即可</p>
<p>另外自动机也需要记录当前已经输入的数字，只要在 <code>s</code> 为 <code>in_number</code> 时，更新我们输入的数字，即可最终得到输入的数字</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 nn 为字符串的长度。我们只需要依次处理所有的字符，处理每个字符需要的时间为 O(1)</li>
<li>空间复杂度：O(1)。自动机的状态只需要常数空间存储</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">myAtoi</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">min</span>(<span class="built_in">int</span>(*re.findall(<span class="string">&#x27;^[\+\-]?\d+&#x27;</span>, s.lstrip())), <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>), -<span class="number">2</span>**<span class="number">31</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INT_MAX = <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span></span><br><span class="line">INT_MIN = -<span class="number">2</span> ** <span class="number">31</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Automaton</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.state = <span class="string">&#x27;start&#x27;</span></span><br><span class="line">        self.sign = <span class="number">1</span></span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line">        self.table = &#123;</span><br><span class="line">            <span class="string">&#x27;start&#x27;</span>: [<span class="string">&#x27;start&#x27;</span>, <span class="string">&#x27;signed&#x27;</span>, <span class="string">&#x27;in_number&#x27;</span>, <span class="string">&#x27;end&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;signed&#x27;</span>: [<span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;in_number&#x27;</span>, <span class="string">&#x27;end&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;in_number&#x27;</span>: [<span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;in_number&#x27;</span>, <span class="string">&#x27;end&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;end&#x27;</span>: [<span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>],</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_col</span>(<span class="params">self, c</span>):</span><br><span class="line">        <span class="keyword">if</span> c.isspace():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&#x27;+&#x27;</span> <span class="keyword">or</span> c == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> c.isdigit():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, c</span>):</span><br><span class="line">        self.state = self.table[self.state][self.get_col(c)]</span><br><span class="line">        <span class="keyword">if</span> self.state == <span class="string">&#x27;in_number&#x27;</span>:</span><br><span class="line">            self.ans = self.ans * <span class="number">10</span> + <span class="built_in">int</span>(c)</span><br><span class="line">            self.ans = <span class="built_in">min</span>(self.ans, INT_MAX) <span class="keyword">if</span> self.sign == <span class="number">1</span> <span class="keyword">else</span> <span class="built_in">min</span>(self.ans, -INT_MIN)</span><br><span class="line">        <span class="keyword">elif</span> self.state == <span class="string">&#x27;signed&#x27;</span>:</span><br><span class="line">            self.sign = <span class="number">1</span> <span class="keyword">if</span> c == <span class="string">&#x27;+&#x27;</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">myAtoi</span>(<span class="params">self, <span class="built_in">str</span>: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        automaton = Automaton()</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">            automaton.get(c)</span><br><span class="line">        <span class="keyword">return</span> automaton.sign * automaton.ans</span><br></pre></td></tr></table></figure>

<h4 id="11-回文链表（Go）234-简单"><a href="#11-回文链表（Go）234-简单" class="headerlink" title="11. 回文链表（Go）234-简单"></a>11. 回文链表（Go）234-简单</h4><p><strong>题目：</strong></p>
<p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> </p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">true</span></span></span><br><span class="line">输入：head = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">false</span></span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点数目在范围<code>[1, 10^5]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：将值复制到数组中后用双指针法<br>思路</p>
<p>如果你还不太熟悉链表，下面有关于列表的概要讲述</p>
<p>有两种常用的列表实现，分别为数组列表和链表。如果我们想在列表中存储值，它们是如何实现的呢</p>
<ul>
<li>数组列表底层是使用数组存储值，我们可以通过索引在 O(1) 的时间访问列表任何位置的值，这是由基于内存寻址的方式</li>
<li>链表存储的是称为节点的对象，每个节点保存一个值和指向下一个节点的指针。访问某个特定索引的节点需要 O(n) 的时间，因为要通过指针获取到下一个位置的节点</li>
</ul>
<p>确定数组列表是否回文很简单，我们可以使用双指针法来比较两端的元素，并向中间移动。一个指针从起点向中间移动，另一个指针从终点向中间移动。这需要 O(n) 的时间，因为访问每个元素的时间是 O(1)，而有 n 个元素要访问</p>
<p>然而同样的方法在链表上操作并不简单，因为不论是正向访问还是反向访问都不是 O(1)。而将链表的值复制到数组列表中是 O(n)，因此最简单的方法就是将链表的值复制到数组列表中，再使用双指针法判断</p>
<p>算法</p>
<p>一共为两个步骤：</p>
<ol>
<li>复制链表值到数组列表中</li>
<li>使用双指针法判断是否为回文</li>
</ol>
<p>第一步，我们需要遍历链表将值复制到数组列表中。我们用 <code>currentNode</code> 指向当前节点。每次迭代向数组添加 <code>currentNode.val</code>，并更新 <code>currentNode = currentNode.next</code>，当 currentNode &#x3D; null&#96; 时停止循环</p>
<p>执行第二步的最佳方法取决于你使用的语言。在 Python 中，很容易构造一个列表的反向副本，也很容易比较两个列表。而在其他语言中，就没有那么简单。因此最好使用双指针法来检查是否为回文。我们在起点放置一个指针，在结尾放置一个指针，每一次迭代判断两个指针指向的元素是否相同，若不同，返回 <code>false</code>；相同则将两个指针向内移动，并继续判断，直到两个指针相遇</p>
<p>在编码的过程中，注意我们比较的是节点值的大小，而不是节点本身。正确的比较方式是：<code>node_1.val == node_2.val</code>，而 <code>node_1 == node_2</code> 是错误的</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li><p>时间复杂度：O(n)，其中 n 指的是链表的元素个数</p>
<ul>
<li>第一步： 遍历链表并将值复制到数组中，O(n)</li>
<li>第二步：双指针判断是否为回文，执行了 O(n&#x2F;2) 次的判断，即 O(n)</li>
<li>总的时间复杂度：O(2n)&#x3D;O(n)</li>
</ul>
</li>
<li><p>空间复杂度：O(n)，其中 nn 指的是链表的元素个数，我们使用了一个数组列表存放链表的元素值</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(head *ListNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    vals := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> ; head != <span class="literal">nil</span>; head = head.Next &#123;</span><br><span class="line">        vals = <span class="built_in">append</span>(vals, head.Val)</span><br><span class="line">    &#125;</span><br><span class="line">    n := <span class="built_in">len</span>(vals)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> vals[:n / <span class="number">2</span>] &#123;</span><br><span class="line">        <span class="keyword">if</span> v != vals[n - <span class="number">1</span> - i] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-用Rand7-实现Rand10-（Go）470-中等"><a href="#12-用Rand7-实现Rand10-（Go）470-中等" class="headerlink" title="12. 用Rand7()实现Rand10()（Go）470-中等"></a>12. 用Rand7()实现Rand10()（Go）470-中等</h4><p><strong>题目：</strong></p>
<p>给定方法 <code>rand7</code> 可生成 <code>[1,7]</code> 范围内的均匀随机整数，试写一个方法 <code>rand10</code> 生成 <code>[1,10]</code> 范围内的均匀随机整数</p>
<p>你只能调用 <code>rand7()</code> 且不能调用其他方法。请不要使用系统的 <code>Math.random()</code> 方法</p>
<p>每个测试用例将有一个内部参数 <code>n</code>，即你实现的函数 <code>rand10()</code> 在测试时将被调用的次数。请注意，这不是传递给 <code>rand10()</code> 的参数</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入<span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">输入<span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">]</span></span><br><span class="line">输入<span class="punctuation">:</span> <span class="number">3</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">,</span><span class="number">10</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
</ul>
<p><strong>思想：</strong></p>
<p>方法一：拒绝采样</p>
<p>思路与算法</p>
<p>我们可以用拒绝采样的方法实现 Rand10()。在拒绝采样中，如果生成的随机数满足要求，那么就返回该随机数，否则会不断生成，直到生成一个满足要求的随机数为止</p>
<ul>
<li>我们只需要能够满足等概率的生成 10 个不同的数即可，具体的生成方法可以有很多种，比如我们可以利用两个 Rand7() 相乘，我们只取其中等概率的 10 个不同的数的组合即可，当然还有许多其他不同的解法，可以利用各种运算和函数的组合等方式来实现<ul>
<li>比如我们可以利用两个Rand7()相乘，分别可以得到结果如下：一大个表格</li>
<li>我们可以得到每个数生成的概率为：一大个表格</li>
<li>我们可以从中挑选 10个等概率的数即可</li>
</ul>
</li>
<li>题目中要求尽可能的减少 Rand7() 的调用次数，则我们应该尽量保证生成的每个不同的数的生成概率尽可能的大，即调用 Rand7() 期望次数尽可能的小</li>
<li>我们可以调用两次 Rand7()，那么可以生成 [1,49] 之间的随机整数，我们只用到其中的前 40 个用来实现 Rand10()，而拒绝剩下的 9 个数，如下图所示</li>
<li>我们可以看到表中的 [1,49] 每个数生成的概率为49分之1。我们实际上只取 [1,40] 这前 40 个数，转化为 [1,10] 时，这 10 个数中每个数的生成概率则为 49分之1</li>
</ul>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：期望时间复杂度为 O(1)，但最坏情况下会达到 O*(∞)（一直被拒绝）</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rand10</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        row := rand7()</span><br><span class="line">        col := rand7()</span><br><span class="line">        idx := (row - <span class="number">1</span>) * <span class="number">7</span> + col</span><br><span class="line">        <span class="keyword">if</span> idx &lt;= <span class="number">40</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + (idx - <span class="number">1</span>) % <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="13-两数之和（Go）1-简单"><a href="#13-两数之和（Go）1-简单" class="headerlink" title="13. 两数之和（Go）1-简单"></a>13. 两数之和（Go）1-简单</h4><p>题目：</p>
<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 和为目标值 <code>target</code>  的那 两个 整数，并返回它们的数组下标</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现</p>
<p>你可以按任意顺序返回答案</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">11</span><span class="punctuation">,</span><span class="number">15</span><span class="punctuation">]</span><span class="punctuation">,</span> target = <span class="number">9</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">解释：因为 nums<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span> + nums<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> == <span class="number">9</span> ，返回 <span class="punctuation">[</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">,</span> target = <span class="number">6</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">,</span> target = <span class="number">6</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 10^4</code></li>
<li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li>
<li><code>-10^9 &lt;= target &lt;= 10^9</code></li>
<li><strong>只会存在一个有效答案</strong></li>
</ul>
<p><strong>思想：</strong></p>
<p>方法二：哈希表</p>
<p>思路及算法</p>
<p>注意到方法一的时间复杂度较高的原因是寻找 <code>target - x</code> 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引</p>
<p>使用哈希表，可以将寻找 <code>target - x</code> 的时间复杂度降低到从 O(N) 降低到 O(1)</p>
<p>这样我们创建一个哈希表，对于每一个 <code>x</code>，我们首先查询哈希表中是否存在 <code>target - x</code>，然后将 <code>x</code> 插入到哈希表中，即可保证不会让 <code>x</code> 和自己匹配</p>
<p><strong>复杂度分析：</strong></p>
<p>时间复杂度：O(N)，其中 NN 是数组中的元素数量。对于每一个元素 <code>x</code>，我们可以 O(1) 地寻找 <code>target - x</code></p>
<p>空间复杂度：O(N)，其中 N 是数组中的元素数量。主要为哈希表的开销</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    hashTable := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> p, ok := hashTable[target - x]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;p, i&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        hashTable[x] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="14-爬楼梯（Go）70-简单"><a href="#14-爬楼梯（Go）70-简单" class="headerlink" title="14. 爬楼梯（Go）70-简单"></a>14. 爬楼梯（Go）70-简单</h4><p><strong>题目：</strong></p>
<p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：有两种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1.</span> <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span> <span class="number">2</span> 阶</span><br><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：有三种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1.</span> <span class="number">1</span> 阶 + <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span> <span class="number">1</span> 阶 + <span class="number">2</span> 阶</span><br><span class="line"><span class="number">3.</span> <span class="number">2</span> 阶 + <span class="number">1</span> 阶</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 45</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：动态规划</p>
<p>思路和算法</p>
<p>我们用 f(x) 表示爬到第 x 级台阶的方案数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，所以我们可以列出如下式子：<br>f(x)&#x3D;f(x−1)+f(x−2)</p>
<p>它意味着爬到第 x 级台阶的方案数是爬到第 x−1 级台阶的方案数和爬到第 x−2 级台阶的方案数的和。很好理解，因为每次只能爬 1 级或 2 级，所以 f(x) 只能从 f(x−1) 和 f(x−2) 转移过来，而这里要统计方案总数，我们就需要对这两项的贡献求和</p>
<p>以上是动态规划的转移方程，下面我们来讨论边界条件。我们是从第 0 级开始爬的，所以从第 0 级爬到第 0 级我们可以看作只有一种方案，即 f(0)&#x3D;1；从第 0 级到第 1 级也只有一种方案，即爬一级，f(1)&#x3D;1。这两个作为边界条件就可以继续向后推导出第 n 级的正确结果</p>
<p>我们不妨写几项来验证一下，根据转移方程得到 f(2)&#x3D;2，f(3)&#x3D;3，f(4)&#x3D;5，……，我们把这些情况都枚举出来，发现计算的结果是正确的</p>
<p>我们不难通过转移方程和边界条件给出一个时间复杂度和空间复杂度都是 O(n) 的实现，但是由于这里的 f(x) 只和 f(x−1) 与 f(x−2) 有关，所以我们可以用「滚动数组思想」把空间复杂度优化成 O(1)。下面的代码中给出的就是这种实现</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：循环执行 n 次，每次花费常数的时间代价，故渐进时间复杂度为 O(n)</li>
<li>空间复杂度：这里只用了常数个变量作为辅助空间，故渐进空间复杂度为 O(1)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    p, q, r := <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        p = q</span><br><span class="line">        q = r</span><br><span class="line">        r = p + q</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-最长递增子系列（Go）-300-中等"><a href="#15-最长递增子系列（Go）-300-中等" class="headerlink" title="15. 最长递增子系列（Go） 300-中等"></a>15. 最长递增子系列（Go） 300-中等</h4><p><strong>题目：</strong></p>
<p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度</p>
<p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">10</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">101</span><span class="punctuation">,</span><span class="number">18</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：最长递增子序列是 <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">101</span><span class="punctuation">]</span>，因此长度为 <span class="number">4</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">7</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2500</code></li>
<li><code>-10的4次方 &lt;= nums[i] &lt;= 10的4次方</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：动态规划</p>
<p>思路与算法</p>
<p>定义 dp[i] 为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取</p>
<p>我们从小到大计算 dp 数组的值，在计算 dp[i] 之前，我们已经计算出 dp[0…i−1] 的值，则状态转移方程为：<br>dp[i] &#x3D; max(dp[j]) + 1，其中0&lt;&#x3D;j&lt;i并且num[j]&lt;num[i]</p>
<p>即考虑往 dp[0…i−1] 中最长的上升子序列后面再加一个 nums[i]。由于 dp[j] 代表 nums[0…j] 中以 nums[j] 结尾的最长上升子序列，所以如果能从 dp[j] 这个状态转移过来，那么 nums[i] 必然要大于 nums[j]，才能将 nums[i] 放在 nums[j] 后面以形成更长的上升子序列</p>
<p>最后，整个数组的最长上升子序列即所有 dp[i] 中的最大值</p>
<p>LISlength &#x3D; max(dp[i])，其中0&lt;&#x3D;i&lt;n</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n的2次方)，其中 n 为数组 nums 的长度。动态规划的状态数为 n，计算状态 dp[i] 时，需要 O(n) 的时间遍历 dp[0…i−1] 的所有状态，所以总时间复杂度为 O(n的2次方)</li>
<li>空间复杂度：O(n)，需要额外使用长度为 n 的 dp 数组</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">func LengthOfList(nums []<span class="built_in">int</span>) <span class="built_in">int</span> &#123;</span><br><span class="line">	// 定义dp[i]标识以nums[i]这个数据结尾的最长递增子系列的长度</span><br><span class="line">	dp := make([]<span class="built_in">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">	ans := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(dp); i++ &#123;</span><br><span class="line">		dp[i] = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">		<span class="keyword">for</span> k := <span class="number">0</span>; k &lt; j; k++ &#123;</span><br><span class="line">			<span class="keyword">if</span> nums[j] &gt; nums[k] &#123;</span><br><span class="line">				<span class="keyword">if</span> dp[j] &lt; dp[k]+<span class="number">1</span> &#123;</span><br><span class="line">					dp[j] = dp[k] + <span class="number">1</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="built_in">range</span> dp &#123;</span><br><span class="line">		<span class="keyword">if</span> v &gt; ans &#123;</span><br><span class="line">			ans = v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	nums := []<span class="built_in">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">11</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;结果为：&quot;</span>, LengthOfList(nums))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="16-有效的括号（Go）20-简单"><a href="#16-有效的括号（Go）20-简单" class="headerlink" title="16. 有效的括号（Go）20-简单"></a>16. 有效的括号（Go）20-简单</h4><p><strong>题目：</strong></p>
<p>给定一个只包括 <code>&#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合</li>
<li>左括号必须以正确的顺序闭合</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;()&quot;</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">true</span></span></span><br><span class="line">输入：s = <span class="string">&quot;()[]&#123;&#125;&quot;</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">true</span></span></span><br><span class="line">输入：s = <span class="string">&quot;(]&quot;</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">false</span></span></span><br><span class="line">输入：s = <span class="string">&quot;([)]&quot;</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">false</span></span></span><br><span class="line">输入：s = <span class="string">&quot;&#123;[]&#125;&quot;</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">true</span></span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10^4</code></li>
<li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：栈</p>
<p>判断括号的有效性可以使用「栈」这一数据结构来解决</p>
<p>我们遍历给定的字符串 s。当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶</p>
<p>当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串 s 无效，返回 False。为了快速判断括号的类型，我们可以使用哈希表存储每一种括号。哈希表的键为右括号，值为相同类型的左括号</p>
<p>在遍历结束后，如果栈中没有左括号，说明我们将字符串 s 中的所有左括号闭合，返回 True，否则返回 False</p>
<p>注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 False，省去后续的遍历判断过程</p>
<div align="center"><img src="https://i.bmp.ovh/imgs/2022/06/22/f79a7d99292db85e.png" style="zoom:50%;" /></div>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 是字符串 s 的长度</li>
<li>空间复杂度：O(n+∣Σ∣)，其中 Σ 表示字符集，本题中字符串只包含 6 种括号，∣Σ∣&#x3D;6。栈中的字符数量为 O(n)，而哈希表使用的空间为 O(∣Σ∣)，相加即可得到总空间复杂度</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    pairs := <span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">byte</span>&#123;</span><br><span class="line">        <span class="string">&#x27;)&#x27;</span>:<span class="string">&#x27;(&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;]&#x27;</span>:<span class="string">&#x27;[&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>:<span class="string">&#x27;&#123;&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    stack := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> pairs[s[i]] &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> || stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>] != pairs[s[i]] &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, s[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="17-环形链表（Go）141-简单"><a href="#17-环形链表（Go）141-简单" class="headerlink" title="17. 环形链表（Go）141-简单"></a>17. 环形链表（Go）141-简单</h4><p><strong>题目：</strong></p>
<p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环</p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：<code>pos</code> 不作为参数进行传递 。仅仅是为了标识链表的实际情况</p>
<p>如果链表中存在环 ，则返回 <code>true</code> 。 否则，返回 <code>false</code> </p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">-4</span><span class="punctuation">]</span><span class="punctuation">,</span> pos = <span class="number">1</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">true</span></span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点</span><br><span class="line">输入：head = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> pos = <span class="number">0</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">true</span></span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点</span><br><span class="line">输入：head = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> pos = <span class="number">-1</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">false</span></span></span><br><span class="line">解释：链表中没有环</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 10^4]</code></li>
<li><code>-10^5&lt;= Node.val &lt;= 10^5</code></li>
<li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：哈希表<br>思路及算法</p>
<p>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过</p>
<p>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N 是链表中的节点数。最坏情况下我们需要遍历每个节点一次</li>
<li>空间复杂度：O(N)，其中 N 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    seen := <span class="keyword">map</span>[*ListNode]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> _, ok := seen[head]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        seen[head] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        head = head.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="18-寻找旋转排序数组中的最小值（Go）153-中等"><a href="#18-寻找旋转排序数组中的最小值（Go）153-中等" class="headerlink" title="18. 寻找旋转排序数组中的最小值（Go）153-中等"></a>18. 寻找旋转排序数组中的最小值（Go）153-中等</h4><p><strong>题目：</strong></p>
<p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 旋转 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p>
<ul>
<li>若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]</li>
<li>若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]</li>
</ul>
<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 旋转一次 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> </p>
<p>给你一个元素值 互不相同 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 </p>
<p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：原数组为 <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span> ，旋转 <span class="number">3</span> 次得到输入数组</span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：原数组为 <span class="punctuation">[</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">]</span> ，旋转 <span class="number">4</span> 次得到输入数组</span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">11</span><span class="punctuation">,</span><span class="number">13</span><span class="punctuation">,</span><span class="number">15</span><span class="punctuation">,</span><span class="number">17</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">11</span></span><br><span class="line">解释：原数组为 <span class="punctuation">[</span><span class="number">11</span><span class="punctuation">,</span><span class="number">13</span><span class="punctuation">,</span><span class="number">15</span><span class="punctuation">,</span><span class="number">17</span><span class="punctuation">]</span> ，旋转 <span class="number">4</span> 次得到输入数组</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 5000</code></li>
<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>
<li><code>nums</code> 中的所有整数 互不相同</li>
<li><code>nums</code> 原来是一个升序排序的数组，并进行了 1 至 n 次旋转</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：二分查找</p>
<p>思路与算法</p>
<p>一个不包含重复元素的升序数组在经过旋转之后，可以得到下面可视化的折线图：</p>
<p>其中横轴表示数组元素的下标，纵轴表示数组元素的值。图中标出了最小值的位置，是我们需要查找的目标</p>
<p>我们考虑数组中的最后一个元素 x：在最小值右侧的元素（不包括最后一个元素本身），它们的值一定都严格小于 x；而在最小值左侧的元素，它们的值一定都严格大于 x。因此，我们可以根据这一条性质，通过二分查找的方法找出最小值</p>
<p>在二分查找的每一步中，左边界为 low，右边界为 high，区间的中点为 pivot，最小值就在该区间内。我们将中轴元素 nums[pivot] 与右边界元素 nums[high] 进行比较，可能会有以下的三种情况：</p>
<p>第一种情况是 nums[pivot]&lt;nums[high]。如下图所示，这说明 nums[pivot] 是最小值右侧的元素，因此我们可以忽略二分查找区间的右半部分</p>
<p>第二种情况是 nums[pivot]&gt;nums[high]。如下图所示，这说明 nums[pivot] 是最小值左侧的元素，因此我们可以忽略二分查找区间的左半部分</p>
<p>由于数组不包含重复元素，并且只要当前的区间长度不为 1，pivot 就不会与 high 重合；而如果当前的区间长度为 1，这说明我们已经可以结束二分查找了。因此不会存在 nums[pivot]&#x3D;nums[high] 的情况</p>
<p>当二分查找结束时，我们就得到了最小值所在的位置</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：时间复杂度为 O(logn)，其中 nn 是数组 nums 的长度。在二分查找的过程中，每一步会忽略一半的区间，因此时间复杂度为 O(logn)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMin</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    low, high := <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> low &lt; high &#123;</span><br><span class="line">        pivot := low + (high - low) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[pivot] &lt; nums[high] &#123;</span><br><span class="line">            high = pivot</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = pivot + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[low]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="19-最长回文子串（Go）5-中等"><a href="#19-最长回文子串（Go）5-中等" class="headerlink" title="19. 最长回文子串（Go）5-中等"></a>19. 最长回文子串（Go）5-中等</h4><p><strong>题目：</strong></p>
<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;babad&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bab&quot;</span></span><br><span class="line">解释：<span class="string">&quot;aba&quot;</span> 同样是符合题意的答案</span><br><span class="line">输入：s = <span class="string">&quot;cbbd&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bb&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 仅由数字和英文字母组成</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法二：中心扩展算法</p>
<p>思路与算法</p>
<p>我们仔细观察一下方法一中的状态转移方程：</p>
<p>P(i,i) &#x3D; true<br>P(i,i+1) &#x3D; (Si&#x3D;&#x3D;Si+1)</p>
<p>P(i,j) &#x3D; P(i+1, j+1)^(Si&#x3D;&#x3D;Sj)</p>
<p>找出其中的状态转移链：</p>
<p><em>P</em>(<em>i</em>,<em>j</em>)←<em>P</em>(<em>i</em>+1,<em>j</em>−1)←<em>P</em>(<em>i</em>+2,<em>j</em>−2)←⋯←某一边界情况</p>
<p>可以发现，所有的状态在转移的时候的可能性都是唯一的。也就是说，我们可以从每一种边界情况开始「扩展」，也可以得出所有的状态对应的答案</p>
<p>边界情况即为子串长度为 1 或 2 的情况。我们枚举每一种边界情况，并从对应的子串开始不断地向两边扩展。如果两边的字母相同，我们就可以继续扩展，例如从 P(i+1,j−1) 扩展到 P(i,j)；如果两边的字母不同，我们就可以停止扩展，因为在这之后的子串都不能是回文串了</p>
<p>聪明的读者此时应该可以发现，「边界情况」对应的子串实际上就是我们「扩展」出的回文串的「回文中心」。方法二的本质即为：我们枚举所有的「回文中心」并尝试「扩展」，直到无法扩展为止，此时的回文串长度即为此「回文中心」下的最长回文串长度。我们对所有的长度求出最大值，即可得到最终的答案</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n的2次方)，其中 n 是字符串的长度。长度为 1 和 2 的回文中心分别有 n 和 n−1 个，每个回文中心最多会向外扩展 O(n) 次</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    start, end := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        left1, right1 := expandAroundCenter(s, i ,i)</span><br><span class="line">        left2, right2 := expandAroundCenter(s, i, i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> right1 - left1 &gt; end - start &#123;</span><br><span class="line">            start, end = left1, right1</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> right2 - left2 &gt; end - start &#123;</span><br><span class="line">            start ,end = left2, right2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s[start:end + <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">expandAroundCenter</span><span class="params">(s <span class="type">string</span>, left, right <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> ; left &gt;= <span class="number">0</span> &amp;&amp; right &lt; <span class="built_in">len</span>(s) &amp;&amp; s[left] == s[right]; </span><br><span class="line">    left, right = left - <span class="number">1</span>, right + <span class="number">1</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">return</span> left + <span class="number">1</span>, right - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="20-最长公共子序列（Go）1143-中等"><a href="#20-最长公共子序列（Go）1143-中等" class="headerlink" title="20. 最长公共子序列（Go）1143-中等"></a>20. 最长公共子序列（Go）1143-中等</h4><p><strong>题目：</strong></p>
<p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 </p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串</p>
<ul>
<li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列</li>
</ul>
<p>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：text1 = <span class="string">&quot;abcde&quot;</span><span class="punctuation">,</span> text2 = <span class="string">&quot;ace&quot;</span> </span><br><span class="line">输出：<span class="number">3</span>  </span><br><span class="line">解释：最长公共子序列是 <span class="string">&quot;ace&quot;</span> ，它的长度为 <span class="number">3</span></span><br><span class="line">输入：text1 = <span class="string">&quot;abc&quot;</span><span class="punctuation">,</span> text2 = <span class="string">&quot;abc&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：最长公共子序列是 <span class="string">&quot;abc&quot;</span> ，它的长度为 <span class="number">3</span></span><br><span class="line">输入：text1 = <span class="string">&quot;abc&quot;</span><span class="punctuation">,</span> text2 = <span class="string">&quot;def&quot;</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：两个字符串没有公共子序列，返回 <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li>
<li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：动态规划<br>最长公共子序列问题是典型的二维动态规划问题</p>
<p>假设字符串 text 1和 text2的长度分别为 m 和 n，创建 m+1 行 n+1 列的二维数组 dp，其中 dp[i] [j]表示 text1[0:i] 和 text2[0:j] 的最长公共子序列的长度</p>
<p>上述表示中，text1[0:i] 表示 text1的长度为 i 的前缀，text2[0:j] 表示 text2的长度为 j 的前缀</p>
<p>考虑动态规划的边界情况：</p>
<ul>
<li>当 i&#x3D;0 时，text1[0:i] 为空，空字符串和任何字符串的最长公共子序列的长度都是 0，因此对任意 0≤j≤n，有 dp[0] [j]&#x3D;0</li>
<li>当 j&#x3D;0 时，text2 [0:j] 为空，同理可得，对任意 0≤i≤m，有 dp[i] [0]&#x3D;0</li>
</ul>
<p>因此动态规划的边界情况是：当 i&#x3D;0 或 j&#x3D;0 时，dp[i] [j]&#x3D;0</p>
<p>当 i&gt;0 且 j&gt;0 时，考虑 dp[i] [j] 的计算：</p>
<ul>
<li>当text1[i-1]!&#x3D;text2[j-1]时，将这两个相同的字符称为公共字符，考虑text1[0:i-1]和text2[0:j-1]的最长公共子序列，再增加一个字符（即公共字符）即可得到text1[0:i]和text2[0:j]的最长公共子序列，因此dp[i] [j]&#x3D;dp[i-1] [j-1]+1</li>
<li>当text1[i-1]!&#x3D;text2[j-1]时，考虑以下两项：<ul>
<li>text1[0:i-1]和text2[0:j]的最长公共子序列</li>
<li>text1[0:i]和text2[0:j-1]的最长公共子系列</li>
</ul>
</li>
</ul>
<p>要得到text1[0:i]和text[o:j]的最长公共子系列，应取两项中的长度较大的一项，因此dp[i] [j]&#x3D;max(dp[i-1],dp[i][j-1])</p>
<p>由此可得到如下状态转移方程：</p>
<p>dp[i] [j]&#x3D;1:dp[i-1] [j-1]+1,text1[i-1]&#x3D;text2[j-1] 2:max(dp[i-1] [j],dp[i] [j-1]),text[i-1]!&#x3D;text[j-1]</p>
<p>最终计算得到db[m] [n] 即为text1和text2的最长公共子系列的长度</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(mn)，其中 m 和 n 分别是字符串 text1和 text 2的长度。二维数组 dp 有m+1 行和 n+1 列，需要对 dp 中的每个元素进行计算</li>
<li>空间复杂度：O(mn)，其中 m 和 n 分别是字符串 text1和 text 2的长度。创建了 m+1 行 n+1 列的二维数组 dp</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonSubsequence</span><span class="params">(text1 <span class="type">string</span>, text2 <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    m, n := <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, c1 := <span class="keyword">range</span> text1 &#123;</span><br><span class="line">        <span class="keyword">for</span> j, c2 := <span class="keyword">range</span> text2 &#123;</span><br><span class="line">            <span class="keyword">if</span> c1 == c2 &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j] + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = max(dp[i][j + <span class="number">1</span>], dp[i + <span class="number">1</span>][j]) </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="21-三数之和（Go）15-中等"><a href="#21-三数之和（Go）15-中等" class="headerlink" title="21. 三数之和（Go）15-中等"></a>21. 三数之和（Go）15-中等</h4><p><strong>题目：</strong></p>
<p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <code>a，b，c</code> ，使得 <code>a + b + c = 0</code> ？请你找出所有和为 <code>0</code> 且不重复的三元组。<strong>注意：</strong>答案中不可以包含重复的三元组</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">-1</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">-1</span><span class="punctuation">,</span><span class="number">-4</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="punctuation">[</span><span class="number">-1</span><span class="punctuation">,</span><span class="number">-1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="punctuation">[</span><span class="number">-1</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 3000</code></li>
<li><code>-10的5次方 &lt;= nums[i] &lt;= 10的5次方</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：排序 + 双指针</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(N的2次方)，其中 N 是数组 nums 的长度</li>
<li>空间复杂度：O(logN)。我们忽略存储答案的空间，额外的排序的空间复杂度为 O(logN)。然而我们修改了输入的数组 nums，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了 nums 的副本并进行排序，空间复杂度为 O(N)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    ans := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 枚举a</span></span><br><span class="line">    <span class="keyword">for</span> first := <span class="number">0</span>; first &lt; n; first++ &#123;</span><br><span class="line">        <span class="comment">// 需要和上一次枚举的数不同</span></span><br><span class="line">        <span class="keyword">if</span> first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first <span class="number">-1</span>] &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// c对应的指针初始指向数组的最右端</span></span><br><span class="line">        third := n - <span class="number">1</span></span><br><span class="line">        target := <span class="number">-1</span> * nums[first]</span><br><span class="line">        <span class="comment">// 枚举b</span></span><br><span class="line">        <span class="keyword">for</span> second := first + <span class="number">1</span>; second &lt; n; second++ &#123;</span><br><span class="line">            <span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">            <span class="keyword">if</span> second &gt; first + <span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 需要保证b的指针在c的指针左侧</span></span><br><span class="line">            <span class="keyword">for</span> second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target &#123;</span><br><span class="line">                third --</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果指针重合，随着b后续的增加，就不会有满足a+b+c=0并且b&lt;c的c了，可以退出循环</span></span><br><span class="line">            <span class="keyword">if</span> second == third &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> nums[second] + nums[third] == target &#123;</span><br><span class="line">                ans = <span class="built_in">append</span>(ans, []<span class="type">int</span>&#123;nums[first], nums[second], nums[third]&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="22-寻找两个正序数组的中位数（Go）4-困难"><a href="#22-寻找两个正序数组的中位数（Go）4-困难" class="headerlink" title="22. 寻找两个正序数组的中位数（Go）4-困难"></a>22. 寻找两个正序数组的中位数（Go）4-困难</h4><p><strong>题目：</strong></p>
<p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> </p>
<p>算法的时间复杂度应该为 <code>O(log (m+n))</code> </p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：nums1 = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">,</span> nums2 = <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">2.00000</span></span><br><span class="line">解释：合并数组 = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span> ，中位数 <span class="number">2</span></span><br><span class="line">===</span><br><span class="line">输入：nums1 = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> nums2 = <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">2.50000</span></span><br><span class="line">解释：合并数组 = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span> ，中位数 (<span class="number">2</span> + <span class="number">3</span>) / <span class="number">2</span> = <span class="number">2.5</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<p><strong>思路：</strong></p>
<p>方法一：二分查找</p>
<p>给定两个有序数组，要求找到两个有序数组的中位数，最直观的思路有以下两种：</p>
<ul>
<li>使用归并的方式，合并两个有序数组，得到一个大的有序数组。大的有序数组的中间位置的元素，即为中位数</li>
<li>不需要合并两个有序数组，只要找到中位数的位置即可。由于两个数组的长度已知，因此中位数对应的两个数组的下标之和也是已知的。维护两个指针，初始时分别指向两个数组的下标 00 的位置，每次将指向较小值的指针后移一位（如果一个指针已经到达数组末尾，则只需要移动另一个数组的指针），直到到达中位数的位置</li>
</ul>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(log(m+n))，其中 mm 和 nn 分别是数组nums1和 nums2的长度。初始时有 k&#x3D;(m+n)&#x2F;2 或 k&#x3D;(m+n)&#x2F;2+1，每一轮循环可以将查找范围减少一半，因此时间复杂度是 O(log(m+n))</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="type">int</span>, nums2 []<span class="type">int</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">	totalLength := <span class="built_in">len</span>(nums1) + <span class="built_in">len</span>(nums2)</span><br><span class="line">	<span class="keyword">if</span> totalLength%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">		midIndex := totalLength / <span class="number">2</span></span><br><span class="line">		<span class="keyword">return</span> <span class="type">float64</span>(getKthElement(nums1, nums2, midIndex+<span class="number">1</span>))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		midIndex1, midIndex2 := totalLength/<span class="number">2</span><span class="number">-1</span>, totalLength/<span class="number">2</span></span><br><span class="line">		<span class="keyword">return</span> <span class="type">float64</span>(getKthElement(nums1, nums2, midIndex1+<span class="number">1</span>)+getKthElement(nums1, nums2, midIndex2+<span class="number">1</span>)) / <span class="number">2.0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getKthElement</span><span class="params">(nums1, nums2 []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	index1, index2 := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> index1 == <span class="built_in">len</span>(nums1) &#123;</span><br><span class="line">			<span class="keyword">return</span> nums2[index2+k<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> index2 == <span class="built_in">len</span>(nums2) &#123;</span><br><span class="line">			<span class="keyword">return</span> nums1[index1+k<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> k == <span class="number">1</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> min(nums1[index1], nums2[index2])</span><br><span class="line">		&#125;</span><br><span class="line">		half := k / <span class="number">2</span></span><br><span class="line">		newIndex1 := min(index1+half, <span class="built_in">len</span>(nums1)) - <span class="number">1</span></span><br><span class="line">		newIndex2 := min(index2+half, <span class="built_in">len</span>(nums2)) - <span class="number">1</span></span><br><span class="line">		pivot1, pivot2 := nums1[newIndex1], nums2[newIndex2]</span><br><span class="line">		<span class="keyword">if</span> pivot1 &lt;= pivot2 &#123;</span><br><span class="line">			k -= (newIndex1 - index1 + <span class="number">1</span>)</span><br><span class="line">			index1 = newIndex1 + <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			k -= (newIndex2 - index2 + <span class="number">1</span>)</span><br><span class="line">			index2 = newIndex2 + <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>&#125;</span><br><span class="line">	nums2 := []<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;结果为：&quot;</span>, findMedianSortedArrays(nums1, nums2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="23-二叉树的层序遍历（Go）102-中等"><a href="#23-二叉树的层序遍历（Go）102-中等" class="headerlink" title="23. 二叉树的层序遍历（Go）102-中等"></a>23. 二叉树的层序遍历（Go）102-中等</h4><p><strong>题目：</strong></p>
<p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：root = <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">20</span><span class="punctuation">,</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="number">15</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="punctuation">[</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="punctuation">[</span><span class="number">9</span><span class="punctuation">,</span><span class="number">20</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="punctuation">[</span><span class="number">15</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">输入：root = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">输入：root = <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[0, 2000]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：广度优先搜索</p>
<p>思路和算法</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：每个点进队出队各一次，故渐进时间复杂度为 O(n)</li>
<li>空间复杂度：队列中元素的个数不超过 n 个，故渐进空间复杂度为 O(n)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeNode 定义二叉树</span></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Val   <span class="type">int</span></span><br><span class="line">	Left  *TreeNode</span><br><span class="line">	Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateNode 创建二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateNode</span><span class="params">(i <span class="type">int</span>, nums []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">	tree := &amp;TreeNode&#123;nums[i], <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">	<span class="comment">// 左节点的数组下标为1，,3，,5...2*i+1</span></span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(nums) &amp;&amp; <span class="number">2</span>*i+<span class="number">1</span> &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">		tree.Left = CreateNode(<span class="number">2</span>*i+<span class="number">1</span>, nums)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 右节点的数组下标为2,4,6...2*i+2</span></span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(nums) &amp;&amp; <span class="number">2</span>*i+<span class="number">2</span> &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">		tree.Right = CreateNode(<span class="number">2</span>*i+<span class="number">2</span>, nums)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LevelOrder 二叉树层序遍历（广度优先搜索）-中等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LevelOrder</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ret [][]<span class="type">int</span></span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ret</span><br><span class="line">	&#125;</span><br><span class="line">	q := []*TreeNode&#123;root&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; <span class="built_in">len</span>(q) &gt; <span class="number">0</span>; i++ &#123;</span><br><span class="line">		ret = <span class="built_in">append</span>(ret, []<span class="type">int</span>&#123;&#125;)</span><br><span class="line">		<span class="keyword">var</span> p []*TreeNode</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(q); j++ &#123;</span><br><span class="line">			node := q[j]</span><br><span class="line">			ret[i] = <span class="built_in">append</span>(ret[i], node.Val)</span><br><span class="line">			<span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">				p = <span class="built_in">append</span>(p, node.Left)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">				p = <span class="built_in">append</span>(p, node.Right)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		q = p</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PreorderTraversal 二叉树前序遍历（递归）-简单-根节点——左子树——右子树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PreorderTraversal</span><span class="params">(root *TreeNode)</span></span> (vals []<span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> preorder <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span></span><br><span class="line">	preorder = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		vals = <span class="built_in">append</span>(vals, node.Val)</span><br><span class="line">		preorder(node.Left)</span><br><span class="line">		preorder(node.Right)</span><br><span class="line">	&#125;</span><br><span class="line">	preorder(root)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InorderTraversal 二叉树中序遍历（递归）-简单-左子树——根节点——右子树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InorderTraversal</span><span class="params">(root *TreeNode)</span></span> (res []<span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> inorder <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span></span><br><span class="line">	inorder = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		inorder(node.Left)</span><br><span class="line">		res = <span class="built_in">append</span>(res, node.Val)</span><br><span class="line">		inorder(node.Right)</span><br><span class="line">	&#125;</span><br><span class="line">	inorder(root)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PostorderTraversal 二叉树后续遍历（递归）-简单-左子树——右子树——根节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PostorderTraversal</span><span class="params">(root *TreeNode)</span></span> (res []<span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> postorder <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span></span><br><span class="line">	postorder = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		postorder(node.Left)</span><br><span class="line">		postorder(node.Right)</span><br><span class="line">		res = <span class="built_in">append</span>(res, node.Val)</span><br><span class="line">	&#125;</span><br><span class="line">	postorder(root)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 0代表节点为空</span></span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line">	<span class="comment">// 将数组切片转化为二叉树结构体</span></span><br><span class="line">	tree := CreateNode(<span class="number">0</span>, nums)</span><br><span class="line">	levelOrder := LevelOrder(tree)</span><br><span class="line">	fmt.Println(<span class="string">&quot;二叉树层序遍历：&quot;</span>, levelOrder)</span><br><span class="line">	preorderTraversal := PreorderTraversal(tree)</span><br><span class="line">	fmt.Println(<span class="string">&quot;二叉树前序遍历：&quot;</span>, preorderTraversal)</span><br><span class="line">	inorderTraversal := InorderTraversal(tree)</span><br><span class="line">	fmt.Println(<span class="string">&quot;二叉树中序遍历：&quot;</span>, inorderTraversal)</span><br><span class="line">	postorderTraversal := PostorderTraversal(tree)</span><br><span class="line">	fmt.Println(<span class="string">&quot;二叉树后序遍历：&quot;</span>, postorderTraversal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="24-补充题6：手撕堆排序（Go）-912-中等"><a href="#24-补充题6：手撕堆排序（Go）-912-中等" class="headerlink" title="24. 补充题6：手撕堆排序（Go） 912-中等"></a>24. 补充题6：手撕堆排序（Go） 912-中等</h4><p><strong>题目：</strong></p>
<p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<p><strong>思路：</strong></p>
<p>算法描述：首先建一个堆，然后调整堆，调整过程是将节点和子节点进行比较，将 其中最大的值变为父节点，递归调整调整次数lgn,最后将根节点和尾节点交换再n次 调整<strong>O(nlgn)</strong></p>
<p>步骤：</p>
<ul>
<li>创建最大堆或者最小堆（我是最小堆）</li>
<li>调整堆</li>
<li>交换首尾节点(为了维持一个完全二叉树才要进行收尾交换)</li>
</ul>
<p><strong>复杂度分析：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapSortMax</span><span class="params">(nums []<span class="type">int</span>, length <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> length &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> nums</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 二叉树深度</span></span><br><span class="line">	depth := length/<span class="number">2</span> - <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := depth; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		<span class="comment">// 假定最大的位置就在i的位置</span></span><br><span class="line">		topmax := i</span><br><span class="line">		leftchild := <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">		rightchild := <span class="number">2</span>*i + <span class="number">2</span></span><br><span class="line">		<span class="comment">// nums[leftchild] &gt; nums[topmax] 防止越界</span></span><br><span class="line">		<span class="keyword">if</span> leftchild &lt;= length<span class="number">-1</span> &amp;&amp; nums[leftchild] &gt; nums[topmax] &#123;</span><br><span class="line">			topmax = leftchild</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// nums[rightchild] &gt; nums[topmax] 防止越界</span></span><br><span class="line">		<span class="keyword">if</span> rightchild &lt;= length<span class="number">-1</span> &amp;&amp; nums[rightchild] &gt; nums[topmax] &#123;</span><br><span class="line">			topmax = rightchild</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> topmax != i &#123;</span><br><span class="line">			nums[i], nums[topmax] = nums[topmax], nums[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	lenght := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; lenght; i++ &#123;</span><br><span class="line">		lastLen := lenght - i</span><br><span class="line">		HeapSortMax(nums, lastLen)</span><br><span class="line">		<span class="keyword">if</span> i &lt; lenght &#123;</span><br><span class="line">			nums[<span class="number">0</span>], nums[lastLen<span class="number">-1</span>] = nums[lastLen<span class="number">-1</span>], nums[<span class="number">0</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">6</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;结果为：&quot;</span>, HeapSort(nums))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="25-相交链表（Go）160-简单"><a href="#25-相交链表（Go）160-简单" class="headerlink" title="25. 相交链表（Go）160-简单"></a>25. 相交链表（Go）160-简单</h4><p><strong>题目：</strong></p>
<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> </p>
<p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p>
<p>题目数据 保证 整个链式结构中不存在环</p>
<p>注意，函数返回结果后，链表必须 保持其原始结构 </p>
<p>自定义评测：</p>
<p>评测系统 的输入如下（你设计的程序 不适用 此输入）：</p>
<ul>
<li>intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0</li>
<li>listA - 第一个链表</li>
<li>listB - 第二个链表</li>
<li>skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数</li>
<li>skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数</li>
</ul>
<p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 </p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = <span class="number">8</span><span class="punctuation">,</span> listA = <span class="punctuation">[</span><span class="number">4</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span><span class="punctuation">,</span> listB = <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span><span class="punctuation">,</span> skipA = <span class="number">2</span><span class="punctuation">,</span> skipB = <span class="number">3</span></span><br><span class="line">输出：Intersected at &#x27;<span class="number">8</span>&#x27;</span><br><span class="line">解释：相交节点的值为 <span class="number">8</span> （注意，如果两个链表相交则不能为 <span class="number">0</span>）</span><br><span class="line">从各自的表头开始算起，链表 A 为 <span class="punctuation">[</span><span class="number">4</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span>，链表 B 为 <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span></span><br><span class="line">在 A 中，相交节点前有 <span class="number">2</span> 个节点；在 B 中，相交节点前有 <span class="number">3</span> 个节点</span><br><span class="line">输入：intersectVal = <span class="number">2</span><span class="punctuation">,</span> listA = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">,</span> listB = <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">,</span> skipA = <span class="number">3</span><span class="punctuation">,</span> skipB = <span class="number">1</span></span><br><span class="line">输出：Intersected at &#x27;<span class="number">2</span>&#x27;</span><br><span class="line">解释：相交节点的值为 <span class="number">2</span> （注意，如果两个链表相交则不能为 <span class="number">0</span>）</span><br><span class="line">从各自的表头开始算起，链表 A 为 <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span>，链表 B 为 <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span></span><br><span class="line">在 A 中，相交节点前有 <span class="number">3</span> 个节点；在 B 中，相交节点前有 <span class="number">1</span> 个节点。</span><br><span class="line">输入：intersectVal = <span class="number">0</span><span class="punctuation">,</span> listA = <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">,</span> listB = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span><span class="punctuation">,</span> skipA = <span class="number">3</span><span class="punctuation">,</span> skipB = <span class="number">2</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">null</span></span></span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span>，链表 B 为 <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span></span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 <span class="number">0</span>，而 skipA 和 skipB 可以是任意值</span><br><span class="line">这两个链表不相交，因此返回 <span class="literal"><span class="keyword">null</span></span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<p><strong>思路：</strong></p>
<p>方法一：哈希集合<br>思路和算法</p>
<p>判断两个链表是否相交，可以使用哈希集合存储链表节点</p>
<p>首先遍历链表 headA，并将链表 headA 中的每个节点加入哈希集合中。然后遍历链表 headB，对于遍历到的每个节点，判断该节点是否在哈希集合中：</p>
<ul>
<li>如果当前节点不在哈希集合中，则继续遍历下一个节点</li>
<li>如果当前节点在哈希集合中，则后面的节点都在哈希集合中，即从当前节点开始的所有节点都在两个链表的相交部分，因此在链表 headB 中遍历到的第一个在哈希集合中的节点就是两个链表相交的节点，返回该节点</li>
</ul>
<p>如果链表 headB 中的所有节点都不在哈希集合中，则两个链表不相交，返回 null</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(m+n)，其中 m 和 n 是分别是链表 headA 和 headB 的长度。需要遍历两个链表各一次</li>
<li>空间复杂度：O(m)，其中 m 是链表 headA 的长度。需要使用哈希集合存储链表 headA 中的全部节点</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    vis := <span class="keyword">map</span>[*ListNode]<span class="type">bool</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> tmp := headA; tmp != <span class="literal">nil</span>; tmp = tmp.Next &#123;</span><br><span class="line">        vis[tmp] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> tmp := headB; tmp != <span class="literal">nil</span>; tmp = tmp.Next &#123;</span><br><span class="line">        <span class="keyword">if</span> vis[tmp] &#123;</span><br><span class="line">            <span class="keyword">return</span> tmp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="26-二叉搜索树的第K大节点（Go）-剑指offer54-简单"><a href="#26-二叉搜索树的第K大节点（Go）-剑指offer54-简单" class="headerlink" title="26. 二叉搜索树的第K大节点（Go） 剑指offer54-简单"></a>26. 二叉搜索树的第K大节点（Go） 剑指offer54-简单</h4><p><strong>题目：</strong></p>
<p>给定一棵二叉搜索树，请找出其中第 <code>k</code> 大的节点的值</p>
<p><strong>示例：</strong></p>
<p><strong>提示：</strong></p>
<p><strong>思路：</strong></p>
<ol>
<li>通过二叉树的中序遍历便是一个从小到大的排序</li>
<li>设置一个count，每遍历一个数据便自增1，当count&#x3D;k时，就找到了正确答案</li>
</ol>
<p><strong>复杂度分析：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 思路：返回中序遍历生成的序列中的第k个节点</span></span><br><span class="line"><span class="comment">// 此题最好只实现：InorderTraverse和KthLargest</span></span><br><span class="line"><span class="comment">// 在Goland IDE里实现全部貌似结果不正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Val   <span class="type">int</span></span><br><span class="line">	Left  *TreeNode</span><br><span class="line">	Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateNode 创建二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateNode</span><span class="params">(i <span class="type">int</span>, nums []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">	tree := &amp;TreeNode&#123;nums[i], <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">	<span class="comment">// 左节点的数组下标为1,3,5...2*i+1</span></span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(nums) &amp;&amp; <span class="number">2</span>*i+<span class="number">1</span> &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">		tree.Left = CreateNode(<span class="number">2</span>*i+<span class="number">1</span>, nums)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 右节点的数组下标为2,4,6...2*i+2</span></span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(nums) &amp;&amp; <span class="number">2</span>*i+<span class="number">2</span> &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">		tree.Right = CreateNode(<span class="number">2</span>*i+<span class="number">2</span>, nums)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InorderTraverse</span><span class="params">(root *TreeNode, ret *[]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	InorderTraverse(root.Left, ret)</span><br><span class="line">	*ret = <span class="built_in">append</span>(*ret, root.Val)</span><br><span class="line">	InorderTraverse(root.Right, ret)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">KthLargest</span><span class="params">(root *TreeNode, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	ret := &amp;[]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	InorderTraverse(root, ret)</span><br><span class="line">	<span class="comment">// 说明没找到第k大节点</span></span><br><span class="line">	<span class="keyword">if</span> k &lt; <span class="number">1</span> &amp;&amp; k &gt; <span class="built_in">len</span>(*ret) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (*ret)[<span class="built_in">len</span>(*ret)-k]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	<span class="comment">// 0代表节点为空</span></span><br><span class="line">	treeNode := CreateNode(<span class="number">0</span>, nums)</span><br><span class="line">	fmt.Println(<span class="string">&quot;结果为：&quot;</span>, KthLargest(treeNode, <span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="27-LFU缓存（Go）-460-困难"><a href="#27-LFU缓存（Go）-460-困难" class="headerlink" title="27. LFU缓存（Go） 460-困难"></a>27. LFU缓存（Go） 460-困难</h4><p><strong>题目：</strong></p>
<p>请你为 最不经常使用（LFU）缓存算法设计并实现数据结构</p>
<p><strong>示例：</strong></p>
<p><strong>提示：</strong></p>
<p><strong>思路：</strong></p>
<p>方法二：双哈希表</p>
<p><strong>复杂度分析：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">	Key   <span class="type">int</span></span><br><span class="line">	Value <span class="type">int</span></span><br><span class="line">	freq  <span class="type">int</span></span><br><span class="line">	pre   *Node</span><br><span class="line">	next  *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LFUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">	limit   <span class="type">int</span></span><br><span class="line">	HashMap <span class="keyword">map</span>[<span class="type">int</span>]*Node</span><br><span class="line">	head    *Node</span><br><span class="line">	end     *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LFUConstructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LFUCache &#123;</span><br><span class="line">	lfuCache := LFUCache&#123;&#125;</span><br><span class="line">	lfuCache.limit = capacity</span><br><span class="line">	lfuCache.HashMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*Node, capacity)</span><br><span class="line">	<span class="keyword">return</span> lfuCache</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lfuCache *LFUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> value, ok := lfuCache.HashMap[key]; ok &#123;</span><br><span class="line">		value.freq++</span><br><span class="line">		lfuCache.refreshNode(value)</span><br><span class="line">		<span class="keyword">return</span> value.Value</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lfuCache *LFUCache)</span></span> Put(key, value <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> v, ok := lfuCache.HashMap[key]; !ok &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(lfuCache.HashMap) &gt;= lfuCache.limit &#123;</span><br><span class="line">			oldKey := lfuCache.removeNode(lfuCache.head)</span><br><span class="line">			<span class="built_in">delete</span>(lfuCache.HashMap, oldKey)</span><br><span class="line">		&#125;</span><br><span class="line">		node := Node&#123;Key: key, Value: value, freq: <span class="number">1</span>&#125;</span><br><span class="line">		lfuCache.addNode(&amp;node)</span><br><span class="line">		lfuCache.HashMap[key] = &amp;node</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		v.Value = value</span><br><span class="line">		v.freq++</span><br><span class="line">		lfuCache.refreshNode(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lfuCache *LFUCache)</span></span> refreshNode(node *Node) &#123;</span><br><span class="line">	<span class="keyword">if</span> node == lfuCache.end &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	lfuCache.removeNode(node)</span><br><span class="line">	lfuCache.addNode(node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lfuCache *LFUCache)</span></span> removeNode(node *Node) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> node == lfuCache.end &#123;</span><br><span class="line">		lfuCache.end = lfuCache.end.pre</span><br><span class="line">		lfuCache.end.next = <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> node == lfuCache.head &#123;</span><br><span class="line">		lfuCache.head = lfuCache.head.next</span><br><span class="line">		lfuCache.head.pre = <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		node.pre.next = node.next</span><br><span class="line">		node.next.pre = node.pre</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> node.Key</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lfuCache *LFUCache)</span></span> addNode(node *Node) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> lfuCache.head == <span class="literal">nil</span> &amp;&amp; lfuCache.end == <span class="literal">nil</span> &#123;</span><br><span class="line">		lfuCache.head = node</span><br><span class="line">		lfuCache.end = node</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	head := lfuCache.head</span><br><span class="line">	<span class="keyword">for</span> head != <span class="literal">nil</span> &amp;&amp; node.freq &gt;= head.freq &#123;</span><br><span class="line">		head = head.next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">		lfuCache.end.next = node</span><br><span class="line">		node.pre = lfuCache.end</span><br><span class="line">		lfuCache.end = node</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">		head.pre.next = node</span><br><span class="line">		node.pre = head.pre</span><br><span class="line">		head.pre = node</span><br><span class="line">		node.next = head</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lfuCache.head.pre = <span class="literal">nil</span></span><br><span class="line">	lfuCache.end.next = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	lfuCache := LFUConstructor(<span class="number">3</span>)</span><br><span class="line">	lfuCache.Put(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">	lfuCache.Put(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">	lfuCache.Put(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">	fmt.Println(lfuCache) <span class="comment">// 此时的链表顺序应该是 1 : 3   2 : 4   3 : 5   lfuCache.head 为1 : 3   lfuCache.end 为3 : 5</span></span><br><span class="line">	lfuCache.Get(<span class="number">1</span>)</span><br><span class="line">	fmt.Println(lfuCache) <span class="comment">// 此时的链表顺序应该是  2 : 4   3 : 5  1 : 3   lfuCache.head 为2 : 4    lfuCache.end 为1 : 3</span></span><br><span class="line">	lfuCache.Put(<span class="number">4</span>, <span class="number">6</span>)</span><br><span class="line">	fmt.Println(lfuCache) <span class="comment">// 此时的链表顺序应该是  3 : 5  4 : 6   1 : 3    lfuCache.head 为3 : 5   lfuCache.end 为1 : 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="28-K个一组翻转链表（Go）25-困难"><a href="#28-K个一组翻转链表（Go）25-困难" class="headerlink" title="28. K个一组翻转链表（Go）25-困难"></a>28. K个一组翻转链表（Go）25-困难</h4><p><strong>题目：</strong></p>
<p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。<code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换</p>
<p><strong>示例：</strong></p>
<p><strong>提示：</strong></p>
<p><strong>思路：</strong></p>
<p><strong>复杂度分析：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Value <span class="type">int</span></span><br><span class="line">	Next  *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseKGroup</span><span class="params">(head *ListNode, k <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">	dummyNode := &amp;ListNode&#123;Next: head&#125;</span><br><span class="line">	pre := dummyNode</span><br><span class="line">	<span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">		tail := pre</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">			tail = tail.Next</span><br><span class="line">			<span class="keyword">if</span> tail == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> dummyNode.Next</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//记录tail后一个节点，以及pre后一个节点</span></span><br><span class="line">		nextGroupHead := tail.Next</span><br><span class="line">		head = pre.Next</span><br><span class="line">		<span class="comment">//反转</span></span><br><span class="line">		ReverseList(head, tail)</span><br><span class="line">		<span class="comment">//拼接</span></span><br><span class="line">		pre.Next = tail</span><br><span class="line">		head.Next = nextGroupHead</span><br><span class="line">		<span class="comment">//更新pre和head</span></span><br><span class="line">		pre = head</span><br><span class="line">		head = nextGroupHead</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dummyNode.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReverseList 翻转链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReverseList</span><span class="params">(head *ListNode, tail *ListNode)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> pre *ListNode</span><br><span class="line">	cur := head</span><br><span class="line">	<span class="keyword">for</span> pre != tail &#123;</span><br><span class="line">		next := cur.Next</span><br><span class="line">		cur.Next = pre</span><br><span class="line">		pre = cur</span><br><span class="line">		cur = next</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="29-买卖股票的最佳时机（Go）121-简单"><a href="#29-买卖股票的最佳时机（Go）121-简单" class="headerlink" title="29. 买卖股票的最佳时机（Go）121-简单"></a>29. 买卖股票的最佳时机（Go）121-简单</h4><p><strong>题目：</strong></p>
<p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 </p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：<span class="punctuation">[</span><span class="number">7</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出，最大利润 = <span class="number">6</span><span class="number">-1</span> = <span class="number">5</span></span><br><span class="line">     注意利润不能是 <span class="number">7</span><span class="number">-1</span> = <span class="number">6</span><span class="punctuation">,</span> 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票</span><br><span class="line">输入：prices = <span class="punctuation">[</span><span class="number">7</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：在这种情况下<span class="punctuation">,</span> 没有交易完成<span class="punctuation">,</span> 所以最大利润为 <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 10的5次方</code></li>
<li><code>0 &lt;= prices[i] &lt;= 10的4次方</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法二：一次遍历（贪心算法）</p>
<p>算法</p>
<p>假设给定的数组为：<code>[7, 1, 5, 3, 6, 4]</code></p>
<p>如果我们在图表上绘制给定数组中的数字，我们将会得到：</p>
<p>我们来假设自己来购买股票。随着时间的推移，每天我们都可以选择出售股票与否。那么，假设在第 i 天，如果我们要在今天卖股票，那么我们能赚多少钱呢</p>
<p>显然，如果我们真的在买卖股票，我们肯定会想：如果我是在历史最低点买的股票就好了！太好了，在题目中，我们只要用一个变量记录一个历史最低价格 minprice，我们就可以假设自己的股票是在那天买的。那么我们在第 i 天卖出股票能得到的利润就是 prices[i] - minprice</p>
<p>因此，我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)，只需要遍历一次</li>
<li>空间复杂度：O(1)，只使用了常数个变量</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MaxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 贪心</span></span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	m := prices[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> prices[i] &gt; m &#123;</span><br><span class="line">			<span class="keyword">if</span> (prices[i] - m) &gt; res &#123;</span><br><span class="line">				res = prices[i] - m</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			m = prices[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;结果为：&quot;</span>, MaxProfit(nums))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="30-基本计算器2（Go）227-中等"><a href="#30-基本计算器2（Go）227-中等" class="headerlink" title="30. 基本计算器2（Go）227-中等"></a>30. 基本计算器2（Go）227-中等</h4><p><strong>题目：</strong></p>
<p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值</p>
<p>整数除法仅保留整数部分</p>
<p>你可以假设给定的表达式总是有效的。所有中间结果将在 <code>[-2^31, 2^31 - 1]</code> 的范围内</p>
<p>注意：不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval()</code> </p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;3+2*2&quot;</span></span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">输入：s = <span class="string">&quot; 3/2 &quot;</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">输入：s = <span class="string">&quot; 3+5 / 2 &quot;</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; s.length &lt;&#x3D; 3 * 10^5</li>
<li>s 由整数和算符 (‘+’, ‘-‘, ‘*’, ‘&#x2F;‘) 组成，中间由一些空格隔开</li>
<li>s 表示一个 有效表达式</li>
<li>表达式中的所有整数都是非负整数，且在范围 [0, 2^31 - 1] 内</li>
<li>题目数据保证答案是一个 32-bit 整数</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：栈<br>思路</p>
<p>由于乘除优先于加减计算，因此不妨考虑先进行所有乘除运算，并将这些乘除运算后的整数值放回原表达式的相应位置，则随后整个表达式的值，就等于一系列整数加减后的值</p>
<p>基于此，我们可以用一个栈，保存这些（进行乘除运算后的）整数的值。对于加减号后的数字，将其直接压入栈中；对于乘除号后的数字，可以直接与栈顶元素计算，并替换栈顶元素为计算后的结果</p>
<p>具体来说，遍历字符串 s，并用变量 preSign 记录每个数字之前的运算符，对于第一个数字，其之前的运算符视为加号。每次遍历到数字末尾时，根据 preSign 来决定计算方式：</p>
<ul>
<li>加号：将数字压入栈</li>
<li>减号：将数字的相反数压入栈</li>
<li>乘除号：计算数字与栈顶元素，并将栈顶元素替换为计算结果</li>
</ul>
<p>代码实现中，若读到一个运算符，或者遍历到字符串末尾，即认为是遍历到了数字末尾。处理完该数字后，更新 preSign 为当前遍历的字符</p>
<p>遍历完字符串 s 后，将栈中元素累加，即为该字符串表达式的值</p>
<p><strong>复杂度分析：</strong></p>
<p>时间复杂度：O(n)，其中 n 为字符串 s 的长度。需要遍历字符串 s 一次，计算表达式的值</p>
<p>空间复杂度：O(n)，其中 n 为字符串 s 的长度。空间复杂度主要取决于栈的空间，栈的元素个数不超过 n</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculate</span><span class="params">(s <span class="type">string</span>)</span></span> (ans <span class="type">int</span>) &#123;</span><br><span class="line">    stack := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    preSign := <span class="string">&#x27;+&#x27;</span></span><br><span class="line">    num := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, ch := <span class="keyword">range</span> s &#123;</span><br><span class="line">        isDigit := <span class="string">&#x27;0&#x27;</span> &lt; ch &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> isDigit &#123;</span><br><span class="line">            num = num * <span class="number">10</span> + <span class="type">int</span>(ch - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !isDigit &amp;&amp; ch != <span class="string">&#x27; &#x27;</span> || i == <span class="built_in">len</span>(s) - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> preSign &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, num)</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, -num)</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>] *= num</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>] /= num</span><br><span class="line">            &#125;</span><br><span class="line">            preSign = ch</span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> stack &#123;</span><br><span class="line">        ans += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="31-数组中重复的数据（Go）442-中等"><a href="#31-数组中重复的数据（Go）442-中等" class="headerlink" title="31. 数组中重复的数据（Go）442-中等"></a>31. 数组中重复的数据（Go）442-中等</h4><p><strong>题目：</strong></p>
<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，其中 <code>nums</code> 的所有整数都在范围 <code>[1, n]</code> 内，且每个整数出现 一次 或 两次 。请你找出所有出现 两次 的整数，并以数组形式返回</p>
<p>你必须设计并实现一个时间复杂度为 <code>O(n)</code> 且仅使用常量额外空间的算法解决此问题</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">4</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输入：nums = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= n</code></li>
<li><code>nums</code> 中的每个元素出现 <strong>一次</strong> 或 <strong>两次</strong></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：将元素交换到对应的位置<br>思路与算法</p>
<p>由于给定的 n 个数都在 [1,n] 的范围内，如果有数字出现了两次，就意味着 [1,n] 中有数字没有出现过</p>
<p>因此，我们可以尝试将每一个数放在对应的位置。由于数组的下标范围是 [0,n−1]，我们需要将数 i 放在数组中下标为 i−1 的位置：</p>
<ul>
<li>如果 i 恰好出现了一次，那么将 i 放在数组中下标为 i−1 的位置即可</li>
<li>如果 i 出现了两次，那么我们希望其中的一个 i 放在数组下标中为 i−1 的位置，另一个 i 放置在任意「不冲突」的位置 j。也就是说，数 j+1 没有在数组中出现过</li>
</ul>
<p>这样一来，如果我们按照上述的规则放置每一个数，那么我们只需要对数组进行一次遍历。当遍历到位置 i 时，如果 nums[i]−1!&#x3D;i，说明 nums[i] 出现了两次（另一次出现在位置 num[i]−1），我们就可以将 num[i] 放入答案</p>
<p>放置的方法也很直观：我们对数组进行一次遍历。当遍历到位置 i 时，我们知道 nums[i] 应该被放在位置 nums[i]−1。因此我们交换 num[i] 和 nums[nums[i]−1] 即可，直到待交换的两个元素相等为止</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li><p>时间复杂度：O(n)。每一次交换操作会使得至少一个元素被交换到对应的正确位置，因此交换的次数为 O(n)，总时间复杂度为 O(n)</p>
</li>
<li><p>空间复杂度：O(1)。返回值不计入空间复杂度</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDuplicates</span><span class="params">(nums []<span class="type">int</span>)</span></span> (ans []<span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">for</span> nums[i] != nums[nums[i] - <span class="number">1</span>] &#123;</span><br><span class="line">            nums[i], nums[nums[i] - <span class="number">1</span>] = nums[nums[i] - <span class="number">1</span>], nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num - <span class="number">1</span> != i &#123;</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, num)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="32-零钱兑换（Go）-332-中等"><a href="#32-零钱兑换（Go）-332-中等" class="headerlink" title="32. 零钱兑换（Go） 332-中等"></a>32. 零钱兑换（Go） 332-中等</h4><p><strong>题目：</strong></p>
<p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。你可以认为每种硬币的数量是无限的</p>
<p><strong>示例：</strong></p>
<p><strong>提示：</strong></p>
<p><strong>思路：</strong></p>
<p>动态规划</p>
<p><strong>复杂度分析：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CoinChange</span><span class="params">(coins []<span class="type">int</span>, amount <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">	<span class="comment">// 初始化线性备忘录</span></span><br><span class="line">	<span class="keyword">for</span> k := <span class="keyword">range</span> dp &#123;</span><br><span class="line">		<span class="comment">// 相当于无限大，方便比较</span></span><br><span class="line">		dp[k] = amount + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 这个就是占位的</span></span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(dp); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> _, coin := <span class="keyword">range</span> coins &#123;</span><br><span class="line">			<span class="comment">// 至少包含 1 枚某种硬币</span></span><br><span class="line">			<span class="keyword">if</span> i-coin &lt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span> <span class="comment">// 这种情况别闹</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 选择一个较小的</span></span><br><span class="line">			dp[i] = min(dp[i], <span class="number">1</span>+dp[i-coin])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> dp[amount] == amount+<span class="number">1</span> &#123;</span><br><span class="line">		<span class="comment">// 没有合适的</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;结果为：&quot;</span>, CoinChange(nums, <span class="number">11</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="33-两数相加（Go）2-中等"><a href="#33-两数相加（Go）2-中等" class="headerlink" title="33. 两数相加（Go）2-中等"></a>33. 两数相加（Go）2-中等</h4><p><strong>题目：</strong></p>
<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：l1 = <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">,</span> l2 = <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">7</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">]</span></span><br><span class="line">解释：<span class="number">342</span> + <span class="number">465</span> = <span class="number">807.</span></span><br><span class="line">输入：l1 = <span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span><span class="punctuation">,</span> l2 = <span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span></span><br><span class="line">输入：l1 = <span class="punctuation">[</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">]</span><span class="punctuation">,</span> l2 = <span class="punctuation">[</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">8</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
<li>题目数据保证列表表示的数字不含前导零</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：模拟<br>思路与算法</p>
<p>由于输入的两个链表都是逆序存储数字的位数的，因此两个链表中同一位置的数字可以直接相加</p>
<p>我们同时遍历两个链表，逐位计算它们的和，并与当前位置的进位值相加。具体而言，如果当前两个链表处相应位置的数字为 n1,n2，进位值为 carry，则它们的和为 n1+n2+carry；其中，答案链表处相应位置的数字为 (n1+n2+carry)mod10，而新的进位值为 ⌊<br>n1+n2+carry除以10⌋</p>
<p>如果两个链表的长度不同，则可以认为长度短的链表的后面有若干个 0 </p>
<p>此外，如果链表遍历结束后，有 carry&gt;0，还需要在答案链表的后面附加一个节点，节点的值为 carry</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(max(m,n))，其中 m 和 n 分别为两个链表的长度。我们要遍历两个链表的全部位置，而处理每个位置只需要 O(1) 的时间</li>
<li>空间复杂度：O(1)。注意返回值不计入空间复杂度</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span></span> (head *ListNode) &#123;</span><br><span class="line">    <span class="keyword">var</span> tail *ListNode</span><br><span class="line">    carry := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> l1 != <span class="literal">nil</span> || l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        n1, n2 := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            n1 = l1.Val</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            n2 = l2.Val</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        sum := n1 + n2 +carry</span><br><span class="line">        sum, carry = sum % <span class="number">10</span>, sum / <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">            head = &amp;ListNode&#123;Val: sum&#125;</span><br><span class="line">            tail = head</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail.Next = &amp;ListNode&#123;Val: sum&#125;</span><br><span class="line">            tail = tail.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> carry &gt; <span class="number">0</span> &#123;</span><br><span class="line">        tail.Next = &amp;ListNode&#123;Val: carry&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="34-链表中倒数第K个节点（Go）剑指offer22-简单"><a href="#34-链表中倒数第K个节点（Go）剑指offer22-简单" class="headerlink" title="34. 链表中倒数第K个节点（Go）剑指offer22-简单"></a>34. 链表中倒数第K个节点（Go）剑指offer22-简单</h4><p><strong>题目：</strong></p>
<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点</p>
<p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 <code>1、2、3、4、5、6</code>。这个链表的倒数第 3 个节点是值为 4 的节点</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">给定一个链表<span class="punctuation">:</span> <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span><span class="punctuation">,</span> 和 k = <span class="number">2.</span></span><br><span class="line">返回链表 <span class="number">4</span>-&gt;<span class="number">5.</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<p><strong>思路：</strong></p>
<p>方法一：顺序查找<br>思路与算法</p>
<p>最简单直接的方法即为顺序查找，假设当前链表的长度为 n，则我们知道链表的倒数第 k 个节点即为正数第 n−k 个节点，此时我们只需要顺序遍历到链表的第 n−k 个节点即为倒数第 k 个节点</p>
<p>我们首先求出链表的长度 n，然后顺序遍历到链表的第 n−k 个节点返回即可</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 为链表的长度。需要两次遍历</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getKthFromEnd</span><span class="params">(head *ListNode, k <span class="type">int</span>)</span></span> (kth *ListNode) &#123;</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> node := head; node != <span class="literal">nil</span>; node = node.Next &#123;</span><br><span class="line">        n++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> kth = head; n &gt; k; n-- &#123;</span><br><span class="line">        kth = kth.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="35-路径总和（Go）112-简单"><a href="#35-路径总和（Go）112-简单" class="headerlink" title="35. 路径总和（Go）112-简单"></a>35. 路径总和（Go）112-简单</h4><p><strong>题目：</strong></p>
<p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> </p>
<p>叶子节点 是指没有子节点的节点</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：root = <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">,</span><span class="number">11</span><span class="punctuation">,</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="number">13</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> targetSum = <span class="number">22</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">true</span></span></span><br><span class="line">解释：等于目标和的根节点到叶节点路径如上图所示</span><br><span class="line">输入：root = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">,</span> targetSum = <span class="number">5</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">false</span></span></span><br><span class="line">解释：树中存在两条根节点到叶子节点的路径：</span><br><span class="line">(<span class="number">1</span> --&gt; <span class="number">2</span>)<span class="punctuation">:</span> 和为 <span class="number">3</span></span><br><span class="line">(<span class="number">1</span> --&gt; <span class="number">3</span>)<span class="punctuation">:</span> 和为 <span class="number">4</span></span><br><span class="line">不存在 sum = <span class="number">5</span> 的根节点到叶子节点的路径</span><br><span class="line">输入：root = <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> targetSum = <span class="number">0</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">false</span></span></span><br><span class="line">解释：由于树是空的，所以不存在根节点到叶子节点的路径</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目在范围 <code>[0, 5000]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：广度优先搜索<br>思路及算法</p>
<p>首先我们可以想到使用广度优先搜索的方式，记录从根节点到当前节点的路径和，以防止重复计算</p>
<p>这样我们使用两个队列，分别存储将要遍历的节点，以及根节点到这些节点的路径和即可</p>
<p><strong>复杂度分析：</strong></p>
<p>时间复杂度：O(N)，其中 N 是树的节点数。对每个节点访问一次</p>
<p>空间复杂度：O(N)，其中 N 是树的节点数。空间复杂度主要取决于队列的开销，队列中的元素个数不会超过树的节点数</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasPathSum</span><span class="params">(root *TreeNode, targetSum <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    queNode := []*TreeNode&#123;&#125;</span><br><span class="line">    queVal := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    queNode = <span class="built_in">append</span>(queNode, root)</span><br><span class="line">    queVal = <span class="built_in">append</span>(queVal, root.Val)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queNode) != <span class="number">0</span> &#123;</span><br><span class="line">        now := queNode[<span class="number">0</span>]</span><br><span class="line">        queNode = queNode[<span class="number">1</span>:]</span><br><span class="line">        temp := queVal[<span class="number">0</span>]</span><br><span class="line">        queVal = queVal[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">if</span> now.Left == <span class="literal">nil</span> &amp;&amp; now.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> temp == targetSum &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> now.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">            queNode = <span class="built_in">append</span>(queNode, now.Left)</span><br><span class="line">            queVal = <span class="built_in">append</span>(queVal, now.Left.Val + temp)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> now.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">            queNode = <span class="built_in">append</span>(queNode, now.Right)</span><br><span class="line">            queVal = <span class="built_in">append</span>(queVal, now.Right.Val + temp)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="36-字符串相乘（Go）43-中等"><a href="#36-字符串相乘（Go）43-中等" class="headerlink" title="36. 字符串相乘（Go）43-中等"></a>36. 字符串相乘（Go）43-中等</h4><p><strong>题目：</strong></p>
<p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式</p>
<p>注意：不能使用任何内置的 <code>BigInteger</code> 库或直接将输入转换为整数</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入<span class="punctuation">:</span> num1 = <span class="string">&quot;2&quot;</span><span class="punctuation">,</span> num2 = <span class="string">&quot;3&quot;</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="string">&quot;6&quot;</span></span><br><span class="line">输入<span class="punctuation">:</span> num1 = <span class="string">&quot;123&quot;</span><span class="punctuation">,</span> num2 = <span class="string">&quot;456&quot;</span></span><br><span class="line">输出<span class="punctuation">:</span> <span class="string">&quot;56088&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; num1.length, num2.length &lt;&#x3D; 200</li>
<li>num1 和 num2 只能由数字组成</li>
<li>num1 和 num2 都不包含任何前导零，除了数字0本身</li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：做加法<br>如果 num1和 num2之一是 0，则直接将 0 作为结果返回即可</p>
<p>如果 num1和 num2都不是 0，则可以通过模拟「竖式乘法」的方法计算乘积。从右往左遍历乘数，将乘数的每一位与被乘数相乘得到对应的结果，再将每次得到的结果累加。这道题中，被乘数是 num1，乘数是 num2</p>
<p>需要注意的是，num2除了最低位以外，其余的每一位的运算结果都需要补 0</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(mn+n^2)，其中 m 和 n 分别是 num1和 num2的长度。需要从右往左遍历 num2，对于 num2 的每一位，都需要和 num1的每一位计算乘积，因此计算乘积的总次数是 mn。字符串相加操作共有 n 次，相加的字符串长度最长为 m+n，因此字符串相加的时间复杂度是 O(mn+n^2)。总时间复杂度是 O(mn+n^2)</li>
<li>空间复杂度：O(m+n)，其中 m 和 n 分别是 num1和 num2的长度。空间复杂度取决于存储中间状态的字符串，由于乘积的最大长度为 m+n，因此存储中间状态的字符串的长度不会超过 m+n</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiply</span><span class="params">(num1 <span class="type">string</span>, num2 <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> num1 == <span class="string">&quot;0&quot;</span> || num2 == <span class="string">&quot;0&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="string">&quot;0&quot;</span></span><br><span class="line">    m, n := <span class="built_in">len</span>(num1), <span class="built_in">len</span>(num2)</span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        curr := <span class="string">&quot;&quot;</span></span><br><span class="line">        add := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j := n - <span class="number">1</span>; j &gt; i; j-- &#123;</span><br><span class="line">            curr += <span class="string">&quot;0&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        y := <span class="type">int</span>(num2[i] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> j := m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j-- &#123;</span><br><span class="line">            x := <span class="type">int</span>(num1[j] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            product := x * y + add</span><br><span class="line">            curr = strconv.Itoa(product % <span class="number">10</span>) + curr</span><br><span class="line">            add = product / <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ; add != <span class="number">0</span>; add /= <span class="number">10</span> &#123;</span><br><span class="line">            curr = strconv.Itoa(add % <span class="number">10</span>) + curr</span><br><span class="line">        &#125;</span><br><span class="line">        ans = addStrings(ans, curr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addStrings</span><span class="params">(num1, num2 <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    i, j := <span class="built_in">len</span>(num1) - <span class="number">1</span>, <span class="built_in">len</span>(num2) - <span class="number">1</span></span><br><span class="line">    add := <span class="number">0</span></span><br><span class="line">    ans := <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> ; i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>; i, j = i - <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">        x, y := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> x &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            x = <span class="type">int</span>(num1[i] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> j &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            y = <span class="type">int</span>(num2[j] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        result := x + y + add</span><br><span class="line">        ans = strconv.Itoa(result % <span class="number">10</span>) + ans</span><br><span class="line">        add = result / <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="37-用栈实现队列（Go）-232-简单"><a href="#37-用栈实现队列（Go）-232-简单" class="headerlink" title="37. 用栈实现队列（Go） 232-简单"></a>37. 用栈实现队列（Go） 232-简单</h4><p><strong>题目：</strong></p>
<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p>
<p>实现 <code>MyQueue</code> 类：</p>
<ul>
<li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li>
<li><code>int pop()</code> 从队列的开头移除并返回元素</li>
<li><code>int peek()</code> 返回队列开头的元素</li>
<li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li>
</ul>
<p>说明：</p>
<ul>
<li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="punctuation">[</span><span class="string">&quot;MyQueue&quot;</span><span class="punctuation">,</span> <span class="string">&quot;push&quot;</span><span class="punctuation">,</span> <span class="string">&quot;push&quot;</span><span class="punctuation">,</span> <span class="string">&quot;peek&quot;</span><span class="punctuation">,</span> <span class="string">&quot;pop&quot;</span><span class="punctuation">,</span> <span class="string">&quot;empty&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">输出：</span><br><span class="line"><span class="punctuation">[</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyQueue myQueue = new MyQueue();</span><br><span class="line">myQueue.push(<span class="number">1</span>); <span class="comment">// queue is: [1]</span></span><br><span class="line">myQueue.push(<span class="number">2</span>); <span class="comment">// queue is: [1, 2] (leftmost is front of the queue)</span></span><br><span class="line">myQueue.peek(); <span class="comment">// return 1</span></span><br><span class="line">myQueue.pop(); <span class="comment">// return 1, queue is [2]</span></span><br><span class="line">myQueue.empty(); <span class="comment">// return false</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= x &lt;= 9</code></li>
<li>最多调用 <code>100</code> 次 <code>push</code>、<code>pop</code>、pe<code>ek</code> 和 <code>empty</code></li>
<li>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li>
</ul>
<p><strong>思路：</strong></p>
<p>队列是一种 先进先出（first in - first out， FIFO）的数据结构，队列中的元素都从后端（rear）入队（push），从前端（front）出队（pop）<br>实现队列最直观的方法是用链表，但在这篇文章里我会介绍另一个方法 - 使用栈</p>
<p>栈是一种 后进先出（last in - first out， LIFO）的数据结构，栈中元素从栈顶（top）压入（push)，也从栈顶弹出（pop）</p>
<p>为了满足队列的 FIFO 的特性，我们需要用到两个栈，用它们其中一个来反转元素的入队顺序，用另一个来存储元素的最终顺序</p>
<p>方法一（使用两个栈 入队 - O(n)， 出队 - O(1)）</p>
<p>算法</p>
<p><strong>一. 入队（push）</strong></p>
<p>一个队列是 FIFO 的，但一个栈是 LIFO 的。这就意味着最新压入的元素必须得放在栈底。为了实现这个目的，我们首先需要把 s1 中所有的元素移到 s2 中，接着把新元素压入 s2。最后把 s2 中所有的元素弹出，再把弹出的元素压入 s1</p>
<p><strong>二. 出队（pop）</strong></p>
<p>直接从 <code>s1</code> 弹出就可以了，因为 <code>s1</code> 的栈顶元素就是队列的队首元素。同时我们把弹出之后 <code>s1</code> 的栈顶元素赋值给代表队首元素的 <code>front</code> 变量</p>
<p><strong>三. 判断空（empty）</strong></p>
<p><code>s1</code> 存储了队列所有的元素，所以只需要检查 <code>s1</code> 的是否为空就可以了</p>
<p><strong>四. 取队首元素（peek）</strong></p>
<p>在我们的算法中，用了 <code>front</code> 变量来存储队首元素，在每次 <code>入队</code> 操作或者 <code>出队</code> 操作之后这个变量都会随之更新</p>
<p><strong>复杂度分析：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> MyQueue struct &#123;</span><br><span class="line">    stack []<span class="built_in">int</span></span><br><span class="line">    back []<span class="built_in">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Constructor() MyQueue &#123;</span><br><span class="line">    <span class="keyword">return</span> MyQueue&#123;</span><br><span class="line">        stack: make([]<span class="built_in">int</span>, <span class="number">0</span>),</span><br><span class="line">        back: make([]<span class="built_in">int</span>, <span class="number">0</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (this *MyQueue) Push(x <span class="built_in">int</span>)  &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(this.back) != <span class="number">0</span> &#123;</span><br><span class="line">        val := this.back[<span class="built_in">len</span>(this.back) - <span class="number">1</span>]</span><br><span class="line">        this.back = this.back[:<span class="built_in">len</span>(this.back) - <span class="number">1</span>]</span><br><span class="line">        this.stack = append(this.stack, val)</span><br><span class="line">    &#125;</span><br><span class="line">    this.stack = append(this.stack, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (this *MyQueue) Pop() <span class="built_in">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(this.stack) != <span class="number">0</span> &#123;</span><br><span class="line">        val := this.stack[<span class="built_in">len</span>(this.stack) - <span class="number">1</span>]</span><br><span class="line">        this.stack = this.stack[:<span class="built_in">len</span>(this.stack) - <span class="number">1</span>]</span><br><span class="line">        this.back = append(this.back, val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.back) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    val := this.back[<span class="built_in">len</span>(this.back) - <span class="number">1</span>]</span><br><span class="line">    this.back = this.back[:<span class="built_in">len</span>(this.back) - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (this *MyQueue) Peek() <span class="built_in">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(this.stack) != <span class="number">0</span> &#123;</span><br><span class="line">        val := this.stack[<span class="built_in">len</span>(this.stack) - <span class="number">1</span>]</span><br><span class="line">        this.stack = this.stack[:<span class="built_in">len</span>(this.stack) - <span class="number">1</span>]</span><br><span class="line">        this.back = append(this.back, val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.back) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    val := this.back[<span class="built_in">len</span>(this.back) - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (this *MyQueue) Empty() <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(this.stack) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(this.back) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="38-用队列实现栈（Go）225-简单"><a href="#38-用队列实现栈（Go）225-简单" class="headerlink" title="38. 用队列实现栈（Go）225-简单"></a>38. 用队列实现栈（Go）225-简单</h4><p><strong>题目：</strong></p>
<p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）</p>
<p><strong>示例：</strong></p>
<p><strong>提示：</strong></p>
<p><strong>思路：</strong></p>
<p><strong>复杂度分析：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyStack <span class="keyword">struct</span> &#123;</span><br><span class="line">	queue1, queue2 []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructor 在这里初始化你的数据结构</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> (s MyStack) &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyStack)</span></span> Push(x <span class="type">int</span>) &#123;</span><br><span class="line">	s.queue2 = <span class="built_in">append</span>(s.queue2, x)</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(s.queue1) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		s.queue2 = <span class="built_in">append</span>(s.queue2, s.queue1[<span class="number">0</span>])</span><br><span class="line">		s.queue1 = s.queue1[<span class="number">1</span>:]</span><br><span class="line">	&#125;</span><br><span class="line">	s.queue1, s.queue2 = s.queue2, s.queue1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyStack)</span></span> Pop() <span class="type">int</span> &#123;</span><br><span class="line">	v := s.queue1[<span class="number">0</span>]</span><br><span class="line">	s.queue1 = s.queue1[<span class="number">1</span>:]</span><br><span class="line">	<span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyStack)</span></span> Top() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.queue1[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyStack)</span></span> Empty() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s.queue1) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="39-翻转字符串里的单词-151-中等"><a href="#39-翻转字符串里的单词-151-中等" class="headerlink" title="39. 翻转字符串里的单词 151-中等"></a>39. 翻转字符串里的单词 151-中等</h4><p><strong>题目：</strong></p>
<p><strong>示例：</strong></p>
<p><strong>提示：</strong></p>
<p><strong>思路：</strong></p>
<p><strong>复杂度分析：</strong></p>
<p><strong>代码：</strong></p>
<h4 id="40-平衡二叉树（Go）110-简单"><a href="#40-平衡二叉树（Go）110-简单" class="headerlink" title="40. 平衡二叉树（Go）110-简单"></a>40. 平衡二叉树（Go）110-简单</h4><p><strong>题目：</strong></p>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树</p>
<p>本题中，一棵高度平衡二叉树定义为：一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 </p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：root = <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">20</span><span class="punctuation">,</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="number">15</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">true</span></span></span><br><span class="line">输入：root = <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">false</span></span></span><br><span class="line">输入：root = <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="literal"><span class="keyword">true</span></span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中的节点数在范围 <code>[0, 5000]</code> 内</li>
<li><code>-10^4 &lt;= Node.val &lt;= 10^4</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>前言<br>这道题中的平衡二叉树的定义是：二叉树的每个节点的左右子树的高度差的绝对值不超过 1，则二叉树是平衡二叉树。根据定义，一棵二叉树是平衡二叉树，当且仅当其所有子树也都是平衡二叉树，因此可以使用递归的方式判断二叉树是不是平衡二叉树，递归的顺序可以是自顶向下或者自底向上</p>
<p>方法一：自顶向下的递归<br>定义函数 height，用于计算二叉树中的任意一个节点 p 的高度：</p>
<p>有了计算节点高度的函数，即可判断二叉树是否平衡。具体做法类似于二叉树的前序遍历，即对于当前遍历到的节点，首先计算左右子树的高度，如果左右子树的高度差是否不超过 1，再分别递归地遍历左右子节点，并判断左子树和右子树是否平衡。这是一个自顶向下的递归的过程</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li><p>时间复杂度：O(n^2)，其中 n 是二叉树中的节点个数</p>
<p>最坏情况下，二叉树是满二叉树，需要遍历二叉树中的所有节点，时间复杂度是 O(n)</p>
<p>对于节点 p，如果它的高度是 d，则 height(p) 最多会被调用 d 次（即遍历到它的每一个祖先节点时）。对于平均的情况，一棵树的高度 h 满足 O(h)&#x3D;O(logn)，因为 d≤h，所以总时间复杂度为 O(nlogn)。对于最坏的情况，二叉树形成链式结构，高度为 O(n)，此时总时间复杂度为 O(n^2)</p>
</li>
<li><p>空间复杂度：O(n)，其中 n 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 n</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isBalanced</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> abs(height(root.Left) - height(root.Right)) &lt;= <span class="number">1</span> &amp;&amp;</span><br><span class="line">    isBalanced(root.Left) &amp;&amp; isBalanced(root.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">height</span><span class="params">(root * TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(height(root.Left), height(root.Right)) + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> * x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="41-螺旋矩阵（Go）54-中等"><a href="#41-螺旋矩阵（Go）54-中等" class="headerlink" title="41. 螺旋矩阵（Go）54-中等"></a>41. 螺旋矩阵（Go）54-中等</h4><p><strong>题目：</strong></p>
<p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素</p>
<p><strong>示例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：matrix = <span class="punctuation">[</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="punctuation">[</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="punctuation">[</span><span class="number">7</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span></span><br><span class="line">输入：matrix = <span class="punctuation">[</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="punctuation">[</span><span class="number">9</span><span class="punctuation">,</span><span class="number">10</span><span class="punctuation">,</span><span class="number">11</span><span class="punctuation">,</span><span class="number">12</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">8</span><span class="punctuation">,</span><span class="number">12</span><span class="punctuation">,</span><span class="number">11</span><span class="punctuation">,</span><span class="number">10</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 10</code></li>
<li><code>-100 &lt;= matrix[i] [j] &lt;= 100</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>方法一：模拟<br>可以模拟螺旋矩阵的路径。初始位置是矩阵的左上角，初始方向是向右，当路径超出界限或者进入之前访问过的位置时，顺时针旋转，进入下一个方向</p>
<p>判断路径是否进入之前访问过的位置需要使用一个与输入矩阵大小相同的辅助矩阵 visited，其中的每个元素表示该位置是否被访问过。当一个元素被访问时，将 visited 中的对应位置的元素设为已访问</p>
<p>如何判断路径是否结束？由于矩阵中的每个元素都被访问一次，因此路径的长度即为矩阵中的元素数量，当路径的长度达到矩阵中的元素数量时即为完整路径，将该路径返回</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(mn)，其中 m 和 n 分别是输入矩阵的行数和列数。矩阵中的每个元素都要被访问一次</li>
<li>空间复杂度：O(mn)。需要创建一个大小为 m×n 的矩阵 visited 记录每个位置是否被访问过</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spiralOrder</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> || <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rows, columns := <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    visited := <span class="built_in">make</span>([][]<span class="type">bool</span>, rows)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ &#123;</span><br><span class="line">        visited[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, columns)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        total = rows * columns</span><br><span class="line">        order = <span class="built_in">make</span>([]<span class="type">int</span>, total)</span><br><span class="line">        row, column = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        directions = [][]<span class="type">int</span>&#123;[]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, []<span class="type">int</span>&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;</span><br><span class="line">        directionIndex = <span class="number">0</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; total; i++ &#123;</span><br><span class="line">        order[i] = matrix[row][column]</span><br><span class="line">        visited[row][column] = <span class="literal">true</span></span><br><span class="line">        nextRow, nextColumn := row + directions[directionIndex][<span class="number">0</span>],</span><br><span class="line">        column + directions[directionIndex][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> nextRow &lt; <span class="number">0</span> || nextRow &gt;= rows || nextColumn &lt; <span class="number">0</span> ||</span><br><span class="line">        nextColumn &gt;= columns || visited[nextRow][nextColumn] &#123;</span><br><span class="line">            directionIndex = (directionIndex + <span class="number">1</span>) % <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">        row += directions[directionIndex][<span class="number">0</span>]</span><br><span class="line">        column += directions[directionIndex][<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> order</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>下面的题为面试经历过的题目</strong></p>
<h4 id="1-Golang合并2个切片并去重排序"><a href="#1-Golang合并2个切片并去重排序" class="headerlink" title="1. Golang合并2个切片并去重排序"></a>1. Golang合并2个切片并去重排序</h4><p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Solution</span><span class="params">(nums1, nums2 []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	nums1 = <span class="built_in">append</span>(nums1, nums2...)</span><br><span class="line">	hashMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">var</span> result []<span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums1 &#123;</span><br><span class="line">		<span class="comment">// 先计算Map长度，然后再往Map里添加数据</span></span><br><span class="line">		hashMapLen := <span class="built_in">len</span>(hashMap)</span><br><span class="line">		hashMap[num] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		<span class="comment">// 如何Map的长度有变化，说明num没有重复，可以将其添加到切片里</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(hashMap) != hashMapLen &#123;</span><br><span class="line">			result = <span class="built_in">append</span>(result, num)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 内置方法排序</span></span><br><span class="line">	sort.Ints(result)</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">2</span>&#125;</span><br><span class="line">	nums2 := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">1</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;结果为：&quot;</span>, Solution(nums1, nums2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-约瑟夫环问题"><a href="#2-约瑟夫环问题" class="headerlink" title="2. 约瑟夫环问题"></a>2. 约瑟夫环问题</h4><p><strong>题目：</strong>有n个人围成一圈，顺序排号。从第1个人开始报数（从1到3报数），凡报到3的人退出圈子，循环报数，问最后剩下的人是开始围圈时的第几号</p>
<p><strong>思路：</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">JosephRing</span><span class="params">(nums [13]<span class="type">int</span>, n, m <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> front, rear, round = <span class="number">0</span>, n, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 队不为空</span></span><br><span class="line">		<span class="keyword">if</span> rear-front == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m<span class="number">-1</span>; i++ &#123;</span><br><span class="line">			front = (front + <span class="number">1</span>) % n</span><br><span class="line">			rear = (rear + <span class="number">1</span>) % n</span><br><span class="line">			nums[rear] = nums[front]</span><br><span class="line">		&#125;</span><br><span class="line">		front = (front + <span class="number">1</span>) % n</span><br><span class="line">		round++</span><br><span class="line">		fmt.Printf(<span class="string">&quot;第%d轮：%d\n&quot;</span>, round, nums[front])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> nums [<span class="number">13</span>]<span class="type">int</span></span><br><span class="line">	<span class="keyword">var</span> n, m = <span class="number">12</span>, <span class="number">3</span></span><br><span class="line">	nums[<span class="number">0</span>] = n</span><br><span class="line">	<span class="comment">// 初始化队列，入队</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n+<span class="number">1</span>; i++ &#123;</span><br><span class="line">		nums[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">	JosephRing(nums, n, m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Josephus</span><span class="params">(n <span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (Josephus(n<span class="number">-1</span>, k)+k<span class="number">-1</span>)%n + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	n := <span class="number">12</span></span><br><span class="line">	k := <span class="number">3</span></span><br><span class="line">	res := Josephus(n, k)</span><br><span class="line">	fmt.Println(<span class="string">&quot;结果为：&quot;</span>, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-一个单链表，如何求倒数第n-1个节点的值"><a href="#3-一个单链表，如何求倒数第n-1个节点的值" class="headerlink" title="3. 一个单链表，如何求倒数第n-1个节点的值"></a>3. 一个单链表，如何求倒数第n-1个节点的值</h4><p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Value <span class="type">int</span></span><br><span class="line">	Next  *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListNodeLen 求单链表长度</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">// 	head：单链表</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">// 	lenght：单链表长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListNodeLen</span><span class="params">(head *ListNode)</span></span> (lenght <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> ; head != <span class="literal">nil</span>; head = head.Next &#123;</span><br><span class="line">		lenght++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lenght</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ToSlice 将链表转化切片，然后直接下标取值</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">// 	head：单链表；n：第n个元素</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">// 	result：单链表第倒数n-1个元素的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToSlice</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> values []<span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> ; head != <span class="literal">nil</span>; head = head.Next &#123;</span><br><span class="line">		values = <span class="built_in">append</span>(values, head.Value)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 切片长度=链表长度</span></span><br><span class="line">	valuesLen := <span class="built_in">len</span>(values)</span><br><span class="line">	<span class="comment">// 判断是否会越界，左右都需要判断</span></span><br><span class="line">	<span class="keyword">if</span> n<span class="number">-1</span> &gt;= <span class="number">1</span> &amp;&amp; n &lt;= valuesLen+<span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> values[valuesLen-n+<span class="number">1</span>]</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FastSlow 快慢指针</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">// 	head：单链表；n：第n个元素</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">// 	result：单链表第倒数n-1个元素的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FastSlow</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">	dummy := &amp;ListNode&#123;<span class="number">0</span>, head&#125;</span><br><span class="line">	first, second := head, dummy</span><br><span class="line">	<span class="comment">// 需要判断是否会越界</span></span><br><span class="line">	listNodeLen := ListNodeLen(head)</span><br><span class="line">	<span class="keyword">if</span> n<span class="number">-1</span> &gt;= <span class="number">1</span> &amp;&amp; n &lt;= listNodeLen+<span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++ &#123;</span><br><span class="line">			first = first.Next</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> ; first != <span class="literal">nil</span>; first = first.Next &#123;</span><br><span class="line">			second = second.Next</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> second.Next.Value</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DoublePointer 双指针，优化后，不需要判断临界值</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">// 	head：单链表；n：第n个元素</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">// 	result：单链表第倒数n-1个元素的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoublePointer</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> second, first *ListNode</span><br><span class="line">	first = head</span><br><span class="line">	second = head</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; first.Next != <span class="literal">nil</span>; i++ &#123;</span><br><span class="line">		<span class="comment">//间隔n-1才赋值</span></span><br><span class="line">		<span class="keyword">if</span> i &gt;= n<span class="number">-1</span> &#123;</span><br><span class="line">			second = second.Next</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//头部往后移动</span></span><br><span class="line">		first = first.Next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> second.Value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReverseList 反转链表，链表反转后，未反转的链表的倒数第n-1个节点的值就是反转后链表的第n-1个的值</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">// 	head：单链表；n：第n个元素</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">// 	result：单链表第倒数n-1个元素的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReverseList</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> prev *ListNode</span><br><span class="line">	curr := head</span><br><span class="line">	<span class="keyword">for</span> curr != <span class="literal">nil</span> &#123;</span><br><span class="line">		next := curr.Next</span><br><span class="line">		curr.Next = prev</span><br><span class="line">		prev = curr</span><br><span class="line">		curr = next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历反转后的链表，然后取出第n-1个的值</span></span><br><span class="line">	i := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> prev != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> i == n<span class="number">-1</span> &#123;</span><br><span class="line">			result = prev.Value</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		i++</span><br><span class="line">		prev = prev.Next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateListNode 使用slice生成单链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateListNode</span><span class="params">(nums []<span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">	<span class="keyword">var</span> head ListNode</span><br><span class="line">	<span class="keyword">var</span> pre ListNode</span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		node := ListNode&#123;Value: num, Next: <span class="literal">nil</span>&#125;</span><br><span class="line">		<span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">			head.Next = &amp;node</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> pre.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">			pre.Next = &amp;node</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			pre.Next.Next = &amp;node</span><br><span class="line">			pre = *pre.Next</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>&#125;</span><br><span class="line">	n := <span class="number">5</span></span><br><span class="line">	head := CreateListNode(nums)</span><br><span class="line">	<span class="comment">// n值如果不在临界值内，返回0</span></span><br><span class="line">	toSlice := ToSlice(head, n)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;链表转切片，链表倒数第%d-1个：%d\n&quot;</span>, n, toSlice)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// n值如果不在临界值内，返回0</span></span><br><span class="line">	fastSlow := FastSlow(head, n)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;快慢指针，链表倒数第%d-1个：%d\n&quot;</span>, n, fastSlow)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// n值如果小于临界值指向链表最后一个元素，大于临界值指向链表第一个元素（倒数第n-1个元素）</span></span><br><span class="line">	doublePointer := DoublePointer(head, n)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;双指针优化后，链表倒数第%d-1个：%d\n&quot;</span>, n, doublePointer)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// n值如果不在临界值内，返回0</span></span><br><span class="line">	reverseList := ReverseList(head, n)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;反转链表，链表倒数第%d-1个：%d\n&quot;</span>, n, reverseList)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ToDo</span></span><br><span class="line">	<span class="comment">// 将单链表转为双链表，只需要找到第n个节点，然后取出双链表的第n个节点的上一个节点的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-多协程统计10000内的素数"><a href="#4-多协程统计10000内的素数" class="headerlink" title="4. 多协程统计10000内的素数"></a>4. 多协程统计10000内的素数</h4><p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// JoinChannel 协程负责将所有需要计算的数字放入intChan通道。注意：全部放入后将intChan通道关闭，这样消费者通过for-range遍历时才不会死循环</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">JoinChannel</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10000</span>; i++ &#123;</span><br><span class="line">		intChan &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(intChan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CloseChannel 判断工作协程是否全部结束，如果结束则关闭resultChan，以此来通知主线程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CloseChannel</span><span class="params">(resultChan, exitChan <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">		&lt;-exitChan</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(resultChan)</span><br><span class="line">	<span class="built_in">close</span>(exitChan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Calculate for-range循环遍历intChan，并计算是否是素数。</span></span><br><span class="line"><span class="comment">// for-range会遍历到该通道被关闭未知，当range循环结束后向exitChan中放入一个标识。表明当前协程已经结束</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Calculate</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>, resultChan <span class="keyword">chan</span> <span class="type">int</span>, exitChan <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> intChan &#123;</span><br><span class="line">		flag := <span class="literal">true</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">2</span>; i &lt; v; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> v%i == <span class="number">0</span> &#123;</span><br><span class="line">				flag = <span class="literal">false</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> flag &#123;</span><br><span class="line">			resultChan &lt;- v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	exitChan &lt;- <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 任务队列通道</span></span><br><span class="line">	intChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1000</span>)</span><br><span class="line">	<span class="comment">// 结果通道，所有计算的结果全部放在这里</span></span><br><span class="line">	resultChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2000</span>)</span><br><span class="line">	<span class="comment">// 标识退出的管道</span></span><br><span class="line">	exitChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="comment">// 分发任务</span></span><br><span class="line">	<span class="keyword">go</span> JoinChannel(intChan)</span><br><span class="line">	<span class="comment">// 开启10个协程来计算素数，并放入结果通道中</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> Calculate(intChan, resultChan, exitChan)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 开启协程，不断从exitChan中获取结束标志，当获取数量达到10个时</span></span><br><span class="line">	<span class="keyword">go</span> CloseChannel(resultChan, exitChan)</span><br><span class="line">	<span class="comment">// 主线程range遍历结果集</span></span><br><span class="line">	<span class="keyword">for</span> result := <span class="keyword">range</span> resultChan &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;素数：&quot;</span>, result)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-abc组成的字符串删除"><a href="#5-abc组成的字符串删除" class="headerlink" title="5. abc组成的字符串删除"></a>5. abc组成的字符串删除</h4><p><strong>题目：</strong> 一个字符串，只有abc三个字符组成，现在需要删除字符串，删除规则为：每次只能删除2个字符，删除a和b或者删除a和c，字符串能否被全部删除，如果能，需要多少次</p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Solution</span><span class="params">(str <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 判断字符串长度是否为奇数，奇数则无法完全删除</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(str) == <span class="number">0</span> || <span class="built_in">len</span>(str)%<span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	a, b, c := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> str &#123;</span><br><span class="line">		<span class="keyword">switch</span> <span class="type">string</span>(s) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">			a += <span class="number">1</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;b&quot;</span>:</span><br><span class="line">			b += <span class="number">1</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;c&quot;</span>:</span><br><span class="line">			c += <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// a的数量等于b+c的数量</span></span><br><span class="line">	<span class="keyword">if</span> a == b+c &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;aabbccaaaaabbcbb&quot;</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;结果为：&quot;</span>, Solution(str))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Go编程题30题"><a href="#Go编程题30题" class="headerlink" title="Go编程题30题"></a>Go编程题30题</h4><p>链接：<a href="https://blog.csdn.net/weixin_45604257/article/details/101649973">点击跳转</a></p>
<hr>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>项目经验面试题</title>
    <url>/2022/10/28/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容">
  <script id="hbeData" type="hbeData" data-hmacdigest="d452ff13ee50f208ba2e56128b8f5aeea374eca1f6bc7e222952681e9730f306">a17b4de793b95f7877066d2186f5861555e2d6b9cb5641947e36c8450a9062241bff23f016a5658fa4702bb8625e1a64927d2e249a90caaa62600a11f5dcd3f66c53fe7239ac25300620da5c82ec4d458706cb81b1903f8a8894fb74b7b49e178b1ed12b5113c92743dd83f16334b11a519cb4937b1f6ca060c3c1602c2e5ab00497eeb7b7d7a4a4a45ca9b9fdc711a262177b0d5ff4bf6e4c9c47d80447f23cd18eb13e8c28580fd1c2934f779e5086f01f803a4ba6bb4a6371d982998985660d5e9b2cf961c1e882ad1c8a8aa710dd432f2230184282005f3cf944af4755a25a3afa8390b4846e22e0c1344ab3b49b32905d7a0b7b3d57bc134676a5f95bb0dac112457d1ff1baa0748602ed6acea81a1644595c8dabb2237e7dfe4b74ac6ff80dfad29602cdb7e29dd4231532cd59a7a98f7f65299dcfe64d5994d79830a9a55e40f90473ea96085cf8352db10806f20c766362c05efdd8e74d8c881ea0ddc387a76ce4bef6288cd709e9616eac194dfbd36930bf49f966568e3747c080b7a1a7ac6c9f996a1e407272e137d22d669d9966d6a6fb0476d04bf59df903b3430fbde42913ce18dbb0f77e7b78192746b2f7c5481cddc741cc7bbef8a44c59c2b3deafb2f06fc0fb2ab69ac65be6f67946ead0c4bd7966629d441238e166742e33d9f6d73430a28fa1077777e863dd000ef7ec4d692930e9b562acaa53e9c738b55cf7258331f79e3f63c47c45147d7f8d0635cab43fa82bbe470eecaec98617b92281a05d93b92f489332383de12333f59eefbaa918bb6b38be2895ae3b7861bcd02398eb42cda366c7edb297284672cbf1cbfc2f60766010b21f17f7bd23ef57f225611ac5ea8d2dc7584f2aeb16f0a50e99daadcfaffdbc7b94544ae0c2267917cabfa0b25e3e059e79e8017126d985133428c9a3ca2808f29155cc987d25ee968d63f58e7c1a34db327fd0b61f6ef2194d97c3c9907a9c1f6d8d35819b4eea39a6908d2da7fd6968a8040a9441260e04c43c9dc6f1b9a3880d7607aece4a3d6e181aa5978796603c3d3bbdc8058e6bea6dd2ab6802395cdacd440fc527781853f21f72b171060b271fd81139d3af25926b4cf8b612ab34e5ce9cf85c92d5d87aad45282f1d038d80afc25c95f5ee3dddaec2ccaeeeecadf6c449d14152e3223d2723b3187e41e90d3c57c1975741a63b9f2e37ea1fa66f43eb5df7dc3afae2f630a6fca55a3d4d319078f74fdca366ee0a8cfc006d5de6ce7db111d2c071f32e290d523cd99ce434003b28fd8fc7118a64b255ae3a0235925e842d72ac7962dcbad744aee5a7a8a0c69e597d8af7189c92b354f19d2b11c2a9bc5f9f81c77545ec44b54b18efdce08f8ded84a6a1baa8f224803d0b32cda4f41b4a0d6cd053407266d47937baa6029abfa0777c14a582cca4f70946d1d78ffabefcf9f7481d5eea5eb81926aeb8defd70bc342e03f16bf75782063290a61febaad44f9bec65f070b75c8aaabc05514eb1d1dda550528acc2ee8d21b6264440dfb5585bf9764756324cc1c60722913de487fdc0654d35f1c893fa6bc41456053dca7fdb2c9b961ba8128009947320da3c0821481a4f1fba49bb5160c0b0797c0a4bc1b16848c67fa80843bd7f9e0aaa43e63e109cedcc3a8d27ea2765e51438ade4c286b9c1e77a2de8c55a130af196af8b2839b6f97dd08edfffc3ace18304b60f0935269390c7d5a574d2f12d5d9771c9f466f27dd51ea488fe37c34d6aa112843a7fb0029adca1704baf3e21979f858c33e3f0027cb10c9b0ab7cfeab84869b4ddc7964c7a87f95091e769a0cc8ec95cd6eadb56f6acd9e624cac4811fb82d586d459a41891b75b910ca8217bf71fc047bc5160cfaae7b472cdee7d3b74fa7d419fa45ec40a12ff8ff0a47f6b2992d4d425058c23cb58154b8c421719fef35d035e7c13adb0e3535025fd6482019d43e567b0e9585fba7b60ab9ee1ce5a59bfe7d4bab77e10f1afae9740fce16dba0a5a05ceb5cadc358721260d5f6aae39011b7a578f575e9b9e15b6862b7932b756aabb5713b6f7f92ee9d54e7cfc83cd012107ea6e823b983fd276bd1b75fd1d95ec9da057f56fc0827333649368ff709f0491e12b9cb3cf73d9c1e4efcf2a1a83975e7056774a686fd3e8b78120d5092712f7a09eed7d94b42931734618ad041b97fd57c2f87c3cf9b085ab0cf50920b30067ddf7d5b15d045bda3434611a0521d062da41315756094b800c12cb30aa8514f7568a759b8dba31ab691c016328b0f31bdbfa6019da0b0dce6e57842e8bdf4532e641306ee62659b40c437a6bc56ae8134ad7815a20d9a08805766b827210b4046af906cb1606fee5f5af499f85835cf11fd6f309132375a12f054e2a355deef4e4c14a9aab3cedece4a39a62770e8cee493d8b8fda7b73fb8f3391590a060d0d243ddd044ddefab9932958f07c1941859f1ff11d2eee0bdadfafd267f7f7e71ae92fd48ac5c9043a98653780b4a7509ee2902b3899df7fc06600787a367b7de6bbc07b74d2fb21a0ce15adae8158c800dec8c16eef115b8a751a47a741cf720f5f99541675861a5cec80064e4d7f80e6dfc0e64b6bd8b31104e19a35611030f75a910832460fbfd8e92b3a00401dde53f04a0d68e036e03391c613f71caaa686b5018bae56a3662b2424913483176f4f7b132fed435fc140d267b2c2a24844cf1b6e204fd66f58bf4704771bb5a8ba565e4b9f0e431c0bfd46e798437e1c9005a9a2023b8e14e189f3248cd885120dc2f7e54d8f1cb5e7238c6389966059f717071ac6f40c9d99941450472583c242dfb270d315f220e76744df9e78d8cc97249748dde500391cc59ead8a37bb048e4d69a54798d688a504c9d8cc4ae569691126880e0ca35390191ca509ade324f261fcc5f3d2abae39bfb0aed31aee7572bb3a9c524fe8d025558c8b6e1d9658a89e6a5c527a9f817ad627a44dad75d2bebb6e6358a2d36a87a92acac9eedef994eeba4e4cf3009e30e3a4cbf3b9c7d285494146d42280e65e50ee9525b36c195a252462f1ce3de01849aa5d277ce6b1f2e3fe5abcd80febf479fc523e43478770413414df2eb804be4b8f66193ab2cbec10efc34983cb2cc7d39925e9731e7e61b07647f51f42925873ca99ec3cdbd1584e94950adf6f40da5840efc1e978c6041dacf2ba690fad7d832d18884666d56f35a70769836ecd1118eab4ade8b16f487427c3f942abebf014067eb905fc0469be0264bdfd18e81eda5ec45a439fe64cc0d95a45a05046db0308df4c1f79cb91e523fde48b84d7b5d3ffbe3140603b771b1a2b43709aab2fae3a7c3a1a92ffebb78c98f728c60095915bc4be861145e0a3a573f050bef17c033660b08edc9dbba96f49fa25cf476cd1d300299bccbfa590e66602338fbf475c7b6a53b2a5a4ba16e16c64db69219a54e09453e74490943e2492aaca246777db1df34cb21629fb5dfd58bd5504340041d0301341bcbabb7809eb0240bfdd80c573149c99ce880a1ead990e2cf0a05bc68a4fb9ad0c9bb6b51d284925788e8e4a026c38e6be7c52ed4e9fd77f92e363cacd3ae35df628bfca47e5b4b288569d3d3d1e590b675e44beca02083b96bf2f01355bc3c6749be031e701cfbd2b23af75d7d8cf2f1ce862b5519c0b4237c8195866ed5528cc2dc0916973b3bb1373319e8c169b6bbfbcb7a6decabb15313b365ed3c3aa519605d6dc0612ee2f70555a479a1dfa9ccb407d155576b767d4b3561fe2352ee2006ea5700d1eaacc402f5068bf84fe15a3a7b10e4e07dc5800bf8b5d175a2aa65c6ac0a0e9234c5a833e0cdef4f5348e7e1a4c12398b15cfe8c34440e0839de2720e4178441f92ec4b148a0cbc98ed29bf7d65fbe47070b37aad788b5844e6693cb75de5863051b00e0ac1737167b4ec976e7b8ad4d6d29ef45c086f65043bd5e535d37a3a7cc2fb77e668b116a38d0ddb4e75be47aac38e66051ef5a7c846d6472f20f9f84e9f598a7453b705c32219f32f9cdc985ba70ef1e1b7b9dce135642b9154dc37c481877281333034aae58607963c391ba7e2ef1eb10ce9866ac45146df331aba2d5594fe87d6dda18225974e6d4b8d1b1dabdc2eb755c6af069f11ab9b797cf900d593ca917193806bf6755ff41e1a1da9627cf2d0c94f7ee3aa393d448c8816ba84597041323647ecc9f308b4c8c2c2e3fd808b65a3e652bdae837c9e39bae3d0a3df0bff5572708d1b0f794f0a1fb396b9ba2c8491bc56359e01e83ab6c5bb358c1636d940796de21c0eb79b9515e03d8d7b82352a6453336069ccaacd64374234f6bd4f07ca878d9a21075a9dde43bc4a5a7776ad55b290bdbc87695d7b505adcda6042cb3bd8cb9755e72127eb114697d3aef789f9b9d8a9c277d5208f4f064f25f5f93d7728c8ebb1deca2a2945799c000f8cfcca0c9271a860a9952582c2da5d5268e5bacaf3a0559e5404a1e683bc1797efaf7ef8f037a18fa929960d906d04e7e33c534dd777d6e36c8a6aaa97cda29b76874a6d29db7a5de8d5d740a321ad27116031100d65795f1885b57abc578af21a95610a8bcf98e3a1623cfaefd1d8b4206c88b64d295ee6c4b278279bf46aeb523728c545e2743022289765460ad8880bdb63c4100a6985bc44bc10ccca93649e290c3b8317853d6546c8f30ea5ebac529eb0ab5ebfccbdc178c6ba86be7c19986590aede86cf8924c2505f9e6dc8e1a461b51610700d31d13e294a74e1f979db9ab9f0175283895dee8de5d42d76e0047ac7eb74a7d31e84d705c441c60a61aa0d5f287237c539170161cb7fad127f82af70392da4bdf4e7f4302666760c1ea3946477dc90663173f3f36127d04b5d0b30efa6e9c9d8dfa59342ec9eee5395c321b18f096653c2f96267f4fbef6d77a23dacc81f5bea3b1932de14a750c172a17d1e8e43d80eeeb988c15becbb4e2670b9bdbc54a13327ebc7b70659d3775a5e9f1aec88c2baeeea46186693b657f911fae72dc7d1bc3d3d1e4aa6d67a317e8236431b5f1fa27c4e4923d06f958e0a07bb0fb07a1ced0c5eb955036a7f7cf3a844740bcd8c59cbbb895bdfc0dae9382f51f7093e5671d17186a1847d7dc4a79f354c8bbc9894f52e4eb61ee10f33b4ef9bf4508cb9f22ddcbe0569f21d91e4f58e41527f4a7354a5b4abf318579d0e7d918a62e3a0cd98996490b3fb765d2b812494773dfb0828e6f187270670a6ceb3e1953b0eefc7357238a90a0874d3f1cfdf67c1b2a2315721854b0030d37e2a9ca16f01f7c8355214b2db52a509b090e33aeb609fd93a77dec9646378a014ef4d35e0996df0c094fc59af5140519774a169d7d0d26085bad04f750a1a7d37da12a1ec2eca5a412a825e82b67c83d0093a0d09b3b52065d7742c8bbf9e8957d3ef7d2cbe58e845064eb3f0c2a14e26d1d9f166ce312139aa6fcb40e11ecec07fbbdc8c29b56649c04bc056cd62bcba2b85c007bb1f4e189610184f864fa1e791c4524a3f04c120af75414f2859f7463fefba0d0bda1d9cacd58bd9716db5669c06aa3d930c8bb5bf590fa543bb6da41a3176d701d7314ee5a36baf60d448736baa7323c77ccdcd263c27fa950af15266789290d2a217451b91f62781e6443c7dda2bcc8ec23152af7ad4ccb68b803808dc34aede2bd49335395cddad79f00762ae4af07bfccfabb948ecd42e77dcd9f519a90d28853dbe03e825e6b2de3b4d65eaea89d9a99329ce6e4fb7e1c9cd763f1bd7919a2f6b5caa8f5323a017c88b1821ab9c8171245e0683c6e622331bea09789ebe8765131b30b6c025ece812740cbf020ecc8fdd128cd73810a58f29d9bdb58464cd0e645e0652b56b25671881c162cde0b6591eade356bdcbdaca4b0c29a69d69a400ceeb52ef931e9b2e783d42907f269b3c0232d555c3083be6f836d7638bbd34041f12d2a54e14d60e4b4f65090beb6e5f6549848cc0933f527605d323c1ca003276a44ca8e83dacd36991e9667d85d81a0819ab22b94579a4a20980402c40c0c3fadb454052a21926737fa4e13e234953236d1fbb35c61a830650f5d57a96c8c095578fb4ed1d81ad425239720ccc948c3cb5aa31624e5788280fce018303e7557001160193940c477a2f78c96a3136d263cd97abc9e12574546ac201c924371f04def27d43d9a0bd9b4e3a813f2f9cc34892af4755dcb1c9c23330d95063d3e7b43e63a6f0140d1d0bf459f5a2bfeb73ecd78f594a236b15a051c16e3ecee0b1cfbdab90d59170a7f6d18ee01dce5d31d0c733184830c43b6ce9dbe6e2a13aa555fa7a7f40b37f39916d018db56a4dedcf30efe76388b139b73f7f58c51f7ae5ba7753043260b7e7719f28dfc1544ee54d136179934727ab45151e1c258ad32dfc92d41768090031ea9bb2155c00c186b2a5411869c8d0aa2dd1437235939c2a2ebd9d7fd6516372e9eb990d17292ce53015ece116558e82eafbae9d9ad912a187a105836cfad468b03d5fa0482509872a468fa49c277d9c19081a0f4e11ec86d87997ca25219950efe4ea5ff41d8ce0e178832b203f36cf5b108e75f94bfb9461a1afa7b1becdf49784a060f9dc21bfa93f4aed05594a8ba9bacea5021227198f64d417c59683b8a1dc933d3ff84494a1d16cfa5092782fd34cf22d8a0a323fbc5692f24334affdf46da4d8420409fbb5929546ff6d5f549f0019240f9ecee5a3ed0aa172a077e8182d9b889d665cbfabb8bab6aad29e2e1aa977d2213a5419f94bce8629607d3c2063b863c766f8db0bafa053f7893bdf039d6f4d75c1b7c13033ebe9a2b3ed797cc9c26c5a37f60a4ccff500e237b8b409abd470da0d9ff8636199e0bc35f113844a50c068699898403def02c60032f1ff764a993f56ac60bad83f406c352a94bfdfd6dd16bc34c6674602721395c38d6b02aeecfcf8565f841a8036e95ace7aec1f0f4ecf6f71ffba178cfa5d438134315d9c4dcd544190075ba62561907b9965376c52935a873f49d3686ddb33590b5bf4dcff38bbd4540dcc72b91647b4b97bc967b354fe9fa7d0160b9dd8dcab546cc76450209bef189f34050b3de3a071453f1ed2220db08e52a0b8d960d0e517f2e6c4595a918c3abc3a6aae72f3237c8d08601fd4ea1f69f9161ccbef94bdc9e08fadbfa3eb4e9e810f4bdad6dc72eb062a839704f1ebbf7570862ccef77c9bf915c31189a0719c220b1be768fd9a268f42ba09bb6c6b320749d9f8bfed14a5ec7063519c62c4f02132acb0285b112f4678816d77aab0619b28c6f38256bda19886ee49403973d1994bf7caafa083302c6202b2f997d7e79d3d9a1454df2a1ae39280b9927d238d53c4ab7e01e49fb60c55b174d5ed25681c46199b407b14fae9124573bb952059fa83044f9c853bd7cae91b975c51810a3254c83bddeec9f0baee3c175494d5be7c9be55a9672a6fec7e24664dd8d3039f5c4d56e75a1f40dd5da32d47e8a4838d4b2e912bab176ee90a20a875a8f20c62407cc30005dd9b87879f4eb1a30bd7021ba095ed4a54d7c14502beaf355f7622f171323309c873cef5397083119798df73217daba372f50d67cdc2852412272b97a9d80b0e987b6bdd65003c9f6af7590ad8ee30c1d2808fc928c48437900b5d0bf15c0e0ef94f3ce3a4b0378c5c38fdf4c822e125c3ccd50e0f13f9d457469d6e59f9fd749c8ebc341161e595e85ee235a9a498f0c66fa3b3ee81e526f7c1adb9a809952cdafd6d9998a3741b08b92437b5c842f83e697444804f4b0d59a685aeb83da3962d3605287960c718d153a785d67daeb43a980cd28ea40fe6a04febeed6060ba5e47dd9dfe4d1b399c81e0ada75652890ce9f05bea656fea095c81f984601f222c4f9c7480efd7982a13cfa035920e019966628dfa83949b108d5d97622310f4948981f9889f3e5862866871440eafc565fdf2b954663361737fe2c3a3165ea10c10cbcb7779859820c103e3d1814dba63511bbb3d265cfbe61505550396803c1c9666055818249c399d30190607549228c886e20c82f25e35352d53d5ea37c7afa0fb9d1099ffec07b41cd249b3cb79939524d5f33744e7ebbdfffff39737ddc5983264acafd8ac21afac6388bce7c13fd72f09ffa8cca148f84b54fb0a61cde170e5a8709be3c4796210e63e92e61c1e6e7c0d3de5b300ff3717d6b53ca1ff454e9801350ce26f016e66ddd444bcf249361137ed916f8c7430841ce678aca2959a4ea1fc7ee6a2282dfbd16f780a9e9b7a0ff2c29b51791773564849f5538e752293d07d27382c6b0f876fb9aa3b40ca9fa79a92faf624dea7f5927c83efb016c377cdadbe0b4cbf5a3139dfa771e76e26fc695a38d78271f35b74d33e92441e171837a1fe9fbfd55269d79f09952e9379ae926bac21d0e325dab54b85409580fab93d252b07b3a07ffa1a37fbf1f4b309b6c2195847ca7a0cb59a41b1bf054631d4167aeae444da6054213e3d77e5221f3e66ce09a115104082dcccd0d257ec909eb3cae255d5eab3e16917a2798b1ff1830584a3b3f16680fe8fe8106629346b42a30f7ad4ba36def1c445479a3c5736bd3a8427c559bfd14ba241357d22877bdc944a3a9cee05df9697b46be0a1c50cb06f37050f7b162f6caaf15c17d6536486dfa14e4d996049f3cba3079debe4fc6ccc6f27e37bd08f4fa8a5fe7632bb9b6d6f7a0deb0998ffd64fca596dc0248b41cb5ae0927a5eac9c06eb38733d55d84077e5614fd340a050f8d972c6c0411e10c62d82bf7633fa1ab2ce0d7026d087b519ef3d6c9abeb76f42ffe5ef89e35fd72f32d93df4b069f51a8c97e8d0dbb70cdf9e40466faeb48b9db07a137c002725f0326eef4ade46e3bf85096a6e3040741710ced981014e0f3e0bba98951fba1c2389d569edd1a8c09099eb2071d735d1d786c455a414ee8032debf2ab96e7659924baafe78b8554d5eb0e18e9cf18e0819ac5cbe2627ad85fcd26a0f3d0f0c820b3d9949c8efe49f3fef872d82330e3d702a6b385c58505f71b475b73aa021b2516db9223cdb50b8e4460f18b8524e465456396445d88c1002e7a915de51f1c661f4263f367347c47d9851f34975020dad751b1774a7cadfea8b92f8cc909529bbc88e0b8e3dfc7ef11dd147f9070e43ae502f0d2c24f5b6562b7e7c53155df2bcb474fbc38dbe4042ef92790f8126720094cb38dc9f0516370020cf9afb500ca8c4e50863f7dc89acef33461cc1952c98416339b1cb962d9730f7eb8e0b3e030c5a9a4e0bf3cbca37a4589e34de2af466ab6fc55f089bd3abe227af28a6e2149802ba425f785a6d9466c9cd72f1c637c46e2f16b4240256e38654cc90576ea0036ab0bec3ebe484d3e911c7078379537490d9f0d3a26222b8dc58c27fbe826e2666fec6f4e79a01fe0d46bafe4937ac04f2d3fd95b26319a2dcdec1a32a8de7a4f46ba25952012cb560c5fd555b16d8bb04e7ff432ae0720feb4a6c8eb822d2027a65be1b361a2cc0a4c34c3de35c1e68efe94bb0f4380b74304e25d486f86fc80cbfdfe04e891cd30f94eed6d7d4c01eb74f9d2ec357f00d7a23ff91e86e659173327bf15e516b2fab6a10b60431607f91227f93c80440f5fc245dd0687d45a21543935135b20746c20e5d8e33b4066ee47cbb7e8dc096407ebc41f7c9c2b3546a3988fc919d9c1745a6c5beeeb49a9cd40e81736c23fa7e5a3faf75576df46afc2a0af6192cab668329a9581134c7014ca6e8b522f3485b41357acb7200dcfd605c03fbf919c71f6684b35c280ec3b5e268d2e97411370a7f453908655d68d4798c5b6ebe6afad88eb5fe419c388acf5ccdfeab89a6a68ca310438da9ad68d3766e01ee820e202652cf45067344943673fedbfd33ad9d16bb4bfd72787cdbacb6e188e7d62d83393626fcb190358c5bbaf00d8f82c1fe9bee9aa5ad4edcbf074347b6f9a785400691737268b277bff6a4ae823a3f0f3dd744d6754eb69fd8d4f08256fc41315ea3a8f732616b317e50d0bd8e57be541441c0b7c9ebcf9b07de5c77ce6b52c14fb67d2ddd2380bb8e342a06782977391f0c4c321499d3e6d05f552fc68145e244ed6251d17d9076756840fd34bfd4629abb4bc7718deec622fd14206041d54a11f134613f234f41303649d06d550973f55e522183a69c4b1c2ec2708d817b7c7a4c4a6bf13ea6368c3d34820d44f0aa8e0cf93d283c0507803bb54c2f375262996f0700177ed5e0a52237be5bf87cdf2f573832c5f2d3b31d2188f839569a7b6d37bf530685a9320993c526902145fa0294a6fe23aaed285e214445db2545c6673c23753343a35ca29f658b756876e0d2d1eed17b8647abb5fd88c51730f3bd5a85ecc7de8e8544cfd385e979b20e57849e84234ab7a1c041da1f01e80454fea302ebb211e24b55370ebf65d3b8e5d4a425678fb56d87fd32073b2abe6405d0e4ba5cec6457f98697d6ed2a5af11aeb272e9f6321d236760fd7cf5e59dfc058d2565d1c575e90ebfbbb9914ae8e0a70c532b3e0eb96e03e26ed08f25b04f6000d2c2b06408183c6e776a8a3e1176b484542c6cdace8e402b0a6efc87dc75a85bcf220fd126ca1c2bd71286493a92e52ac46c9bcc276399b4189ea1eb9644c94a6829263e1ae64ef2566b0a1560b98c040b4b5c7a736ebba7757a62c9a793e327a70f19b5808f738415d57189c1e7ea20055dbb6747bc0c4df666cf4e64bd7815a4534cd1106fcba4ab16d2be8787d27deeda036b66aadd81c5c750ebb266fb27975eade9ae3e81e3870d7615a5ddd7252a98528ff28f64facbcdcbad36ea71f748408850bf727a74f1c10d791439eafb9ed6307dd3aebf0b55f29b094a013cf659d413b3fc241f688f2c0eb50f327a0a42fc4d97598d15435e37227091758bd50d0c8e298f044f23e599ae9c37145e8b22dd487dfe1eb3dd2157d890757ad0a89be083af2a2df62a1269b41bc9c70012050f763474b4956958ab05cdabdedc204cf509a9137a98073b47d24878088031fac05341ecaafaa1f51281af2b4fd6c8e760d23fa877e5e6c4e653c0d1f0fcf6b5b2e216bfd2955ac9d6c5e2ae5adef396c44cf163236959a861f2d4be602c07d139e7c43f0ceb9cf04001db4380d633b54e4f3f5c4f60f2c5ddc8f86eb3c3794117073e468be153d9ecb2719212d76d0b5b1abd25b809149efbcd3468ae91f5ce34ef08a7804f0af5ea3cdbcc97298d4113f3d554083d290cc445bfd628a6be6031fcf41db3455fd347d698e22ead75e8c0ea8a2a67965a8723cd0d16eb8a090b125716d4a4eff71761d5566e48bec9a8c522bbd7154ade6ff2cb7a05d22ab610d21d510e891a087042df843f8ff5ac5da0dfc5d281ba6aa8c6661008d4278cd4730b9a079549e59c04ee8403d10dcf4770faff491258fa93d1e28765b5592af2ab38f9d760a8351c92d36eb7f85546e235a46c908696f99335aed9197054706ec2e289037bd04f1</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 请输入密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>项目经验</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络面试题</title>
    <url>/2022/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>计算机网络常见面试题</p>
<h4 id="1-OSI七层模型，TCP-x2F-IP四层模型，五层协议"><a href="#1-OSI七层模型，TCP-x2F-IP四层模型，五层协议" class="headerlink" title="1. OSI七层模型，TCP&#x2F;IP四层模型，五层协议"></a>1. OSI七层模型，TCP&#x2F;IP四层模型，五层协议</h4><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7m5w06lbkj313n0iawpi.jpg" alt="69.jpg" style="zoom:55%;" /></div>

<h5 id="1-1-OSI七层模型"><a href="#1-1-OSI七层模型" class="headerlink" title="1.1 OSI七层模型"></a>1.1 OSI七层模型</h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7m5mu30e3j30v41834qp.jpg" alt="1.jpeg" style="zoom:80%;" /></div>

<h5 id="1-2-TCP-x2F-IP四层模型"><a href="#1-2-TCP-x2F-IP四层模型" class="headerlink" title="1.2 TCP&#x2F;IP四层模型"></a>1.2 TCP&#x2F;IP四层模型</h5><ul>
<li>它只有四层，相当于五层协议中<strong>数据链路层和物理层合并为网络接口层</strong></li>
<li>现在的 TCP&#x2F;IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层</li>
<li>TCP&#x2F;IP 协议族是一种沙漏形状，中间小两边大，IP 协议在其中占用举足轻重的地位</li>
</ul>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7m62vqibaj324q0v8amp.jpg" alt="image.png" style="zoom:20%;" /></div>

<h5 id="1-3-五层协议"><a href="#1-3-五层协议" class="headerlink" title="1.3 五层协议"></a>1.3 五层协议</h5><ul>
<li><strong>应用层：</strong> 提供用户接口，特指能够发起网络流量的程序，比如客户端程序：QQ，MSN，浏览器等；服务器程序：web服务器，邮件服务器，流媒体服务器等等。数据单位为报文</li>
<li><strong>传输层：</strong> 提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议</li>
<li><strong>网络层：</strong> 为主机间提供数据传输服务，而运输层协议是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组</li>
<li><strong>数据链路层：</strong> 不同的网络类型，发送数据的机制不同，数据链路层就是将数据包封装成能够在不同的网络传输的帧。能够进行差错检验，但不纠错，监测处错误丢掉该帧</li>
<li><strong>物理层：</strong> 物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的主要任务描述为：确定与传输媒体的接口的一些特性</li>
</ul>
<h4 id="2-TCP和UDP有什么区别"><a href="#2-TCP和UDP有什么区别" class="headerlink" title="2. TCP和UDP有什么区别"></a>2. TCP和UDP有什么区别</h4><ul>
<li>TCP面向连接（如打电话要先拨号建立连接）；UDP是无连接的，即发送数据之前不需要建立连接</li>
<li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付.</li>
<li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文的</li>
<li>每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信</li>
<li>TCP首部开销20字节；UDP的首部开销小，只有8个字节</li>
<li>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</li>
</ul>
<p>TCP使用场景：</p>
<ul>
<li>相对于 UDP，TCP 实现了数据传输过程中的各种控制，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。在对可靠性要求较高的情况下，可以使用 TCP，即不考虑 UDP 的时候，都可以选择 TCP</li>
</ul>
<hr>
<p>UDP使用场景：</p>
<ul>
<li>包总量较小的通信（DNS、SNMP）</li>
<li>视频、音频等多媒体通信（即时通信）</li>
<li>广播通信</li>
</ul>
<h4 id="3-TCP中三次握手和四次挥手"><a href="#3-TCP中三次握手和四次挥手" class="headerlink" title="3. TCP中三次握手和四次挥手"></a>3. TCP中三次握手和四次挥手</h4><h5 id="3-1-三次握手"><a href="#3-1-三次握手" class="headerlink" title="3.1 三次握手"></a>3.1 三次握手</h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7m6hb6w0oj318a0o6qau.jpg" alt="75.jpg" style="zoom:30%;" /></div>

<p>假设 A 为客户端，B 为服务器端：</p>
<ul>
<li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求</li>
<li>A 向 B 发送连接请求报文段，<code>SYN=1</code>，<code>ACK=0</code>，选择一个初始的序号 <code>seq = x</code></li>
<li>B 收到连接请求报文段，如果同意建立连接，则向 A 发送连接确认报文段，<code>SYN=1</code>，<code>ACK=1</code>，确认号为 <code>x+1</code>，同时也选择一个初始的序号 <code>seq = y</code></li>
<li>A 收到 B 的连接确认报文段后，还要向 B 发出确认，确认号为 <code>ack = y+1</code>，序号为 <code>seq = x+1</code></li>
<li>A 的 TCP 通知上层应用进程，连接已经建立。</li>
<li>B 收到 A 的确认后，连接建立。</li>
<li>B 的 TCP 收到主机 A 的确认后，也通知其上层应用进程：TCP 连接已经建立</li>
</ul>
<p><strong>为什么TCP连接需要三次握手，两次不可以吗?</strong></p>
<ul>
<li>TCP是一个双向通信协议，通信双方都有能力发送信息，并接收响应。如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认</li>
<li>为了防止已失效的连接请求报文段突然又传送到了服务端，占用服务器资源<ul>
<li>现假定出现一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络节点长时间滞留了，以致延误到连接释放以后的某个时间才到B。本来这是一个已失效的报文段。但是B收到此失效的连接请求报文段后，就误认为是A有发出一次新的连接请求。于是就向A发出确认报文段，同意建立连接。假定不采用三次握手，那么只要B发出确认，新的连接就建立了</li>
<li>由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据。但B却以为新的运输连接已经建立了，并一直等待A发来数据。B的许多资源就这样白白浪费了</li>
<li>采用三次握手的办法可以防止上述现象的发生。例如在刚才的情况下，A不会向B的确认发出确认。B由于收不到确认，就知道A并没有要求建立连接</li>
</ul>
</li>
</ul>
<h5 id="3-2-四次挥手"><a href="#3-2-四次挥手" class="headerlink" title="3.2 四次挥手"></a>3.2 四次挥手</h5><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7m6m8l61xj31hc0u0h05.jpg" alt="76.jpg" style="zoom:30%;" /></div>

<p>数据传输结束后，通信的双方都可释放连接。现在 A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP连接</p>
<ul>
<li>A 把连接释放报文段首部的 <code>FIN = 1</code>，其序号 <code>seq = u</code>，等待 B 的确认。</li>
<li>B 发出确认，确认号 <code>ack = u+1</code>，而这个报文段自己的序号 <code>seq = v</code>。（TCP 服务器进程通知高层应用进程）</li>
<li>从 A 到 B 这个方向的连接就释放了，TCP 连接处于半关闭状态。A 不能向 B 发送数据；B 若发送数据，A 仍要接收</li>
<li>当 B 不再需要连接时，发送连接释放请求报文段，FIN&#x3D;1。</li>
<li>A 收到后发出确认，进入<code>TIME-WAIT</code>状态，等待 <code>2 MSL（2*2 = 4 mins）</code>时间后释放连接。</li>
<li>B 收到 A 的确认后释放连接</li>
</ul>
<p><strong>为什么需要四次挥手</strong></p>
<ul>
<li>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 <code>CLOSE-WAIT</code>状态</li>
<li>这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文</li>
</ul>
<h4 id="4-常见的HTTP状态码有哪些"><a href="#4-常见的HTTP状态码有哪些" class="headerlink" title="4. 常见的HTTP状态码有哪些"></a>4. 常见的HTTP状态码有哪些</h4><table>
<thead>
<tr>
<th align="left">状态码</th>
<th align="left">类别</th>
<th align="left">原因短语</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1XX</td>
<td align="left">Informational（信息性状态码）</td>
<td align="left">接收的请求正在处理</td>
</tr>
<tr>
<td align="left">2XX</td>
<td align="left">Success（成功状态码）</td>
<td align="left">请求正常处理完毕</td>
</tr>
<tr>
<td align="left">3XX</td>
<td align="left">Redirection（重定向状态码）</td>
<td align="left">需要进行附加操作以完成请求</td>
</tr>
<tr>
<td align="left">4XX</td>
<td align="left">Client Error（客户端错误状态码）</td>
<td align="left">服务器无法处理请求</td>
</tr>
<tr>
<td align="left">5XX</td>
<td align="left">Server Error（服务器错误状态码）</td>
<td align="left">服务器处理请求出错</td>
</tr>
</tbody></table>
<ul>
<li>1XX：<ul>
<li><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应</li>
</ul>
</li>
<li>2XX：<ul>
<li><strong>200 OK</strong></li>
<li><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用</li>
<li><strong>206 Partial Content</strong> ：表示客户端进行了范围请求。响应报文包含由 Content-Range 指定范围的实体内容</li>
</ul>
</li>
<li>3XX：<ul>
<li><strong>301 Moved Permanently</strong> ：永久性重定向</li>
<li><strong>302 Found</strong> ：临时性重定向</li>
<li>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法</li>
<li><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源</li>
<li><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码</li>
<li><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法</li>
</ul>
</li>
<li>4XX：<ul>
<li><strong>400 Bad Request</strong> ：请求报文中存在语法错误</li>
<li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败</li>
<li><strong>403 Forbidden</strong> ：请求被拒绝，服务器端没有必要给出拒绝的详细理由</li>
<li><strong>404 Not Found</strong></li>
</ul>
</li>
<li>5XX：<ul>
<li><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误</li>
<li><strong>502 Bad Gateway</strong> : 是用来表示代理或网关在处理请求时发生了错误，并不一定是原始服务器出现了问题</li>
<li><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</li>
<li><strong>504 Gateway Timeout</strong>：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应</li>
</ul>
</li>
</ul>
<p><strong>注意：某些代理服务器在DNS查询超时时会返回400或者500错误</strong></p>
<h4 id="5-HTTPS和HTTP有什么区别"><a href="#5-HTTPS和HTTP有什么区别" class="headerlink" title="5. HTTPS和HTTP有什么区别"></a>5. HTTPS和HTTP有什么区别</h4><p>http协议和https协议的区别：<strong>传输信息安全性不同</strong>、<strong>连接方式不同</strong>、<strong>端口不同</strong>、<strong>证书专申请方式不同</strong></p>
<ul>
<li>传输信息安全性不同<ul>
<li>http协议：是超文本传输协议，信息是明文传输。如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息</li>
<li>https协议：是具有安全性的SSL&#x2F;TLS加密传输协议，为浏览器和服务器之间的通信加密，确保数据传输的安全性</li>
</ul>
</li>
<li>连接方式不同<ul>
<li>http协议：http的连接很简单，是无状态的，客户端和服务器端都无法验证对方的身份</li>
<li>https协议：是由SSL&#x2F;TLS＋HTTP协议构建的可进行加密传输、身份认证的网络协议。客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份</li>
</ul>
</li>
<li>端口不同<ul>
<li>http协议：使用的端口是80</li>
<li>https协议：使用的端口是443</li>
</ul>
</li>
<li>证书申请方式不同<ul>
<li>http协议：无需申请证书</li>
<li>https协议：需要到ca申请证书，一般免费证书很少，需要交费</li>
</ul>
</li>
</ul>
<h4 id="6-HTTP-x2F-HTPS安全性"><a href="#6-HTTP-x2F-HTPS安全性" class="headerlink" title="6. HTTP&#x2F;HTPS安全性"></a>6. HTTP&#x2F;HTPS安全性</h4><h5 id="6-1-HTTP的安全性问题"><a href="#6-1-HTTP的安全性问题" class="headerlink" title="6.1 HTTP的安全性问题"></a>6.1 HTTP的安全性问题</h5><ul>
<li>使用明文进行通信，内容可能会被窃听</li>
<li>不验证通信方的身份，通信方的身份有可能遭遇伪装</li>
<li>无法证明报文的完整性，报文有可能遭篡改</li>
</ul>
<hr>
<p>HTTPs（Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲HTTPs是HTTP的安全版。HTTPs 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信。也就是说 HTTPs 使用了隧道进行通信。通过使用 SSL，HTTPs 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）</p>
<h5 id="6-2-对称密钥加密"><a href="#6-2-对称密钥加密" class="headerlink" title="6.2 对称密钥加密"></a>6.2 对称密钥加密</h5><p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥</p>
<ul>
<li>优点：运算速度快；</li>
<li>缺点：无法安全地将密钥传输给通信方</li>
</ul>
<h5 id="6-3-非对称密钥加密"><a href="#6-3-非对称密钥加密" class="headerlink" title="6.3 非对称密钥加密"></a>6.3 非对称密钥加密</h5><p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密</p>
<p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确</p>
<ul>
<li>优点：可以更安全地将公开密钥传输给通信发送方</li>
<li>缺点：运算速度慢</li>
</ul>
<h5 id="6-4-HTTPs-采用的加密方式"><a href="#6-4-HTTPs-采用的加密方式" class="headerlink" title="6.4 HTTPs 采用的加密方式"></a>6.4 HTTPs 采用的加密方式</h5><p>HTTPs 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证安全性，之后使用对称密钥加密进行通信来保证效率</p>
<h4 id="7-SSL-x2F-TLS协议的握手过程"><a href="#7-SSL-x2F-TLS协议的握手过程" class="headerlink" title="7. SSL&#x2F;TLS协议的握手过程"></a>7. SSL&#x2F;TLS协议的握手过程</h4><p>我们知道，HTTP 协议都是明文传输内容，在早期只展示静态内容时没有问题。伴随着互联网的快速发展，人们对于网络传输安全性的要求也越来越高，HTTPS 协议因此出现。如上图所示，在 HTTPS 加密中真正起作用的其实是 SSL&#x2F;TLS 协议。SSL&#x2F;TLS 协议作用在 HTTP 协议之下，对于上层应用来说，原来的发送接收数据流程不变，这就很好地兼容了老的 HTTP 协议，这也是软件开发中分层实现的体现</p>
<h5 id="7-1-SSL-Secure-Socket-Layer，安全套接字层"><a href="#7-1-SSL-Secure-Socket-Layer，安全套接字层" class="headerlink" title="7.1 SSL (Secure Socket Layer，安全套接字层)"></a>7.1 SSL (Secure Socket Layer，安全套接字层)</h5><p>SSL为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取，当前为3.0版本</p>
<p>SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等</p>
<h5 id="7-2-TLS-Transport-Layer-Security，传输层安全协议"><a href="#7-2-TLS-Transport-Layer-Security，传输层安全协议" class="headerlink" title="7.2 TLS (Transport Layer Security，传输层安全协议)"></a>7.2 TLS (Transport Layer Security，传输层安全协议)</h5><p>用于两个应用程序之间提供保密性和数据完整性</p>
<p>TLS 1.0是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本，可以理解为SSL 3.1，它是写入了 RFC 的。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面</p>
<h5 id="7-3-握手过程"><a href="#7-3-握手过程" class="headerlink" title="7.3 握手过程"></a>7.3 握手过程</h5><ul>
<li><p><strong>1-client hello：</strong> 握手第一步是客户端向服务端发送 Client Hello 消息，这个消息里包含了一个客户端生成的随机数 <strong>Random1</strong>、客户端支持的<strong>加密套件</strong>（Support Ciphers）和 SSL Version 等信息</p>
</li>
<li><p><strong>2-server hello：</strong> 第二步是服务端向客户端发送 Server Hello 消息，这个消息会从 Client Hello 传过来的 Support Ciphers 里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法，另外还会生成一份随机数 <strong>Random2</strong>。注意，至此客户端和服务端都拥有了两个随机数（Random1+ Random2），这两个随机数会在后续生成对称秘钥时用到</p>
</li>
<li><p><strong>3-server certificate：</strong> 这一步是服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥</p>
</li>
<li><p><strong>4-Server Hello Done：</strong> Server Hello Done 通知客户端 Server Hello 过程结束</p>
</li>
<li><p><strong>5-Client Key Exchange：</strong> 上面客户端根据服务器传来的公钥生成了 <strong>PreMaster Key</strong>，Client Key Exchange 就是将这个 key 传给服务端，服务端再用自己的私钥解出这个 <strong>PreMaster Key</strong> 得到客户端生成的 <strong>Random3</strong>。至此，客户端和服务端都拥有 <strong>Random1</strong> + <strong>Random2</strong> + <strong>Random3</strong>，两边再根据同样的算法就可以生成一份秘钥，握手结束后的应用层数据都是使用这个秘钥进行对称加密。为什么要使用三个随机数呢？这是因为 SSL&#x2F;TLS 握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解出来</p>
</li>
<li><p><strong>6-Change Cipher Spec(Client)：</strong> 这一步是客户端通知服务端后面再发送的消息都会使用前面协商出来的秘钥加密了，是一条事件消息</p>
</li>
<li><p><strong>7-Finished(Client)：</strong> 客户端发送Finished报文。该报文包含连接至今全部报文的整理校验值。这次握手协议是否能成功，要以服务器是否能够正确解密该报文作为判定标准</p>
</li>
<li><p><strong>8-Change Cipher Spec(Server)：</strong> 服务器同样发送Change Cipher Spec报文给客户端</p>
</li>
<li><p><strong>9-Finished(Server)：</strong> 服务器同样发送Finished报文给客户端</p>
</li>
<li><p><strong>10-11Application Data：</strong> 到这里，双方已安全地协商出了同一份秘钥，所有的应用层数据都会用这个秘钥加密后再通过 TCP 进行可靠传输</p>
</li>
<li><p><strong>12-Alert：warning, close notify：</strong> 最后由客户端断开连接。断开连接时，发送close_notify报文。上图做了一些省略，在这步之后再发送一种叫做MAC（Message Authentication Code）的报文摘要。MAC能够查知报文是否遭到篡改，从而保护报文的完整性</p>
</li>
</ul>
<h4 id="8-Get和Post区别"><a href="#8-Get和Post区别" class="headerlink" title="8. Get和Post区别"></a>8. Get和Post区别</h4><ul>
<li><p>一般约束为：GET是从服务器上获取数据，POST是向服务器传送数据</p>
</li>
<li><p>Get是不安全的，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的</p>
</li>
<li><p>Get传送的数据量较小，这主要是因为受URL长度限制；Post传送的数据量较大，一般被默认为不受限制</p>
</li>
<li><p>Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集</p>
</li>
<li><p>Get执行效率却比Post方法好。Get是form提交的默认方法</p>
</li>
<li><p>GET产生一个TCP数据包；POST产生两个TCP数据包（非必然，客户端可灵活决定）</p>
</li>
</ul>
<h4 id="9-从输入网址到获得页面的网络请求过程"><a href="#9-从输入网址到获得页面的网络请求过程" class="headerlink" title="9. 从输入网址到获得页面的网络请求过程"></a>9. 从输入网址到获得页面的网络请求过程</h4><ol>
<li>输入地址</li>
<li>浏览器查找域名的 IP 地址</li>
<li>浏览器向 web 服务器发送一个 HTTP 请求</li>
<li>服务器的永久重定向响应</li>
<li>服务器处理请求</li>
<li>服务器返回一个 HTTP 响应</li>
<li>浏览器显示 HTML</li>
<li>浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）</li>
</ol>
<p><strong>详细解读：</strong> <a href="https://zhuanlan.zhihu.com/p/133906695">点击跳转至网页</a></p>
<h4 id="10-TCP报头格式和UDP报头格式"><a href="#10-TCP报头格式和UDP报头格式" class="headerlink" title="10. TCP报头格式和UDP报头格式"></a>10. TCP报头格式和UDP报头格式</h4><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。运输层提供了进程间的逻辑通信，运输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个运输层实体之间有一条端到端的逻辑通信信道</p>
<ul>
<li><p>TCP和UDP的特点</p>
<ul>
<li><strong>传输控制协议 TCP</strong>（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）</li>
<li><strong>用户数据报协议 UDP</strong>（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。例如：视频传输、实时通信</li>
</ul>
</li>
<li><p>TCP首部格式</p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7m8ophl1uj317p0r3n7l.jpg" alt="74.jpg" style="zoom:30%;" /></div>

<ul>
<li><strong>序号 seq</strong> ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。[301,400]为序号301的数据长度，下一个则为401。</li>
<li><strong>确认号 ack</strong> ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</li>
<li><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度</li>
<li><strong>确认 ACK</strong> ：当 ACK&#x3D;1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1</li>
<li><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当 SYN&#x3D;1，ACK&#x3D;0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN&#x3D;1，ACK&#x3D;1。</li>
<li><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN&#x3D;1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</li>
<li><strong>窗口</strong> ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的</li>
</ul>
</li>
<li><p>UDP首部格式</p>
<p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的</p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7m8rstr7dj31580k211a.jpg" alt="73.jpg" style="zoom:33%;" /></div></li>
</ul>
<h4 id="11-TCP连接中如果断电怎么办"><a href="#11-TCP连接中如果断电怎么办" class="headerlink" title="11. TCP连接中如果断电怎么办"></a>11. TCP连接中如果断电怎么办</h4><p>都已经断电了，还能怎么办，等电来</p>
<h4 id="12-TCP滑动窗口"><a href="#12-TCP滑动窗口" class="headerlink" title="12. TCP滑动窗口"></a>12. TCP滑动窗口</h4><div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7mctzf6qaj31hm0setua.jpg" alt="78.jpg" style="zoom:30%;" /></div>

<p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，<strong>接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小</strong></p>
<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口</p>
<p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {32, 33} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收</p>
<h4 id="13-TCP流量控制"><a href="#13-TCP流量控制" class="headerlink" title="13. TCP流量控制"></a>13. TCP流量控制</h4><ul>
<li>流量控制是为了控制发送方发送速率，保证接收方来得及接收</li>
<li>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据</li>
</ul>
<h4 id="14-TCP拥塞处理（Congestion-Handling）"><a href="#14-TCP拥塞处理（Congestion-Handling）" class="headerlink" title="14. TCP拥塞处理（Congestion Handling）"></a>14. TCP拥塞处理（Congestion Handling）</h4><p><strong>拥塞控制的一般原理：</strong></p>
<ul>
<li>在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏——产生拥塞(congestion)。</li>
<li>出现资源拥塞的条件：对资源需求的总和 &gt; 可用资源</li>
<li>若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降</li>
</ul>
<p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度</p>
<p>TCP 主要通过四种算法来进行拥塞控制：<strong>慢开始</strong>、<strong>拥塞避免</strong>、<strong>快重传</strong>、<strong>快恢复</strong></p>
<h4 id="15-TCP的LISTEN状态是什么"><a href="#15-TCP的LISTEN状态是什么" class="headerlink" title="15. TCP的LISTEN状态是什么"></a>15. TCP的LISTEN状态是什么</h4><p>TCP的LISTEN是服务器处于监听状态：</p>
<ul>
<li><strong>CLOSED：</strong> 初始状态</li>
<li><strong>LISTEN：</strong> 服务器处于监听状态</li>
<li><strong>TIME_WAIT：</strong> 客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态</li>
</ul>
<h4 id="16-Tcp中的拆包和粘包是怎么回事"><a href="#16-Tcp中的拆包和粘包是怎么回事" class="headerlink" title="16. Tcp中的拆包和粘包是怎么回事"></a>16. Tcp中的拆包和粘包是怎么回事</h4><ul>
<li>粘包：** 在socket通讯过程中，如果通讯的一端一次性连续发送多条数据包，tcp协议会将多个数据包打包成一个tcp报文发送出去，这就是所谓的粘包</li>
<li><strong>拆包：</strong> 而如果通讯的一端发送的数据包超过一次tcp报文所能传输的最大值时，就会将一个数据包拆成多个最大tcp长度的tcp报文分开传输，这就叫做拆包</li>
</ul>
<h4 id="17-HTTP的请求和响应报文"><a href="#17-HTTP的请求和响应报文" class="headerlink" title="17. HTTP的请求和响应报文"></a>17. HTTP的请求和响应报文</h4><ul>
<li><p>请求报文</p>
<ul>
<li>请求行：由三部分组成（请求方法、请求URL-不包括域名、HTTP版本协议）</li>
<li>请求头：由关键字-值对组成，每行一对</li>
<li>空行：通知服务器以下不再有请求头</li>
<li>请求体</li>
</ul>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7m91nfjb1j30i8065djn.jpg" alt="84.jpg" style="zoom:80%;" /></div>
</li>
<li><p>响应报文</p>
<ul>
<li>响应行：由三部分组成：服务器HTTP协议版本，响应状态码，状态码的文本描述</li>
<li>响应头：由关键字-值对组成，每行一对</li>
<li>空行：通知服务器以下不再有响应头</li>
<li>响应体</li>
</ul>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7m93g347vj30jk07faec.jpg" alt="96.jpg" style="zoom:80%;" /></div></li>
</ul>
<h4 id="18-HTTP方法"><a href="#18-HTTP方法" class="headerlink" title="18. HTTP方法"></a>18. HTTP方法</h4><ul>
<li>GET：获取资源<ul>
<li>当前网络请求中，绝大部分使用的是GET方法</li>
</ul>
</li>
<li>HEAD：获取报文首部<ul>
<li>和GET方法一样，但是不返回报文实体主体部分</li>
<li>主要用于确认 URL 的有效性以及资源更新的日期时间等</li>
</ul>
</li>
<li>POST：传输实体主体<ul>
<li>POST 主要用来传输数据，而 GET 主要用来获取资源</li>
</ul>
</li>
<li>PUT：上传文件<ul>
<li>由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法</li>
</ul>
</li>
<li>PATCH：对资源进行部分修改<ul>
<li>PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改</li>
</ul>
</li>
<li>DELETE：删除文件<ul>
<li>与 PUT 功能相反，并且同样不带验证机制</li>
</ul>
</li>
<li>OPTIONS：查询支持的方法<ul>
<li>查询指定的 URL 能够支持的方法</li>
<li>会返回 Allow：GET，POST，HEAD，OPTIONS 这样的内容</li>
</ul>
</li>
<li>CONNECT：要求在与代理服务器通信时建立隧道<ul>
<li>使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输</li>
</ul>
</li>
<li>TRACE：追踪路径<ul>
<li>服务器会将通信路径返回给客户端</li>
<li>发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输</li>
<li>通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）</li>
</ul>
</li>
</ul>
<h4 id="19-如何理解HTTP协议是无状态的"><a href="#19-如何理解HTTP协议是无状态的" class="headerlink" title="19. 如何理解HTTP协议是无状态的"></a>19. 如何理解HTTP协议是无状态的</h4><ul>
<li>HTTP协议是无状态的（stateless），指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系</li>
<li>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）</li>
<li>缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快</li>
</ul>
<h4 id="20-HTTP2-0特性"><a href="#20-HTTP2-0特性" class="headerlink" title="20. HTTP2.0特性"></a>20. HTTP2.0特性</h4><p>HTTP&#x2F;2的通过支持请求与响应的多路复用来减少延迟，通过压缩HTTP首部字段将协议开销降至最低，同时增加对请求优先级和服务器端推送的支持</p>
<h4 id="21-什么是短连接和长连接"><a href="#21-什么是短连接和长连接" class="headerlink" title="21. 什么是短连接和长连接"></a>21. 什么是短连接和长连接</h4><p>在HTTP&#x2F;1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话</p>
<p>而从HTTP&#x2F;1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure>

<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接</p>
<p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接</p>
<h4 id="22-Client如何实现长连接"><a href="#22-Client如何实现长连接" class="headerlink" title="22. Client如何实现长连接"></a>22. Client如何实现长连接</h4><p>使用TCP协议的<strong>KeepAlive</strong>机制与<strong>HeartBeat</strong>心跳包</p>
<ul>
<li><code>HeartBeat</code>心跳包</li>
<li>TCP协议的<code>KeepAlive</code>机制</li>
</ul>
<h4 id="23-Quic有什么优点相比Http2"><a href="#23-Quic有什么优点相比Http2" class="headerlink" title="23. Quic有什么优点相比Http2"></a>23. Quic有什么优点相比Http2</h4><ul>
<li><strong>HTTP1：</strong> 有连接无法复用、队头阻塞、协议开销大和安全因素等多个缺陷</li>
<li><strong>HTTP2：</strong> 通过多路复用、二进制流、Header 压缩等等技术，极大地提高了性能，但是还是存在着问题的</li>
<li><strong>Quic：</strong> 基于 UDP 实现，是 HTTP3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议.quic中加密认证的报文(TCP 协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改，注入和窃听。比如修改序列号、滑动窗口。这些行为有可能是出于性能优化，也有可能是主动攻击)。这样只要对 QUIC 报文任何修改，接收端都能够及时发现，有效地降低了安全风险</li>
</ul>
<p>此外quic还有向前纠错的能力，QUIC 协议有一个非常独特的特性，称为向前纠错 (Forward Error Correction，FEC)，每个数据包除了它本身的内容之外，还包括了部分其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传。向前纠错牺牲了每个数据包可以发送数据的上限，但是减少了因为丢包导致的数据重传，因为数据重传将会消耗更多的时间(包括确认数据包丢失、请求重传、等待新数据包等步骤的时间消耗)</p>
<h4 id="24-Grpc的优缺点"><a href="#24-Grpc的优缺点" class="headerlink" title="24. Grpc的优缺点"></a>24. Grpc的优缺点</h4><p>gRPC是Google公司基于Protobuf开发的跨语言的开源RPC框架。gRPC基于HTTP&#x2F;2协议设计，可以基于一个HTTP&#x2F;2链接提供多个服务，对于移动设备更加友好</p>
<p>最底层为TCP或Unix Socket协议，在此之上是HTTP&#x2F;2协议的实现，然后在HTTP&#x2F;2协议之上又构建了针对Go语言的gRPC核心库。应用程序通过gRPC插件生产的Stub代码和gRPC核心库通信，也可以直接和gRPC核心库通信</p>
<p><strong>优点：</strong></p>
<ul>
<li>protobuf二进制消息，性能好&#x2F;效率高（空间和时间效率都很不错）</li>
<li>proto文件生成目标代码，简单易用</li>
<li>序列化反序列化直接对应程序中的数据类，不需要解析后在进行映射(XML,JSON都是这种方式)</li>
<li>支持向前兼容（新加字段采用默认值）和向后兼容（忽略新加字段），简化升级</li>
<li>支持多种语言（可以把proto文件看做IDL文件）</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>GRPC尚未提供连接池，需要自行实现</li>
<li>尚未提供“服务发现”、“负载均衡”机制</li>
<li>因为基于HTTP2，绝大部多数<code>HTTP Server、Nginx</code>都尚不支持，即Nginx不能将GRPC请求作为HTTP请求来负载均衡，而是作为普通的TCP请求（nginx1.9版本已支持）</li>
<li>Protobuf二进制可读性差（貌似提供了Text_Fromat功能）默认不具备动态特性（可以通过动态定义生成消息类型或者动态编译支持）</li>
</ul>
<h4 id="25-Http1和Http2和Grpc之间的区别是什么"><a href="#25-Http1和Http2和Grpc之间的区别是什么" class="headerlink" title="25. Http1和Http2和Grpc之间的区别是什么"></a>25. Http1和Http2和Grpc之间的区别是什么</h4><p>在互联网流量传输只使用了几个网络协议。使用 <code>IPv4</code> 进行路由，使用 <code>TCP</code> 进行连接层面的流量控制，使用 <code>SSL/TLS</code> 协议实现传输安全，使用 <code>DNS</code> 进行域名解析，使用 <code>HTTP</code> 进行应用数据的传输</p>
<p><strong>HTTP2和HTTP1相比的新特性包括：</strong></p>
<ul>
<li><p>新的二进制格式（Binary Format）</p>
<ul>
<li>HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮</li>
</ul>
</li>
<li><p>多路复用（MultiPlexing）</p>
<ul>
<li>连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面</li>
</ul>
</li>
<li><p>Header压缩</p>
<p>Header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小</p>
</li>
<li><p>服务端推送（server push）</p>
<ul>
<li>服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能</li>
</ul>
</li>
</ul>
<hr>
<p>Grpc的设计目标是在任何环境下运行，支持可插拔的负载均衡，跟踪，运行状况检查和身份验证。它不仅支持数据中心内部和跨数据中心的服务调用，它也适用于分布式计算的最后一公里，将设备，移动应用程序和浏览器连接到后端服务，同时，它也是高性能的，而 HTTP2 恰好支持这些</p>
<p><strong>Grpc是基于http2的</strong></p>
<ul>
<li>HTTP2天然的通用性满足各种设备，场景</li>
<li>HTTP2的性能相对来说也是很好的，除非你需要极致的性能</li>
<li>HTTP2的安全性非常好，天然支持 SSL</li>
<li>HTTP2的鉴权也非常成熟</li>
<li>Grpc基于 HTTP2 多语言实现也更容易</li>
</ul>
<h4 id="26-数字签名、数字证书、SSL、https是什么关系"><a href="#26-数字签名、数字证书、SSL、https是什么关系" class="headerlink" title="26. 数字签名、数字证书、SSL、https是什么关系"></a>26. 数字签名、数字证书、SSL、https是什么关系</h4><p>HTTPS 是建立在密码学基础之上的一种安全通信协议，严格来说是基于 HTTP 协议和 SSL&#x2F;TLS 的组合</p>
<h4 id="27-Cookie"><a href="#27-Cookie" class="headerlink" title="27. Cookie"></a>27. Cookie</h4><p>HTTP协议是无状态的，主要是为了让HTTP协议尽可能简单，使得它能够处理大量事务。HTTP&#x2F;1.1引入Cookie来保存状态信息</p>
<p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。它用于告知服务端两个请求是否来自同一浏览器，并保持用户的登录状态</p>
<ul>
<li><p>用途</p>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
</li>
<li><p>创建过程</p>
<ul>
<li>服务器发送的响应报文包含Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中</li>
<li>客户端之后对同一个服务器发送请求时，会从浏览器中读出 Cookie 信息通过 Cookie 请求首部字段发送给服务器</li>
</ul>
</li>
<li><p>分类</p>
<ul>
<li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效</li>
<li>持久性 Cookie：指定一个特定的过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie</li>
</ul>
</li>
<li><p>JavaScript 获取 Cookie</p>
<ul>
<li>通过 <code>Document.cookie</code> 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie</li>
</ul>
</li>
<li><p>Secure 和 HttpOnly</p>
<ul>
<li>标记为 Secure 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障</li>
<li>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。因为跨域脚本 (XSS) 攻击常常使用 JavaScript 的 <code>Document.cookie</code>API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击</li>
</ul>
</li>
<li><p>作用域</p>
<ul>
<li>Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain&#x3D;mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）</li>
<li>Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (“&#x2F;“) 作为路径分隔符，子路径也会被匹配</li>
</ul>
</li>
</ul>
<h4 id="28-Session"><a href="#28-Session" class="headerlink" title="28. Session"></a>28. Session</h4><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全</p>
<p>Session 可以存储在服务器上的文件、数据库或者内存中，现在最常见的是将 Session 存储在内存型数据库中，比如 Redis</p>
<p>使用 Session 维护用户登录的过程如下：</p>
<ul>
<li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li>
<li>服务器验证该用户名和密码</li>
<li>如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 ID 称为 Session ID</li>
<li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中</li>
<li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之后的业务操作</li>
</ul>
<p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式</p>
<div align="center"><img src="http://tva1.sinaimg.cn/large/0079DIvogy1h7mdikcs2aj31d80jr11b.jpg" alt="86.jpg" style="zoom:100%;" /></div>

<h4 id="29-Cookie与Session异同"><a href="#29-Cookie与Session异同" class="headerlink" title="29. Cookie与Session异同"></a>29. Cookie与Session异同</h4><p>Cookie 和 Session 都为了用来保存状态信息，都是保存客户端状态的机制，它们都是为了解决HTTP无状态的问题而所做的努力</p>
<ul>
<li>作用范围不同：Cookie 保存在客户端(浏览器)，Session 保存在服务器端</li>
<li>存取方式的不同：Cookie只能保存 ASCII，Session可以存任意数据类型，比如UserId等</li>
<li>有效期不同：Cookie可设置为长时间保持，比如默认登录功能功能，Session一般有效时间较短，客户端关闭或者Session超时都会失效</li>
<li>隐私策略不同：Cookie存储在客户端，信息容易被窃取;Session存储在服务端，相对安全一些</li>
<li>存储大小不同： 单个Cookie 保存的数据不能超过 4K，Session可存储数据远高于Cookie</li>
</ul>
<h4 id="30-浏览器禁用Cookie"><a href="#30-浏览器禁用Cookie" class="headerlink" title="30. 浏览器禁用Cookie"></a>30. 浏览器禁用Cookie</h4><p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递</p>
<h4 id="31-Cookie与Session选择"><a href="#31-Cookie与Session选择" class="headerlink" title="31. Cookie与Session选择"></a>31. Cookie与Session选择</h4><ul>
<li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存取任何类型的数据，因此在考虑数据复杂性时首选 Session</li>
<li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密</li>
<li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中</li>
</ul>
<h4 id="32-Unicode和ASCII以及Utf8的区别"><a href="#32-Unicode和ASCII以及Utf8的区别" class="headerlink" title="32. Unicode和ASCII以及Utf8的区别"></a>32. Unicode和ASCII以及Utf8的区别</h4><ul>
<li>Unicode 是字符集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储</li>
<li>ASCII 码一共规定了128个字符的编码，比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）</li>
<li>UTF-8 是编码规则</li>
</ul>
<h4 id="33-TFO的原理是什么"><a href="#33-TFO的原理是什么" class="headerlink" title="33. TFO的原理是什么"></a>33. TFO的原理是什么</h4><p>TCP快速打开（TCP Fast Open，TFO）是对TCP的一种简化握手手续的拓展，用于提高两端点间连接的打开速度</p>
<p>简而言之，就是在TCP的三次握手过程中传输实际有用的数据。这个扩展最初在Linux系统实现，Linux服务器，Linux系统上的Chrome浏览器，或运行在Linux上的其他支持的软件</p>
<p>它通过握手开始时的SYN包中的TFO cookie来验证一个之前连接过的客户端。如果验证成功，它可以在三次握手最终的ACK包收到之前就开始发送数据，这样便跳过了一个绕路的行为，更在传输开始时就降低了延迟</p>
<p>这个加密的Cookie被存储在客户端，在一开始的连接时被设定好。然后每当客户端连接时，这个Cookie被重复返回</p>
<p>请求Tcp Fast Open Cookie：</p>
<ul>
<li>客户端发送SYN数据包，该数据包包含Fast Open选项，且该选项的Cookie为空，这表明客户端请求Fast Open Cookie</li>
<li>支持TCP Fast Open的服务器生成Cookie，并将其置于SYN-ACK数据包中的Fast Open选项以发回客户端</li>
<li>客户端收到SYN-ACK后，缓存Fast Open选项中的Cookie</li>
</ul>
<h4 id="34-TIME-WAIT的作用"><a href="#34-TIME-WAIT的作用" class="headerlink" title="34. TIME_WAIT的作用"></a>34. TIME_WAIT的作用</h4><p>主动关闭的Socket端会进入TIME_WAIT状态，并且持续2MSL时间长度，MSL就是maximum segment lifetime(最大分节生命期），这是一个IP数据包能在互联网上生存的最长时间，超过这个时间将在网络中消失。MSL在RFC 1122上建议是2分钟，而源自berkeley的TCP实现传统上使用30秒，因而，TIME_WAIT状态一般维持在1-4分钟</p>
<ul>
<li>可靠地实现TCP全双工连接的终止</li>
<li>允许老的重复分节在网络中消逝</li>
</ul>
<h4 id="35-网络的性能指标有哪些"><a href="#35-网络的性能指标有哪些" class="headerlink" title="35. 网络的性能指标有哪些"></a>35. 网络的性能指标有哪些</h4><p>通常是以4个指标来衡量网络的性能，分别是带宽、延时、吞吐率、PPS（Packet Per Second），它们表示的意义如下：</p>
<ul>
<li>带宽：表示链路的最大传输速率，单位是 <code>b/s</code> （比特 &#x2F; 秒），带宽越大，其传输能力就越强</li>
<li>延时：表示请求数据包发送后，收到对端响应，所需要的时间延迟。不同的场景有着不同的含义，比如可以表示建立 <code>TCP</code> 连接所需的时间延迟，或一个数据包往返所需的时间延迟</li>
<li>吞吐率：表示单位时间内成功传输的数据量，单位是 <code>b/s</code>（比特 &#x2F; 秒）或者 <code>B/s</code>（字节 &#x2F; 秒），吞吐受带宽限制，带宽越大，吞吐率的上限才可能越高</li>
<li>PPS：全称是 <code>Packet Per Second</code>（包 &#x2F; 秒），表示以网络包为单位的传输速率，一般用来评估系统对于网络的转发能</li>
</ul>
<p>除了以上这四种基本的指标，还有一些其他常用的性能指标，比如：</p>
<ul>
<li>网络的可用性：表示网络能否正常通信</li>
<li>并发连接数：表示 TCP 连接数量</li>
<li>丢包率：表示所丢失数据包数量占所发送数据组的比率</li>
<li>重传率：表示重传网络包的比例</li>
</ul>
<h4 id="36-如何区分流量控制和拥塞控制"><a href="#36-如何区分流量控制和拥塞控制" class="headerlink" title="36. 如何区分流量控制和拥塞控制"></a>36. 如何区分流量控制和拥塞控制</h4><ul>
<li>拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷</li>
<li>拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素</li>
<li>流量控制往往指在给定的发送端和接收端之间的点对点通信量的控制</li>
<li>流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收</li>
<li>流量控制属于通信双方协商；拥塞控制涉及通信链路全局</li>
<li>流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整</li>
<li>实际最终发送窗口 &#x3D; min{流控发送窗口，拥塞窗口}</li>
</ul>
<h4 id="37-解释RTO，RTT和超时重传"><a href="#37-解释RTO，RTT和超时重传" class="headerlink" title="37. 解释RTO，RTT和超时重传"></a>37. 解释RTO，RTT和超时重传</h4><ul>
<li><strong>超时重传</strong>：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况：<ul>
<li>发送的数据没能到达接收端，所以对方没有响应。</li>
<li>接收端接收到数据，但是ACK报文在返回过程中丢失</li>
<li>接收端拒绝或丢弃数据</li>
</ul>
</li>
<li><strong>RTO</strong>：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间。就是重传间隔<ul>
<li>通常每次重传RTO是前一次重传间隔的两倍，计量单位通常是RTT。例：1RTT，2RTT，4RTT，8RTT……</li>
<li>重传次数到达上限之后停止重传</li>
</ul>
</li>
<li><strong>RTT</strong>：数据从发送到接收到对方响应之间的时间间隔，即数据报在网络中一个往返用时。大小不稳定</li>
</ul>
<h4 id="38-停止等待和超时重传"><a href="#38-停止等待和超时重传" class="headerlink" title="38. 停止等待和超时重传"></a>38. 停止等待和超时重传</h4><ul>
<li>停止等待：通常我们说如果A和B双方建立好tcp连接后就可以相互发送数据了，A为发送方，B为接收方。因为这里讨论可靠传输原理，所以把传输的数据单元称为分组。“停止等待”就是每发送完一个分组就停止发送，等待对方确认后再发送下一个分组。停止等待协议考虑了数据在网络中传输出现的几种情况来提供有效措施保障数据的可靠传输，下面我们就一一来介绍这几种情况</li>
<li>超时重传：原理是在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的ACK报文，那么就重新发送数据，直到发送成功为止。影响超时重传机制协议效率的一个关键参数是重传超时时间（RTO，Retransmission TimeOut）</li>
</ul>
<h4 id="39-交换机和路由器的区别"><a href="#39-交换机和路由器的区别" class="headerlink" title="39. 交换机和路由器的区别"></a>39. 交换机和路由器的区别</h4><ul>
<li>交换机是一根网线上网，但是大家上网是分别拨号，各自使用自己的宽带，大家上网没有影响。而路由器比交换机多了一个虚拟拨号功能，通过同一台路由器上网的电脑是共用一个宽带账号，大家上网要相互影响</li>
<li>交换机工作在中继层，交换机根据MAC地址寻址。路由器工作在网络层，根据IP地址寻址，路由器可以处理TCP&#x2F;IP协议，而交换机不可以</li>
<li>交换机可以使连接它的多台电脑组成局域网，如果还有代理服务器的话还可以实现同时上网功能而且局域网所有电脑是共享它的带宽速率的，但是交换机没有路由器的自动识别数据包发送和到达地址的功能。路由器可以自动识别数据包发送和到达的地址，路由器相当于马路上的警察，负责交通疏导和指路的</li>
<li>举几个例子,路由器是小邮局，就一个地址(IP)，负责一个地方的收发(个人电脑，某个服务器，所以你家上网要这个东西)，交换机是省里的大邮政中心，负责由一个地址给各个小地方的联系。简单的说路由器专管入网，交换机只管配送，路由路由就是给你找路让你上网的，交换机只负责开门，交换机上面要没有路由你是上不了网的</li>
<li>路由器提供了防火墙的服务。路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包传送和未知目标网络数据包的传送，从而可以防止广播风暴</li>
</ul>
<h4 id="40-子网掩码的作用"><a href="#40-子网掩码的作用" class="headerlink" title="40. 子网掩码的作用"></a>40. 子网掩码的作用</h4><p>内网中192.168.1.199的前三组是网络号，后一组是主机号，子网掩码就是255.255.255.0</p>
<p><strong>首先要说明的是</strong>：不是某个IP的网络号和主机号决定子网掩码是什么，而是子网掩码决定了某个IP地址的网络号与主机号是什么，IP地址是要搭配子网掩码使用的。例如上面的子网掩码决定了192.168.1.199的前三段192.168.1是网络号，最后一段199是主机号</p>
<p>我们再来理解子网掩码的作用，先举个例子，市面上的两个厂家都生产电子秤，每个厂家都坚称他们的秤最准，那你是怎么知道他们的秤到底准不准？很简单，你去找一个 1KG 的国际千克原器，各放到他们的秤上测量，如果秤的测量值是1KG，那这把秤就是准的，<strong>子网掩码的作用</strong>就相当于这个大家公认的国际千克原器，是我们测量两个IP是否属于同一个网段的一个工具（应该说是让你知道某个IP地址的网络号与主机号分别是什么） </p>
<hr>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
